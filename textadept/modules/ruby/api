add ThreadGroup.add(p1)\nAdds the given <em>thread</em> to this group, removing it from any other\ngroup to which it may have previously belonged.\n\n   puts "Initial group is #{ThreadGroup::Default.list}"\n   tg = ThreadGroup.new\n   t1 = Thread.new { sleep }\n   t2 = Thread.new { sleep }\n   puts "t1 is #{t1}"\n   puts "t2 is #{t2}"\n   tg.add(t1)\n   puts "Initial group now #{ThreadGroup::Default.list}"\n   puts "tg group now #{tg.list}"\n\n<em>produces:</em>\n\n   Initial group is #<Thread:0x401bdf4c>\n   t1 is #<Thread:0x401b3c90>\n   t2 is #<Thread:0x401b3c18>\n   Initial group now #<Thread:0x401b3c18>#<Thread:0x401bdf4c>\n   tg group now #<Thread:0x401b3c90>\n
enclose ThreadGroup.enclose()\nPrevents threads from being added to or removed from the receiving\n`ThreadGroup`. New threads can still be started in an enclosed\n`ThreadGroup`.\n\n   ThreadGroup::Default.enclose        #=> #<ThreadGroup:0x4029d914>\n   thr = Thread::new { Thread.stop }   #=> #<Thread:0x402a7210 sleep>\n   tg = ThreadGroup::new               #=> #<ThreadGroup:0x402752d4>\n   tg.add thr\n\n<em>produces:</em>\n\n   ThreadError: can't move from the enclosed thread group\n
enclosed? ThreadGroup.enclosed?()\nReturns `true` if <em>thgrp</em> is enclosed. See also\nThreadGroup#enclose.\n
list ThreadGroup.list()\nReturns an array of all existing `Thread` objects that belong to\nthis group.\n\n   ThreadGroup::Default.list   #=> [#<Thread:0x401bdf4c run>]\n
new Mutex.new()\nCreates a new Mutex\n
lock Mutex.lock()\nAttempts to grab the lock and waits if it isn't available.\nRaises +ThreadError+ if +mutex+ was locked by the current thread.\n
locked? Mutex.locked?()\nReturns +true+ if this lock is currently held by some thread.\n
sleep Mutex.sleep(p1 = v1)\nReleases the lock and sleeps +timeout+ seconds if it is given and\nnon-nil or forever.  Raises +ThreadError+ if +mutex+ wasn't locked by\nthe current thread.\n
synchronize Mutex.synchronize()\nObtains a lock, runs the block, and releases the lock when the\nblock completes.  See the example under Mutex.\n
try_lock Mutex.try_lock()\nAttempts to obtain the lock and returns immediately. Returns +true+ if the\nlock was granted.\n
unlock Mutex.unlock()\nReleases the lock.\nRaises +ThreadError+ if +mutex+ wasn't locked by the current thread.\n
DEBUG Thread.DEBUG()\nReturns the thread debug level.  Available only if compiled with\nTHREAD_DEBUG=-1.\n
DEBUG= Thread.DEBUG=(p1)\nSets the thread debug level.  Available only if compiled with\nTHREAD_DEBUG=-1.\n
abort_on_exception Thread.abort_on_exception()\nReturns the status of the global ``abort on exception'' condition.  The\ndefault is `false`. When set to `true`, or if the\nglobal `$DEBUG` flag is `true` (perhaps because the\ncommand line option `-d` was specified) all threads will abort\n(the process will `exit(0)`) if an exception is raised in any\nthread. See also `Thread::abort_on_exception=`.\n
abort_on_exception= Thread.abort_on_exception=(p1)\nWhen set to `true`, all threads will abort if an exception is\nraised. Returns the new state.\n\n   Thread.abort_on_exception = true\n   t1 = Thread.new do\n     puts  "In new thread"\n     raise "Exception from thread"\n   end\n   sleep(1)\n   puts "not reached"\n\n<em>produces:</em>\n\n   In new thread\n   prog.rb:4: Exception from thread (RuntimeError)\n    from prog.rb:2:in `initialize'\n    from prog.rb:2:in `new'\n    from prog.rb:2\n
current Thread.current()\nReturns the currently executing thread.\n\n   Thread.current   #=> #<Thread:0x401bdf4c run>\n
exclusive Thread.exclusive()\nWraps a block in Thread.critical, restoring the original value\nupon exit from the critical section, and returns the value of the\nblock.\n
exit Thread.exit()\nTerminates the currently running thread and schedules another thread to be\nrun. If this thread is already marked to be killed, `exit`\nreturns the `Thread`. If this is the main thread, or the last\nthread, exit the process.\n
fork Thread.fork(*args)\nBasically the same as `Thread::new`. However, if class\n`Thread` is subclassed, then calling `start` in that\nsubclass will not invoke the subclass's `initialize` method.\n
kill Thread.kill(p1)\nCauses the given <em>thread</em> to exit (see `Thread::exit`).\n\n   count = 0\n   a = Thread.new { loop { count += 1 } }\n   sleep(0.1)       #=> 0\n   Thread.kill(a)   #=> #<Thread:0x401b3d30 dead>\n   count            #=> 93947\n   a.alive?         #=> false\n
list Thread.list()\nReturns an array of `Thread` objects for all threads that are\neither runnable or stopped.\n\n   Thread.new { sleep(200) }\n   Thread.new { 1000000.times {|i| i*i } }\n   Thread.new { Thread.stop }\n   Thread.list.each {|t| p t}\n\n<em>produces:</em>\n<Thread:0x401b3e84 sleep>\n<Thread:0x401b3f38 run>\n<Thread:0x401b3fb0 sleep>\n<Thread:0x401bdf4c run>\n
main Thread.main()\nReturns the main thread.\n
new Thread.new(*arg, &block)\n\n
pass Thread.pass()\nGive the thread scheduler a hint to pass execution to another thread.\nA running thread may or may not switch, it depends on OS and processor.\n
start Thread.start(*args)\nBasically the same as `Thread::new`. However, if class\n`Thread` is subclassed, then calling `start` in that\nsubclass will not invoke the subclass's `initialize` method.\n
stop Thread.stop()\nStops execution of the current thread, putting it into a ``sleep'' state,\nand schedules execution of another thread.\n\n   a = Thread.new { print "a"; Thread.stop; print "c" }\n   sleep 0.1 while a.status!='sleep'\n   print "b"\n   a.run\n   a.join\n\n<em>produces:</em>\n\n   abc\n
abort_on_exception Thread.abort_on_exception()\nReturns the status of the thread-local ``abort on exception'' condition for\n<i>thr</i>. The default is `false`. See also\n`Thread::abort_on_exception=`.\n
abort_on_exception= Thread.abort_on_exception=(p1)\nWhen set to `true`, causes all threads (including the main\nprogram) to abort if an exception is raised in <i>thr</i>. The process will\neffectively `exit(0)`.\n
add_trace_func Thread.add_trace_func(p1)\nAdds _proc_ as a handler for tracing.\nSee `Thread#set_trace_func` and +set_trace_func+.\n
alive? Thread.alive?()\nReturns `true` if <i>thr</i> is running or sleeping.\n\n   thr = Thread.new { }\n   thr.join                #=> #<Thread:0x401b3fb0 dead>\n   Thread.current.alive?   #=> true\n   thr.alive?              #=> false\n
backtrace Thread.backtrace()\nReturns the current back trace of the _thr_.\n
exit Thread.exit()\nTerminates <i>thr</i> and schedules another thread to be run. If this thread\nis already marked to be killed, `exit` returns the\n`Thread`. If this is the main thread, or the last thread, exits\nthe process.\n
group Thread.group()\nReturns the `ThreadGroup` which contains <i>thr</i>, or nil if\nthe thread is not a member of any group.\n\n   Thread.main.group   #=> #<ThreadGroup:0x4029d914>\n
inspect Thread.inspect()\nDump the name, id, and status of _thr_ to a string.\n
join Thread.join(p1 = v1)\nThe calling thread will suspend execution and run <i>thr</i>. Does not\nreturn until <i>thr</i> exits or until <i>limit</i> seconds have passed. If\nthe time limit expires, `nil` will be returned, otherwise\n<i>thr</i> is returned.\n\nAny threads not joined will be killed when the main program exits.  If\n<i>thr</i> had previously raised an exception and the\n`abort_on_exception` and `$DEBUG` flags are not set\n(so the exception has not yet been processed) it will be processed at this\ntime.\n\n   a = Thread.new { print "a"; sleep(10); print "b"; print "c" }\n   x = Thread.new { print "x"; Thread.pass; print "y"; print "z" }\n   x.join # Let x thread finish, a will be killed on exit.\n\n<em>produces:</em>\n\n   axyz\n\nThe following example illustrates the <i>limit</i> parameter.\n\n   y = Thread.new { 4.times { sleep 0.1; puts 'tick... ' }}\n   puts "Waiting" until y.join(0.15)\n\n<em>produces:</em>\n\n   tick...\n   Waiting\n   tick...\n   Waitingtick...\n\n   tick...\n
key? Thread.key?(p1)\nReturns `true` if the given string (or symbol) exists as a\nthread-local variable.\n\n   me = Thread.current\n   me[:oliver] = "a"\n   me.key?(:oliver)    #=> true\n   me.key?(:stanley)   #=> false\n
keys Thread.keys()\nReturns an an array of the names of the thread-local variables (as Symbols).\n\n   thr = Thread.new do\n     Thread.current[:cat] = 'meow'\n     Thread.current["dog"] = 'woof'\n   end\n   thr.join   #=> #<Thread:0x401b3f10 dead>\n   thr.keys   #=> [:dog, :cat]\n
kill Thread.kill()\nTerminates <i>thr</i> and schedules another thread to be run. If this thread\nis already marked to be killed, `exit` returns the\n`Thread`. If this is the main thread, or the last thread, exits\nthe process.\n
org_initialize Thread.org_initialize(*arg, &block)\n\n
priority Thread.priority()\nReturns the priority of <i>thr</i>. Default is inherited from the\ncurrent thread which creating the new thread, or zero for the\ninitial main thread; higher-priority thread will run more frequently\nthan lower-priority threads (but lower-priority threads can also run).\n\nThis is just hint for Ruby thread scheduler.  It may be ignored on some\nplatform.\n\n   Thread.current.priority   #=> 0\n
priority= Thread.priority=(p1)\nSets the priority of <i>thr</i> to <i>integer</i>. Higher-priority threads\nwill run more frequently than lower-priority threads (but lower-priority\nthreads can also run).\n\nThis is just hint for Ruby thread scheduler.  It may be ignored on some\nplatform.\n\n   count1 = count2 = 0\n   a = Thread.new do\n         loop { count1 += 1 }\n       end\n   a.priority = -1\n\n   b = Thread.new do\n         loop { count2 += 1 }\n       end\n   b.priority = -2\n   sleep 1   #=> 1\n   count1    #=> 622504\n   count2    #=> 5832\n
raise Thread.raise(*args)\nRaises an exception (see `Kernel::raise`) from <i>thr</i>. The\ncaller does not have to be <i>thr</i>.\n\n   Thread.abort_on_exception = true\n   a = Thread.new { sleep(200) }\n   a.raise("Gotcha")\n\n<em>produces:</em>\n\n   prog.rb:3: Gotcha (RuntimeError)\n    from prog.rb:2:in `initialize'\n    from prog.rb:2:in `new'\n    from prog.rb:2\n
run Thread.run()\nWakes up <i>thr</i>, making it eligible for scheduling.\n\n   a = Thread.new { puts "a"; Thread.stop; puts "c" }\n   sleep 0.1 while a.status!='sleep'\n   puts "Got here"\n   a.run\n   a.join\n\n<em>produces:</em>\n\n   a\n   Got here\n   c\n
safe_level Thread.safe_level()\nReturns the safe level in effect for <i>thr</i>. Setting thread-local safe\nlevels can help when implementing sandboxes which run insecure code.\n\n   thr = Thread.new { $SAFE = 3; sleep }\n   Thread.current.safe_level   #=> 0\n   thr.safe_level              #=> 3\n
set_trace_func Thread.set_trace_func(p1)\nEstablishes _proc_ on _thr_ as the handler for tracing, or\ndisables tracing if the parameter is +nil+.\nSee +set_trace_func+.\n
status Thread.status()\nReturns the status of <i>thr</i>: ```sleep`'' if <i>thr</i> is\nsleeping or waiting on I/O, ```run`'' if <i>thr</i> is executing,\n```aborting`'' if <i>thr</i> is aborting, `false` if\n<i>thr</i> terminated normally, and `nil` if <i>thr</i>\nterminated with an exception.\n\n   a = Thread.new { raise("die now") }\n   b = Thread.new { Thread.stop }\n   c = Thread.new { Thread.exit }\n   d = Thread.new { sleep }\n   d.kill                  #=> #<Thread:0x401b3678 aborting>\n   a.status                #=> nil\n   b.status                #=> "sleep"\n   c.status                #=> false\n   d.status                #=> "aborting"\n   Thread.current.status   #=> "run"\n
stop? Thread.stop?()\nReturns `true` if <i>thr</i> is dead or sleeping.\n\n   a = Thread.new { Thread.stop }\n   b = Thread.current\n   a.stop?   #=> true\n   b.stop?   #=> false\n
terminate Thread.terminate()\nTerminates <i>thr</i> and schedules another thread to be run. If this thread\nis already marked to be killed, `exit` returns the\n`Thread`. If this is the main thread, or the last thread, exits\nthe process.\n
value Thread.value()\nWaits for <i>thr</i> to complete (via `Thread#join`) and returns\nits value.\n\n   a = Thread.new { 2 + 2 }\n   a.value   #=> 4\n
wakeup Thread.wakeup()\nMarks <i>thr</i> as eligible for scheduling (it may still remain blocked on\nI/O, however). Does not invoke the scheduler (see `Thread#run`).\n\n   c = Thread.new { Thread.stop; puts "hey!" }\n   sleep 0.1 while c.status!='sleep'\n   c.wakeup\n   c.join\n\n<em>produces:</em>\n\n   hey!\n
constants Module.constants(*args)\nIn the first form, returns an array of the names of all\nconstants accessible from the point of call.\nThis list includes the names of all modules and classes\ndefined in the global scope.\n\n   Module.constants.first(4)\n => [:ARGF, :ARGV, :ArgumentError, :Array]\n\n   Module.constants.include?(:SEEK_SET)   # => false\n\n   class IO\n     Module.constants.include?(:SEEK_SET) # => true\n   end\n\nThe second form calls the instance method +constants+.\n
nesting Module.nesting()\nReturns the list of +Modules+ nested at the point of call.\n\n   module M1\n     module M2\n       $a = Module.nesting\n     end\n   end\n   $a           #=> [M1::M2, M1]\n   $a[0].name   #=> "M1::M2"\n
new Module.new()\nCreates a new anonymous module. If a block is given, it is passed\nthe module object, and the block is evaluated in the context of this\nmodule using `module_eval`.\n\n   fred = Module.new do\n     def meth1\n       "hello"\n     end\n     def meth2\n       "bye"\n     end\n   end\n   a = "my string"\n   a.extend(fred)   #=> "my string"\n   a.meth1          #=> "hello"\n   a.meth2          #=> "bye"\n\nAssign the module to a constant (name starting uppercase) if you\nwant to treat it like a regular module.\n
ancestors Module.ancestors()\nReturns a list of modules included in <i>mod</i> (including\n<i>mod</i> itself).\n\n   module Mod\n     include Math\n     include Comparable\n   end\n\n   Mod.ancestors    #=> [Mod, Comparable, Math]\n   Math.ancestors   #=> [Math]\n
autoload Module.autoload(p1, p2)\nRegisters _filename_ to be loaded (using `Kernel::require`)\nthe first time that _module_ (which may be a `String` or\na symbol) is accessed in the namespace of _mod_.\n\n   module A\n   end\n   A.autoload(:B, "b")\n   A::B.doit            # autoloads "b"\n
autoload? Module.autoload?(p1)\nReturns _filename_ to be loaded if _name_ is registered as\n+autoload+ in the namespace of _mod_.\n\n   module A\n   end\n   A.autoload(:B, "b")\n   A.autoload?(:B)            #=> "b"\n
class_eval Module.class_eval(*args)\nEvaluates the string or block in the context of _mod_. This can\nbe used to add methods to a class. `module_eval` returns\nthe result of evaluating its argument. The optional _filename_\nand _lineno_ parameters set the text for error messages.\n\n   class Thing\n   end\n   a = %q{def hello() "Hello there!" end}\n   Thing.module_eval(a)\n   puts Thing.new.hello()\n   Thing.module_eval("invalid code", "dummy", 123)\n\n<em>produces:</em>\n\n   Hello there!\n   dummy:123:in `module_eval': undefined local variable\n       or method `code' for Thing:Class\n
class_exec Module.class_exec(*args)\nEvaluates the given block in the context of the class/module.\nThe method defined in the block will belong to the receiver.\n\n   class Thing\n   end\n   Thing.class_exec{\n     def hello() "Hello there!" end\n   }\n   puts Thing.new.hello()\n\n<em>produces:</em>\n\n   Hello there!\n
class_variable_defined? Module.class_variable_defined?(p1)\nReturns `true` if the given class variable is defined\nin <i>obj</i>.\n\n   class Fred\n     @@foo = 99\n   end\n   Fred.class_variable_defined?(:@@foo)    #=> true\n   Fred.class_variable_defined?(:@@bar)    #=> false\n
class_variable_get Module.class_variable_get(p1)\nReturns the value of the given class variable (or throws a\n`NameError` exception). The `@@` part of the\nvariable name should be included for regular class variables\n\n   class Fred\n     @@foo = 99\n   end\n   Fred.class_variable_get(:@@foo)     #=> 99\n
class_variable_set Module.class_variable_set(p1, p2)\nSets the class variable names by <i>symbol</i> to\n<i>object</i>.\n\n   class Fred\n     @@foo = 99\n     def foo\n       @@foo\n     end\n   end\n   Fred.class_variable_set(:@@foo, 101)     #=> 101\n   Fred.new.foo                             #=> 101\n
class_variables Module.class_variables()\nReturns an array of the names of class variables in <i>mod</i>.\n\n   class One\n     @@var1 = 1\n   end\n   class Two < One\n     @@var2 = 2\n   end\n   One.class_variables   #=> [:@@var1]\n   Two.class_variables   #=> [:@@var2]\n
const_defined? Module.const_defined?(p1, p2 = v2)\nChecks for a constant with the given name in <i>mod</i>\nIf +inherit+ is set, the lookup will also search\nthe ancestors (and +Object+ if <i>mod</i> is a +Module+.)\n\nReturns whether or not a definition is found:\n\n   Math.const_defined? "PI"   #=> true\n   IO.const_defined? :SYNC   #=> true\n   IO.const_defined? :SYNC, false   #=> false\n
const_get Module.const_get(p1, p2 = v2)\nChecks for a constant with the given name in <i>mod</i>\nIf +inherit+ is set, the lookup will also search\nthe ancestors (and +Object+ if <i>mod</i> is a +Module+.)\n\nThe value of the constant is returned if a definition is found,\notherwise a +NameError+ is raised.\n\n   Math.const_get(:PI)   #=> 3.14159265358979\n
const_missing Module.const_missing(p1)\nInvoked when a reference is made to an undefined constant in\n<i>mod</i>. It is passed a symbol for the undefined constant, and\nreturns a value to be used for that constant. The\nfollowing code is an example of the same:\n\n  def Foo.const_missing(name)\n    name # return the constant name as Symbol\n  end\n\n  Foo::UNDEFINED_CONST    #=> :UNDEFINED_CONST: symbol returned\n\nIn the next example when a reference is made to an undefined constant,\nit attempts to load a file whose name is the lowercase version of the\nconstant (thus class `Fred` is assumed to be in file\n`fred.rb`).  If found, it returns the loaded class. It\ntherefore implements an autoload feature similar to Kernel#autoload and\nModule#autoload.\n\n  def Object.const_missing(name)\n    @looked_for ||= {}\n    str_name = name.to_s\n    raise "Class not found: #{name}" if @looked_for[str_name]\n    @looked_for[str_name] = 1\n    file = str_name.downcase\n    require file\n    klass = const_get(name)\n    return klass if klass\n    raise "Class not found: #{name}"\n  end\n
const_set Module.const_set(p1, p2)\nSets the named constant to the given object, returning that object.\nCreates a new constant if no constant with the given name previously\nexisted.\n\n   Math.const_set("HIGH_SCHOOL_PI", 22.0/7.0)   #=> 3.14285714285714\n   Math::HIGH_SCHOOL_PI - Math::PI              #=> 0.00126448926734968\n
constants Module.constants(p1 = v1)\nReturns an array of the names of the constants accessible in\n<i>mod</i>. This includes the names of constants in any included\nmodules (example at start of section), unless the <i>all</i>\nparameter is set to `false`.\n\n  IO.constants.include?(:SYNC)        #=> true\n  IO.constants(false).include?(:SYNC) #=> false\n\nAlso see `Module::const_defined?`.\n
freeze Module.freeze()\nPrevents further modifications to <i>mod</i>.\n\nThis method returns self.\n
include? Module.include?(p1)\nReturns `true` if <i>module</i> is included in\n<i>mod</i> or one of <i>mod</i>'s ancestors.\n\n   module A\n   end\n   class B\n     include A\n   end\n   class C < B\n   end\n   B.include?(A)   #=> true\n   C.include?(A)   #=> true\n   A.include?(A)   #=> false\n
included_modules Module.included_modules()\nReturns the list of modules included in <i>mod</i>.\n\n   module Mixin\n   end\n\n   module Outer\n     include Mixin\n   end\n\n   Mixin.included_modules   #=> []\n   Outer.included_modules   #=> [Mixin]\n
instance_method Module.instance_method(p1)\nReturns an +UnboundMethod+ representing the given\ninstance method in _mod_.\n\n   class Interpreter\n     def do_a() print "there, "; end\n     def do_d() print "Hello ";  end\n     def do_e() print "!\\n";     end\n     def do_v() print "Dave";    end\n     Dispatcher = {\n       "a" => instance_method(:do_a),\n       "d" => instance_method(:do_d),\n       "e" => instance_method(:do_e),\n       "v" => instance_method(:do_v)\n     }\n     def interpret(string)\n       string.each_char {|b| Dispatcher[b].bind(self).call }\n     end\n   end\n\n   interpreter = Interpreter.new\n   interpreter.interpret('dave')\n\n<em>produces:</em>\n\n   Hello there, Dave!\n
instance_methods Module.instance_methods(*args)\nReturns an array containing the names of the public and protected instance\nmethods in the receiver. For a module, these are the public and protected\nmethods;\nfor a class, they are the instance (not singleton) methods. With no\nargument, or with an argument that is `false`, the\ninstance methods in <i>mod</i> are returned, otherwise the methods\nin <i>mod</i> and <i>mod</i>'s superclasses are returned.\n\n   module A\n     def method1()  end\n   end\n   class B\n     def method2()  end\n   end\n   class C < B\n     def method3()  end\n   end\n\n   A.instance_methods                #=> [:method1]\n   B.instance_methods(false)         #=> [:method2]\n   C.instance_methods(false)         #=> [:method3]\n   C.instance_methods(true).length   #=> 43\n
method_defined? Module.method_defined?(p1)\nReturns +true+ if the named method is defined by\n_mod_ (or its included modules and, if _mod_ is a class,\nits ancestors). Public and protected methods are matched.\n\n   module A\n     def method1()  end\n   end\n   class B\n     def method2()  end\n   end\n   class C < B\n     include A\n     def method3()  end\n   end\n\n   A.method_defined? :method1    #=> true\n   C.method_defined? "method1"   #=> true\n   C.method_defined? "method2"   #=> true\n   C.method_defined? "method3"   #=> true\n   C.method_defined? "method4"   #=> false\n
module_eval Module.module_eval(*args)\nEvaluates the string or block in the context of _mod_. This can\nbe used to add methods to a class. `module_eval` returns\nthe result of evaluating its argument. The optional _filename_\nand _lineno_ parameters set the text for error messages.\n\n   class Thing\n   end\n   a = %q{def hello() "Hello there!" end}\n   Thing.module_eval(a)\n   puts Thing.new.hello()\n   Thing.module_eval("invalid code", "dummy", 123)\n\n<em>produces:</em>\n\n   Hello there!\n   dummy:123:in `module_eval': undefined local variable\n       or method `code' for Thing:Class\n
module_exec Module.module_exec(*args)\nEvaluates the given block in the context of the class/module.\nThe method defined in the block will belong to the receiver.\n\n   class Thing\n   end\n   Thing.class_exec{\n     def hello() "Hello there!" end\n   }\n   puts Thing.new.hello()\n\n<em>produces:</em>\n\n   Hello there!\n
name Module.name()\nReturns the name of the module <i>mod</i>.  Returns nil for anonymous modules.\n
private_class_method Module.private_class_method(*args)\nMakes existing class methods private. Often used to hide the default\nconstructor `new`.\n\n   class SimpleSingleton  # Not thread safe\n     private_class_method :new\n     def SimpleSingleton.create(*args, &block)\n       @me = new(*args, &block) if ! @me\n       @me\n     end\n   end\n
private_instance_methods Module.private_instance_methods(*args)\nReturns a list of the private instance methods defined in\n<i>mod</i>. If the optional parameter is not `false`, the\nmethods of any ancestors are included.\n\n   module Mod\n     def method1()  end\n     private :method1\n     def method2()  end\n   end\n   Mod.instance_methods           #=> [:method2]\n   Mod.private_instance_methods   #=> [:method1]\n
private_method_defined? Module.private_method_defined?(p1)\nReturns +true+ if the named private method is defined by\n_ mod_ (or its included modules and, if _mod_ is a class,\nits ancestors).\n\n   module A\n     def method1()  end\n   end\n   class B\n     private\n     def method2()  end\n   end\n   class C < B\n     include A\n     def method3()  end\n   end\n\n   A.method_defined? :method1            #=> true\n   C.private_method_defined? "method1"   #=> false\n   C.private_method_defined? "method2"   #=> true\n   C.method_defined? "method2"           #=> false\n
protected_instance_methods Module.protected_instance_methods(*args)\nReturns a list of the protected instance methods defined in\n<i>mod</i>. If the optional parameter is not `false`, the\nmethods of any ancestors are included.\n
protected_method_defined? Module.protected_method_defined?(p1)\nReturns +true+ if the named protected method is defined\nby _mod_ (or its included modules and, if _mod_ is a\nclass, its ancestors).\n\n   module A\n     def method1()  end\n   end\n   class B\n     protected\n     def method2()  end\n   end\n   class C < B\n     include A\n     def method3()  end\n   end\n\n   A.method_defined? :method1              #=> true\n   C.protected_method_defined? "method1"   #=> false\n   C.protected_method_defined? "method2"   #=> true\n   C.method_defined? "method2"             #=> true\n
psych_yaml_as Module.psych_yaml_as(url)\n\n
public_class_method Module.public_class_method(*args)\nMakes a list of existing class methods public.\n
public_instance_method Module.public_instance_method(p1)\nSimilar to _instance_method_, searches public method only.\n
public_instance_methods Module.public_instance_methods(*args)\nReturns a list of the public instance methods defined in <i>mod</i>.\nIf the optional parameter is not `false`, the methods of\nany ancestors are included.\n
public_method_defined? Module.public_method_defined?(p1)\nReturns +true+ if the named public method is defined by\n_mod_ (or its included modules and, if _mod_ is a class,\nits ancestors).\n\n   module A\n     def method1()  end\n   end\n   class B\n     protected\n     def method2()  end\n   end\n   class C < B\n     include A\n     def method3()  end\n   end\n\n   A.method_defined? :method1           #=> true\n   C.public_method_defined? "method1"   #=> true\n   C.public_method_defined? "method2"   #=> false\n   C.method_defined? "method2"          #=> true\n
rake_extension Module.rake_extension(method)\nCheck for an existing method in the current class before extending.  IF\nthe method already exists, then a warning is printed and the extension is\nnot added.  Otherwise the block is yielded and any definitions in the\nblock will take effect.\n\nUsage:\n\n  class String\n    rake_extension("xyz") do\n      def xyz\n        ...\n      end\n    end\n  end\n
rake_original_const_missing Module.rake_original_const_missing(p1)\nRename the original handler to make it available.\n
remove_class_variable Module.remove_class_variable(p1)\nRemoves the definition of the <i>sym</i>, returning that\nconstant's value.\n\n   class Dummy\n     @@var = 99\n     puts @@var\n     remove_class_variable(:@@var)\n     p(defined? @@var)\n   end\n\n<em>produces:</em>\n\n   99\n   nil\n
to_s Module.to_s()\nReturn a string representing this module or class. For basic\nclasses and modules, this is the name. For singletons, we\nshow information on the thing we're attached to as well.\n
yaml_as Module.yaml_as(url)\n\n
yaml_tag Object.yaml_tag(url)\n\n
CSV Object.CSV(*args, &block)\nAnother name for CSV::instance().\n
DelegateClass Object.DelegateClass(superclass)\nThe primary interface to this library.  Use to setup delegation when defining\nyour class.\n\n  class MyClass < DelegateClass(ClassToDelegateTo) # Step 1\n    def initialize\n      super(obj_of_ClassToDelegateTo)              # Step 2\n    end\n  end\n\nHere's a sample of use from Tempfile which is really a File object with a\nfew special rules about storage location and when the File should be\ndeleted.  That makes for an almost textbook perfect example of how to use\ndelegation.\n\n  class Tempfile < DelegateClass(File)\n constant and class member data initialization...\n\n    def initialize(basename, tmpdir=Dir::tmpdir)\n build up file path/name in var tmpname...\n\n      @tmpfile = File.open(tmpname, File::RDWR|File::CREAT|File::EXCL, 0600)\n ...\n\n      super(@tmpfile)\n below this point, all methods of File are supported...\n    end\n ...\n  end\n
Digest Object.Digest(name)\nReturns a Digest subclass by +name+.\n\n  require 'digest'\n\n  Digest("MD5")\n => Digest::MD5\n\n  Digest("Foo")\n => LoadError: library not found for class Digest::Foo -- digest/foo\n
check_signedness Object.check_signedness(type, headers = nil, opts = nil, &b)\nReturns the signedness of the given +type+.  You may optionally\nspecify additional +headers+ to search in for the +type+.\n\nIf the +type+ is found and is a numeric type, a macro is passed as a\npreprocessor constant to the compiler using the +type+ name, in\nuppercase, prepended with 'SIGNEDNESS_OF_', followed by the +type+\nname, followed by '=X' where 'X' is positive integer if the +type+ is\nunsigned, or negative integer if the +type+ is signed.\n\nFor example, if size_t is defined as unsigned, then\ncheck_signedness('size_t') would returned +1 and the\nSIGNEDNESS_OF_SIZE_T=+1 preprocessor macro would be passed to the\ncompiler, and SIGNEDNESS_OF_INT=-1 if check_signedness('int') is\ndone.\n
check_sizeof Object.check_sizeof(type, headers = nil, opts = "", &b)\nReturns the size of the given +type+.  You may optionally specify additional\n+headers+ to search in for the +type+.\n\nIf found, a macro is passed as a preprocessor constant to the compiler using\nthe type name, in uppercase, prepended with 'SIZEOF_', followed by the type\nname, followed by '=X' where 'X' is the actual size.\n\nFor example, if check_sizeof('mystruct') returned 12, then the\nSIZEOF_MYSTRUCT=12 preprocessor macro would be passed to the compiler.\n
chmod Object.chmod()\nChange the mode of each FILE to OCTAL-MODE.\n\n  ruby -run -e chmod -- [OPTION] OCTAL-MODE FILE\n\n  -v          verbose\n
class Object.class()\nReturns the class of <i>obj</i>. This method must always be\ncalled with an explicit receiver, as `class` is also a\nreserved word in Ruby.\n\n   1.class      #=> Fixnum\n   self.class   #=> Object\n
clone Object.clone()\nProduces a shallow copy of <i>obj</i>---the instance variables of\n<i>obj</i> are copied, but not the objects they reference. Copies\nthe frozen and tainted state of <i>obj</i>. See also the discussion\nunder `Object#dup`.\n\n   class Klass\n      attr_accessor :str\n   end\n   s1 = Klass.new      #=> #<Klass:0x401b3a38>\n   s1.str = "Hello"    #=> "Hello"\n   s2 = s1.clone       #=> #<Klass:0x401b3998 @str="Hello">\n   s2.str[1,4] = "i"   #=> "i"\n   s1.inspect          #=> "#<Klass:0x401b3a38 @str=\"Hi\">"\n   s2.inspect          #=> "#<Klass:0x401b3998 @str=\"Hi\">"\n\nThis method may have class-specific behavior.  If so, that\nbehavior will be documented under the #+initialize_copy+ method of\nthe class.\n
convertible_int Object.convertible_int(type, headers = nil, opts = nil, &b)\nReturns the convertible integer type of the given +type+.  You may\noptionally specify additional +headers+ to search in for the +type+.\n_Convertible_ means actually same type, or typedefed from same type.\n\nIf the +type+ is a integer type and _convertible_ type is found,\nfollowing macros are passed as preprocessor constants to the\ncompiler using the +type+ name, in uppercase.\n\n* 'TYPEOF_', followed by the +type+ name, followed by '=X' where 'X'\n  is the found _convertible_ type name.  * 'TYP2NUM' and 'NUM2TYP,\n  where 'TYP' is the +type+ name in uppercase with replacing '_t'\n  suffix with 'T', followed by '=X' where 'X' is the macro name to\n  convert +type+ to +Integer+ object, and vice versa.\n\nFor example, if foobar_t is defined as unsigned long, then\nconvertible_int("foobar_t") would return "unsigned long", and define\nmacros:\ndefine TYPEOF_FOOBAR_T unsigned long\ndefine FOOBART2NUM ULONG2NUM\ndefine NUM2FOOBART NUM2ULONG\n
cp Object.cp()\nCopy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY\n\n  ruby -run -e cp -- [OPTION] SOURCE DEST\n\n  -p          preserve file attributes if possible\n  -r          copy recursively\n  -v          verbose\n
create_header Object.create_header(header = "extconf.h")\nGenerates a header file consisting of the various macro definitions generated\nby other methods such as have_func and have_header. These are then wrapped in\na custom #ifndef based on the +header+ file name, which defaults to\n'extconf.h'.\n\nFor example:\n extconf.rb\n   require 'mkmf'\n   have_func('realpath')\n   have_header('sys/utime.h')\n   create_header\n   create_makefile('foo')\n\nThe above script would generate the following extconf.h file:\nifndef EXTCONF_H\ndefine EXTCONF_H\ndefine HAVE_REALPATH 1\ndefine HAVE_SYS_UTIME_H 1\nendif\n\nGiven that the create_header method generates a file based on definitions\nset earlier in your extconf.rb file, you will probably want to make this\none of the last methods you call in your script.\n
create_makefile Object.create_makefile(target, srcprefix = nil)\nGenerates the Makefile for your extension, passing along any options and\npreprocessor constants that you may have generated through other methods.\n\nThe +target+ name should correspond the name of the global function name\ndefined within your C extension, minus the 'Init_'.  For example, if your\nC extension is defined as 'Init_foo', then your target would simply be 'foo'.\n\nIf any '/' characters are present in the target name, only the last name\nis interpreted as the target name, and the rest are considered toplevel\ndirectory names, and the generated Makefile will be altered accordingly to\nfollow that directory structure.\n\nFor example, if you pass 'test/foo' as a target name, your extension will\nbe installed under the 'test' directory.  This means that in order to\nload the file within a Ruby program later, that directory structure will\nhave to be followed, e.g. "require 'test/foo'".\n\nThe +srcprefix+ should be used when your source files are not in the same\ndirectory as your build script. This will not only eliminate the need for\nyou to manually copy the source files into the same directory as your build\nscript, but it also sets the proper +target_prefix+ in the generated\nMakefile.\n\nSetting the +target_prefix+ will, in turn, install the generated binary in\na directory under your RbConfig::CONFIG['sitearchdir'] that mimics your local\nfilesystem when you run 'make install'.\n\nFor example, given the following file tree:\n\n   ext/\n      extconf.rb\n      test/\n         foo.c\n\nAnd given the following code:\n\n   create_makefile('test/foo', 'test')\n\nThat will set the +target_prefix+ in the generated Makefile to 'test'. That,\nin turn, will create the following file tree when installed via the\n'make install' command:\n\n   /path/to/ruby/sitearchdir/test/foo.so\n\nIt is recommended that you use this approach to generate your makefiles,\ninstead of copying files around manually, because some third party\nlibraries may depend on the +target_prefix+ being set properly.\n\nThe +srcprefix+ argument can be used to override the default source\ndirectory, i.e. the current directory . It is included as part of the VPATH\nand added to the list of INCFLAGS.\n
dclone Object.dclone()\nprovides a unified +clone+ operation, for REXML::XPathParser\nto use across multiple Object types\n
default_src_encoding Object.default_src_encoding()\nDO NOT WRITE ANY MAGIC COMMENT HERE.\n
define_singleton_method Object.define_singleton_method(*args)\nDefines a singleton method in the receiver. The _method_\nparameter can be a +Proc+, a +Method+ or an +UnboundMethod+ object.\nIf a block is specified, it is used as the method body.\n\n   class A\n     class << self\n       def class_name\n         to_s\n       end\n     end\n   end\n   A.define_singleton_method(:who_am_i) do\n     "I am: #{class_name}"\n   end\n   A.who_am_i   # ==> "I am: A"\n\n   guy = "Bob"\n   guy.define_singleton_method(:hello) { "#{self}: Hello there!" }\n   guy.hello    #=>  "Bob: Hello there!"\n
depend_rules Object.depend_rules(depend)\nProcesses the data contents of the "depend" file.\nEach line of this file is expected to be a file name.\n\nReturns the output of findings, in Makefile format.\n
dir_config Object.dir_config(target, idefault=nil, ldefault=nil)\nSets a +target+ name that the user can then use to configure various 'with'\noptions with on the command line by using that name.  For example, if the\ntarget is set to "foo", then the user could use the --with-foo-dir command\nline option.\n\nYou may pass along additional 'include' or 'lib' defaults via the +idefault+\nand +ldefault+ parameters, respectively.\n\nNote that dir_config only adds to the list of places to search for libraries\nand include files.  It does not link the libraries into your application.\n
display Object.display(p1 = v1)\nPrints <i>obj</i> on the given port (default `$>`).\nEquivalent to:\n\n   def display(port=$>)\n     port.write self\n   end\n\nFor example:\n\n   1.display\n   "cat".display\n   [ 4, 5, 6 ].display\n   puts\n\n<em>produces:</em>\n\n   1cat456\n
dummy_makefile Object.dummy_makefile(srcdir)\ncreates a stub Makefile.\n
dup Object.dup()\nProduces a shallow copy of <i>obj</i>---the instance variables of\n<i>obj</i> are copied, but not the objects they reference.\n`dup` copies the tainted state of <i>obj</i>. See also\nthe discussion under `Object#clone`. In general,\n`clone` and `dup` may have different semantics\nin descendant classes. While `clone` is used to duplicate\nan object, including its internal state, `dup` typically\nuses the class of the descendant object to create the new instance.\n\nThis method may have class-specific behavior.  If so, that\nbehavior will be documented under the #+initialize_copy+ method of\nthe class.\n
enable_config Object.enable_config(config, default=nil)\nTests for the presence of an --enable-<tt>config</tt> or\n--disable-<tt>config</tt> option. Returns true if the enable option is given,\nfalse if the disable option is given, and the default value otherwise.\n\nThis can be useful for adding custom definitions, such as debug information.\n\nExample:\n\n   if enable_config("debug")\n      $defs.push("-DOSSL_DEBUG") unless $defs.include? "-DOSSL_DEBUG"\n   end\n
enum_for Object.enum_for(*args)\nCreates a new Enumerator which will enumerate by on calling +method+ on\n+obj+.\n\n+method+:: the method to call on +obj+ to generate the enumeration\n+args+:: arguments that will be passed in +method+ <i>in addition</i>\n         to the item itself.  Note that the number of args\n         must not exceed the number expected by +method+\n\n=== Example\n\n  str = "xyz"\n\n  enum = str.enum_for(:each_byte)\n  enum.each { |b| puts b }\n => 120\n => 121\n => 122\n protect an array from being modified by some_method\n  a = [1, 2, 3]\n  some_method(a.to_enum)\n
eql? Object.eql?(p1)\nEquality---At the `Object` level, `==` returns\n`true` only if <i>obj</i> and <i>other</i> are the\nsame object. Typically, this method is overridden in descendant\nclasses to provide class-specific meaning.\n\nUnlike `==`, the `equal?` method should never be\noverridden by subclasses: it is used to determine object identity\n(that is, `a.equal?(b)` iff `a` is the same\nobject as `b`).\n\nThe `eql?` method returns `true` if\n<i>obj</i> and <i>anObject</i> have the same value. Used by\n`Hash` to test members for equality.  For objects of\nclass `Object`, `eql?` is synonymous with\n`==`. Subclasses normally continue this tradition, but\nthere are exceptions. `Numeric` types, for example,\nperform type conversion across `==`, but not across\n`eql?`, so:\n\n   1 == 1.0     #=> true\n   1.eql? 1.0   #=> false\n
extend Object.extend(*args)\nAdds to _obj_ the instance methods from each module given as a\nparameter.\n\n   module Mod\n     def hello\n       "Hello from Mod.\\n"\n     end\n   end\n\n   class Klass\n     def hello\n       "Hello from Klass.\\n"\n     end\n   end\n\n   k = Klass.new\n   k.hello         #=> "Hello from Klass.\\n"\n   k.extend(Mod)   #=> #<Klass:0x401b3bc8>\n   k.hello         #=> "Hello from Mod.\\n"\n
find_executable Object.find_executable(bin, path = nil)\nSearches for the executable +bin+ on +path+. The default path is your\nPATH environment variable. If that isn't defined, it will resort to\nsearching /usr/local/bin, /usr/ucb, /usr/bin and /bin.\n\nIf found, it will return the full path, including the executable name,\nof where it was found.\n\nNote that this method does not actually affect the generated Makefile.\n
find_header Object.find_header(header, *paths)\nInstructs mkmf to search for the given +header+ in any of the +paths+\nprovided, and returns whether or not it was found in those paths.\n\nIf the header is found then the path it was found on is added to the list\nof included directories that are sent to the compiler (via the -I switch).\n
find_library Object.find_library(lib, func, *paths, &b)\nReturns whether or not the entry point +func+ can be found within the library\n+lib+ in one of the +paths+ specified, where +paths+ is an array of strings.\nIf +func+ is nil , then the main() function is used as the entry point.\n\nIf +lib+ is found, then the path it was found on is added to the list of\nlibrary paths searched and linked against.\n
find_type Object.find_type(type, opt, *headers, &b)\nReturns where the static type +type+ is defined.\n\nYou may also pass additional flags to +opt+ which are then passed along to\nthe compiler.\n\nSee also +have_type+.\n
freeze Object.freeze()\nPrevents further modifications to <i>obj</i>. A\n`RuntimeError` will be raised if modification is attempted.\nThere is no way to unfreeze a frozen object. See also\n`Object#frozen?`.\n\nThis method returns self.\n\n   a = [ "a", "b", "c" ]\n   a.freeze\n   a << "z"\n\n<em>produces:</em>\n\n   prog.rb:3:in `<<': can't modify frozen array (RuntimeError)\n    from prog.rb:3\n
frozen? Object.frozen?()\nReturns the freeze status of <i>obj</i>.\n\n   a = [ "a", "b", "c" ]\n   a.freeze    #=> ["a", "b", "c"]\n   a.frozen?   #=> true\n
hash Object.hash()\nGenerates a `Fixnum` hash value for this object.\nThis function must have the property that a.eql?(b) implies\na.hash `==` b.hash.\nThe hash value is used by class `Hash`.\nAny hash value that exceeds the capacity of a `Fixnum` will be\ntruncated before being used.\n\n     "waffle".hash #=> -910576647\n
have_const Object.have_const(const, headers = nil, opt = "", &b)\nReturns whether or not the constant +const+ is defined.  You may\noptionally pass the +type+ of +const+ as `[const, type]`,\nlike as:\n\n  have_const(%w[PTHREAD_MUTEX_INITIALIZER pthread_mutex_t], "pthread.h")\n\nYou may also pass additional +headers+ to check against in addition\nto the common header files, and additional flags to +opt+ which are\nthen passed along to the compiler.\n\nIf found, a macro is passed as a preprocessor constant to the compiler using\nthe type name, in uppercase, prepended with 'HAVE_CONST_'.\n\nFor example, if have_const('foo') returned true, then the HAVE_CONST_FOO\npreprocessor macro would be passed to the compiler.\n
have_framework Object.have_framework(fw, &b)\nReturns whether or not the given +framework+ can be found on your system.\nIf found, a macro is passed as a preprocessor constant to the compiler\nusing the framework name, in uppercase, prepended with +HAVE_FRAMEWORK_+.\n\nFor example, if `have_framework('Ruby')` returned true, then\nthe +HAVE_FRAMEWORK_RUBY+ preprocessor macro would be passed to the\ncompiler.\n\nIf +fw+ is a pair of the framework name and its header file name\nthat header file is checked, instead of the normally used header\nfile which is named same as the framework.\n
have_func Object.have_func(func, headers = nil, &b)\nReturns whether or not the function +func+ can be found in the common\nheader files, or within any +headers+ that you provide.  If found, a\nmacro is passed as a preprocessor constant to the compiler using the\nfunction name, in uppercase, prepended with 'HAVE_'.\n\nFor example, if have_func('foo') returned true, then the HAVE_FOO\npreprocessor macro would be passed to the compiler.\n
have_header Object.have_header(header, preheaders = nil, &b)\nReturns whether or not the given +header+ file can be found on your system.\nIf found, a macro is passed as a preprocessor constant to the compiler using\nthe header file name, in uppercase, prepended with 'HAVE_'.\n\nFor example, if have_header('foo.h') returned true, then the HAVE_FOO_H\npreprocessor macro would be passed to the compiler.\n
have_library Object.have_library(lib, func = nil, headers = nil, &b)\nReturns whether or not the given entry point +func+ can be found within\n+lib+.  If +func+ is nil, the 'main()' entry point is used by default.\nIf found, it adds the library to list of libraries to be used when linking\nyour extension.\n\nIf +headers+ are provided, it will include those header files as the\nheader files it looks in when searching for +func+.\n\nThe real name of the library to be linked can be altered by\n'--with-FOOlib' configuration option.\n
have_macro Object.have_macro(macro, headers = nil, opt = "", &b)\nReturns whether or not +macro+ is defined either in the common header\nfiles or within any +headers+ you provide.\n\nAny options you pass to +opt+ are passed along to the compiler.\n
have_struct_member Object.have_struct_member(type, member, headers = nil, &b)\nReturns whether or not the struct of type +type+ contains +member+.  If\nit does not, or the struct type can't be found, then false is returned.  You\nmay optionally specify additional +headers+ in which to look for the struct\n(in addition to the common header files).\n\nIf found, a macro is passed as a preprocessor constant to the compiler using\nthe type name and the member name, in uppercase, prepended with 'HAVE_'.\n\nFor example, if have_struct_member('struct foo', 'bar') returned true, then the\nHAVE_STRUCT_FOO_BAR preprocessor macro would be passed to the compiler.\n\nHAVE_ST_BAR is also defined for backward compatibility.\n
have_type Object.have_type(type, headers = nil, opt = "", &b)\nReturns whether or not the static type +type+ is defined.  You may\noptionally pass additional +headers+ to check against in addition to the\ncommon header files.\n\nYou may also pass additional flags to +opt+ which are then passed along to\nthe compiler.\n\nIf found, a macro is passed as a preprocessor constant to the compiler using\nthe type name, in uppercase, prepended with 'HAVE_TYPE_'.\n\nFor example, if have_type('foo') returned true, then the HAVE_TYPE_FOO\npreprocessor macro would be passed to the compiler.\n
have_var Object.have_var(var, headers = nil, &b)\nReturns whether or not the variable +var+ can be found in the common\nheader files, or within any +headers+ that you provide.  If found, a\nmacro is passed as a preprocessor constant to the compiler using the\nvariable name, in uppercase, prepended with 'HAVE_'.\n\nFor example, if have_var('foo') returned true, then the HAVE_FOO\npreprocessor macro would be passed to the compiler.\n
help Object.help()\nDisplay help message.\n\n  ruby -run -e help [COMMAND]\n
httpd Object.httpd()\nRun WEBrick HTTP server.\n\n  ruby -run -e httpd -- [OPTION] DocumentRoot\n\n  --bind-address=ADDR         address to bind\n  --port=NUM                  listening port number\n  --max-clients=MAX           max number of simultaneous clients\n  --temp-dir=DIR              temporary directory\n  --do-not-reverse-lookup     disable reverse lookup\n  --request-timeout=SECOND    request timeout in seconds\n  --http-version=VERSION      HTTP version\n  -v                          verbose\n
inspect Object.inspect()\nReturns a string containing a human-readable representation of\n<i>obj</i>. If not overridden and no instance variables, uses the\n`to_s` method to generate the string.\n<i>obj</i>.  If not overridden, uses the `to_s` method to\ngenerate the string.\n\n   [ 1, 2, 3..4, 'five' ].inspect   #=> "[1, 2, 3..4, \"five\"]"\n   Time.new.inspect                 #=> "2008-03-08 19:43:39 +0900"\n
install Object.install()\nCopy SOURCE to DEST.\n\n  ruby -run -e install -- [OPTION] SOURCE DEST\n\n  -p          apply access/modification times of SOURCE files to\n              corresponding destination files\n  -m          set permission mode (as in chmod), instead of 0755\n  -v          verbose\n
instance_of? Object.instance_of?(p1)\nReturns `true` if <i>obj</i> is an instance of the given\nclass. See also `Object#kind_of?`.\n\n   class A;     end\n   class B < A; end\n   class C < B; end\n\n   b = B.new\n   b.instance_of? A   #=> false\n   b.instance_of? B   #=> true\n   b.instance_of? C   #=> false\n
instance_variable_defined? Object.instance_variable_defined?(p1)\nReturns `true` if the given instance variable is\ndefined in <i>obj</i>.\n\n   class Fred\n     def initialize(p1, p2)\n       @a, @b = p1, p2\n     end\n   end\n   fred = Fred.new('cat', 99)\n   fred.instance_variable_defined?(:@a)    #=> true\n   fred.instance_variable_defined?("@b")   #=> true\n   fred.instance_variable_defined?("@c")   #=> false\n
instance_variable_get Object.instance_variable_get(p1)\nReturns the value of the given instance variable, or nil if the\ninstance variable is not set. The `@` part of the\nvariable name should be included for regular instance\nvariables. Throws a `NameError` exception if the\nsupplied symbol is not valid as an instance variable name.\n\n   class Fred\n     def initialize(p1, p2)\n       @a, @b = p1, p2\n     end\n   end\n   fred = Fred.new('cat', 99)\n   fred.instance_variable_get(:@a)    #=> "cat"\n   fred.instance_variable_get("@b")   #=> 99\n
instance_variable_set Object.instance_variable_set(p1, p2)\nSets the instance variable names by <i>symbol</i> to\n<i>object</i>, thereby frustrating the efforts of the class's\nauthor to attempt to provide proper encapsulation. The variable\ndid not have to exist prior to this call.\n\n   class Fred\n     def initialize(p1, p2)\n       @a, @b = p1, p2\n     end\n   end\n   fred = Fred.new('cat', 99)\n   fred.instance_variable_set(:@a, 'dog')   #=> "dog"\n   fred.instance_variable_set(:@c, 'cat')   #=> "cat"\n   fred.inspect                             #=> "#<Fred:0x401b3da8 @a=\"dog\",\n   @b=99, @c=\"cat\">"\n
instance_variables Object.instance_variables()\nReturns an array of instance variable names for the receiver. Note\nthat simply defining an accessor does not create the corresponding\ninstance variable.\n\n   class Fred\n     attr_accessor :a1\n     def initialize\n       @iv = 3\n     end\n   end\n   Fred.new.instance_variables   #=> [:@iv]\n
is_a? Object.is_a?(p1)\nReturns `true` if <i>class</i> is the class of\n<i>obj</i>, or if <i>class</i> is one of the superclasses of\n<i>obj</i> or modules included in <i>obj</i>.\n\n   module M;    end\n   class A\n     include M\n   end\n   class B < A; end\n   class C < B; end\n\n   b = B.new\n   b.is_a? A          #=> true\n   b.is_a? B          #=> true\n   b.is_a? C          #=> false\n   b.is_a? M          #=> true\n\n   b.kind_of? A       #=> true\n   b.kind_of? B       #=> true\n   b.kind_of? C       #=> false\n   b.kind_of? M       #=> true\n
kind_of? Object.kind_of?(p1)\nReturns `true` if <i>class</i> is the class of\n<i>obj</i>, or if <i>class</i> is one of the superclasses of\n<i>obj</i> or modules included in <i>obj</i>.\n\n   module M;    end\n   class A\n     include M\n   end\n   class B < A; end\n   class C < B; end\n\n   b = B.new\n   b.is_a? A          #=> true\n   b.is_a? B          #=> true\n   b.is_a? C          #=> false\n   b.is_a? M          #=> true\n\n   b.kind_of? A       #=> true\n   b.kind_of? B       #=> true\n   b.kind_of? C       #=> false\n   b.kind_of? M       #=> true\n
ln Object.ln()\nCreate a link to the specified TARGET with LINK_NAME.\n\n  ruby -run -e ln -- [OPTION] TARGET LINK_NAME\n\n  -s          make symbolic links instead of hard links\n  -f          remove existing destination files\n  -v          verbose\n
method Object.method(p1)\nLooks up the named method as a receiver in <i>obj</i>, returning a\n`Method` object (or raising `NameError`). The\n`Method` object acts as a closure in <i>obj</i>'s object\ninstance, so instance variables and the value of `self`\nremain available.\n\n   class Demo\n     def initialize(n)\n       @iv = n\n     end\n     def hello()\n       "Hello, @iv = #{@iv}"\n     end\n   end\n\n   k = Demo.new(99)\n   m = k.method(:hello)\n   m.call   #=> "Hello, @iv = 99"\n\n   l = Demo.new('Fred')\n   m = l.method("hello")\n   m.call   #=> "Hello, @iv = Fred"\n
methods Object.methods(p1)\nReturns a list of the names of public and protected methods of\n<i>obj</i>. This will include all the methods accessible in\n<i>obj</i>'s ancestors.\n\n   class Klass\n     def klass_method()\n     end\n   end\n   k = Klass.new\n   k.methods[0..9]    #=> [:klass_method, :nil?, :===,\n    :==~, :!, :eql?\n    :hash, :<=>, :class, :singleton_class]\n   k.methods.length   #=> 57\n
mkdir Object.mkdir()\nCreate the DIR, if they do not already exist.\n\n  ruby -run -e mkdir -- [OPTION] DIR\n\n  -p          no error if existing, make parent directories as needed\n  -v          verbose\n
mkmf Object.mkmf()\nCreate makefile using mkmf.\n\n  ruby -run -e mkmf -- [OPTION] EXTNAME [OPTION]\n\n  -d ARGS     run dir_config\n  -h ARGS     run have_header\n  -l ARGS     run have_library\n  -f ARGS     run have_func\n  -v ARGS     run have_var\n  -t ARGS     run have_type\n  -m ARGS     run have_macro\n  -c ARGS     run have_const\n  --vendor    install to vendor_ruby\n
mv Object.mv()\nRename SOURCE to DEST, or move SOURCE(s) to DIRECTORY.\n\n  ruby -run -e mv -- [OPTION] SOURCE DEST\n\n  -v          verbose\n
nil? Object.nil?()\ncall_seq:\n  nil.nil?               -> true\n  <anything_else>.nil?   -> false\n\nOnly the object <i>nil</i> responds `true` to `nil?`.\n
object_id Object.object_id()\nReturns an integer identifier for <i>obj</i>. The same number will\nbe returned on all calls to `id` for a given object, and\nno two active objects will share an id.\n`Object#object_id` is a different concept from the\n`:name` notation, which returns the symbol id of\n`name`. Replaces the deprecated `Object#id`.\n
pretty_print Object.pretty_print(q)\n\n
pretty_print_cycle Object.pretty_print_cycle(q)\n\n
private_methods Object.private_methods(*args)\nReturns the list of private methods accessible to <i>obj</i>. If\nthe <i>all</i> parameter is set to `false`, only those methods\nin the receiver will be listed.\n
protected_methods Object.protected_methods(*args)\nReturns the list of protected methods accessible to <i>obj</i>. If\nthe <i>all</i> parameter is set to `false`, only those methods\nin the receiver will be listed.\n
psych_to_yaml Object.psych_to_yaml(options = {})\nConvert an object to YAML.  See Psych.dump for more information on the\navailable +options+.\n
public_method Object.public_method(p1)\nSimilar to _method_, searches public method only.\n
public_methods Object.public_methods(*args)\nReturns the list of public methods accessible to <i>obj</i>. If\nthe <i>all</i> parameter is set to `false`, only those methods\nin the receiver will be listed.\n
public_send Object.public_send(*args)\nInvokes the method identified by _symbol_, passing it any\narguments specified. Unlike send, public_send calls public\nmethods only.\n\n   1.public_send(:puts, "hello")  # causes NoMethodError\n
respond_to? Object.respond_to?(p1, p2 = v2)\nReturns +true+ if _obj_ responds to the given\nmethod. Private methods are included in the search only if the\noptional second parameter evaluates to +true+.\n\nIf the method is not implemented,\nas Process.fork on Windows, File.lchmod on GNU/Linux, etc.,\nfalse is returned.\n\nIf the method is not defined, `respond_to_missing?`\nmethod is called and the result is returned.\n
respond_to_missing? Object.respond_to_missing?(p1, p2)\nHook method to return whether the _obj_ can respond to _id_ method\nor not.\n\nSee #respond_to?.\n
rm Object.rm()\nRemove the FILE\n\n  ruby -run -e rm -- [OPTION] FILE\n\n  -f          ignore nonexistent files\n  -r          remove the contents of directories recursively\n  -v          verbose\n
rmdir Object.rmdir()\nRemove the DIR.\n\n  ruby -run -e rmdir -- [OPTION] DIR\n\n  -p          remove DIRECTORY and its ancestors.\n  -v          verbose\n
send Object.send(*args)\nInvokes the method identified by _symbol_, passing it any\narguments specified. You can use `__send__` if the name\n+send+ clashes with an existing method in _obj_.\n\n   class Klass\n     def hello(*args)\n       "Hello " + args.join(' ')\n     end\n   end\n   k = Klass.new\n   k.send :hello, "gentle", "readers"   #=> "Hello gentle readers"\n
setup Object.setup(options = "", *long_options)\n\n
singleton_class Object.singleton_class()\nReturns the singleton class of <i>obj</i>.  This method creates\na new singleton class if <i>obj</i> does not have it.\n\nIf <i>obj</i> is `nil`, `true`, or\n`false`, it returns NilClass, TrueClass, or FalseClass,\nrespectively.\nIf <i>obj</i> is a Fixnum or a Symbol, it raises a TypeError.\n\n   Object.new.singleton_class  #=> #<Class:#<Object:0xb7ce1e24>>\n   String.singleton_class      #=> #<Class:String>\n   nil.singleton_class         #=> NilClass\n
singleton_methods Object.singleton_methods(p1 = v1)\nReturns an array of the names of singleton methods for <i>obj</i>.\nIf the optional <i>all</i> parameter is true, the list will include\nmethods in modules included in <i>obj</i>.\nOnly public and protected singleton methods are returned.\n\n   module Other\n     def three() end\n   end\n\n   class Single\n     def Single.four() end\n   end\n\n   a = Single.new\n\n   def a.one()\n   end\n\n   class << a\n     include Other\n     def two()\n     end\n   end\n\n   Single.singleton_methods    #=> [:four]\n   a.singleton_methods(false)  #=> [:two, :one]\n   a.singleton_methods         #=> [:two, :one, :three]\n
sysread Object.sysread(io, size)\ncgi_runner.rb -- CGI launcher.\n\nAuthor: IPR -- Internet Programming with Ruby -- writers\nCopyright (c) 2000 TAKAHASHI Masayoshi, GOTOU YUUZOU\nCopyright (c) 2002 Internet Programming with Ruby writers. All rights\nreserved.\n\n$IPR: cgi_runner.rb,v 1.9 2002/09/25 11:33:15 gotoyuzo Exp $\n
taint Object.taint()\nMarks <i>obj</i> as tainted---if the `$SAFE` level is\nset appropriately, many method calls which might alter the running\nprograms environment will refuse to accept tainted strings.\n
tainted? Object.tainted?()\nReturns `true` if the object is tainted.\n
tap Object.tap()\nYields `x` to the block, and then returns `x`.\nThe primary purpose of this method is to "tap into" a method chain,\nin order to perform operations on intermediate results within the chain.\n\n    (1..10)                .tap {|x| puts "original: #{x.inspect}"}\n      .to_a                .tap {|x| puts "array: #{x.inspect}"}\n      .select {|x| x%2==0} .tap {|x| puts "evens: #{x.inspect}"}\n      .map { |x| x*x }     .tap {|x| puts "squares: #{x.inspect}"}\n
timeout Object.timeout(n, e = nil, &block)\nIdentical to:\n\n  Timeout::timeout(n, e, &block).\n\nThis method is deprecated and provided only for backwards compatibility.\nYou should use Timeout#timeout instead.\n
to_enum Object.to_enum(*args)\nCreates a new Enumerator which will enumerate by on calling +method+ on\n+obj+.\n\n+method+:: the method to call on +obj+ to generate the enumeration\n+args+:: arguments that will be passed in +method+ <i>in addition</i>\n         to the item itself.  Note that the number of args\n         must not exceed the number expected by +method+\n\n=== Example\n\n  str = "xyz"\n\n  enum = str.enum_for(:each_byte)\n  enum.each { |b| puts b }\n => 120\n => 121\n => 122\n protect an array from being modified by some_method\n  a = [1, 2, 3]\n  some_method(a.to_enum)\n
to_s Object.to_s()\nReturns a string representing <i>obj</i>. The default\n`to_s` prints the object's class and an encoding of the\nobject id. As a special case, the top-level object that is the\ninitial execution context of Ruby programs returns ``main.''\n
to_yaml Object.to_yaml(options = {})\n\n
touch Object.touch()\nUpdate the access and modification times of each FILE to the current time.\n\n  ruby -run -e touch -- [OPTION] FILE\n\n  -v          verbose\n
trust Object.trust()\nRemoves the untrusted mark from <i>obj</i>.\n
try_const Object.try_const(const, headers = nil, opt = "", &b)\nReturns whether or not the Constant +const+ is defined.\n\nSee also +have_const+\n
try_type Object.try_type(type, headers = nil, opt = "", &b)\nReturns whether or not the static type +type+ is defined.\n\nSee also +have_type+\n
untaint Object.untaint()\nRemoves the taint from <i>obj</i>.\n
untrust Object.untrust()\nMarks <i>obj</i> as untrusted.\n
untrusted? Object.untrusted?()\nReturns `true` if the object is untrusted.\n
wait_writable Object.wait_writable()\nWait until the file becomes writable.\n\n  ruby -run -e wait_writable -- [OPTION] FILE\n\n  -n RETRY    count to retry\n  -w SEC      each wait time in seconds\n  -v          verbose\n
with_config Object.with_config(config, default=nil)\nTests for the presence of a --with-<tt>config</tt> or --without-<tt>config</tt>\noption. Returns true if the with option is given, false if the without\noption is given, and the default value otherwise.\n\nThis can be useful for adding custom definitions, such as debug information.\n\nExample:\n\n   if with_config("debug")\n      $defs.push("-DOSSL_DEBUG") unless $defs.include? "-DOSSL_DEBUG"\n   end\n
xmp Object.xmp(exps, bind = nil)\n\n
lex Ripper.lex(src, filename = '-', lineno = 1)\nTokenizes the Ruby program and returns an array of an array,\nwhich is formatted like `[[lineno, column], type, token]`.\n\n  require 'ripper'\n  require 'pp'\n\n  p Ripper.lex("def m(a) nil end")\n=> [[[1,  0], :on_kw,     "def"],\n         [[1,  3], :on_sp,     " "  ],\n         [[1,  4], :on_ident,  "m"  ],\n         [[1,  5], :on_lparen, "("  ],\n         [[1,  6], :on_ident,  "a"  ],\n         [[1,  7], :on_rparen, ")"  ],\n         [[1,  8], :on_sp,     " "  ],\n         [[1,  9], :on_kw,     "nil"],\n         [[1, 12], :on_sp,     " "  ],\n         [[1, 13], :on_kw,     "end"]]\n
new Ripper.new(p1, p2 = v2, p3 = v3)\nCreate a new Ripper object.\n_src_ must be a String, an IO, or an Object which has #gets method.\n\nThis method does not starts parsing.\nSee also Ripper#parse and Ripper.parse.\n
parse Ripper.parse(src, filename = '(ripper)', lineno = 1)\nParses Ruby program read from _src_.\n_src_ must be a String or a IO or a object which has #gets method.\n
sexp Ripper.sexp(src, filename = '-', lineno = 1)\n[EXPERIMENTAL]\nParses +src+ and create S-exp tree.\nReturns more readable tree rather than Ripper.sexp_raw.\nThis method is for mainly developper use.\n\n  require 'ripper'\n  require 'pp'\n\n  pp Ripper.sexp("def m(a) nil end")\n=> [:program,\n         [[:def,\n          [:@ident, "m", [1, 4]],\n          [:paren, [:params, [[:@ident, "a", [1, 6]]], nil, nil, nil, nil]],\n          [:bodystmt, [[:var_ref, [:@kw, "nil", [1, 9]]]], nil, nil, nil]]]]\n
sexp_raw Ripper.sexp_raw(src, filename = '-', lineno = 1)\n[EXPERIMENTAL]\nParses +src+ and create S-exp tree.\nThis method is for mainly developper use.\n\n  require 'ripper'\n  require 'pp'\n\n  pp Ripper.sexp_raw("def m(a) nil end")\n=> [:program,\n         [:stmts_add,\n          [:stmts_new],\n          [:def,\n           [:@ident, "m", [1, 4]],\n           [:paren, [:params, [[:@ident, "a", [1, 6]]], nil, nil, nil]],\n           [:bodystmt,\n            [:stmts_add, [:stmts_new], [:var_ref, [:@kw, "nil", [1, 9]]]],\n            nil,\n            nil,\n            nil]]]]\n
slice Ripper.slice(src, pattern, n = 0)\n[EXPERIMENTAL]\nParses +src+ and return a string which was matched to +pattern+.\n+pattern+ should be described as Regexp.\n\n  require 'ripper'\n\n  p Ripper.slice('def m(a) nil end', 'ident')                   #=> "m"\n  p Ripper.slice('def m(a) nil end', '[ident lparen rparen]+')  #=> "m(a)"\n  p Ripper.slice("<<EOS\\nstring\\nEOS",\n                 'heredoc_beg nl $(tstring_content*) heredoc_end', 1)\n=> "string\\n"\n
tokenize Ripper.tokenize(src, filename = '-', lineno = 1)\nTokenizes the Ruby program and returns an array of strings.\n\n  p Ripper.tokenize("def m(a) nil end")\n => ["def", " ", "m", "(", "a", ")", " ", "nil", " ", "end"]\n
column Ripper.column()\nReturn column number of current parsing line.\nThis number starts from 0.\n
encoding Ripper.encoding()\nReturn encoding of the source.\n
end_seen? Ripper.end_seen?()\nReturn true if parsed source ended by +\_\_END\_\_+.\n
filename Ripper.filename()\nReturn current parsing filename.\n
lineno Ripper.lineno()\nReturn line number of current parsing line.\nThis number starts from 1.\n
parse Ripper.parse()\nStart parsing and returns the value of the root action.\n
yydebug Ripper.yydebug()\nGet yydebug.\n
yydebug= Ripper.yydebug=(p1)\nSet yydebug.\n
new String.new(p1 = v1)\nReturns a new string object containing a copy of <i>str</i>.\n
try_convert String.try_convert(p1)\nTry to convert <i>obj</i> into a String, using to_str method.\nReturns converted string or nil if <i>obj</i> cannot be converted\nfor any reason.\n\n   String.try_convert("str")     #=> "str"\n   String.try_convert(/re/)      #=> nil\n
ascii_only? String.ascii_only?()\nReturns true for a string which has only ASCII characters.\n\n  "abc".force_encoding("UTF-8").ascii_only?          #=> true\n  "abc\u{6666}".force_encoding("UTF-8").ascii_only?  #=> false\n
block_scanf String.block_scanf(fstr)\nScans the current string until the match is exhausted\nyielding each match as it is encountered in the string.\nA block is not necessary as the results will simply\nbe aggregated into the final array.\n\n  "123 456".block_scanf("%d")\n => [123, 456]\n\nIf a block is given, the value from that is returned from\nthe yield is added to an output array.\n\n  "123 456".block_scanf("%d) do |digit,| # the ',' unpacks the Array\n    digit + 100\n  end\n => [223, 556]\n\nSee Scanf for details on creating a format string.\n\nYou will need to require 'scanf' to use String#block_scanf\n
bytes String.bytes()\nPasses each byte in <i>str</i> to the given block, or returns\nan enumerator if no block is given.\n\n   "hello".each_byte {|c| print c, ' ' }\n\n<em>produces:</em>\n\n   104 101 108 108 111\n
bytesize String.bytesize()\nReturns the length of <i>str</i> in bytes.\n
byteslice String.byteslice(*args)\nByte Reference---If passed a single `Fixnum`, returns a\nsubstring of one byte at that position. If passed two `Fixnum`\nobjects, returns a substring starting at the offset given by the first, and\na length given by the second. If given a `Range`, a substring containing\nbytes at offsets given by the range is returned. In all three cases, if\nan offset is negative, it is counted from the end of <i>str</i>. Returns\n`nil` if the initial offset falls outside the string, the length\nis negative, or the beginning of the range is greater than the end.\nThe encoding of the resulted string keeps original encoding.\n\n   "hello".byteslice(1)     #=> "e"\n   "hello".byteslice(-1)    #=> "o"\n   "hello".byteslice(1, 2)  #=> "el"\n   "\x80\u3042".byteslice(1, 3) #=> "\u3042"\n   "\x03\u3042\xff".byteslice(1..3) #=> "\u3942"\n
capitalize String.capitalize()\nReturns a copy of <i>str</i> with the first character converted to uppercase\nand the remainder to lowercase.\nNote: case conversion is effective only in ASCII region.\n\n   "hello".capitalize    #=> "Hello"\n   "HELLO".capitalize    #=> "Hello"\n   "123ABC".capitalize   #=> "123abc"\n
capitalize! String.capitalize!()\nModifies <i>str</i> by converting the first character to uppercase and the\nremainder to lowercase. Returns `nil` if no changes are made.\nNote: case conversion is effective only in ASCII region.\n\n   a = "hello"\n   a.capitalize!   #=> "Hello"\n   a               #=> "Hello"\n   a.capitalize!   #=> nil\n
casecmp String.casecmp(p1)\nCase-insensitive version of `String#<=>`.\n\n   "abcdef".casecmp("abcde")     #=> 1\n   "aBcDeF".casecmp("abcdef")    #=> 0\n   "abcdef".casecmp("abcdefg")   #=> -1\n   "abcdef".casecmp("ABCDEF")    #=> 0\n
center String.center(*args)\nIf <i>integer</i> is greater than the length of <i>str</i>, returns a new\n`String` of length <i>integer</i> with <i>str</i> centered and\npadded with <i>padstr</i>; otherwise, returns <i>str</i>.\n\n   "hello".center(4)         #=> "hello"\n   "hello".center(20)        #=> "       hello        "\n   "hello".center(20, '123') #=> "1231231hello12312312"\n
chars String.chars()\nPasses each character in <i>str</i> to the given block, or returns\nan enumerator if no block is given.\n\n   "hello".each_char {|c| print c, ' ' }\n\n<em>produces:</em>\n\n   h e l l o\n
chomp String.chomp(*args)\nReturns a new `String` with the given record separator removed\nfrom the end of <i>str</i> (if present). If `$/` has not been\nchanged from the default Ruby record separator, then `chomp` also\nremoves carriage return characters (that is it will remove `\\n`,\n`\r`, and `\r\\n`).\n\n   "hello".chomp            #=> "hello"\n   "hello\\n".chomp          #=> "hello"\n   "hello\r\\n".chomp        #=> "hello"\n   "hello\\n\r".chomp        #=> "hello\\n"\n   "hello\r".chomp          #=> "hello"\n   "hello \\n there".chomp   #=> "hello \\n there"\n   "hello".chomp("llo")     #=> "he"\n
chomp! String.chomp!(p1 = v1)\nModifies <i>str</i> in place as described for `String#chomp`,\nreturning <i>str</i>, or `nil` if no modifications were made.\n
chop String.chop()\nReturns a new `String` with the last character removed.  If the\nstring ends with `\r\\n`, both characters are removed. Applying\n`chop` to an empty string returns an empty\nstring. `String#chomp` is often a safer alternative, as it leaves\nthe string unchanged if it doesn't end in a record separator.\n\n   "string\r\\n".chop   #=> "string"\n   "string\\n\r".chop   #=> "string\\n"\n   "string\\n".chop     #=> "string"\n   "string".chop       #=> "strin"\n   "x".chop.chop       #=> ""\n
chop! String.chop!()\nProcesses <i>str</i> as for `String#chop`, returning <i>str</i>,\nor `nil` if <i>str</i> is the empty string.  See also\n`String#chomp!`.\n
chr String.chr()\nReturns a one-character string at the beginning of the string.\n\n   a = "abcde"\n   a.chr    #=> "a"\n
clear String.clear()\nMakes string empty.\n\n   a = "abcde"\n   a.clear    #=> ""\n
codepoints String.codepoints()\nPasses the `Integer` ordinal of each character in <i>str</i>,\nalso known as a <i>codepoint</i> when applied to Unicode strings to the\ngiven block.\n\nIf no block is given, an enumerator is returned instead.\n\n   "hello\u0639".each_codepoint {|c| print c, ' ' }\n\n<em>produces:</em>\n\n   104 101 108 108 111 1593\n
concat String.concat(p1)\nAppend---Concatenates the given object to <i>str</i>. If the object is a\n`Integer`, it is considered as a codepoint, and is converted\nto a character before concatenation.\n\n   a = "hello "\n   a << "world"   #=> "hello world"\n   a.concat(33)   #=> "hello world!"\n
count String.count(*args)\nEach <i>other_str</i> parameter defines a set of characters to count.  The\nintersection of these sets defines the characters to count in\n<i>str</i>. Any <i>other_str</i> that starts with a caret (^) is\nnegated. The sequence c1--c2 means all characters between c1 and c2.\n\n   a = "hello world"\n   a.count "lo"            #=> 5\n   a.count "lo", "o"       #=> 2\n   a.count "hello", "^l"   #=> 4\n   a.count "ej-m"          #=> 4\n
crypt String.crypt(p1)\nApplies a one-way cryptographic hash to <i>str</i> by invoking the standard\nlibrary function `crypt`. The argument is the salt string, which\nshould be two characters long, each character drawn from\n`[a-zA-Z0-9./]`.\n
delete String.delete(*args)\nReturns a copy of <i>str</i> with all characters in the intersection of its\narguments deleted. Uses the same rules for building the set of characters as\n`String#count`.\n\n   "hello".delete "l","lo"        #=> "heo"\n   "hello".delete "lo"            #=> "he"\n   "hello".delete "aeiou", "^e"   #=> "hell"\n   "hello".delete "ej-m"          #=> "ho"\n
delete! String.delete!(*args)\nPerforms a `delete` operation in place, returning <i>str</i>, or\n`nil` if <i>str</i> was not modified.\n
downcase String.downcase()\nReturns a copy of <i>str</i> with all uppercase letters replaced with their\nlowercase counterparts. The operation is locale insensitive---only\ncharacters ``A'' to ``Z'' are affected.\nNote: case replacement is effective only in ASCII region.\n\n   "hEllO".downcase   #=> "hello"\n
downcase! String.downcase!()\nDowncases the contents of <i>str</i>, returning `nil` if no\nchanges were made.\nNote: case replacement is effective only in ASCII region.\n
dump String.dump()\nProduces a version of <i>str</i> with all nonprinting characters replaced by\n`\\nnn` notation and all special characters escaped.\n
each_byte String.each_byte()\nPasses each byte in <i>str</i> to the given block, or returns\nan enumerator if no block is given.\n\n   "hello".each_byte {|c| print c, ' ' }\n\n<em>produces:</em>\n\n   104 101 108 108 111\n
each_char String.each_char()\nPasses each character in <i>str</i> to the given block, or returns\nan enumerator if no block is given.\n\n   "hello".each_char {|c| print c, ' ' }\n\n<em>produces:</em>\n\n   h e l l o\n
each_codepoint String.each_codepoint()\nPasses the `Integer` ordinal of each character in <i>str</i>,\nalso known as a <i>codepoint</i> when applied to Unicode strings to the\ngiven block.\n\nIf no block is given, an enumerator is returned instead.\n\n   "hello\u0639".each_codepoint {|c| print c, ' ' }\n\n<em>produces:</em>\n\n   104 101 108 108 111 1593\n
each_line String.each_line(p1 = v1)\nSplits <i>str</i> using the supplied parameter as the record separator\n(`$/` by default), passing each substring in turn to the supplied\nblock. If a zero-length record separator is supplied, the string is split\ninto paragraphs delimited by multiple successive newlines.\n\nIf no block is given, an enumerator is returned instead.\n\n   print "Example one\\n"\n   "hello\\nworld".each_line {|s| p s}\n   print "Example two\\n"\n   "hello\\nworld".each_line('l') {|s| p s}\n   print "Example three\\n"\n   "hello\\n\\n\\nworld".each_line('') {|s| p s}\n\n<em>produces:</em>\n\n   Example one\n   "hello\\n"\n   "world"\n   Example two\n   "hel"\n   "l"\n   "o\\nworl"\n   "d"\n   Example three\n   "hello\\n\\n\\n"\n   "world"\n
empty? String.empty?()\nReturns `true` if <i>str</i> has a length of zero.\n\n   "hello".empty?   #=> false\n   "".empty?        #=> true\n
encode String.encode(*args)\nThe first form returns a copy of +str+ transcoded\nto encoding +encoding+.\nThe second form returns a copy of +str+ transcoded\nfrom src_encoding to dst_encoding.\nThe last form returns a copy of +str+ transcoded to\n<tt>Encoding.default_internal</tt>.\n\nBy default, the first and second form raise\nEncoding::UndefinedConversionError for characters that are\nundefined in the destination encoding, and\nEncoding::InvalidByteSequenceError for invalid byte sequences\nin the source encoding. The last form by default does not raise\nexceptions but uses replacement strings.\n\nPlease note that conversion from an encoding +enc+ to the\nsame encoding +enc+ is a no-op, i.e. the receiver is returned without\nany changes, and no exceptions are raised, even if there are invalid bytes.\n\nThe +options+ Hash gives details for conversion and can have the following\nkeys:\n\n:invalid ::\n  If the value is +:replace+, #encode replaces invalid byte sequences in\n  +str+ with the replacement character.  The default is to raise the\n  Encoding::InvalidByteSequenceError exception\n:undef ::\n  If the value is +:replace+, #encode replaces characters which are\n  undefined in the destination encoding with the replacement character.\n  The default is to raise the Encoding::UndefinedConversionError.\n:replace ::\n  Sets the replacement string to the given value. The default replacement\n  string is "\uFFFD" for Unicode encoding forms, and "?" otherwise.\n:fallback ::\n  Sets the replacement string by the given object for undefined\n  character.  The object should be a Hash, a Proc, a Method, or an\n  object which has [] method.\n  Its key is an undefined character encoded in the source encoding\n  of current transcoder. Its value can be any encoding until it\n  can be converted into the destination encoding of the transcoder.\n:xml ::\n  The value must be +:text+ or +:attr+.\n  If the value is +:text+ #encode replaces undefined characters with their\n  (upper-case hexadecimal) numeric character references. '&', '<', and '>'\n  are converted to "&amp;", "&lt;", and "&gt;", respectively.\n  If the value is +:attr+, #encode also quotes the replacement result\n  (using '"'), and replaces '"' with "&quot;".\n:cr_newline ::\n  Replaces LF ("\\n") with CR ("\r") if value is true.\n:crlf_newline ::\n  Replaces LF ("\\n") with CRLF ("\r\\n") if value is true.\n:universal_newline ::\n  Replaces CRLF ("\r\\n") and CR ("\r") with LF ("\\n") if value is true.\n
encode! String.encode!(*args)\nThe first form transcodes the contents of <i>str</i> from\nstr.encoding to +encoding+.\nThe second form transcodes the contents of <i>str</i> from\nsrc_encoding to dst_encoding.\nThe options Hash gives details for conversion. See String#encode\nfor details.\nReturns the string even if no changes were made.\n
encoding String.encoding()\nReturns the Encoding object that represents the encoding of obj.\n
end_with? String.end_with?(*args)\nReturns true if <i>str</i> ends with one of the suffixes given.\n
eql? String.eql?(p1)\nTwo strings are equal if they have the same length and content.\n
ext String.ext(newext='')\nReplace the file extension with +newext+.  If there is no extension on\nthe string, append the new extension to the end.  If the new extension\nis not given, or is the empty string, remove any existing extension.\n\n+ext+ is a user added method for the String class.\n
force_encoding String.force_encoding(p1)\nChanges the encoding to +encoding+ and returns self.\n
getbyte String.getbyte(p1)\nreturns the <i>index</i>th byte as an integer.\n
gsub String.gsub(*args)\nReturns a copy of <i>str</i> with the <em>all</em> occurrences of\n<i>pattern</i> substituted for the second argument. The <i>pattern</i> is\ntypically a `Regexp`; if given as a `String`, any\nregular expression metacharacters it contains will be interpreted\nliterally, e.g. `'\\\d'` will match a backlash followed by 'd',\ninstead of a digit.\n\nIf <i>replacement</i> is a `String` it will be substituted for\nthe matched text. It may contain back-references to the pattern's capture\ngroups of the form `\\\d`, where <i>d</i> is a group number, or\n`\\\k<n>`, where <i>n</i> is a group name. If it is a\ndouble-quoted string, both back-references must be preceded by an\nadditional backslash. However, within <i>replacement</i> the special match\nvariables, such as `&$`, will not refer to the current match.\n\nIf the second argument is a `Hash`, and the matched text is one\nof its keys, the corresponding value is the replacement string.\n\nIn the block form, the current match string is passed in as a parameter,\nand variables such as `$1`, `$2`, `$``,\n`$&`, and `$'` will be set appropriately. The value\nreturned by the block will be substituted for the match on each call.\n\nThe result inherits any tainting in the original string or any supplied\nreplacement string.\n\nWhen neither a block nor a second argument is supplied, an\n`Enumerator` is returned.\n\n   "hello".gsub(/[aeiou]/, '*')                  #=> "h*ll*"\n   "hello".gsub(/([aeiou])/, '<\1>')             #=> "h<e>ll<o>"\n   "hello".gsub(/./) {|s| s.ord.to_s + ' '}      #=> "104 101 108 108 111 "\n   "hello".gsub(/(?<foo>[aeiou])/, '{\k<foo>}')  #=> "h{e}ll{o}"\n   'hello'.gsub(/[eo]/, 'e' => 3, 'o' => '*')    #=> "h3ll*"\n
gsub! String.gsub!(*args)\nPerforms the substitutions of `String#gsub` in place, returning\n<i>str</i>, or `nil` if no substitutions were performed.\nIf no block and no <i>replacement</i> is given, an enumerator is returned\ninstead.\n
hash String.hash()\nReturn a hash based on the string's length and content.\n
hex String.hex()\nTreats leading characters from <i>str</i> as a string of hexadecimal digits\n(with an optional sign and an optional `0x`) and returns the\ncorresponding number. Zero is returned on error.\n\n   "0x0a".hex     #=> 10\n   "-1234".hex    #=> -4660\n   "0".hex        #=> 0\n   "wombat".hex   #=> 0\n
include? String.include?(p1)\nReturns `true` if <i>str</i> contains the given string or\ncharacter.\n\n   "hello".include? "lo"   #=> true\n   "hello".include? "ol"   #=> false\n   "hello".include? ?h     #=> true\n
index String.index(p1, p2 = v2)\nReturns the index of the first occurrence of the given <i>substring</i> or\npattern (<i>regexp</i>) in <i>str</i>. Returns `nil` if not\nfound. If the second parameter is present, it specifies the position in the\nstring to begin the search.\n\n   "hello".index('e')             #=> 1\n   "hello".index('lo')            #=> 3\n   "hello".index('a')             #=> nil\n   "hello".index(?e)              #=> 1\n   "hello".index(/[aeiou]/, -3)   #=> 4\n
initialize_copy String.initialize_copy(p1)\nReplaces the contents and taintedness of <i>str</i> with the corresponding\nvalues in <i>other_str</i>.\n\n   s = "hello"         #=> "hello"\n   s.replace "world"   #=> "world"\n
insert String.insert(p1, p2)\nInserts <i>other_str</i> before the character at the given\n<i>index</i>, modifying <i>str</i>. Negative indices count from the\nend of the string, and insert <em>after</em> the given character.\nThe intent is insert <i>aString</i> so that it starts at the given\n<i>index</i>.\n\n   "abcd".insert(0, 'X')    #=> "Xabcd"\n   "abcd".insert(3, 'X')    #=> "abcXd"\n   "abcd".insert(4, 'X')    #=> "abcdX"\n   "abcd".insert(-3, 'X')   #=> "abXcd"\n   "abcd".insert(-1, 'X')   #=> "abcdX"\n
inspect String.inspect()\nReturns a printable version of _str_, surrounded by quote marks,\nwith special characters escaped.\n\n   str = "hello"\n   str[3] = "\b"\n   str.inspect       #=> "\"hel\\bo\""\n
intern String.intern()\nReturns the `Symbol` corresponding to <i>str</i>, creating the\nsymbol if it did not previously exist. See `Symbol#id2name`.\n\n   "Koala".intern         #=> :Koala\n   s = 'cat'.to_sym       #=> :cat\n   s == :cat              #=> true\n   s = '@cat'.to_sym      #=> :@cat\n   s == :@cat             #=> true\n\nThis can also be used to create symbols that cannot be represented using the\n`:xxx` notation.\n\n   'cat and dog'.to_sym   #=> :"cat and dog"\n
iseuc String.iseuc()\nReturns whether `self`'s encoding is EUC-JP or not.\n
isjis String.isjis()\nReturns whether `self`'s encoding is ISO-2022-JP or not.\n
issjis String.issjis()\nReturns whether `self`'s encoding is Shift_JIS or not.\n
isutf8 String.isutf8()\nReturns whether `self`'s encoding is UTF-8 or not.\n
kconv String.kconv(to_enc, from_enc=nil)\nConvert `self` to `to_enc`.\n`to_enc` and `from_enc` are given as constants of Kconv or Encoding objects.\n
length String.length()\nReturns the character length of <i>str</i>.\n
lines String.lines(p1 = v1)\nSplits <i>str</i> using the supplied parameter as the record separator\n(`$/` by default), passing each substring in turn to the supplied\nblock. If a zero-length record separator is supplied, the string is split\ninto paragraphs delimited by multiple successive newlines.\n\nIf no block is given, an enumerator is returned instead.\n\n   print "Example one\\n"\n   "hello\\nworld".each_line {|s| p s}\n   print "Example two\\n"\n   "hello\\nworld".each_line('l') {|s| p s}\n   print "Example three\\n"\n   "hello\\n\\n\\nworld".each_line('') {|s| p s}\n\n<em>produces:</em>\n\n   Example one\n   "hello\\n"\n   "world"\n   Example two\n   "hel"\n   "l"\n   "o\\nworl"\n   "d"\n   Example three\n   "hello\\n\\n\\n"\n   "world"\n
ljust String.ljust(*args)\nIf <i>integer</i> is greater than the length of <i>str</i>, returns a new\n`String` of length <i>integer</i> with <i>str</i> left justified\nand padded with <i>padstr</i>; otherwise, returns <i>str</i>.\n\n   "hello".ljust(4)            #=> "hello"\n   "hello".ljust(20)           #=> "hello               "\n   "hello".ljust(20, '1234')   #=> "hello123412341234123"\n
lstrip String.lstrip()\nReturns a copy of <i>str</i> with leading whitespace removed. See also\n`String#rstrip` and `String#strip`.\n\n   "  hello  ".lstrip   #=> "hello  "\n   "hello".lstrip       #=> "hello"\n
lstrip! String.lstrip!()\nRemoves leading whitespace from <i>str</i>, returning `nil` if no\nchange was made. See also `String#rstrip!` and\n`String#strip!`.\n\n   "  hello  ".lstrip   #=> "hello  "\n   "hello".lstrip!      #=> nil\n
match String.match(*args)\nConverts <i>pattern</i> to a `Regexp` (if it isn't already one),\nthen invokes its `match` method on <i>str</i>.  If the second\nparameter is present, it specifies the position in the string to begin the\nsearch.\n\n   'hello'.match('(.)\1')      #=> #<MatchData "ll" 1:"l">\n   'hello'.match('(.)\1')[0]   #=> "ll"\n   'hello'.match(/(.)\1/)[0]   #=> "ll"\n   'hello'.match('xx')         #=> nil\n\nIf a block is given, invoke the block with MatchData if match succeed, so\nthat you can write\n\n   str.match(pat) {|m| ...}\n\ninstead of\n\n   if m = str.match(pat)\n     ...\n   end\n\nThe return value is a value from block execution in this case.\n
next String.next()\nReturns the successor to <i>str</i>. The successor is calculated by\nincrementing characters starting from the rightmost alphanumeric (or\nthe rightmost character if there are no alphanumerics) in the\nstring. Incrementing a digit always results in another digit, and\nincrementing a letter results in another letter of the same case.\nIncrementing nonalphanumerics uses the underlying character set's\ncollating sequence.\n\nIf the increment generates a ``carry,'' the character to the left of\nit is incremented. This process repeats until there is no carry,\nadding an additional character if necessary.\n\n   "abcd".succ        #=> "abce"\n   "THX1138".succ     #=> "THX1139"\n   "<<koala>>".succ   #=> "<<koalb>>"\n   "1999zzz".succ     #=> "2000aaa"\n   "ZZZ9999".succ     #=> "AAAA0000"\n   "***".succ         #=> "**+"\n
next! String.next!()\nEquivalent to `String#succ`, but modifies the receiver in\nplace.\n
oct String.oct()\nTreats leading characters of <i>str</i> as a string of octal digits (with an\noptional sign) and returns the corresponding number.  Returns 0 if the\nconversion fails.\n\n   "123".oct       #=> 83\n   "-377".oct      #=> -255\n   "bad".oct       #=> 0\n   "0377bad".oct   #=> 255\n
ord String.ord()\nReturn the `Integer` ordinal of a one-character string.\n\n   "a".ord         #=> 97\n
parse_csv String.parse_csv(options = Hash.new)\nEquivalent to <tt>CSV::parse_line(self, options)</tt>.\n
partition String.partition(p1)\nSearches <i>sep</i> or pattern (<i>regexp</i>) in the string\nand returns the part before it, the match, and the part\nafter it.\nIf it is not found, returns two empty strings and <i>str</i>.\n\n   "hello".partition("l")         #=> ["he", "l", "lo"]\n   "hello".partition("x")         #=> ["hello", "", ""]\n   "hello".partition(/.l/)        #=> ["h", "el", "lo"]\n
pathmap String.pathmap(spec=nil, &block)\nMap the path according to the given specification.  The specification\ncontrols the details of the mapping.  The following special patterns are\nrecognized:\n\n* <b>%p</b> -- The complete path.\n* <b>%f</b> -- The base file name of the path, with its file extension,\n  but without any directories.\n* <b>%n</b> -- The file name of the path without its file extension.\n* <b>%d</b> -- The directory list of the path.\n* <b>%x</b> -- The file extension of the path.  An empty string if there\n  is no extension.\n* <b>%X</b> -- Everything *but* the file extension.\n* <b>%s</b> -- The alternate file separator if defined, otherwise use\n  the standard file separator.\n* <b>%%</b> -- A percent sign.\n\nThe %d specifier can also have a numeric prefix (e.g. '%2d'). If the\nnumber is positive, only return (up to) +n+ directories in the path,\nstarting from the left hand side.  If +n+ is negative, return (up to)\n|+n+| directories from the right hand side of the path.\n\nExamples:\n\n  'a/b/c/d/file.txt'.pathmap("%2d")   => 'a/b'\n  'a/b/c/d/file.txt'.pathmap("%-2d")  => 'c/d'\n\nAlso the %d, %p, %f, %n, %x, and %X operators can take a\npattern/replacement argument to perform simple string substitutions on a\nparticular part of the path.  The pattern and replacement are separated\nby a comma and are enclosed by curly braces.  The replacement spec comes\nafter the % character but before the operator letter.  (e.g.\n"%{old,new}d").  Multiple replacement specs should be separated by\nsemi-colons (e.g. "%{old,new;src,bin}d").\n\nRegular expressions may be used for the pattern, and back refs may be\nused in the replacement text.  Curly braces, commas and semi-colons are\nexcluded from both the pattern and replacement text (let's keep parsing\nreasonable).\n\nFor example:\n\n   "src/org/onestepback/proj/A.java".pathmap("%{^src,bin}X.class")\n\nreturns:\n\n   "bin/org/onestepback/proj/A.class"\n\nIf the replacement text is '*', then a block may be provided to perform\nsome arbitrary calculation for the replacement.\n\nFor example:\n\n  "/path/to/file.TXT".pathmap("%X%{.*,*}x") { |ext|\n     ext.downcase\n  }\n\nReturns:\n\n "/path/to/file.txt"\n
pathmap_explode String.pathmap_explode()\nExplode a path into individual components.  Used by +pathmap+.\n
pathmap_partial String.pathmap_partial(n)\nExtract a partial path from the path.  Include +n+ directories from the\nfront end (left hand side) if +n+ is positive.  Include |+n+|\ndirectories from the back end (right hand side) if +n+ is negative.\n
pathmap_replace String.pathmap_replace(patterns, &block)\nPreform the pathmap replacement operations on the given path. The\npatterns take the form 'pat1,rep1;pat2,rep2...'.\n
prepend String.prepend(p1)\nPrepend---Prepend the given string to <i>str</i>.\n\na = "world"\na.prepend("hello ") #=> "hello world"\na                   #=> "hello world"\n
replace String.replace(p1)\nReplaces the contents and taintedness of <i>str</i> with the corresponding\nvalues in <i>other_str</i>.\n\n   s = "hello"         #=> "hello"\n   s.replace "world"   #=> "world"\n
reverse String.reverse()\nReturns a new string with the characters from <i>str</i> in reverse order.\n\n   "stressed".reverse   #=> "desserts"\n
reverse! String.reverse!()\nReverses <i>str</i> in place.\n
rindex String.rindex(p1, p2 = v2)\nReturns the index of the last occurrence of the given <i>substring</i> or\npattern (<i>regexp</i>) in <i>str</i>. Returns `nil` if not\nfound. If the second parameter is present, it specifies the position in the\nstring to end the search---characters beyond this point will not be\nconsidered.\n\n   "hello".rindex('e')             #=> 1\n   "hello".rindex('l')             #=> 3\n   "hello".rindex('a')             #=> nil\n   "hello".rindex(?e)              #=> 1\n   "hello".rindex(/[aeiou]/, -2)   #=> 1\n
rjust String.rjust(*args)\nIf <i>integer</i> is greater than the length of <i>str</i>, returns a new\n`String` of length <i>integer</i> with <i>str</i> right justified\nand padded with <i>padstr</i>; otherwise, returns <i>str</i>.\n\n   "hello".rjust(4)            #=> "hello"\n   "hello".rjust(20)           #=> "               hello"\n   "hello".rjust(20, '1234')   #=> "123412341234123hello"\n
rpartition String.rpartition(p1)\nSearches <i>sep</i> or pattern (<i>regexp</i>) in the string from the end\nof the string, and returns the part before it, the match, and the part\nafter it.\nIf it is not found, returns two empty strings and <i>str</i>.\n\n   "hello".rpartition("l")         #=> ["hel", "l", "o"]\n   "hello".rpartition("x")         #=> ["", "", "hello"]\n   "hello".rpartition(/.l/)        #=> ["he", "ll", "o"]\n
rstrip String.rstrip()\nReturns a copy of <i>str</i> with trailing whitespace removed. See also\n`String#lstrip` and `String#strip`.\n\n   "  hello  ".rstrip   #=> "  hello"\n   "hello".rstrip       #=> "hello"\n
rstrip! String.rstrip!()\nRemoves trailing whitespace from <i>str</i>, returning `nil` if\nno change was made. See also `String#lstrip!` and\n`String#strip!`.\n\n   "  hello  ".rstrip   #=> "  hello"\n   "hello".rstrip!      #=> nil\n
scan String.scan(p1)\nBoth forms iterate through <i>str</i>, matching the pattern (which may be a\n`Regexp` or a `String`). For each match, a result is\ngenerated and either added to the result array or passed to the block. If\nthe pattern contains no groups, each individual result consists of the\nmatched string, `$&`.  If the pattern contains groups, each\nindividual result is itself an array containing one entry per group.\n\n   a = "cruel world"\n   a.scan(/\w+/)        #=> ["cruel", "world"]\n   a.scan(/.../)        #=> ["cru", "el ", "wor"]\n   a.scan(/(...)/)      #=> [["cru"], ["el "], ["wor"]]\n   a.scan(/(..)(..)/)   #=> [["cr", "ue"], ["l ", "wo"]]\n\nAnd the block form:\n\n   a.scan(/\w+/) {|w| print "<<#{w}>> " }\n   print "\\n"\n   a.scan(/(.)(.)/) {|x,y| print y, x }\n   print "\\n"\n\n<em>produces:</em>\n\n   <<cruel>> <<world>>\n   rceu lowlr\n
scanf String.scanf(fstr)\nScans the current string. If a block is given, it\nfunctions exactly like block_scanf.\n\n  arr = "123 456".scanf("%d%d")\n => [123, 456]\n\n  require 'pp'\n\n  "this 123 read that 456 other".scanf("%s%d%s") {|m| pp m}\n ["this", 123, "read"]\n ["that", 456, "other"]\n => [["this", 123, "read"], ["that", 456, "other"]]\n\nSee Scanf for details on creating a format string.\n\nYou will need to require 'scanf' to use String#scanf\n
setbyte String.setbyte(p1, p2)\nmodifies the <i>index</i>th byte as <i>int</i>.\n
shellescape String.shellescape()\nEscapes +str+ so that it can be safely used in a Bourne shell\ncommand line.  See Shellwords::shellescape for details.\n
shellsplit String.shellsplit()\nSplits +str+ into an array of tokens in the same way the UNIX\nBourne shell does.  See Shellwords::shellsplit for details.\n
size String.size()\nReturns the character length of <i>str</i>.\n
slice String.slice(*args)\nElement Reference---If passed a single `Fixnum`, returns a\nsubstring of one character at that position. If passed two `Fixnum`\nobjects, returns a substring starting at the offset given by the first, and\nwith a length given by the second. If passed a range, its beginning and end\nare interpreted as offsets delimiting the substring to be returned. In all\nthree cases, if an offset is negative, it is counted from the end of\n<i>str</i>.\nReturns `nil` if the initial offset falls outside the string or\nthe length is negative.\n\nIf a `Regexp` is supplied, the matching portion of <i>str</i> is\nreturned. If a numeric or name parameter follows the regular expression, that\ncomponent of the `MatchData` is returned instead. If a\n`String` is given, that string is returned if it occurs in\n<i>str</i>. In both cases, `nil` is returned if there is no\nmatch.\n\n   a = "hello there"\n   a[1]                   #=> "e"\n   a[2, 3]                #=> "llo"\n   a[2..3]                #=> "ll"\n   a[-3, 2]               #=> "er"\n   a[7..-2]               #=> "her"\n   a[-4..-2]              #=> "her"\n   a[-2..-4]              #=> ""\n   a[12..-1]              #=> nil\n   a[/[aeiou](.)\1/]      #=> "ell"\n   a[/[aeiou](.)\1/, 0]   #=> "ell"\n   a[/[aeiou](.)\1/, 1]   #=> "l"\n   a[/[aeiou](.)\1/, 2]   #=> nil\n   a["lo"]                #=> "lo"\n   a["bye"]               #=> nil\n
slice! String.slice!(*args)\nDeletes the specified portion from <i>str</i>, and returns the portion\ndeleted.\n\n   string = "this is a string"\n   string.slice!(2)        #=> "i"\n   string.slice!(3..6)     #=> " is "\n   string.slice!(/s.*t/)   #=> "sa st"\n   string.slice!("r")      #=> "r"\n   string                  #=> "thing"\n
split String.split(p1 = v1, p2 = v2)\nDivides <i>str</i> into substrings based on a delimiter, returning an array\nof these substrings.\n\nIf <i>pattern</i> is a `String`, then its contents are used as\nthe delimiter when splitting <i>str</i>. If <i>pattern</i> is a single\nspace, <i>str</i> is split on whitespace, with leading whitespace and runs\nof contiguous whitespace characters ignored.\n\nIf <i>pattern</i> is a `Regexp`, <i>str</i> is divided where the\npattern matches. Whenever the pattern matches a zero-length string,\n<i>str</i> is split into individual characters. If <i>pattern</i> contains\ngroups, the respective matches will be returned in the array as well.\n\nIf <i>pattern</i> is omitted, the value of `$;` is used.  If\n`$;` is `nil` (which is the default), <i>str</i> is\nsplit on whitespace as if ` ' were specified.\n\nIf the <i>limit</i> parameter is omitted, trailing null fields are\nsuppressed. If <i>limit</i> is a positive number, at most that number of\nfields will be returned (if <i>limit</i> is `1`, the entire\nstring is returned as the only entry in an array). If negative, there is no\nlimit to the number of fields returned, and trailing null fields are not\nsuppressed.\n\n   " now's  the time".split        #=> ["now's", "the", "time"]\n   " now's  the time".split(' ')   #=> ["now's", "the", "time"]\n   " now's  the time".split(/ /)   #=> ["", "now's", "", "the", "time"]\n   "1, 2.34,56, 7".split(%r{,\s*}) #=> ["1", "2.34", "56", "7"]\n   "hello".split(//)               #=> ["h", "e", "l", "l", "o"]\n   "hello".split(//, 3)            #=> ["h", "e", "llo"]\n   "hi mom".split(%r{\s*})         #=> ["h", "i", "m", "o", "m"]\n\n   "mellow yellow".split("ello")   #=> ["m", "w y", "w"]\n   "1,2,,3,4,,".split(',')         #=> ["1", "2", "", "3", "4"]\n   "1,2,,3,4,,".split(',', 4)      #=> ["1", "2", "", "3,4,,"]\n   "1,2,,3,4,,".split(',', -4)     #=> ["1", "2", "", "3", "4", "", ""]\n
squeeze String.squeeze(*args)\nBuilds a set of characters from the <i>other_str</i> parameter(s) using the\nprocedure described for `String#count`. Returns a new string\nwhere runs of the same character that occur in this set are replaced by a\nsingle character. If no arguments are given, all runs of identical\ncharacters are replaced by a single character.\n\n   "yellow moon".squeeze                  #=> "yelow mon"\n   "  now   is  the".squeeze(" ")         #=> " now is the"\n   "putters shoot balls".squeeze("m-z")   #=> "puters shot balls"\n
squeeze! String.squeeze!(*args)\nSqueezes <i>str</i> in place, returning either <i>str</i>, or\n`nil` if no changes were made.\n
start_with? String.start_with?(*args)\nReturns true if <i>str</i> starts with one of the prefixes given.\n\n  p "hello".start_with?("hell")               #=> true\n returns true if one of the prefixes matches.\n  p "hello".start_with?("heaven", "hell")     #=> true\n  p "hello".start_with?("heaven", "paradise") #=> false\n
strip String.strip()\nReturns a copy of <i>str</i> with leading and trailing whitespace removed.\n\n   "    hello    ".strip   #=> "hello"\n   "\tgoodbye\r\\n".strip   #=> "goodbye"\n
strip! String.strip!()\nRemoves leading and trailing whitespace from <i>str</i>. Returns\n`nil` if <i>str</i> was not altered.\n
sub String.sub(*args)\nReturns a copy of <i>str</i> with the <em>first</em> occurrence of\n<i>pattern</i> substituted for the second argument. The <i>pattern</i> is\ntypically a `Regexp`; if given as a `String`, any\nregular expression metacharacters it contains will be interpreted\nliterally, e.g. `'\\\d'` will match a backlash followed by 'd',\ninstead of a digit.\n\nIf <i>replacement</i> is a `String` it will be substituted for\nthe matched text. It may contain back-references to the pattern's capture\ngroups of the form `\\\d`, where <i>d</i> is a group number, or\n`\\\k<n>`, where <i>n</i> is a group name. If it is a\ndouble-quoted string, both back-references must be preceded by an\nadditional backslash. However, within <i>replacement</i> the special match\nvariables, such as `&$`, will not refer to the current match.\n\nIf the second argument is a `Hash`, and the matched text is one\nof its keys, the corresponding value is the replacement string.\n\nIn the block form, the current match string is passed in as a parameter,\nand variables such as `$1`, `$2`, `$``,\n`$&`, and `$'` will be set appropriately. The value\nreturned by the block will be substituted for the match on each call.\n\nThe result inherits any tainting in the original string or any supplied\nreplacement string.\n\n   "hello".sub(/[aeiou]/, '*')                  #=> "h*llo"\n   "hello".sub(/([aeiou])/, '<\1>')             #=> "h<e>llo"\n   "hello".sub(/./) {|s| s.ord.to_s + ' ' }     #=> "104 ello"\n   "hello".sub(/(?<foo>[aeiou])/, '*\k<foo>*')  #=> "h*e*llo"\n   'Is SHELL your preferred shell?'.sub(/[[:upper:]]{2,}/, ENV)\n=> "Is /bin/bash your preferred shell?"\n
sub! String.sub!(*args)\nPerforms the substitutions of `String#sub` in place,\nreturning <i>str</i>, or `nil` if no substitutions were\nperformed.\n
succ String.succ()\nReturns the successor to <i>str</i>. The successor is calculated by\nincrementing characters starting from the rightmost alphanumeric (or\nthe rightmost character if there are no alphanumerics) in the\nstring. Incrementing a digit always results in another digit, and\nincrementing a letter results in another letter of the same case.\nIncrementing nonalphanumerics uses the underlying character set's\ncollating sequence.\n\nIf the increment generates a ``carry,'' the character to the left of\nit is incremented. This process repeats until there is no carry,\nadding an additional character if necessary.\n\n   "abcd".succ        #=> "abce"\n   "THX1138".succ     #=> "THX1139"\n   "<<koala>>".succ   #=> "<<koalb>>"\n   "1999zzz".succ     #=> "2000aaa"\n   "ZZZ9999".succ     #=> "AAAA0000"\n   "***".succ         #=> "**+"\n
succ! String.succ!()\nEquivalent to `String#succ`, but modifies the receiver in\nplace.\n
sum String.sum(p1 = v1)\nReturns a basic <em>n</em>-bit checksum of the characters in <i>str</i>,\nwhere <em>n</em> is the optional `Fixnum` parameter, defaulting\nto 16. The result is simply the sum of the binary value of each character in\n<i>str</i> modulo `2**n - 1`. This is not a particularly good\nchecksum.\n
swapcase String.swapcase()\nReturns a copy of <i>str</i> with uppercase alphabetic characters converted\nto lowercase and lowercase characters converted to uppercase.\nNote: case conversion is effective only in ASCII region.\n\n   "Hello".swapcase          #=> "hELLO"\n   "cYbEr_PuNk11".swapcase   #=> "CyBeR_pUnK11"\n
swapcase! String.swapcase!()\nEquivalent to `String#swapcase`, but modifies the receiver in\nplace, returning <i>str</i>, or `nil` if no changes were made.\nNote: case conversion is effective only in ASCII region.\n
to_c String.to_c()\nReturns a complex which denotes the string form.  The parser\nignores leading whitespaces and trailing garbage.  Any digit\nsequences can be separated by an underscore.  Returns zero for null\nor garbage string.\n\nFor example:\n\n   '9'.to_c           #=> (9+0i)\n   '2.5'.to_c         #=> (2.5+0i)\n   '2.5/1'.to_c       #=> ((5/2)+0i)\n   '-3/2'.to_c        #=> ((-3/2)+0i)\n   '-i'.to_c          #=> (0-1i)\n   '45i'.to_c         #=> (0+45i)\n   '3-4i'.to_c        #=> (3-4i)\n   '-4e2-4e-2i'.to_c  #=> (-400.0-0.04i)\n   '-0.0-0.0i'.to_c   #=> (-0.0-0.0i)\n   '1/2+3/4i'.to_c    #=> ((1/2)+(3/4)*i)\n   'ruby'.to_c        #=> (0+0i)\n
to_d String.to_d()\nConvert +string+ to a BigDecimal and return it.\n\n    require 'bigdecimal'\n    require 'bigdecimal/util'\n\n    "0.5".to_d\n => #<BigDecimal:1dc69e0,'0.5E0',9(18)>\n
to_f String.to_f()\nReturns the result of interpreting leading characters in <i>str</i> as a\nfloating point number. Extraneous characters past the end of a valid number\nare ignored. If there is not a valid number at the start of <i>str</i>,\n`0.0` is returned. This method never raises an exception.\n\n   "123.45e1".to_f        #=> 1234.5\n   "45.67 degrees".to_f   #=> 45.67\n   "thx1138".to_f         #=> 0.0\n
to_i String.to_i(p1 = v1)\nReturns the result of interpreting leading characters in <i>str</i> as an\ninteger base <i>base</i> (between 2 and 36). Extraneous characters past the\nend of a valid number are ignored. If there is not a valid number at the\nstart of <i>str</i>, `0` is returned. This method never raises an\nexception when <i>base</i> is valid.\n\n   "12345".to_i             #=> 12345\n   "99 red balloons".to_i   #=> 99\n   "0a".to_i                #=> 0\n   "0a".to_i(16)            #=> 10\n   "hello".to_i             #=> 0\n   "1100101".to_i(2)        #=> 101\n   "1100101".to_i(8)        #=> 294977\n   "1100101".to_i(10)       #=> 1100101\n   "1100101".to_i(16)       #=> 17826049\n
to_r String.to_r()\nReturns a rational which denotes the string form.  The parser\nignores leading whitespaces and trailing garbage.  Any digit\nsequences can be separated by an underscore.  Returns zero for null\nor garbage string.\n\nNOTE: '0.3'.to_r isn't the same as 0.3.to_r.  The former is\nequivalent to '3/10'.to_r, but the latter isn't so.\n\nFor example:\n\n   '  2  '.to_r       #=> (2/1)\n   '300/2'.to_r       #=> (150/1)\n   '-9.2'.to_r        #=> (-46/5)\n   '-9.2e2'.to_r      #=> (-920/1)\n   '1_234_567'.to_r   #=> (1234567/1)\n   '21 june 09'.to_r  #=> (21/1)\n   '21/06/09'.to_r    #=> (7/2)\n   'bwv 1079'.to_r    #=> (0/1)\n
to_s String.to_s()\nReturns the receiver.\n
to_str String.to_str()\nReturns the receiver.\n
to_sym String.to_sym()\nReturns the `Symbol` corresponding to <i>str</i>, creating the\nsymbol if it did not previously exist. See `Symbol#id2name`.\n\n   "Koala".intern         #=> :Koala\n   s = 'cat'.to_sym       #=> :cat\n   s == :cat              #=> true\n   s = '@cat'.to_sym      #=> :@cat\n   s == :@cat             #=> true\n\nThis can also be used to create symbols that cannot be represented using the\n`:xxx` notation.\n\n   'cat and dog'.to_sym   #=> :"cat and dog"\n
toeuc String.toeuc()\nConvert `self` to EUC-JP\n
tojis String.tojis()\nConvert `self` to ISO-2022-JP\n
tolocale String.tolocale()\nConvert `self` to locale encoding\n
tosjis String.tosjis()\nConvert `self` to Shift_JIS\n
toutf16 String.toutf16()\nConvert `self` to UTF-16\n
toutf32 String.toutf32()\nConvert `self` to UTF-32\n
toutf8 String.toutf8()\nConvert `self` to UTF-8\n
tr String.tr(p1, p2)\nReturns a copy of <i>str</i> with the characters in <i>from_str</i>\nreplaced by the corresponding characters in <i>to_str</i>. If\n<i>to_str</i> is shorter than <i>from_str</i>, it is padded with its last\ncharacter in order to maintain the correspondence.\n\n   "hello".tr('el', 'ip')      #=> "hippo"\n   "hello".tr('aeiou', '*')    #=> "h*ll*"\n\nBoth strings may use the c1-c2 notation to denote ranges of characters,\nand <i>from_str</i> may start with a `^`, which denotes all\ncharacters except those listed.\n\n   "hello".tr('a-y', 'b-z')    #=> "ifmmp"\n   "hello".tr('^aeiou', '*')   #=> "*e**o"\n
tr! String.tr!(p1, p2)\nTranslates <i>str</i> in place, using the same rules as\n`String#tr`. Returns <i>str</i>, or `nil` if no\nchanges were made.\n
tr_s String.tr_s(p1, p2)\nProcesses a copy of <i>str</i> as described under `String#tr`,\nthen removes duplicate characters in regions that were affected by the\ntranslation.\n\n   "hello".tr_s('l', 'r')     #=> "hero"\n   "hello".tr_s('el', '*')    #=> "h*o"\n   "hello".tr_s('el', 'hx')   #=> "hhxo"\n
tr_s! String.tr_s!(p1, p2)\nPerforms `String#tr_s` processing on <i>str</i> in place,\nreturning <i>str</i>, or `nil` if no changes were made.\n
unpack String.unpack(p1)\nDecodes <i>str</i> (which may contain binary data) according to the\nformat string, returning an array of each value extracted. The\nformat string consists of a sequence of single-character directives,\nsummarized in the table at the end of this entry.\nEach directive may be followed\nby a number, indicating the number of times to repeat with this\ndirective. An asterisk (```*`'') will use up all\nremaining elements. The directives `sSiIlL` may each be\nfollowed by an underscore (```_`'') or\nexclamation mark (```!`'') to use the underlying\nplatform's native size for the specified type; otherwise, it uses a\nplatform-independent consistent size. Spaces are ignored in the\nformat string. See also `Array#pack`.\n\n   "abc \0\0abc \0\0".unpack('A6Z6')   #=> ["abc", "abc "]\n   "abc \0\0".unpack('a3a3')           #=> ["abc", " \000\000"]\n   "abc \0abc \0".unpack('Z*Z*')       #=> ["abc ", "abc "]\n   "aa".unpack('b8B8')                 #=> ["10000110", "01100001"]\n   "aaa".unpack('h2H2c')               #=> ["16", "61", 97]\n   "\xfe\xff\xfe\xff".unpack('sS')     #=> [-2, 65534]\n   "now=20is".unpack('M*')             #=> ["now is"]\n   "whole".unpack('xax2aX2aX1aX2a')    #=> ["h", "e", "l", "l", "o"]\n\nThis table summarizes the various formats and the Ruby classes\nreturned by each.\n\n Integer      |         |\n Directive    | Returns | Meaning\n -----------------------------------------------------------------\n    C         | Integer | 8-bit unsigned (unsigned char)\n    S         | Integer | 16-bit unsigned, native endian (uint16_t)\n    L         | Integer | 32-bit unsigned, native endian (uint32_t)\n    Q         | Integer | 64-bit unsigned, native endian (uint64_t)\n              |         |\n    c         | Integer | 8-bit signed (signed char)\n    s         | Integer | 16-bit signed, native endian (int16_t)\n    l         | Integer | 32-bit signed, native endian (int32_t)\n    q         | Integer | 64-bit signed, native endian (int64_t)\n              |         |\n    S_, S!    | Integer | unsigned short, native endian\n    I, I_, I! | Integer | unsigned int, native endian\n    L_, L!    | Integer | unsigned long, native endian\n              |         |\n    s_, s!    | Integer | signed short, native endian\n    i, i_, i! | Integer | signed int, native endian\n    l_, l!    | Integer | signed long, native endian\n              |         |\n    S> L> Q>  | Integer | same as the directives without ">" except\n    s> l> q>  |         | big endian\n    S!> I!>   |         | (available since Ruby 1.9.3)\n    L!> Q!>   |         | "S>" is same as "n"\n    s!> i!>   |         | "L>" is same as "N"\n    l!> q!>   |         |\n              |         |\n    S< L< Q<  | Integer | same as the directives without "<" except\n    s< l< q<  |         | little endian\n    S!< I!<   |         | (available since Ruby 1.9.3)\n    L!< Q!<   |         | "S<" is same as "v"\n    s!< i!<   |         | "L<" is same as "V"\n    l!< q!<   |         |\n              |         |\n    n         | Integer | 16-bit unsigned, network (big-endian) byte order\n    N         | Integer | 32-bit unsigned, network (big-endian) byte order\n    v         | Integer | 16-bit unsigned, VAX (little-endian) byte order\n    V         | Integer | 32-bit unsigned, VAX (little-endian) byte order\n              |         |\n    U         | Integer | UTF-8 character\n    w         | Integer | BER-compressed integer (see Array.pack)\n\n Float        |         |\n Directive    | Returns | Meaning\n -----------------------------------------------------------------\n    D, d      | Float   | double-precision, native format\n    F, f      | Float   | single-precision, native format\n    E         | Float   | double-precision, little-endian byte order\n    e         | Float   | single-precision, little-endian byte order\n    G         | Float   | double-precision, network (big-endian) byte order\n    g         | Float   | single-precision, network (big-endian) byte order\n\n String       |         |\n Directive    | Returns | Meaning\n -----------------------------------------------------------------\n    A         | String  | arbitrary binary string (remove trailing nulls\n    and ASCII spaces)\n    a         | String  | arbitrary binary string\n    Z         | String  | null-terminated string\n    B         | String  | bit string (MSB first)\n    b         | String  | bit string (LSB first)\n    H         | String  | hex string (high nibble first)\n    h         | String  | hex string (low nibble first)\n    u         | String  | UU-encoded string\n    M         | String  | quoted-printable, MIME encoding (see RFC2045)\n    m         | String  | base64 encoded string (RFC 2045) (default)\n              |         | base64 encoded string (RFC 4648) if followed by 0\n    P         | String  | pointer to a structure (fixed-length string)\n    p         | String  | pointer to a null-terminated string\n\n Misc.        |         |\n Directive    | Returns | Meaning\n -----------------------------------------------------------------\n    @         | ---     | skip to the offset given by the length argument\n    X         | ---     | skip backward one byte\n    x         | ---     | skip forward one byte\n
upcase String.upcase()\nReturns a copy of <i>str</i> with all lowercase letters replaced with their\nuppercase counterparts. The operation is locale insensitive---only\ncharacters ``a'' to ``z'' are affected.\nNote: case replacement is effective only in ASCII region.\n\n   "hEllO".upcase   #=> "HELLO"\n
upcase! String.upcase!()\nUpcases the contents of <i>str</i>, returning `nil` if no changes\nwere made.\nNote: case replacement is effective only in ASCII region.\n
upto String.upto(p1, p2 = v2)\nIterates through successive values, starting at <i>str</i> and\nending at <i>other_str</i> inclusive, passing each value in turn to\nthe block. The `String#succ` method is used to generate\neach value.  If optional second argument exclusive is omitted or is false,\nthe last value will be included; otherwise it will be excluded.\n\nIf no block is given, an enumerator is returned instead.\n\n   "a8".upto("b6") {|s| print s, ' ' }\n   for s in "a8".."b6"\n     print s, ' '\n   end\n\n<em>produces:</em>\n\n   a8 a9 b0 b1 b2 b3 b4 b5 b6\n   a8 a9 b0 b1 b2 b3 b4 b5 b6\n\nIf <i>str</i> and <i>other_str</i> contains only ascii numeric characters,\nboth are recognized as decimal numbers. In addition, the width of\nstring (e.g. leading zeros) is handled appropriately.\n\n   "9".upto("11").to_a   #=> ["9", "10", "11"]\n   "25".upto("5").to_a   #=> []\n   "07".upto("11").to_a  #=> ["07", "08", "09", "10", "11"]\n
valid_encoding? String.valid_encoding?()\nReturns true for a string which encoded correctly.\n\n  "\xc2\xa1".force_encoding("UTF-8").valid_encoding?  #=> true\n  "\xc2".force_encoding("UTF-8").valid_encoding?      #=> false\n  "\x80".force_encoding("UTF-8").valid_encoding?      #=> false\n
all_symbols Symbol.all_symbols()\nReturns an array of all the symbols currently in Ruby's symbol\ntable.\n\n   Symbol.all_symbols.size    #=> 903\n   Symbol.all_symbols[1,20]   #=> [:floor, :ARGV, :Binding, :symlink,\n                                   :chown, :EOFError, :$;, :String,\n                                   :LOCK_SH, :"setuid?", :$<,\n                                   :default_proc, :compact, :extend,\n                                   :Tms, :getwd, :$=, :ThreadGroup,\n                                   :wait2, :$>]\n
json_create Symbol.json_create(o)\nDeserializes JSON string by converting the <tt>string</tt> value stored in\nthe object to a Symbol\n
as_json Symbol.as_json(*)\nReturns a hash, that will be turned into a JSON object and represent this\nobject.\n
capitalize Symbol.capitalize()\nSame as `sym.to_s.capitalize.intern`.\n
casecmp Symbol.casecmp(p1)\nCase-insensitive version of `Symbol#<=>`.\n
dclone Symbol.dclone()\nprovides a unified +clone+ operation, for REXML::XPathParser\nto use across multiple Object types\n
downcase Symbol.downcase()\nSame as `sym.to_s.downcase.intern`.\n
empty? Symbol.empty?()\nReturns that _sym_ is :"" or not.\n
encoding Symbol.encoding()\nReturns the Encoding object that represents the encoding of _sym_.\n
id2name Symbol.id2name()\nReturns the name or string corresponding to <i>sym</i>.\n\n   :fred.id2name   #=> "fred"\n
inspect Symbol.inspect()\nReturns the representation of <i>sym</i> as a symbol literal.\n\n   :fred.inspect   #=> ":fred"\n
intern Symbol.intern()\nIn general, `to_sym` returns the `Symbol` corresponding\nto an object. As <i>sym</i> is already a symbol, `self` is returned\nin this case.\n
length Symbol.length()\nSame as `sym.to_s.length`.\n
match Symbol.match(p1)\nReturns `sym.to_s =~ obj`.\n
next Symbol.next()\nSame as `sym.to_s.succ.intern`.\n
size Symbol.size()\nSame as `sym.to_s.length`.\n
slice Symbol.slice(*args)\nReturns `sym.to_s[]`.\n
succ Symbol.succ()\nSame as `sym.to_s.succ.intern`.\n
swapcase Symbol.swapcase()\nSame as `sym.to_s.swapcase.intern`.\n
to_json Symbol.to_json(*a)\nStores class name (Symbol) with String representation of Symbol as a JSON\nstring.\n
to_proc Symbol.to_proc()\nReturns a _Proc_ object which respond to the given method by _sym_.\n\n  (1..3).collect(&:to_s)  #=> ["1", "2", "3"]\n
to_s Symbol.to_s()\nReturns the name or string corresponding to <i>sym</i>.\n\n   :fred.id2name   #=> "fred"\n
to_sym Symbol.to_sym()\nIn general, `to_sym` returns the `Symbol` corresponding\nto an object. As <i>sym</i> is already a symbol, `self` is returned\nin this case.\n
upcase Symbol.upcase()\nSame as `sym.to_s.upcase.intern`.\n
new SignalException.new(*args)\nConstruct a new SignalException object.  +sig_name+ should be a known\nsignal name.\n
signo SignalException.signo()\nReturns a signal number.\n
json_create Range.json_create(object)\nDeserializes JSON string by constructing new Range object with arguments\n<tt>a</tt> serialized by <tt>to_json</tt>.\n
new Range.new(p1, p2, p3 = v3)\nConstructs a range using the given <i>start</i> and <i>end</i>. If the third\nparameter is omitted or is `false`, the <i>range</i> will include\nthe end object; otherwise, it will be excluded.\n
as_json Range.as_json(*)\nReturns a hash, that will be turned into a JSON object and represent this\nobject.\n
begin Range.begin()\nReturns the first object in <i>rng</i>.\n
cover? Range.cover?(p1)\nReturns `true` if <i>obj</i> is between beg and end,\ni.e `beg <= obj <= end` (or <i>end</i> exclusive when\n`exclude_end?` is true).\n\n   ("a".."z").cover?("c")    #=> true\n   ("a".."z").cover?("5")    #=> false\n
each Range.each()\nIterates over the elements <i>rng</i>, passing each in turn to the\nblock. You can only iterate if the start object of the range\nsupports the +succ+ method (which means that you can't iterate over\nranges of +Float+ objects).\n\nIf no block is given, an enumerator is returned instead.\n\n   (10..15).each do |n|\n      print n, ' '\n   end\n\n<em>produces:</em>\n\n   10 11 12 13 14 15\n
end Range.end()\nReturns the object that defines the end of <i>rng</i>.\n\n   (1..10).end    #=> 10\n   (1...10).end   #=> 10\n
eql? Range.eql?(p1)\nReturns `true` only if <i>obj</i> is a Range, has equivalent\nbeginning and end items (by comparing them with #eql?), and has the same\nexclude_end? setting as <i>rng</i>.\n\n  (0..2).eql?(0..2)            #=> true\n  (0..2).eql?(Range.new(0,2))  #=> true\n  (0..2).eql?(0...2)           #=> false\n
exclude_end? Range.exclude_end?()\nReturns `true` if <i>rng</i> excludes its end value.\n
first Range.first(p1)\nReturns the first object in <i>rng</i>, or the first +n+ elements.\n
hash Range.hash()\nGenerate a hash value such that two ranges with the same start and\nend points, and the same value for the "exclude end" flag, generate\nthe same hash value.\n
include? Range.include?(p1)\nReturns `true` if <i>obj</i> is an element of\n<i>rng</i>, `false` otherwise.  If beg and end are\nnumeric, comparison is done according magnitude of values.\n\n   ("a".."z").include?("g")  # -> true\n   ("a".."z").include?("A")  # -> false\n
inspect Range.inspect()\nConvert this range object to a printable form (using\n`inspect` to convert the start and end\nobjects).\n
last Range.last(*args)\nReturns the last object in <i>rng</i>, or the last +n+ elements.\n
max Range.max()\nReturns the maximum value in <i>rng</i>. The second uses\nthe block to compare values.  Returns nil if the first\nvalue in range is larger than the last value.\n
member? Range.member?(p1)\nReturns `true` if <i>obj</i> is an element of\n<i>rng</i>, `false` otherwise.  If beg and end are\nnumeric, comparison is done according magnitude of values.\n\n   ("a".."z").include?("g")  # -> true\n   ("a".."z").include?("A")  # -> false\n
min Range.min()\nReturns the minimum value in <i>rng</i>. The second uses\nthe block to compare values.  Returns nil if the first\nvalue in range is larger than the last value.\n
pretty_print Range.pretty_print(q)\n\n
step Range.step(p1 = v1)\nIterates over <i>rng</i>, passing each <i>n</i>th element to the block. If\nthe range contains numbers, <i>n</i> is added for each iteration.  Otherwise\n`step` invokes `succ` to iterate through range\nelements. The following code uses class `Xs`, which is defined\nin the class-level documentation.\n\nIf no block is given, an enumerator is returned instead.\n\n   range = Xs.new(1)..Xs.new(10)\n   range.step(2) {|x| puts x}\n   range.step(3) {|x| puts x}\n\n<em>produces:</em>\n\n    1 x\n    3 xxx\n    5 xxxxx\n    7 xxxxxxx\n    9 xxxxxxxxx\n    1 x\n    4 xxxx\n    7 xxxxxxx\n   10 xxxxxxxxxx\n
to_json Range.to_json(*args)\nStores class name (Range) with JSON array of arguments <tt>a</tt> which\ninclude <tt>first</tt> (integer), <tt>last</tt> (integer), and\n<tt>exclude_end?</tt> (boolean) as JSON string.\n
to_s Range.to_s()\nConvert this range object to a printable form.\n
aliases Encoding.aliases()\nReturns the hash of available encoding alias and original encoding name.\n\n  Encoding.aliases\n=> {"BINARY"=>"ASCII-8BIT", "ASCII"=>"US-ASCII", "ANSI_X3.4-1986"=>"US-ASCII",\n        "SJIS"=>"Shift_JIS", "eucJP"=>"EUC-JP", "CP932"=>"Windows-31J"}\n
compatible? Encoding.compatible?(p1, p2)\nChecks the compatibility of two objects.\n\nIf the objects are both strings they are compatible when they are\nconcatenatable.  The encoding of the concatenated string will be returned\nif they are compatible, nil if they are not.\n\n  Encoding.compatible?("\xa1".force_encoding("iso-8859-1"), "b")\n=> #<Encoding:ISO-8859-1>\n\n  Encoding.compatible?(\n    "\xa1".force_encoding("iso-8859-1"),\n    "\xa1\xa1".force_encoding("euc-jp"))\n=> nil\n\nIf the objects are non-strings their encodings are compatible when they\nhave an encoding and:\n* Either encoding is US-ASCII compatible\n* One of the encodings is a 7-bit encoding\n
default_external Encoding.default_external()\nReturns default external encoding.\n\nThe default external encoding is used by default for strings created from\nthe following locations:\n\n* CSV\n* File data read from disk\n* SDBM\n* StringIO\n* Zlib::GzipReader\n* Zlib::GzipWriter\n* String#inspect\n* Regexp#inspect\n\nWhile strings created from these locations will have this encoding, the\nencoding may not be valid.  Be sure to check String#valid_encoding?.\n\nFile data written to disk will be transcoded to the default external\nencoding when written.\n\nThe default external encoding is initialized by the locale or -E option.\n
default_external= Encoding.default_external=(p1)\nSets default external encoding.  You should not set\nEncoding::default_external in ruby code as strings created before changing\nthe value may have a different encoding from strings created after thevalue\nwas changed., instead you should use <tt>ruby -E</tt> to invoke ruby with\nthe correct default_external.\n\nSee Encoding::default_external for information on how the default external\nencoding is used.\n
default_internal Encoding.default_internal()\nReturns default internal encoding.  Strings will be transcoded to the\ndefault internal encoding in the following places if the default internal\nencoding is not nil:\n\n* CSV\n* Etc.sysconfdir and Etc.systmpdir\n* File data read from disk\n* File names from Dir\n* Integer#chr\n* String#inspect and Regexp#inspect\n* Strings returned from Curses\n* Strings returned from Readline\n* Strings returned from SDBM\n* Time#zone\n* Values from ENV\n* Values in ARGV including $PROGRAM_NAME\n* __FILE__\n\nAdditionally String#encode and String#encode! use the default internal\nencoding if no encoding is given.\n\nThe locale encoding (__ENCODING__), not default_internal, is used as the\nencoding of created strings.\n\nEncoding::default_internal is initialized by the source file's\ninternal_encoding or -E option.\n
default_internal= Encoding.default_internal=(p1)\nSets default internal encoding or removes default internal encoding when\npassed nil.  You should not set Encoding::default_internal in ruby code as\nstrings created before changing the value may have a different encoding\nfrom strings created after the change.  Instead you should use\n<tt>ruby -E</tt> to invoke ruby with the correct default_internal.\n\nSee Encoding::default_internal for information on how the default internal\nencoding is used.\n
find Encoding.find(p1)\nSearch the encoding with specified <i>name</i>.\n<i>name</i> should be a string or symbol.\n\n  Encoding.find("US-ASCII")  #=> #<Encoding:US-ASCII>\n  Encoding.find(:Shift_JIS)  #=> #<Encoding:Shift_JIS>\n\nNames which this method accept are encoding names and aliases\nincluding following special aliases\n\n"external"::   default external encoding\n"internal"::   default internal encoding\n"locale"::     locale encoding\n"filesystem":: filesystem encoding\n\nAn ArgumentError is raised when no encoding with <i>name</i>.\nOnly `Encoding.find("internal")` however returns nil\nwhen no encoding named "internal", in other words, when Ruby has no\ndefault internal encoding.\n
list Encoding.list()\nReturns the list of loaded encodings.\n\n  Encoding.list\n=> [#<Encoding:ASCII-8BIT>, #<Encoding:UTF-8>,\n<Encoding:ISO-2022-JP (dummy)>]\n\n  Encoding.find("US-ASCII")\n=> #<Encoding:US-ASCII>\n\n  Encoding.list\n=> [#<Encoding:ASCII-8BIT>, #<Encoding:UTF-8>,\n<Encoding:US-ASCII>, #<Encoding:ISO-2022-JP (dummy)>]\n
locale_charmap Encoding.locale_charmap()\nReturns the locale charmap name.\nIt returns nil if no appropriate information.\n\n  Debian GNU/Linux\n    LANG=C\n      Encoding.locale_charmap  #=> "ANSI_X3.4-1968"\n    LANG=ja_JP.EUC-JP\n      Encoding.locale_charmap  #=> "EUC-JP"\n\n  SunOS 5\n    LANG=C\n      Encoding.locale_charmap  #=> "646"\n    LANG=ja\n      Encoding.locale_charmap  #=> "eucJP"\n\nThe result is highly platform dependent.\nSo Encoding.find(Encoding.locale_charmap) may cause an error.\nIf you need some encoding object even for unknown locale,\nEncoding.find("locale") can be used.\n
name_list Encoding.name_list()\nReturns the list of available encoding names.\n\n  Encoding.name_list\n=> ["US-ASCII", "ASCII-8BIT", "UTF-8",\n        "ISO-8859-1", "Shift_JIS", "EUC-JP",\n        "Windows-31J",\n        "BINARY", "CP932", "eucJP"]\n
ascii_compatible? Encoding.ascii_compatible?()\nReturns whether ASCII-compatible or not.\n\n  Encoding::UTF_8.ascii_compatible?     #=> true\n  Encoding::UTF_16BE.ascii_compatible?  #=> false\n
dummy? Encoding.dummy?()\nReturns true for dummy encodings.\nA dummy encoding is an encoding for which character handling is not properly\nimplemented.\nIt is used for stateful encodings.\n\n  Encoding::ISO_2022_JP.dummy?       #=> true\n  Encoding::UTF_8.dummy?             #=> false\n
inspect Encoding.inspect()\nReturns a string which represents the encoding for programmers.\n\n  Encoding::UTF_8.inspect       #=> "#<Encoding:UTF-8>"\n  Encoding::ISO_2022_JP.inspect #=> "#<Encoding:ISO-2022-JP (dummy)>"\n
name Encoding.name()\nReturns the name of the encoding.\n\n  Encoding::UTF_8.name      #=> "UTF-8"\n
names Encoding.names()\nReturns the list of name and aliases of the encoding.\n\n  Encoding::WINDOWS_31J.names  #=> ["Windows-31J", "CP932", "csWindows31J"]\n
replicate Encoding.replicate(p1)\nReturns a replicated encoding of _enc_ whose name is _name_.\nThe new encoding should have the same byte structure of _enc_.\nIf _name_ is used by another encoding, raise ArgumentError.\n
to_s Encoding.to_s()\nReturns the name of the encoding.\n\n  Encoding::UTF_8.name      #=> "UTF-8"\n
new Enumerator.new(*args)\nCreates a new Enumerator object, which can be used as an\nEnumerable.\n\nIn the first form, iteration is defined by the given block, in\nwhich a "yielder" object, given as block parameter, can be used to\nyield a value by calling the +yield+ method (aliased as +<<+):\n\n  fib = Enumerator.new do |y|\n    a = b = 1\n    loop do\n      y << a\n      a, b = b, a + b\n    end\n  end\n\n  p fib.take(10) # => [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n\nIn the second, deprecated, form, a generated Enumerator iterates over the\ngiven object using the given method with the given arguments passed.\n\nUse of this form is discouraged.  Use Kernel#enum_for or Kernel#to_enum\ninstead.\n\n  e = Enumerator.new(ObjectSpace, :each_object)\n-> ObjectSpace.enum_for(:each_object)\n\n  e.select { |obj| obj.is_a?(Class) }  #=> array of all classes\n
each Enumerator.each()\nIterates over the block according to how this Enumerable was constructed.\nIf no block is given, returns self.\n
each_with_index Enumerator.each_with_index()\nSame as Enumerator#with_index(0), i.e. there is no starting offset.\n\nIf no block is given, a new Enumerator is returned that includes the index.\n
each_with_object Enumerator.each_with_object(p1)\nIterates the given block for each element with an arbitrary object, +obj+,\nand returns +obj+\n\nIf no block is given, returns a new Enumerator.\n\n=== Example\n\n  to_three = Enumerator.new do |y|\n    3.times do |x|\n      y << x\n    end\n  end\n\n  to_three_with_string = to_three.with_object("foo")\n  to_three_with_string.each do |x,string|\n    puts "#{string}: #{x}"\n  end\n => foo:0\n => foo:1\n => foo:2\n
feed Enumerator.feed(p1)\nSets the value to be returned by the next yield inside +e+.\n\nIf the value is not set, the yield returns nil.\n\nThis value is cleared after being yielded.\n\n  o = Object.new\n  def o.each\n    x = yield         # (2) blocks\n    p x               # (5) => "foo"\n    x = yield         # (6) blocks\n    p x               # (8) => nil\n    x = yield         # (9) blocks\n    p x               # not reached w/o another e.next\n  end\n\n  e = o.to_enum\n  e.next              # (1)\n  e.feed "foo"        # (3)\n  e.next              # (4)\n  e.next              # (7)\n (10)\n
inspect Enumerator.inspect()\nCreates a printable version of <i>e</i>.\n
next Enumerator.next()\nReturns the next object in the enumerator, and move the internal position\nforward.  When the position reached at the end, StopIteration is raised.\n\n=== Example\n\n  a = [1,2,3]\n  e = a.to_enum\n  p e.next   #=> 1\n  p e.next   #=> 2\n  p e.next   #=> 3\n  p e.next   #raises StopIteration\n\nNote that enumeration sequence by +next+ does not affect other non-external\nenumeration methods, unless the underlying iteration methods itself has\nside-effect, e.g. IO#each_line.\n
next_values Enumerator.next_values()\nReturns the next object as an array in the enumerator, and move the\ninternal position forward.  When the position reached at the end,\nStopIteration is raised.\n\nThis method can be used to distinguish `yield` and `yield\nnil`.\n\n=== Example\n\n  o = Object.new\n  def o.each\n    yield\n    yield 1\n    yield 1, 2\n    yield nil\n    yield [1, 2]\n  end\n  e = o.to_enum\n  p e.next_values\n  p e.next_values\n  p e.next_values\n  p e.next_values\n  p e.next_values\n  e = o.to_enum\n  p e.next\n  p e.next\n  p e.next\n  p e.next\n  p e.next\n yield args       next_values      next\n  yield            []               nil\n  yield 1          [1]              1\n  yield 1, 2       [1, 2]           [1, 2]\n  yield nil        [nil]            nil\n  yield [1, 2]     [[1, 2]]         [1, 2]\n\nNote that +next_values+ does not affect other non-external enumeration\nmethods unless underlying iteration method itself has side-effect, e.g.\nIO#each_line.\n
peek Enumerator.peek()\nReturns the next object in the enumerator, but doesn't move the internal\nposition forward.  If the position is already at the end, StopIteration\nis raised.\n\n=== Example\n\n  a = [1,2,3]\n  e = a.to_enum\n  p e.next   #=> 1\n  p e.peek   #=> 2\n  p e.peek   #=> 2\n  p e.peek   #=> 2\n  p e.next   #=> 2\n  p e.next   #=> 3\n  p e.next   #raises StopIteration\n
peek_values Enumerator.peek_values()\nReturns the next object as an array, similar to Enumerator#next_values, but\ndoesn't move the internal position forward.  If the position is already at\nthe end, StopIteration is raised.\n\n=== Example\n\n  o = Object.new\n  def o.each\n    yield\n    yield 1\n    yield 1, 2\n  end\n  e = o.to_enum\n  p e.peek_values    #=> []\n  e.next\n  p e.peek_values    #=> [1]\n  p e.peek_values    #=> [1]\n  e.next\n  p e.peek_values    #=> [1, 2]\n  e.next\n  p e.peek_values    # raises StopIteration\n
rewind Enumerator.rewind()\nRewinds the enumeration sequence to the beginning.\n\nIf the enclosed object responds to a "rewind" method, it is called.\n
with_index Enumerator.with_index(p1 = v1)\nIterates the given block for each element with an index, which\nstarts from +offset+.  If no block is given, returns a new Enumerator\nthat includes the index, starting from +offset+\n\n+offset+:: the starting index to use\n
with_object Enumerator.with_object(p1)\nIterates the given block for each element with an arbitrary object, +obj+,\nand returns +obj+\n\nIf no block is given, returns a new Enumerator.\n\n=== Example\n\n  to_three = Enumerator.new do |y|\n    3.times do |x|\n      y << x\n    end\n  end\n\n  to_three_with_string = to_three.with_object("foo")\n  to_three_with_string.each do |x,string|\n    puts "#{string}: #{x}"\n  end\n => foo:0\n => foo:1\n => foo:2\n
result StopIteration.result()\nReturns the return value of the iterator.\n\n  o = Object.new\n  def o.each\n    yield 1\n    yield 2\n    yield 3\n    100\n  end\n\n  e = o.to_enum\n\n  puts e.next                   #=> 1\n  puts e.next                   #=> 2\n  puts e.next                   #=> 3\n\n  begin\n    e.next\n  rescue StopIteration => ex\n    puts ex.result              #=> 100\n  end\n
new BasicObject.new()\nNot documented\n
__id__ BasicObject.__id__()\nReturns an integer identifier for <i>obj</i>. The same number will\nbe returned on all calls to `id` for a given object, and\nno two active objects will share an id.\n`Object#object_id` is a different concept from the\n`:name` notation, which returns the symbol id of\n`name`. Replaces the deprecated `Object#id`.\n
__send__ BasicObject.__send__(*args)\nInvokes the method identified by _symbol_, passing it any\narguments specified. You can use `__send__` if the name\n+send+ clashes with an existing method in _obj_.\n\n   class Klass\n     def hello(*args)\n       "Hello " + args.join(' ')\n     end\n   end\n   k = Klass.new\n   k.send :hello, "gentle", "readers"   #=> "Hello gentle readers"\n
equal? BasicObject.equal?(p1)\nEquality---At the `Object` level, `==` returns\n`true` only if <i>obj</i> and <i>other</i> are the\nsame object. Typically, this method is overridden in descendant\nclasses to provide class-specific meaning.\n\nUnlike `==`, the `equal?` method should never be\noverridden by subclasses: it is used to determine object identity\n(that is, `a.equal?(b)` iff `a` is the same\nobject as `b`).\n\nThe `eql?` method returns `true` if\n<i>obj</i> and <i>anObject</i> have the same value. Used by\n`Hash` to test members for equality.  For objects of\nclass `Object`, `eql?` is synonymous with\n`==`. Subclasses normally continue this tradition, but\nthere are exceptions. `Numeric` types, for example,\nperform type conversion across `==`, but not across\n`eql?`, so:\n\n   1 == 1.0     #=> true\n   1.eql? 1.0   #=> false\n
instance_eval BasicObject.instance_eval(*args)\nEvaluates a string containing Ruby source code, or the given block,\nwithin the context of the receiver (_obj_). In order to set the\ncontext, the variable +self+ is set to _obj_ while\nthe code is executing, giving the code access to _obj_'s\ninstance variables. In the version of `instance_eval`\nthat takes a +String+, the optional second and third\nparameters supply a filename and starting line number that are used\nwhen reporting compilation errors.\n\n   class KlassWithSecret\n     def initialize\n       @secret = 99\n     end\n   end\n   k = KlassWithSecret.new\n   k.instance_eval { @secret }   #=> 99\n
instance_exec BasicObject.instance_exec(*args)\nExecutes the given block within the context of the receiver\n(_obj_). In order to set the context, the variable +self+ is set\nto _obj_ while the code is executing, giving the code access to\n_obj_'s instance variables.  Arguments are passed as block parameters.\n\n   class KlassWithSecret\n     def initialize\n       @secret = 99\n     end\n   end\n   k = KlassWithSecret.new\n   k.instance_exec(5) {|x| @secret+x }   #=> 104\n
json_create Struct.json_create(object)\nDeserializes JSON string by constructing new Struct object with values\n<tt>v</tt> serialized by <tt>to_json</tt>.\n
new Struct.new(p1, *args)\nCreates a new class, named by <i>aString</i>, containing accessor\nmethods for the given symbols. If the name <i>aString</i> is\nomitted, an anonymous structure class will be created. Otherwise,\nthe name of this struct will appear as a constant in class\n`Struct`, so it must be unique for all\n`Struct`s in the system and should start with a capital\nletter. Assigning a structure class to a constant effectively gives\nthe class the name of the constant.\n\n`Struct::new` returns a new `Class` object,\nwhich can then be used to create specific instances of the new\nstructure. The number of actual parameters must be\nless than or equal to the number of attributes defined for this\nclass; unset parameters default to `nil`.  Passing too many\nparameters will raise an `ArgumentError`.\n\nThe remaining methods listed in this section (class and instance)\nare defined for this generated class.\n Create a structure with a name in Struct\n   Struct.new("Customer", :name, :address)    #=> Struct::Customer\n   Struct::Customer.new("Dave", "123 Main")   #=> #<struct Struct::Customer\n   name="Dave", address="123 Main">\n Create a structure named by its constant\n   Customer = Struct.new(:name, :address)     #=> Customer\n   Customer.new("Dave", "123 Main")           #=> #<struct Customer\n   name="Dave", address="123 Main">\n
as_json Struct.as_json(*)\nReturns a hash, that will be turned into a JSON object and represent this\nobject.\n
each Struct.each()\nCalls <i>block</i> once for each instance variable, passing the\nvalue as a parameter.\n\nIf no block is given, an enumerator is returned instead.\n\n   Customer = Struct.new(:name, :address, :zip)\n   joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)\n   joe.each {|x| puts(x) }\n\n<em>produces:</em>\n\n   Joe Smith\n   123 Maple, Anytown NC\n   12345\n
each_pair Struct.each_pair()\nCalls <i>block</i> once for each instance variable, passing the name\n(as a symbol) and the value as parameters.\n\nIf no block is given, an enumerator is returned instead.\n\n   Customer = Struct.new(:name, :address, :zip)\n   joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)\n   joe.each_pair {|name, value| puts("#{name} => #{value}") }\n\n<em>produces:</em>\n\n   name => Joe Smith\n   address => 123 Maple, Anytown NC\n   zip => 12345\n
eql? Struct.eql?(p1)\ncode-seq:\n  struct.eql?(other)   -> true or false\n\nTwo structures are equal if they are the same object, or if all their\nfields are equal (using `eql?`).\n
hash Struct.hash()\nReturn a hash value based on this struct's contents.\n
inspect Struct.inspect()\nDescribe the contents of this struct in a string.\n
length Struct.length()\nReturns the number of instance variables.\n\n   Customer = Struct.new(:name, :address, :zip)\n   joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)\n   joe.length   #=> 3\n
members Struct.members()\nReturns an array of strings representing the names of the instance\nvariables.\n\n   Customer = Struct.new(:name, :address, :zip)\n   joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)\n   joe.members   #=> [:name, :address, :zip]\n
pretty_print Struct.pretty_print(q)\n\n
pretty_print_cycle Struct.pretty_print_cycle(q)\n\n
select Struct.select(*args)\nInvokes the block passing in successive elements from\n<i>struct</i>, returning an array containing those elements\nfor which the block returns a true value (equivalent to\n`Enumerable#select`).\n\n   Lots = Struct.new(:a, :b, :c, :d, :e, :f)\n   l = Lots.new(11, 22, 33, 44, 55, 66)\n   l.select {|v| (v % 2).zero? }   #=> [22, 44, 66]\n
size Struct.size()\nReturns the number of instance variables.\n\n   Customer = Struct.new(:name, :address, :zip)\n   joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)\n   joe.length   #=> 3\n
to_a Struct.to_a()\nReturns the values for this instance as an array.\n\n   Customer = Struct.new(:name, :address, :zip)\n   joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)\n   joe.to_a[1]   #=> "123 Maple, Anytown NC"\n
to_json Struct.to_json(*args)\nStores class name (Struct) with Struct values <tt>v</tt> as a JSON string.\nOnly named structs are supported.\n
to_s Struct.to_s()\n\n
values Struct.values()\nReturns the values for this instance as an array.\n\n   Customer = Struct.new(:name, :address, :zip)\n   joe = Customer.new("Joe Smith", "123 Maple, Anytown NC", 12345)\n   joe.to_a[1]   #=> "123 Maple, Anytown NC"\n
values_at Struct.values_at(*args)\nReturns an array containing the elements in\n+self+ corresponding to the given selector(s). The selectors\nmay be either integer indices or ranges.\nSee also `.select`.\n\n   a = %w{ a b c d e f }\n   a.values_at(1, 3, 5)\n   a.values_at(1, 3, 5, 7)\n   a.values_at(-1, -3, -5, -7)\n   a.values_at(1..3, 2...5)\n
new Random.new(p1 = v1)\nCreates new Mersenne Twister based pseudorandom number generator with\nseed.  When the argument seed is omitted, the generator is initialized\nwith Random.new_seed.\n\nThe argument seed is used to ensure repeatable sequences of random numbers\nbetween different runs of the program.\n\n    prng = Random.new(1234)\n    [ prng.rand, prng.rand ]   #=> [0.191519450378892, 0.622108771039832]\n    [ prng.integer(10), prng.integer(1000) ]  #=> [4, 664]\n    prng = Random.new(1234)\n    [ prng.rand, prng.rand ]   #=> [0.191519450378892, 0.622108771039832]\n
new_seed Random.new_seed()\nReturns arbitrary value for seed.\n
rand Random.rand(*args)\nAlias of _Random::DEFAULT.rand_.\n
srand Random.srand(p1 = v1)\nSeeds the pseudorandom number generator to the value of\n<i>number</i>. If <i>number</i> is omitted,\nseeds the generator using a combination of the time, the\nprocess id, and a sequence number. (This is also the behavior if\n`Kernel::rand` is called without previously calling\n`srand`, but without the sequence.) By setting the seed\nto a known value, scripts can be made deterministic during testing.\nThe previous seed value is returned. Also see `Kernel::rand`.\n
bytes Random.bytes(p1)\nReturns a random binary string.  The argument size specified the length of\nthe result string.\n
rand Random.rand(*args)\nWhen the argument is an +Integer+ or a +Bignum+, it returns a\nrandom integer greater than or equal to zero and less than the\nargument.  Unlike Random.rand, when the argument is a negative\ninteger or zero, it raises an ArgumentError.\n\nWhen the argument is a +Float+, it returns a random floating point\nnumber between 0.0 and _max_, including 0.0 and excluding _max_.\n\nWhen the argument _limit_ is a +Range+, it returns a random\nnumber where range.member?(number) == true.\n    prng.rand(5..9)  #=> one of [5, 6, 7, 8, 9]\n    prng.rand(5...9) #=> one of [5, 6, 7, 8]\n    prng.rand(5.0..9.0) #=> between 5.0 and 9.0, including 9.0\n    prng.rand(5.0...9.0) #=> between 5.0 and 9.0, excluding 9.0\n\n+begin+/+end+ of the range have to have subtract and add methods.\n\nOtherwise, it raises an ArgumentError.\n
seed Random.seed()\nReturns the seed of the generator.\n
absolute_path File.absolute_path(p1, p2 = v2)\nConverts a pathname to an absolute pathname. Relative paths are\nreferenced from the current working directory of the process unless\n<i>dir_string</i> is given, in which case it will be used as the\nstarting point. If the given pathname starts with a ```~`''\nit is NOT expanded, it is treated as a normal directory name.\n\n   File.absolute_path("~oracle/bin")       #=> "<relative_path>/~oracle/bin"\n
atime File.atime(p1)\nReturns the last access time for the named file as a Time object).\n\n   File.atime("testfile")   #=> Wed Apr 09 08:51:48 CDT 2003\n
basename File.basename(p1, p2 = v2)\nReturns the last component of the filename given in <i>file_name</i>,\nwhich must be formed using forward slashes (```/`'')\nregardless of the separator used on the local file system. If\n<i>suffix</i> is given and present at the end of <i>file_name</i>,\nit is removed.\n\n   File.basename("/home/gumby/work/ruby.rb")          #=> "ruby.rb"\n   File.basename("/home/gumby/work/ruby.rb", ".rb")   #=> "ruby"\n
blockdev? File.blockdev?(p1)\nReturns `true` if the named file is a block device.\n
chardev? File.chardev?(p1)\nReturns `true` if the named file is a character device.\n
chmod File.chmod(p1, *args)\nChanges permission bits on the named file(s) to the bit pattern\nrepresented by <i>mode_int</i>. Actual effects are operating system\ndependent (see the beginning of this section). On Unix systems, see\n`chmod(2)` for details. Returns the number of files\nprocessed.\n\n   File.chmod(0644, "testfile", "out")   #=> 2\n
chown File.chown(p1, p2, *args)\nChanges the owner and group of the named file(s) to the given\nnumeric owner and group id's. Only a process with superuser\nprivileges may change the owner of a file. The current owner of a\nfile may change the file's group to any group to which the owner\nbelongs. A `nil` or -1 owner or group id is ignored.\nReturns the number of files processed.\n\n   File.chown(nil, 100, "testfile")\n
ctime File.ctime(p1)\nReturns the change time for the named file (the time at which\ndirectory information about the file was changed, not the file\nitself).\n\nNote that on Windows (NTFS), returns creation time (birth time).\n\n   File.ctime("testfile")   #=> Wed Apr 09 08:53:13 CDT 2003\n
delete File.delete(*args)\nDeletes the named files, returning the number of names\npassed as arguments. Raises an exception on any error.\nSee also `Dir::rmdir`.\n
directory? File.directory?(p1)\nReturns `true` if the named file is a directory,\nor a symlink that points at a directory, and `false`\notherwise.\n\n   File.directory?(".")\n
dirname File.dirname(p1)\nReturns all components of the filename given in <i>file_name</i>\nexcept the last one. The filename must be formed using forward\nslashes (```/`'') regardless of the separator used on the\nlocal file system.\n\n   File.dirname("/home/gumby/work/ruby.rb")   #=> "/home/gumby/work"\n
executable? File.executable?(p1)\nReturns `true` if the named file is executable by the effective\nuser id of this process.\n
executable_real? File.executable_real?(p1)\nReturns `true` if the named file is executable by the real\nuser id of this process.\n
exist? File.exist?(p1)\nReturns `true` if the named file is a directory,\n`false` otherwise.\n
exists? File.exists?(p1)\nReturn `true` if the named file exists.\n
expand_path File.expand_path(p1, p2 = v2)\nConverts a pathname to an absolute pathname. Relative paths are\nreferenced from the current working directory of the process unless\n<i>dir_string</i> is given, in which case it will be used as the\nstarting point. The given pathname may start with a\n```~`'', which expands to the process owner's home\ndirectory (the environment variable `HOME` must be set\ncorrectly). ```~`<i>user</i>'' expands to the named\nuser's home directory.\n\n   File.expand_path("~oracle/bin")           #=> "/home/oracle/bin"\n   File.expand_path("../../bin", "/tmp/x")   #=> "/bin"\n
extname File.extname(p1)\nReturns the extension (the portion of file name in <i>path</i>\nafter the period).\n\n   File.extname("test.rb")         #=> ".rb"\n   File.extname("a/b/d/test.rb")   #=> ".rb"\n   File.extname("test")            #=> ""\n   File.extname(".profile")        #=> ""\n
file? File.file?(p1)\nReturns `true` if the named file exists and is a\nregular file.\n
fnmatch File.fnmatch(p1, p2, p3 = v3)\nReturns true if <i>path</i> matches against <i>pattern</i> The\npattern is not a regular expression; instead it follows rules\nsimilar to shell filename globbing. It may contain the following\nmetacharacters:\n\n`*`::        Matches any file. Can be restricted by\n                        other values in the glob. `*`\n                        will match all files; `c*` will\n                        match all files beginning with\n                        `c`; `*c` will match\n                        all files ending with `c`; and\n                        `\*c*` will match all files that\n                        have `c` in them (including at\n                        the beginning or end). Equivalent to\n                        `/ .* /x` in regexp.\n`**`::       Matches directories recursively or files\n                        expansively.\n`?`::        Matches any one character. Equivalent to\n                        `/.{1}/` in regexp.\n`[set]`::    Matches any one character in +set+.\n                        Behaves exactly like character sets in\n                        Regexp, including set negation\n                        (`[^a-z]`).\n`\`::        Escapes the next metacharacter.\n\n<i>flags</i> is a bitwise OR of the `FNM_xxx`\nparameters. The same glob pattern and flags are used by\n`Dir::glob`.\n\n   File.fnmatch('cat',       'cat')        #=> true  # match entire string\n   File.fnmatch('cat',       'category')   #=> false # only match partial\n   string\n   File.fnmatch('c{at,ub}s', 'cats')       #=> false # { } isn't supported\n\n   File.fnmatch('c?t',     'cat')          #=> true  # '?' match only\n   1 character\n   File.fnmatch('c??t',    'cat')          #=> false # ditto\n   File.fnmatch('c*',      'cats')         #=> true  # '*' match 0 or more\n   characters\n   File.fnmatch('c*t',     'c/a/b/t')      #=> true  # ditto\n   File.fnmatch('ca[a-z]', 'cat')          #=> true  # inclusive bracket\n   expression\n   File.fnmatch('ca[^t]',  'cat')          #=> false # exclusive bracket\n   expression ('^' or '!')\n\n   File.fnmatch('cat', 'CAT')                     #=> false # case sensitive\n   File.fnmatch('cat', 'CAT', File::FNM_CASEFOLD) #=> true  # case insensitive\n\n   File.fnmatch('?',   '/', File::FNM_PATHNAME)  #=> false # wildcard doesn't\n   match '/' on FNM_PATHNAME\n   File.fnmatch('*',   '/', File::FNM_PATHNAME)  #=> false # ditto\n   File.fnmatch('[/]', '/', File::FNM_PATHNAME)  #=> false # ditto\n\n   File.fnmatch('\?',   '?')                       #=> true  # escaped\n   wildcard becomes ordinary\n   File.fnmatch('\a',   'a')                       #=> true  # escaped\n   ordinary remains ordinary\n   File.fnmatch('\a',   '\a', File::FNM_NOESCAPE)  #=> true  # FNM_NOESACPE\n   makes '\' ordinary\n   File.fnmatch('[\?]', '?')                       #=> true  # can escape\n   inside bracket expression\n\n   File.fnmatch('*',   '.profile')                      #=> false # wildcard\n   doesn't match leading\n   File.fnmatch('*',   '.profile', File::FNM_DOTMATCH)  #=> true  # period\n   by default.\n   File.fnmatch('.*',  '.profile')                      #=> true\n\n   rbfiles = '**' '/' '*.rb' # you don't have to do like this. just write\n   in single string.\n   File.fnmatch(rbfiles, 'main.rb')                    #=> false\n   File.fnmatch(rbfiles, './main.rb')                  #=> false\n   File.fnmatch(rbfiles, 'lib/song.rb')                #=> true\n   File.fnmatch('**.rb', 'main.rb')                    #=> true\n   File.fnmatch('**.rb', './main.rb')                  #=> false\n   File.fnmatch('**.rb', 'lib/song.rb')                #=> true\n   File.fnmatch('*',           'dave/.profile')                      #=> true\n\n   pattern = '*' '/' '*'\n   File.fnmatch(pattern, 'dave/.profile', File::FNM_PATHNAME)  #=> false\n   File.fnmatch(pattern, 'dave/.profile', File::FNM_PATHNAME |\n   File::FNM_DOTMATCH) #=> true\n\n   pattern = '**' '/' 'foo'\n   File.fnmatch(pattern, 'a/b/c/foo', File::FNM_PATHNAME)     #=> true\n   File.fnmatch(pattern, '/a/b/c/foo', File::FNM_PATHNAME)    #=> true\n   File.fnmatch(pattern, 'c:/a/b/c/foo', File::FNM_PATHNAME)  #=> true\n   File.fnmatch(pattern, 'a/.b/c/foo', File::FNM_PATHNAME)    #=> false\n   File.fnmatch(pattern, 'a/.b/c/foo', File::FNM_PATHNAME | File::FNM_DOTMATCH)\n   #=> true\n
fnmatch? File.fnmatch?(p1, p2, p3 = v3)\nReturns true if <i>path</i> matches against <i>pattern</i> The\npattern is not a regular expression; instead it follows rules\nsimilar to shell filename globbing. It may contain the following\nmetacharacters:\n\n`*`::        Matches any file. Can be restricted by\n                        other values in the glob. `*`\n                        will match all files; `c*` will\n                        match all files beginning with\n                        `c`; `*c` will match\n                        all files ending with `c`; and\n                        `\*c*` will match all files that\n                        have `c` in them (including at\n                        the beginning or end). Equivalent to\n                        `/ .* /x` in regexp.\n`**`::       Matches directories recursively or files\n                        expansively.\n`?`::        Matches any one character. Equivalent to\n                        `/.{1}/` in regexp.\n`[set]`::    Matches any one character in +set+.\n                        Behaves exactly like character sets in\n                        Regexp, including set negation\n                        (`[^a-z]`).\n`\`::        Escapes the next metacharacter.\n\n<i>flags</i> is a bitwise OR of the `FNM_xxx`\nparameters. The same glob pattern and flags are used by\n`Dir::glob`.\n\n   File.fnmatch('cat',       'cat')        #=> true  # match entire string\n   File.fnmatch('cat',       'category')   #=> false # only match partial\n   string\n   File.fnmatch('c{at,ub}s', 'cats')       #=> false # { } isn't supported\n\n   File.fnmatch('c?t',     'cat')          #=> true  # '?' match only\n   1 character\n   File.fnmatch('c??t',    'cat')          #=> false # ditto\n   File.fnmatch('c*',      'cats')         #=> true  # '*' match 0 or more\n   characters\n   File.fnmatch('c*t',     'c/a/b/t')      #=> true  # ditto\n   File.fnmatch('ca[a-z]', 'cat')          #=> true  # inclusive bracket\n   expression\n   File.fnmatch('ca[^t]',  'cat')          #=> false # exclusive bracket\n   expression ('^' or '!')\n\n   File.fnmatch('cat', 'CAT')                     #=> false # case sensitive\n   File.fnmatch('cat', 'CAT', File::FNM_CASEFOLD) #=> true  # case insensitive\n\n   File.fnmatch('?',   '/', File::FNM_PATHNAME)  #=> false # wildcard doesn't\n   match '/' on FNM_PATHNAME\n   File.fnmatch('*',   '/', File::FNM_PATHNAME)  #=> false # ditto\n   File.fnmatch('[/]', '/', File::FNM_PATHNAME)  #=> false # ditto\n\n   File.fnmatch('\?',   '?')                       #=> true  # escaped\n   wildcard becomes ordinary\n   File.fnmatch('\a',   'a')                       #=> true  # escaped\n   ordinary remains ordinary\n   File.fnmatch('\a',   '\a', File::FNM_NOESCAPE)  #=> true  # FNM_NOESACPE\n   makes '\' ordinary\n   File.fnmatch('[\?]', '?')                       #=> true  # can escape\n   inside bracket expression\n\n   File.fnmatch('*',   '.profile')                      #=> false # wildcard\n   doesn't match leading\n   File.fnmatch('*',   '.profile', File::FNM_DOTMATCH)  #=> true  # period\n   by default.\n   File.fnmatch('.*',  '.profile')                      #=> true\n\n   rbfiles = '**' '/' '*.rb' # you don't have to do like this. just write\n   in single string.\n   File.fnmatch(rbfiles, 'main.rb')                    #=> false\n   File.fnmatch(rbfiles, './main.rb')                  #=> false\n   File.fnmatch(rbfiles, 'lib/song.rb')                #=> true\n   File.fnmatch('**.rb', 'main.rb')                    #=> true\n   File.fnmatch('**.rb', './main.rb')                  #=> false\n   File.fnmatch('**.rb', 'lib/song.rb')                #=> true\n   File.fnmatch('*',           'dave/.profile')                      #=> true\n\n   pattern = '*' '/' '*'\n   File.fnmatch(pattern, 'dave/.profile', File::FNM_PATHNAME)  #=> false\n   File.fnmatch(pattern, 'dave/.profile', File::FNM_PATHNAME |\n   File::FNM_DOTMATCH) #=> true\n\n   pattern = '**' '/' 'foo'\n   File.fnmatch(pattern, 'a/b/c/foo', File::FNM_PATHNAME)     #=> true\n   File.fnmatch(pattern, '/a/b/c/foo', File::FNM_PATHNAME)    #=> true\n   File.fnmatch(pattern, 'c:/a/b/c/foo', File::FNM_PATHNAME)  #=> true\n   File.fnmatch(pattern, 'a/.b/c/foo', File::FNM_PATHNAME)    #=> false\n   File.fnmatch(pattern, 'a/.b/c/foo', File::FNM_PATHNAME | File::FNM_DOTMATCH)\n   #=> true\n
ftype File.ftype(p1)\nIdentifies the type of the named file; the return string is one of\n```file`'', ```directory`'',\n```characterSpecial`'', ```blockSpecial`'',\n```fifo`'', ```link`'',\n```socket`'', or ```unknown`''.\n\n   File.ftype("testfile")            #=> "file"\n   File.ftype("/dev/tty")            #=> "characterSpecial"\n   File.ftype("/tmp/.X11-unix/X0")   #=> "socket"\n
grpowned? File.grpowned?(p1)\nReturns `true` if the named file exists and the\neffective group id of the calling process is the owner of\nthe file. Returns `false` on Windows.\n
identical? File.identical?(p1, p2)\nReturns `true` if the named files are identical.\n\n    open("a", "w") {}\n    p File.identical?("a", "a")      #=> true\n    p File.identical?("a", "./a")    #=> true\n    File.link("a", "b")\n    p File.identical?("a", "b")      #=> true\n    File.symlink("a", "c")\n    p File.identical?("a", "c")      #=> true\n    open("d", "w") {}\n    p File.identical?("a", "d")      #=> false\n
join File.join(*args)\nReturns a new string formed by joining the strings using\n`File::SEPARATOR`.\n\n   File.join("usr", "mail", "gumby")   #=> "usr/mail/gumby"\n
lchmod File.lchmod(p1, *args)\nEquivalent to `File::chmod`, but does not follow symbolic\nlinks (so it will change the permissions associated with the link,\nnot the file referenced by the link). Often not available.\n
lchown File.lchown(p1, p2, *args)\nEquivalent to `File::chown`, but does not follow symbolic\nlinks (so it will change the owner associated with the link, not the\nfile referenced by the link). Often not available. Returns number\nof files in the argument list.\n
link File.link(p1, p2)\nCreates a new name for an existing file using a hard link. Will not\noverwrite <i>new_name</i> if it already exists (raising a subclass\nof `SystemCallError`). Not available on all platforms.\n\n   File.link("testfile", ".testfile")   #=> 0\n   IO.readlines(".testfile")[0]         #=> "This is line one\\n"\n
lstat File.lstat(p1)\nSame as `File::stat`, but does not follow the last symbolic\nlink. Instead, reports on the link itself.\n\n   File.symlink("testfile", "link2test")   #=> 0\n   File.stat("testfile").size              #=> 66\n   File.lstat("link2test").size            #=> 8\n   File.stat("link2test").size             #=> 66\n
mtime File.mtime(p1)\nReturns the modification time for the named file as a Time object.\n\n   File.mtime("testfile")   #=> Tue Apr 08 12:58:04 CDT 2003\n
new File.new(*args)\nOpens the file named by +filename+ according to +mode+ (default is "r")\nand returns a new `File` object.\n\n=== Parameters\n\nSee the description of class IO for a description of +mode+.  The file\nmode may optionally be specified as a Fixnum by +or+-ing together the\nflags (O_RDONLY etc, again described under +IO+).\n\nOptional permission bits may be given in +perm+.  These mode and\npermission bits are platform dependent; on Unix systems, see\n`open(2)` for details.\n\nOptional +opt+ parameter is same as in IO.open.\n\n=== Examples\n\n  f = File.new("testfile", "r")\n  f = File.new("newfile",  "w+")\n  f = File.new("newfile", File::CREAT|File::TRUNC|File::RDWR, 0644)\n
open File.open(*args)\nWith no associated block, `File.open` is a synonym for\nFile.new. If the optional code block is given, it will\nbe passed the opened +file+ as an argument, and the File object will\nautomatically be closed when the block terminates.  In this instance,\n`File.open` returns the value of the block.\n\nSee IO.new for a list of values for the +opt+ parameter.\n
owned? File.owned?(p1)\nReturns `true` if the named file exists and the\neffective used id of the calling process is the owner of\nthe file.\n
path File.path(p1)\nReturns the string representation of the path\n\n   File.path("/dev/null")          #=> "/dev/null"\n   File.path(Pathname.new("/tmp")) #=> "/tmp"\n
pipe? File.pipe?(p1)\nReturns `true` if the named file is a pipe.\n
readable? File.readable?(p1)\nReturns `true` if the named file is readable by the effective\nuser id of this process.\n
readable_real? File.readable_real?(p1)\nReturns `true` if the named file is readable by the real\nuser id of this process.\n
readlink File.readlink(p1)\nReturns the name of the file referenced by the given link.\nNot available on all platforms.\n\n   File.symlink("testfile", "link2test")   #=> 0\n   File.readlink("link2test")              #=> "testfile"\n
realdirpath File.realdirpath(p1, p2 = v2)\nReturns the real (absolute) pathname of _pathname_ in the actual filesystem.\nThe real pathname doesn't contain symlinks or useless dots.\n\nIf _dir_string_ is given, it is used as a base directory\nfor interpreting relative pathname instead of the current directory.\n\nThe last component of the real pathname can be nonexistent.\n
realpath File.realpath(p1, p2 = v2)\nReturns the real (absolute) pathname of _pathname_ in the actual\nfilesystem not containing symlinks or useless dots.\n\nIf _dir_string_ is given, it is used as a base directory\nfor interpreting relative pathname instead of the current directory.\n\nAll components of the pathname must exist when this method is\ncalled.\n
rename File.rename(p1, p2)\nRenames the given file to the new name. Raises a\n`SystemCallError` if the file cannot be renamed.\n\n   File.rename("afile", "afile.bak")   #=> 0\n
setgid? File.setgid?(p1)\nReturns `true` if the named file has the setgid bit set.\n
setuid? File.setuid?(p1)\nReturns `true` if the named file has the setuid bit set.\n
size File.size(p1)\nReturns the size of `file_name`.\n
size? File.size?(p1)\nReturns +nil+ if +file_name+ doesn't exist or has zero size, the size of the\nfile otherwise.\n
socket? File.socket?(p1)\nReturns `true` if the named file is a socket.\n
split File.split(p1)\nSplits the given string into a directory and a file component and\nreturns them in a two-element array. See also\n`File::dirname` and `File::basename`.\n\n   File.split("/home/gumby/.profile")   #=> ["/home/gumby", ".profile"]\n
stat File.stat(p1)\nReturns a `File::Stat` object for the named file (see\n`File::Stat`).\n\n   File.stat("testfile").mtime   #=> Tue Apr 08 12:58:04 CDT 2003\n
sticky? File.sticky?(p1)\nReturns `true` if the named file has the sticky bit set.\n
symlink File.symlink(p1, p2)\nCreates a symbolic link called <i>new_name</i> for the existing file\n<i>old_name</i>. Raises a `NotImplemented` exception on\nplatforms that do not support symbolic links.\n\n   File.symlink("testfile", "link2test")   #=> 0\n
symlink? File.symlink?(p1)\nReturns `true` if the named file is a symbolic link.\n
truncate File.truncate(p1, p2)\nTruncates the file <i>file_name</i> to be at most <i>integer</i>\nbytes long. Not available on all platforms.\n\n   f = File.new("out", "w")\n   f.write("1234567890")     #=> 10\n   f.close                   #=> nil\n   File.truncate("out", 5)   #=> 0\n   File.size("out")          #=> 5\n
umask File.umask(*args)\nReturns the current umask value for this process. If the optional\nargument is given, set the umask to that value and return the\nprevious value. Umask values are <em>subtracted</em> from the\ndefault permissions, so a umask of `0222` would make a\nfile read-only for everyone.\n\n   File.umask(0006)   #=> 18\n   File.umask         #=> 6\n
unlink File.unlink(*args)\nDeletes the named files, returning the number of names\npassed as arguments. Raises an exception on any error.\nSee also `Dir::rmdir`.\n
utime File.utime(p1, p2, *args)\nSets the access and modification times of each\nnamed file to the first two arguments. Returns\nthe number of file names in the argument list.\n
world_readable? File.world_readable?(p1)\nIf <i>file_name</i> is readable by others, returns an integer\nrepresenting the file permission bits of <i>file_name</i>. Returns\n`nil` otherwise. The meaning of the bits is platform\ndependent; on Unix systems, see `stat(2)`.\n\n   File.world_readable?("/etc/passwd")           #=> 420\n   m = File.world_readable?("/etc/passwd")\n   sprintf("%o", m)                              #=> "644"\n
world_writable? File.world_writable?(p1)\nIf <i>file_name</i> is writable by others, returns an integer\nrepresenting the file permission bits of <i>file_name</i>. Returns\n`nil` otherwise. The meaning of the bits is platform\ndependent; on Unix systems, see `stat(2)`.\n\n   File.world_writable?("/tmp")                  #=> 511\n   m = File.world_writable?("/tmp")\n   sprintf("%o", m)                              #=> "777"\n
writable? File.writable?(p1)\nReturns `true` if the named file is writable by the effective\nuser id of this process.\n
writable_real? File.writable_real?(p1)\nReturns `true` if the named file is writable by the real\nuser id of this process.\n
zero? File.zero?(p1)\nReturns `true` if the named file exists and has\na zero size.\n
atime File.atime()\nReturns the last access time (a `Time` object)\n for <i>file</i>, or epoch if <i>file</i> has not been accessed.\n\n   File.new("testfile").atime   #=> Wed Dec 31 18:00:00 CST 1969\n
chmod File.chmod(p1)\nChanges permission bits on <i>file</i> to the bit pattern\nrepresented by <i>mode_int</i>. Actual effects are platform\ndependent; on Unix systems, see `chmod(2)` for details.\nFollows symbolic links. Also see `File#lchmod`.\n\n   f = File.new("out", "w");\n   f.chmod(0644)   #=> 0\n
chown File.chown(p1, p2)\nChanges the owner and group of <i>file</i> to the given numeric\nowner and group id's. Only a process with superuser privileges may\nchange the owner of a file. The current owner of a file may change\nthe file's group to any group to which the owner belongs. A\n`nil` or -1 owner or group id is ignored. Follows\nsymbolic links. See also `File#lchown`.\n\n   File.new("testfile").chown(502, 1000)\n
ctime File.ctime()\nReturns the change time for <i>file</i> (that is, the time directory\ninformation about the file was changed, not the file itself).\n\nNote that on Windows (NTFS), returns creation time (birth time).\n\n   File.new("testfile").ctime   #=> Wed Apr 09 08:53:14 CDT 2003\n
flock File.flock(p1)\nLocks or unlocks a file according to <i>locking_constant</i> (a\nlogical <em>or</em> of the values in the table below).\nReturns `false` if `File::LOCK_NB` is\nspecified and the operation would otherwise have blocked. Not\navailable on all platforms.\n\nLocking constants (in class File):\n\n   LOCK_EX   | Exclusive lock. Only one process may hold an\n             | exclusive lock for a given file at a time.\n   ----------+------------------------------------------------\n   LOCK_NB   | Don't block when locking. May be combined\n             | with other lock options using logical or.\n   ----------+------------------------------------------------\n   LOCK_SH   | Shared lock. Multiple processes may each hold a\n             | shared lock for a given file at the same time.\n   ----------+------------------------------------------------\n   LOCK_UN   | Unlock.\n\nExample:\n update a counter using write lock\n don't use "w" because it truncates the file before lock.\n   File.open("counter", File::RDWR|File::CREAT, 0644) {|f|\n     f.flock(File::LOCK_EX)\n     value = f.read.to_i + 1\n     f.rewind\n     f.write("#{value}\\n")\n     f.flush\n     f.truncate(f.pos)\n   }\n read the counter using read lock\n   File.open("counter", "r") {|f|\n     f.flock(File::LOCK_SH)\n     p f.read\n   }\n
lstat File.lstat()\nSame as `IO#stat`, but does not follow the last symbolic\nlink. Instead, reports on the link itself.\n\n   File.symlink("testfile", "link2test")   #=> 0\n   File.stat("testfile").size              #=> 66\n   f = File.new("link2test")\n   f.lstat.size                            #=> 8\n   f.stat.size                             #=> 66\n
mtime File.mtime()\nReturns the modification time for <i>file</i>.\n\n   File.new("testfile").mtime   #=> Wed Apr 09 08:53:14 CDT 2003\n
path File.path()\nReturns the pathname used to create <i>file</i> as a string. Does\nnot normalize the name.\n\n   File.new("testfile").path               #=> "testfile"\n   File.new("/tmp/../tmp/xxx", "w").path   #=> "/tmp/../tmp/xxx"\n
size File.size()\nReturns the size of <i>file</i> in bytes.\n\n   File.new("testfile").size   #=> 66\n
to_path File.to_path()\nReturns the pathname used to create <i>file</i> as a string. Does\nnot normalize the name.\n\n   File.new("testfile").path               #=> "testfile"\n   File.new("/tmp/../tmp/xxx", "w").path   #=> "/tmp/../tmp/xxx"\n
truncate File.truncate(p1)\nTruncates <i>file</i> to at most <i>integer</i> bytes. The file\nmust be opened for writing. Not available on all platforms.\n\n   f = File.new("out", "w")\n   f.syswrite("1234567890")   #=> 10\n   f.truncate(5)              #=> 0\n   f.close()                  #=> nil\n   File.size("out")           #=> 5\n
new File::Stat.new(p1)\nCreate a File::Stat object for the given file name (raising an\nexception if the file doesn't exist).\n
atime File::Stat.atime()\nReturns the last access time for this file as an object of class\n`Time`.\n\n   File.stat("testfile").atime   #=> Wed Dec 31 18:00:00 CST 1969\n
blksize File::Stat.blksize()\nReturns the native file system's block size. Will return `nil`\non platforms that don't support this information.\n\n   File.stat("testfile").blksize   #=> 4096\n
blockdev? File::Stat.blockdev?()\nReturns `true` if the file is a block device,\n`false` if it isn't or if the operating system doesn't\nsupport this feature.\n\n   File.stat("testfile").blockdev?    #=> false\n   File.stat("/dev/hda1").blockdev?   #=> true\n
blocks File::Stat.blocks()\nReturns the number of native file system blocks allocated for this\nfile, or `nil` if the operating system doesn't\nsupport this feature.\n\n   File.stat("testfile").blocks   #=> 2\n
chardev? File::Stat.chardev?()\nReturns `true` if the file is a character device,\n`false` if it isn't or if the operating system doesn't\nsupport this feature.\n\n   File.stat("/dev/tty").chardev?   #=> true\n
ctime File::Stat.ctime()\nReturns the change time for <i>stat</i> (that is, the time\ndirectory information about the file was changed, not the file\nitself).\n\nNote that on Windows (NTFS), returns creation time (birth time).\n\n   File.stat("testfile").ctime   #=> Wed Apr 09 08:53:14 CDT 2003\n
dev File::Stat.dev()\nReturns an integer representing the device on which <i>stat</i>\nresides.\n\n   File.stat("testfile").dev   #=> 774\n
dev_major File::Stat.dev_major()\nReturns the major part of `File_Stat#dev` or\n`nil`.\n\n   File.stat("/dev/fd1").dev_major   #=> 2\n   File.stat("/dev/tty").dev_major   #=> 5\n
dev_minor File::Stat.dev_minor()\nReturns the minor part of `File_Stat#dev` or\n`nil`.\n\n   File.stat("/dev/fd1").dev_minor   #=> 1\n   File.stat("/dev/tty").dev_minor   #=> 0\n
directory? File::Stat.directory?()\nReturns `true` if the named file is a directory,\nor a symlink that points at a directory, and `false`\notherwise.\n\n   File.directory?(".")\n
executable? File::Stat.executable?()\nReturns `true` if <i>stat</i> is executable or if the\noperating system doesn't distinguish executable files from\nnonexecutable files. The tests are made using the effective owner of\nthe process.\n\n   File.stat("testfile").executable?   #=> false\n
executable_real? File::Stat.executable_real?()\nSame as `executable?`, but tests using the real owner of\nthe process.\n
file? File::Stat.file?()\nReturns `true` if <i>stat</i> is a regular file (not\na device file, pipe, socket, etc.).\n\n   File.stat("testfile").file?   #=> true\n
ftype File::Stat.ftype()\nIdentifies the type of <i>stat</i>. The return string is one of:\n```file`'', ```directory`'',\n```characterSpecial`'', ```blockSpecial`'',\n```fifo`'', ```link`'',\n```socket`'', or ```unknown`''.\n\n   File.stat("/dev/tty").ftype   #=> "characterSpecial"\n
gid File::Stat.gid()\nReturns the numeric group id of the owner of <i>stat</i>.\n\n   File.stat("testfile").gid   #=> 500\n
grpowned? File::Stat.grpowned?()\nReturns true if the effective group id of the process is the same as\nthe group id of <i>stat</i>. On Windows NT, returns `false`.\n\n   File.stat("testfile").grpowned?      #=> true\n   File.stat("/etc/passwd").grpowned?   #=> false\n
ino File::Stat.ino()\nReturns the inode number for <i>stat</i>.\n\n   File.stat("testfile").ino   #=> 1083669\n
inspect File::Stat.inspect()\nProduce a nicely formatted description of <i>stat</i>.\n\n  File.stat("/etc/passwd").inspect\n=> "#<File::Stat dev=0xe000005, ino=1078078, mode=0100644,\n    nlink=1, uid=0, gid=0, rdev=0x0, size=1374, blksize=4096,\n    blocks=8, atime=Wed Dec 10 10:16:12 CST 2003,\n    mtime=Fri Sep 12 15:41:41 CDT 2003,\n    ctime=Mon Oct 27 11:20:27 CST 2003>"\n
mode File::Stat.mode()\nReturns an integer representing the permission bits of\n<i>stat</i>. The meaning of the bits is platform dependent; on\nUnix systems, see `stat(2)`.\n\n   File.chmod(0644, "testfile")   #=> 1\n   s = File.stat("testfile")\n   sprintf("%o", s.mode)          #=> "100644"\n
mtime File::Stat.mtime()\nReturns the modification time of <i>stat</i>.\n\n   File.stat("testfile").mtime   #=> Wed Apr 09 08:53:14 CDT 2003\n
nlink File::Stat.nlink()\nReturns the number of hard links to <i>stat</i>.\n\n   File.stat("testfile").nlink             #=> 1\n   File.link("testfile", "testfile.bak")   #=> 0\n   File.stat("testfile").nlink             #=> 2\n
owned? File::Stat.owned?()\nReturns `true` if the effective user id of the process is\nthe same as the owner of <i>stat</i>.\n\n   File.stat("testfile").owned?      #=> true\n   File.stat("/etc/passwd").owned?   #=> false\n
pipe? File::Stat.pipe?()\nReturns `true` if the operating system supports pipes and\n<i>stat</i> is a pipe; `false` otherwise.\n
pretty_print File::Stat.pretty_print(q)\n\n
rdev File::Stat.rdev()\nReturns an integer representing the device type on which\n<i>stat</i> resides. Returns `nil` if the operating\nsystem doesn't support this feature.\n\n   File.stat("/dev/fd1").rdev   #=> 513\n   File.stat("/dev/tty").rdev   #=> 1280\n
rdev_major File::Stat.rdev_major()\nReturns the major part of `File_Stat#rdev` or\n`nil`.\n\n   File.stat("/dev/fd1").rdev_major   #=> 2\n   File.stat("/dev/tty").rdev_major   #=> 5\n
rdev_minor File::Stat.rdev_minor()\nReturns the minor part of `File_Stat#rdev` or\n`nil`.\n\n   File.stat("/dev/fd1").rdev_minor   #=> 1\n   File.stat("/dev/tty").rdev_minor   #=> 0\n
readable? File::Stat.readable?()\nReturns `true` if <i>stat</i> is readable by the\neffective user id of this process.\n\n   File.stat("testfile").readable?   #=> true\n
readable_real? File::Stat.readable_real?()\nReturns `true` if <i>stat</i> is readable by the real\nuser id of this process.\n\n   File.stat("testfile").readable_real?   #=> true\n
setgid? File::Stat.setgid?()\nReturns `true` if <i>stat</i> has the set-group-id\npermission bit set, `false` if it doesn't or if the\noperating system doesn't support this feature.\n\n   File.stat("/usr/sbin/lpc").setgid?   #=> true\n
setuid? File::Stat.setuid?()\nReturns `true` if <i>stat</i> has the set-user-id\npermission bit set, `false` if it doesn't or if the\noperating system doesn't support this feature.\n\n   File.stat("/bin/su").setuid?   #=> true\n
size File::Stat.size()\nReturns the size of <i>stat</i> in bytes.\n\n   File.stat("testfile").size   #=> 66\n
size? File::Stat.size?()\nReturns the size of <i>stat</i> in bytes.\n\n   File.stat("testfile").size   #=> 66\n
socket? File::Stat.socket?()\nReturns `true` if <i>stat</i> is a socket,\n`false` if it isn't or if the operating system doesn't\nsupport this feature.\n\n   File.stat("testfile").socket?   #=> false\n
sticky? File::Stat.sticky?()\nReturns `true` if <i>stat</i> has its sticky bit set,\n`false` if it doesn't or if the operating system doesn't\nsupport this feature.\n\n   File.stat("testfile").sticky?   #=> false\n
symlink? File::Stat.symlink?()\nReturns `true` if <i>stat</i> is a symbolic link,\n`false` if it isn't or if the operating system doesn't\nsupport this feature. As `File::stat` automatically\nfollows symbolic links, `symlink?` will always be\n`false` for an object returned by\n`File::stat`.\n\n   File.symlink("testfile", "alink")   #=> 0\n   File.stat("alink").symlink?         #=> false\n   File.lstat("alink").symlink?        #=> true\n
uid File::Stat.uid()\nReturns the numeric user id of the owner of <i>stat</i>.\n\n   File.stat("testfile").uid   #=> 501\n
world_readable? File::Stat.world_readable?()\nIf <i>stat</i> is readable by others, returns an integer\nrepresenting the file permission bits of <i>stat</i>. Returns\n`nil` otherwise. The meaning of the bits is platform\ndependent; on Unix systems, see `stat(2)`.\n\n   m = File.stat("/etc/passwd").world_readable?  #=> 420\n   sprintf("%o", m)                              #=> "644"\n
world_writable? File::Stat.world_writable?()\nIf <i>stat</i> is writable by others, returns an integer\nrepresenting the file permission bits of <i>stat</i>. Returns\n`nil` otherwise. The meaning of the bits is platform\ndependent; on Unix systems, see `stat(2)`.\n\n   m = File.stat("/tmp").world_writable?         #=> 511\n   sprintf("%o", m)                              #=> "777"\n
writable? File::Stat.writable?()\nReturns `true` if <i>stat</i> is writable by the\neffective user id of this process.\n\n   File.stat("testfile").writable?   #=> true\n
writable_real? File::Stat.writable_real?()\nReturns `true` if <i>stat</i> is writable by the real\nuser id of this process.\n\n   File.stat("testfile").writable_real?   #=> true\n
zero? File::Stat.zero?()\nReturns `true` if <i>stat</i> is a zero-length file;\n`false` otherwise.\n\n   File.stat("testfile").zero?   #=> false\n
binread IO.binread(p1, p2 = v2, p3 = v3)\nOpens the file, optionally seeks to the given <i>offset</i>, then returns\n<i>length</i> bytes (defaulting to the rest of the file).\n`binread` ensures the file is closed before returning.\nThe open mode would be "rb:ASCII-8BIT".\n\n   IO.binread("testfile")           #=> "This is line one\\nThis is line\n   two\\nThis is line three\\nAnd so on...\\n"\n   IO.binread("testfile", 20)       #=> "This is line one\\nThi"\n   IO.binread("testfile", 20, 10)   #=> "ne one\\nThis is line "\n
binwrite IO.binwrite(*args)\nOpens the file, optionally seeks to the given <i>offset</i>, writes\n<i>string</i> then returns the length written.\n`binwrite` ensures the file is closed before returning.\nThe open mode would be "wb:ASCII-8BIT".\nIf <i>offset</i> is not given, the file is truncated.  Otherwise,\nit is not truncated.\n\n   IO.binwrite("testfile", "0123456789", 20) # => 10\n File could contain:  "This is line one\\nThi0123456789two\\nThis is line\n three\\nAnd so on...\\n"\n   IO.binwrite("testfile", "0123456789")      #=> 10\n File would now read: "0123456789"\n
console IO.console()\nReturns an File instance opened console.\n\nYou must require 'io/console' to use this method.\n
copy_stream IO.copy_stream(p1, p2, p3 = v3, p4 = v4)\nIO.copy_stream copies <i>src</i> to <i>dst</i>.\n<i>src</i> and <i>dst</i> is either a filename or an IO.\n\nThis method returns the number of bytes copied.\n\nIf optional arguments are not given,\nthe start position of the copy is\nthe beginning of the filename or\nthe current file offset of the IO.\nThe end position of the copy is the end of file.\n\nIf <i>copy_length</i> is given,\nNo more than <i>copy_length</i> bytes are copied.\n\nIf <i>src_offset</i> is given,\nit specifies the start position of the copy.\n\nWhen <i>src_offset</i> is specified and\n<i>src</i> is an IO,\nIO.copy_stream doesn't move the current file offset.\n
for_fd IO.for_fd(*args)\nSynonym for `IO.new`.\n
foreach IO.foreach(p1, p2 = v2, p3 = v3, p4 = v4, p5 = {})\nExecutes the block for every line in the named I/O port, where lines\nare separated by <em>sep</em>.\n\nIf no block is given, an enumerator is returned instead.\n\n   IO.foreach("testfile") {|x| print "GOT ", x }\n\n<em>produces:</em>\n\n   GOT This is line one\n   GOT This is line two\n   GOT This is line three\n   GOT And so on...\n\nIf the last argument is a hash, it's the keyword argument to open.\nSee `IO.read` for detail.\n
new IO.new(p1, p2 = v2, p3 = {})\nReturns a new IO object (a stream) for the given IO object or integer file\ndescriptor and mode string.  See also IO.sysopen and IO.for_fd.\n\n=== Parameters\n\nfd:: numeric file descriptor or IO object\nmode:: file mode. a string or an integer\nopt:: hash for specifying +mode+ by name.\n\n==== Mode\n\nWhen mode is an integer it must be combination of the modes defined in\nFile::Constants.\n\nWhen mode is a string it must be in one of the following forms:\n- "fmode",\n- "fmode:extern",\n- "fmode:extern:intern".\n`extern` is the external encoding name for the IO.\n`intern` is the internal encoding.\n`fmode` must be a file open mode string. See the description of\nclass IO for mode string directives.\n\nWhen the mode of original IO is read only, the mode cannot be changed to\nbe writable.  Similarly, the mode cannot be changed from write only to\nreadable.\n\nWhen such a change is attempted the error is raised in different locations\naccording to the platform.\n\n==== Options\n+opt+ can have the following keys\n:mode ::\n  Same as +mode+ parameter\n:external_encoding ::\n  External encoding for the IO.  "-" is a synonym for the default external\n  encoding.\n:internal_encoding ::\n  Internal encoding for the IO.  "-" is a synonym for the default internal\n  encoding.\n\n  If the value is nil no conversion occurs.\n:encoding ::\n  Specifies external and internal encodings as "extern:intern".\n:textmode ::\n  If the value is truth value, same as "t" in argument +mode+.\n:binmode ::\n  If the value is truth value, same as "b" in argument +mode+.\n:autoclose ::\n  If the value is +false+, the +fd+ will be kept open after this IO\n  instance gets finalized.\n\nAlso +opt+ can have same keys in String#encode for controlling conversion\nbetween the external encoding and the internal encoding.\n\n=== Example 1\n\n  fd = IO.sysopen("/dev/tty", "w")\n  a = IO.new(fd,"w")\n  $stderr.puts "Hello"\n  a.puts "World"\n\n<em>produces:</em>\n\n  Hello\n  World\n\n=== Example 2\n\n  require 'fcntl'\n\n  fd = STDERR.fcntl(Fcntl::F_DUPFD)\n  io = IO.new(fd, mode: 'w:UTF-16LE', cr_newline: true)\n  io.puts "Hello, World!"\n\n  fd = STDERR.fcntl(Fcntl::F_DUPFD)\n  io = IO.new(fd, mode: 'w', cr_newline: true,\n              external_encoding: Encoding::UTF_16LE)\n  io.puts "Hello, World!"\n\nBoth of above print "Hello, World!" in UTF-16LE to standard error output\nwith converting EOL generated by `puts` to CR.\n
open IO.open(*args)\nWith no associated block, `IO.open` is a synonym for IO.new. If\nthe optional code block is given, it will be passed +io+ as an\nargument, and the IO object will automatically be closed when the block\nterminates. In this instance, IO.open returns the value of the block.\n\nSee IO.new for a description of values for the +opt+ parameter.\n
pipe IO.pipe(p1 = v1, p2 = v2, p3 = {})\nCreates a pair of pipe endpoints (connected to each other) and\nreturns them as a two-element array of `IO` objects:\n`[` <i>read_io</i>, <i>write_io</i> `]`.\n\nIf a block is given, the block is called and\nreturns the value of the block.\n<i>read_io</i> and <i>write_io</i> are sent to the block as arguments.\nIf read_io and write_io are not closed when the block exits, they are closed.\ni.e. closing read_io and/or write_io doesn't cause an error.\n\nNot available on all platforms.\n\nIf an encoding (encoding name or encoding object) is specified as an optional\nargument,\nread string from pipe is tagged with the encoding specified.\nIf the argument is a colon separated two encoding names "A:B",\nthe read string is converted from encoding A (external encoding)\nto encoding B (internal encoding), then tagged with B.\nIf two optional arguments are specified, those must be\nencoding objects or encoding names,\nand the first one is the external encoding,\nand the second one is the internal encoding.\nIf the external encoding and the internal encoding is specified,\noptional hash argument specify the conversion option.\n\nIn the example below, the two processes close the ends of the pipe\nthat they are not using. This is not just a cosmetic nicety. The\nread end of a pipe will not generate an end of file condition if\nthere are any writers with the pipe still open. In the case of the\nparent process, the `rd.read` will never return if it\ndoes not first issue a `wr.close`.\n\n   rd, wr = IO.pipe\n\n   if fork\n     wr.close\n     puts "Parent got: <#{rd.read}>"\n     rd.close\n     Process.wait\n   else\n     rd.close\n     puts "Sending message to parent"\n     wr.write "Hi Dad"\n     wr.close\n   end\n\n<em>produces:</em>\n\n   Sending message to parent\n   Parent got: <Hi Dad>\n
popen IO.popen(p1, p2 = v2, p3 = {})\nRuns the specified command as a subprocess; the subprocess's\nstandard input and output will be connected to the returned\n`IO` object.\n\nThe PID of the started process can be obtained by IO#pid method.\n\n_cmd_ is a string or an array as follows.\n\n  cmd:\n    "-"                                      : fork\n    commandline                              : command line string which is\n    passed to a shell\n    [env, cmdname, arg1, ..., opts]          : command name and zero or more\n    arguments (no shell)\n    [env, [cmdname, argv0], arg1, ..., opts] : command name, argv[0] and\n    zero or more arguments (no shell)\n  (env and opts are optional.)\n\nIf _cmd_ is a +String+ ```-`'',\nthen a new instance of Ruby is started as the subprocess.\n\nIf <i>cmd</i> is an +Array+ of +String+,\nthen it will be used as the subprocess's +argv+ bypassing a shell.\nThe array can contains a hash at first for environments and\na hash at last for options similar to `spawn`.\n\nThe default mode for the new file object is ``r'',\nbut <i>mode</i> may be set to any of the modes listed in the description\nfor class IO.\nThe last argument <i>opt</i> qualifies <i>mode</i>.\n set IO encoding\n  IO.popen("nkf -e filename", :external_encoding=>"EUC-JP") {|nkf_io|\n    euc_jp_string = nkf_io.read\n  }\n merge standard output and standard error using\n spawn option.  See the document of Kernel.spawn.\n  IO.popen(["ls", "/", :err=>[:child, :out]]) {|ls_io|\n    ls_result_with_error = ls_io.read\n  }\n\nRaises exceptions which `IO.pipe` and\n`Kernel.spawn` raise.\n\nIf a block is given, Ruby will run the command as a child connected\nto Ruby with a pipe. Ruby's end of the pipe will be passed as a\nparameter to the block.\nAt the end of block, Ruby close the pipe and sets `$?`.\nIn this case `IO.popen` returns\nthe value of the block.\n\nIf a block is given with a _cmd_ of ```-`'',\nthe block will be run in two separate processes: once in the parent,\nand once in a child. The parent process will be passed the pipe\nobject as a parameter to the block, the child version of the block\nwill be passed `nil`, and the child's standard in and\nstandard out will be connected to the parent through the pipe. Not\navailable on all platforms.\n\n   f = IO.popen("uname")\n   p f.readlines\n   f.close\n   puts "Parent is #{Process.pid}"\n   IO.popen("date") { |f| puts f.gets }\n   IO.popen("-") {|f| $stderr.puts "#{Process.pid} is here, f is #{f.inspect}"}\n   p $?\n   IO.popen(%w"sed -e s|^|<foo>| -e s&$&;zot;&", "r+") {|f|\n     f.puts "bar"; f.close_write; puts f.gets\n   }\n\n<em>produces:</em>\n\n   ["Linux\\n"]\n   Parent is 21346\n   Thu Jan 15 22:41:19 JST 2009\n   21346 is here, f is #<IO:fd 3>\n   21352 is here, f is nil\n<Process::Status: pid 21352 exit 0>\n   <foo>bar;zot;\n
read IO.read(p1, p2 = v2, p3 = v3, p4 = v4, p5 = {})\nOpens the file, optionally seeks to the given <i>offset</i>, then returns\n<i>length</i> bytes (defaulting to the rest of the file).\n`read` ensures the file is closed before returning.\n\nIf the last argument is a hash, it specifies option for internal\nopen().  The key would be the following.  open_args: is exclusive\nto others.\n\n encoding: string or encoding\n\n  specifies encoding of the read string.  encoding will be ignored\n  if length is specified.\n\n mode: string\n\n  specifies mode argument for open().  it should start with "r"\n  otherwise it would cause error.\n\n open_args: array of strings\n\n  specifies arguments for open() as an array.\n\n   IO.read("testfile")           #=> "This is line one\\nThis is line\n   two\\nThis is line three\\nAnd so on...\\n"\n   IO.read("testfile", 20)       #=> "This is line one\\nThi"\n   IO.read("testfile", 20, 10)   #=> "ne one\\nThis is line "\n
readlines IO.readlines(p1, p2 = v2, p3 = v3, p4 = v4, p5 = {})\nReads the entire file specified by <i>name</i> as individual\nlines, and returns those lines in an array. Lines are separated by\n<i>sep</i>.\n\n   a = IO.readlines("testfile")\n   a[0]   #=> "This is line one\\n"\n\nIf the last argument is a hash, it's the keyword argument to open.\nSee `IO.read` for detail.\n
select IO.select(p1, p2 = v2, p3 = v3, p4 = v4)\nCalls select(2) system call.\nIt monitors given arrays of `IO` objects, waits one or more\nof `IO` objects ready for reading, are ready for writing,\nand have pending exceptions respectably, and returns an array that\ncontains arrays of those IO objects.  It will return `nil`\nif optional <i>timeout</i> value is given and no `IO` object\nis ready in <i>timeout</i> seconds.\n\n=== Parameters\nread_array:: an array of `IO` objects that wait until ready for read\nwrite_array:: an array of `IO` objects that wait until ready for write\nerror_array:: an array of `IO` objects that wait for exceptions\ntimeout:: a numeric value in second\n\n=== Example\n\n    rp, wp = IO.pipe\n    mesg = "ping "\n    100.times {\n      rs, ws, = IO.select([rp], [wp])\n      if r = rs[0]\n        ret = r.read(5)\n        print ret\n        case ret\n        when /ping/\n          mesg = "pong\\n"\n        when /pong/\n          mesg = "ping "\n        end\n      end\n      if w = ws[0]\n        w.write(mesg)\n      end\n    }\n\n<em>produces:</em>\n\n    ping pong\n    ping pong\n    ping pong\n    (snipped)\n    ping\n
sysopen IO.sysopen(p1, p2 = v2, p3 = v3)\nOpens the given path, returning the underlying file descriptor as a\n`Fixnum`.\n\n   IO.sysopen("testfile")   #=> 3\n
try_convert IO.try_convert(p1)\nTry to convert <i>obj</i> into an IO, using to_io method.\nReturns converted IO or nil if <i>obj</i> cannot be converted\nfor any reason.\n\n   IO.try_convert(STDOUT)     #=> STDOUT\n   IO.try_convert("STDOUT")   #=> nil\n\n   require 'zlib'\n   f = open("/tmp/zz.gz")       #=> #<File:/tmp/zz.gz>\n   z = Zlib::GzipReader.open(f) #=> #<Zlib::GzipReader:0x81d8744>\n   IO.try_convert(z)            #=> #<File:/tmp/zz.gz>\n
write IO.write(*args)\nOpens the file, optionally seeks to the given <i>offset</i>, writes\n<i>string</i>, then returns the length written.\n`write` ensures the file is closed before returning.\nIf <i>offset</i> is not given, the file is truncated.  Otherwise,\nit is not truncated.\n\nIf the last argument is a hash, it specifies option for internal\nopen().  The key would be the following.  open_args: is exclusive\nto others.\n\n encoding: string or encoding\n\n  specifies encoding of the read string.  encoding will be ignored\n  if length is specified.\n\n mode: string\n\n  specifies mode argument for open().  it should start with "w" or "a" or "r+"\n  otherwise it would cause error.\n\n perm: fixnum\n\n  specifies perm argument for open().\n\n open_args: array\n\n  specifies arguments for open() as an array.\n\n   IO.write("testfile", "0123456789", 20) # => 10\n File could contain:  "This is line one\\nThi0123456789two\\nThis is line\n three\\nAnd so on...\\n"\n   IO.write("testfile", "0123456789")      #=> 10\n File would now read: "0123456789"\n
advise IO.advise(p1, p2 = v2, p3 = v3)\n Announce an intention to access data from the current file in a\n specific pattern. On platforms that do not support the\n <em>posix_fadvise(2)</em> system call, this method is a no-op.\n\n_advice_ is one of the following symbols:\n\n * :normal - No advice to give; the default assumption for an open file.\n * :sequential - The data will be accessed sequentially:\n    with lower offsets read before higher ones.\n * :random - The data will be accessed in random order.\n * :willneed - The data will be accessed in the near future.\n * :dontneed - The data will not be accessed in the near future.\n * :noreuse - The data will only be accessed once.\n\nThe semantics of a piece of advice are platform-dependent. See\n<em>man 2 posix_fadvise</em> for details.\n\n "data" means the region of the current file that begins at\n _offset_ and extends for _len_ bytes. If _len_ is 0, the region\n ends at the last byte of the file. By default, both _offset_ and\n _len_ are 0, meaning that the advice applies to the entire file.\n\n If an error occurs, one of the following exceptions will be raised:\n\n * `IOError` - The `IO` stream is closed.\n * `Errno::EBADF` - The file descriptor of the current file is\n   invalid.\n * `Errno::EINVAL` - An invalid value for _advice_ was given.\n * `Errno::ESPIPE` - The file descriptor of the current\n * file refers to a FIFO or pipe. (Linux raises `Errno::EINVAL`\n * in this case).\n * `TypeError` - Either _advice_ was not a Symbol, or one of the\n   other arguments was not an `Integer`.\n * `RangeError` - One of the arguments given was too big/small.\n\nThis list is not exhaustive; other Errno:: exceptions are also possible.\n
autoclose= IO.autoclose=(p1)\nSets auto-close flag.\n\n   f = open("/dev/null")\n   IO.for_fd(f.fileno)\n ...\n   f.gets # may cause IOError\n\n   f = open("/dev/null")\n   IO.for_fd(f.fileno).autoclose = true\n ...\n   f.gets # won't cause IOError\n
autoclose? IO.autoclose?()\nReturns +true+ if the underlying file descriptor of _ios_ will be\nclosed automatically at its finalization, otherwise +false+.\n
binmode IO.binmode()\nPuts <em>ios</em> into binary mode.\nOnce a stream is in binary mode, it cannot be reset to nonbinary mode.\n\n- newline conversion disabled\n- encoding conversion disabled\n- content is treated as ASCII-8BIT\n
binmode? IO.binmode?()\nReturns `true` if <em>ios</em> is binmode.\n
bytes IO.bytes()\nCalls the given block once for each byte (0..255) in <em>ios</em>,\npassing the byte as an argument. The stream must be opened for\nreading or an `IOError` will be raised.\n\nIf no block is given, an enumerator is returned instead.\n\n   f = File.new("testfile")\n   checksum = 0\n   f.each_byte {|x| checksum ^= x }   #=> #<File:testfile>\n   checksum                           #=> 12\n
chars IO.chars()\nCalls the given block once for each character in <em>ios</em>,\npassing the character as an argument. The stream must be opened for\nreading or an `IOError` will be raised.\n\nIf no block is given, an enumerator is returned instead.\n\n   f = File.new("testfile")\n   f.each_char {|c| print c, ' ' }   #=> #<File:testfile>\n
close IO.close()\nCloses <em>ios</em> and flushes any pending writes to the operating\nsystem. The stream is unavailable for any further data operations;\nan `IOError` is raised if such an attempt is made. I/O\nstreams are automatically closed when they are claimed by the\ngarbage collector.\n\nIf <em>ios</em> is opened by `IO.popen`,\n`close` sets `$?`.\n
close_on_exec= IO.close_on_exec=(p1)\nSets a close-on-exec flag.\n\n   f = open("/dev/null")\n   f.close_on_exec = true\n   system("cat", "/proc/self/fd/#{f.fileno}") # cat: /proc/self/fd/3: No\n   such file or directory\n   f.closed?                #=> false\n
close_on_exec? IO.close_on_exec?()\nReturns `true` if <em>ios</em> will be closed on exec.\n\n   f = open("/dev/null")\n   f.close_on_exec?                 #=> false\n   f.close_on_exec = true\n   f.close_on_exec?                 #=> true\n   f.close_on_exec = false\n   f.close_on_exec?                 #=> false\n
close_read IO.close_read()\nCloses the read end of a duplex I/O stream (i.e., one that contains\nboth a read and a write stream, such as a pipe). Will raise an\n`IOError` if the stream is not duplexed.\n\n   f = IO.popen("/bin/sh","r+")\n   f.close_read\n   f.readlines\n\n<em>produces:</em>\n\n   prog.rb:3:in `readlines': not opened for reading (IOError)\n    from prog.rb:3\n
close_write IO.close_write()\nCloses the write end of a duplex I/O stream (i.e., one that contains\nboth a read and a write stream, such as a pipe). Will raise an\n`IOError` if the stream is not duplexed.\n\n   f = IO.popen("/bin/sh","r+")\n   f.close_write\n   f.print "nowhere"\n\n<em>produces:</em>\n\n   prog.rb:3:in `write': not opened for writing (IOError)\n    from prog.rb:3:in `print'\n    from prog.rb:3\n
closed? IO.closed?()\nReturns `true` if <em>ios</em> is completely closed (for\nduplex streams, both reader and writer), `false`\notherwise.\n\n   f = File.new("testfile")\n   f.close         #=> nil\n   f.closed?       #=> true\n   f = IO.popen("/bin/sh","r+")\n   f.close_write   #=> nil\n   f.closed?       #=> false\n   f.close_read    #=> nil\n   f.closed?       #=> true\n
codepoints IO.codepoints()\nPasses the `Integer` ordinal of each character in <i>ios</i>,\npassing the codepoint as an argument. The stream must be opened for\nreading or an `IOError` will be raised.\n\nIf no block is given, an enumerator is returned instead.\n
cooked IO.cooked()\nYields +self+ within cooked mode.\n\n  STDIN.cooked(&:gets)\n\nwill read and return a line with echo back and line editing.\n\nYou must require 'io/console' to use this method.\n
cooked! IO.cooked!()\nEnables cooked mode.\n\nIf the terminal mode needs to be back, use io.cooked { ... }.\n\nYou must require 'io/console' to use this method.\n
each IO.each(*args)\nExecutes the block for every line in <em>ios</em>, where lines are\nseparated by <i>sep</i>. <em>ios</em> must be opened for\nreading or an `IOError` will be raised.\n\nIf no block is given, an enumerator is returned instead.\n\n   f = File.new("testfile")\n   f.each {|line| puts "#{f.lineno}: #{line}" }\n\n<em>produces:</em>\n\n   1: This is line one\n   2: This is line two\n   3: This is line three\n   4: And so on...\n
each_byte IO.each_byte()\nCalls the given block once for each byte (0..255) in <em>ios</em>,\npassing the byte as an argument. The stream must be opened for\nreading or an `IOError` will be raised.\n\nIf no block is given, an enumerator is returned instead.\n\n   f = File.new("testfile")\n   checksum = 0\n   f.each_byte {|x| checksum ^= x }   #=> #<File:testfile>\n   checksum                           #=> 12\n
each_char IO.each_char()\nCalls the given block once for each character in <em>ios</em>,\npassing the character as an argument. The stream must be opened for\nreading or an `IOError` will be raised.\n\nIf no block is given, an enumerator is returned instead.\n\n   f = File.new("testfile")\n   f.each_char {|c| print c, ' ' }   #=> #<File:testfile>\n
each_codepoint IO.each_codepoint()\nPasses the `Integer` ordinal of each character in <i>ios</i>,\npassing the codepoint as an argument. The stream must be opened for\nreading or an `IOError` will be raised.\n\nIf no block is given, an enumerator is returned instead.\n
each_line IO.each_line(*args)\nExecutes the block for every line in <em>ios</em>, where lines are\nseparated by <i>sep</i>. <em>ios</em> must be opened for\nreading or an `IOError` will be raised.\n\nIf no block is given, an enumerator is returned instead.\n\n   f = File.new("testfile")\n   f.each {|line| puts "#{f.lineno}: #{line}" }\n\n<em>produces:</em>\n\n   1: This is line one\n   2: This is line two\n   3: This is line three\n   4: And so on...\n
echo= IO.echo=(p1)\nEnables/disables echo back.\nOn some platforms, all combinations of this flags and raw/cooked\nmode may not be valid.\n\nYou must require 'io/console' to use this method.\n
echo? IO.echo?()\nReturns +true+ if echo back is enabled.\n\nYou must require 'io/console' to use this method.\n
eof IO.eof()\nReturns true if <em>ios</em> is at end of file that means\nthere are no more data to read.\nThe stream must be opened for reading or an `IOError` will be\nraised.\n\n   f = File.new("testfile")\n   dummy = f.readlines\n   f.eof   #=> true\n\nIf <em>ios</em> is a stream such as pipe or socket, `IO#eof?`\nblocks until the other end sends some data or closes it.\n\n   r, w = IO.pipe\n   Thread.new { sleep 1; w.close }\n   r.eof?  #=> true after 1 second blocking\n\n   r, w = IO.pipe\n   Thread.new { sleep 1; w.puts "a" }\n   r.eof?  #=> false after 1 second blocking\n\n   r, w = IO.pipe\n   r.eof?  # blocks forever\n\nNote that `IO#eof?` reads data to the input byte buffer.\nSo `IO#sysread` may not behave as you intend with\n`IO#eof?`, unless you call `IO#rewind`\nfirst (which is not available for some streams).\n
eof? IO.eof?()\nReturns true if <em>ios</em> is at end of file that means\nthere are no more data to read.\nThe stream must be opened for reading or an `IOError` will be\nraised.\n\n   f = File.new("testfile")\n   dummy = f.readlines\n   f.eof   #=> true\n\nIf <em>ios</em> is a stream such as pipe or socket, `IO#eof?`\nblocks until the other end sends some data or closes it.\n\n   r, w = IO.pipe\n   Thread.new { sleep 1; w.close }\n   r.eof?  #=> true after 1 second blocking\n\n   r, w = IO.pipe\n   Thread.new { sleep 1; w.puts "a" }\n   r.eof?  #=> false after 1 second blocking\n\n   r, w = IO.pipe\n   r.eof?  # blocks forever\n\nNote that `IO#eof?` reads data to the input byte buffer.\nSo `IO#sysread` may not behave as you intend with\n`IO#eof?`, unless you call `IO#rewind`\nfirst (which is not available for some streams).\n
expect IO.expect(pat,timeout=9999999)\nReads from the IO until pattern +pat+ matches or the +timeout+ is over.\nIt returns an array with the read buffer, followed by the matches.\nIf a block is given, the result is yielded to the block and returns nil.\n\nThe optional timeout parameter defines, in seconds, the total time to wait\nfor the pattern.  If the timeout expires or eof is found, nil is returned\nor yielded.  However, the buffer in a timeout session is kept for the next\nexpect call.  The default timeout is 9999999 seconds.\n
external_encoding IO.external_encoding()\nReturns the Encoding object that represents the encoding of the file.\nIf io is write mode and no encoding is specified, returns `nil`.\n
fcntl IO.fcntl(p1, p2 = v2)\nProvides a mechanism for issuing low-level commands to control or\nquery file-oriented I/O streams. Arguments and results are platform\ndependent. If <i>arg</i> is a number, its value is passed\ndirectly. If it is a string, it is interpreted as a binary sequence\nof bytes (`Array#pack` might be a useful way to build this\nstring). On Unix platforms, see `fcntl(2)` for details.\nNot implemented on all platforms.\n
fdatasync IO.fdatasync()\nImmediately writes all buffered data in <em>ios</em> to disk.\n\nIf the underlying operating system does not support <em>fdatasync(2)</em>,\n`IO#fsync` is called instead (which might raise a\n`NotImplementedError`).\n
fileno IO.fileno()\nReturns an integer representing the numeric file descriptor for\n<em>ios</em>.\n\n   $stdin.fileno    #=> 0\n   $stdout.fileno   #=> 1\n
flush IO.flush()\nFlushes any buffered data within <em>ios</em> to the underlying\noperating system (note that this is Ruby internal buffering only;\nthe OS may buffer the data as well).\n\n   $stdout.print "no newline"\n   $stdout.flush\n\n<em>produces:</em>\n\n   no newline\n
fsync IO.fsync()\nImmediately writes all buffered data in <em>ios</em> to disk.\nNote that `fsync` differs from\nusing `IO#sync=`. The latter ensures that data is flushed\nfrom Ruby's buffers, but doesn't not guarantee that the underlying\noperating system actually writes it to disk.\n\n`NotImplementedError` is raised\nif the underlying operating system does not support <em>fsync(2)</em>.\n
getbyte IO.getbyte()\nGets the next 8-bit byte (0..255) from <em>ios</em>. Returns\n`nil` if called at end of file.\n\n   f = File.new("testfile")\n   f.getbyte   #=> 84\n   f.getbyte   #=> 104\n
getc IO.getc()\nReads a one-character string from <em>ios</em>. Returns\n`nil` if called at end of file.\n\n   f = File.new("testfile")\n   f.getc   #=> "h"\n   f.getc   #=> "e"\n
getch IO.getch(*args)\nReads and returns a character in raw mode.\n\nYou must require 'io/console' to use this method.\n
gets IO.gets(*args)\nReads the next ``line'' from the I/O stream; lines are separated by\n<i>sep</i>. A separator of `nil` reads the entire\ncontents, and a zero-length separator reads the input a paragraph at\na time (two successive newlines in the input separate paragraphs).\nThe stream must be opened for reading or an `IOError`\nwill be raised. The line read in will be returned and also assigned\nto `$_`. Returns `nil` if called at end of\nfile.  If the first argument is an integer, or optional second\nargument is given, the returning string would not be longer than the\ngiven value in bytes.\n\n   File.new("testfile").gets   #=> "This is line one\\n"\n   $_                          #=> "This is line one\\n"\n
iflush IO.iflush()\nFlushes input buffer in kernel.\n\nYou must require 'io/console' to use this method.\n
inspect IO.inspect()\nReturn a string describing this IO object.\n
internal_encoding IO.internal_encoding()\nReturns the Encoding of the internal string if conversion is\nspecified.  Otherwise returns nil.\n
ioctl IO.ioctl(p1, p2 = v2)\nProvides a mechanism for issuing low-level commands to control or\nquery I/O devices. Arguments and results are platform dependent. If\n<i>arg</i> is a number, its value is passed directly. If it is a\nstring, it is interpreted as a binary sequence of bytes. On Unix\nplatforms, see `ioctl(2)` for details. Not implemented on\nall platforms.\n
ioflush IO.ioflush()\nFlushes input and output buffers in kernel.\n\nYou must require 'io/console' to use this method.\n
isatty IO.isatty()\nReturns `true` if <em>ios</em> is associated with a\nterminal device (tty), `false` otherwise.\n\n   File.new("testfile").isatty   #=> false\n   File.new("/dev/tty").isatty   #=> true\n
lineno IO.lineno()\nReturns the current line number in <em>ios</em>.  The stream must be\nopened for reading. `lineno` counts the number of times\ngets is called rather than the number of newlines encountered.  The two\nvalues will differ if #gets is called with a separator other than newline.\n\nMethods that use `$/` like #each, #lines and #readline will\nalso increment `lineno`.\n\nSee also the `$.` variable.\n\n   f = File.new("testfile")\n   f.lineno   #=> 0\n   f.gets     #=> "This is line one\\n"\n   f.lineno   #=> 1\n   f.gets     #=> "This is line two\\n"\n   f.lineno   #=> 2\n
lineno= IO.lineno=(p1)\nManually sets the current line number to the given value.\n`$.` is updated only on the next read.\n\n   f = File.new("testfile")\n   f.gets                     #=> "This is line one\\n"\n   $.                         #=> 1\n   f.lineno = 1000\n   f.lineno                   #=> 1000\n   $.                         #=> 1         # lineno of last read\n   f.gets                     #=> "This is line two\\n"\n   $.                         #=> 1001      # lineno of last read\n
lines IO.lines(*args)\nExecutes the block for every line in <em>ios</em>, where lines are\nseparated by <i>sep</i>. <em>ios</em> must be opened for\nreading or an `IOError` will be raised.\n\nIf no block is given, an enumerator is returned instead.\n\n   f = File.new("testfile")\n   f.each {|line| puts "#{f.lineno}: #{line}" }\n\n<em>produces:</em>\n\n   1: This is line one\n   2: This is line two\n   3: This is line three\n   4: And so on...\n
noecho IO.noecho()\nYields +self+ with disabling echo back.\n\n  STDIN.noecho(&:gets)\n\nwill read and return a line without echo back.\n\nYou must require 'io/console' to use this method.\n
nread IO.nread()\nReturns number of bytes that can be read without blocking.\nReturns zero if no information available.\n
oflush IO.oflush()\nFlushes output buffer in kernel.\n\nYou must require 'io/console' to use this method.\n
pid IO.pid()\nReturns the process ID of a child process associated with\n<em>ios</em>. This will be set by `IO.popen`.\n\n   pipe = IO.popen("-")\n   if pipe\n     $stderr.puts "In parent, child pid is #{pipe.pid}"\n   else\n     $stderr.puts "In child, pid is #{$$}"\n   end\n\n<em>produces:</em>\n\n   In child, pid is 26209\n   In parent, child pid is 26209\n
pos IO.pos()\nReturns the current offset (in bytes) of <em>ios</em>.\n\n   f = File.new("testfile")\n   f.pos    #=> 0\n   f.gets   #=> "This is line one\\n"\n   f.pos    #=> 17\n
pos= IO.pos=(p1)\nSeeks to the given position (in bytes) in <em>ios</em>.\n\n   f = File.new("testfile")\n   f.pos = 17\n   f.gets   #=> "This is line two\\n"\n
print IO.print(*args)\nWrites the given object(s) to <em>ios</em>. The stream must be\nopened for writing. If the output field separator (`$,`)\nis not `nil`, it will be inserted between each object.\nIf the output record separator (`$\\`)\nis not `nil`, it will be appended to the output. If no\narguments are given, prints `$_`. Objects that aren't\nstrings will be converted by calling their `to_s` method.\nWith no argument, prints the contents of the variable `$_`.\nReturns `nil`.\n\n   $stdout.print("This is ", 100, " percent.\\n")\n\n<em>produces:</em>\n\n   This is 100 percent.\n
printf IO.printf(*args)\nFormats and writes to <em>ios</em>, converting parameters under\ncontrol of the format string. See `Kernel#sprintf`\nfor details.\n
putc IO.putc(p1)\nIf <i>obj</i> is `Numeric`, write the character whose code is\nthe least-significant byte of <i>obj</i>, otherwise write the first byte\nof the string representation of <i>obj</i> to <em>ios</em>. Note: This\nmethod is not safe for use with multi-byte characters as it will truncate\nthem.\n\n   $stdout.putc "A"\n   $stdout.putc 65\n\n<em>produces:</em>\n\n   AA\n
puts IO.puts(*args)\nWrites the given objects to <em>ios</em> as with\n`IO#print`. Writes a record separator (typically a\nnewline) after any that do not already end with a newline sequence.\nIf called with an array argument, writes each element on a new line.\nIf called without arguments, outputs a single record separator.\n\n   $stdout.puts("this", "is", "a", "test")\n\n<em>produces:</em>\n\n   this\n   is\n   a\n   test\n
raw IO.raw(*args)\nYields +self+ within raw mode.\n\n  STDIN.raw(&:gets)\n\nwill read and return a line without echo back and line editing.\n\nYou must require 'io/console' to use this method.\n
raw! IO.raw!(*args)\nEnables raw mode.\n\nIf the terminal mode needs to be back, use io.raw { ... }.\n\nYou must require 'io/console' to use this method.\n
read IO.read(p1 = v1, p2 = v2)\nReads <i>length</i> bytes from the I/O stream.\n\n<i>length</i> must be a non-negative integer or `nil`.\n\nIf <i>length</i> is a positive integer,\nit try to read <i>length</i> bytes without any conversion (binary mode).\nIt returns `nil` or a string whose length is 1 to <i>length</i> bytes.\n`nil` means it met EOF at beginning.\nThe 1 to <i>length</i>-1 bytes string means it met EOF after reading the\nresult.\nThe <i>length</i> bytes string means it doesn't meet EOF.\nThe resulted string is always ASCII-8BIT encoding.\n\nIf <i>length</i> is omitted or is `nil`,\nit reads until EOF and the encoding conversion is applied.\nIt returns a string even if EOF is met at beginning.\n\nIf <i>length</i> is zero, it returns `""`.\n\nIf the optional <i>buffer</i> argument is present, it must reference\na String, which will receive the data.\n\nAt end of file, it returns `nil` or `""`\ndepend on <i>length</i>.\n`<i>ios</i>.read()` and\n`<i>ios</i>.read(nil)` returns `""`.\n`<i>ios</i>.read(<i>positive-integer</i>)` returns `nil`.\n\n   f = File.new("testfile")\n   f.read(16)   #=> "This is line one"\n reads whole file\n   open("file") {|f|\n     data = f.read # This returns a string even if the file is empty.\n     ...\n   }\n iterate over fixed length records.\n   open("fixed-record-file") {|f|\n     while record = f.read(256)\n       ...\n     end\n   }\n iterate over variable length records.\n record is prefixed by 32-bit length.\n   open("variable-record-file") {|f|\n     while len = f.read(4)\n       len = len.unpack("N")[0] # 32-bit length\n       record = f.read(len) # This returns a string even if len is 0.\n     end\n   }\n\nNote that this method behaves like fread() function in C.\nIf you need the behavior like read(2) system call,\nconsider readpartial, read_nonblock and sysread.\n
read_nonblock IO.read_nonblock(*args)\nReads at most <i>maxlen</i> bytes from <em>ios</em> using\nthe read(2) system call after O_NONBLOCK is set for\nthe underlying file descriptor.\n\nIf the optional <i>outbuf</i> argument is present,\nit must reference a String, which will receive the data.\n\nread_nonblock just calls the read(2) system call.\nIt causes all errors the read(2) system call causes: Errno::EWOULDBLOCK,\nErrno::EINTR, etc.\nThe caller should care such errors.\n\nIf the exception is Errno::EWOULDBLOCK or Errno::AGAIN,\nit is extended by IO::WaitReadable.\nSo IO::WaitReadable can be used to rescue the exceptions for retrying\nread_nonblock.\n\nread_nonblock causes EOFError on EOF.\n\nIf the read byte buffer is not empty,\nread_nonblock reads from the buffer like readpartial.\nIn this case, the read(2) system call is not called.\n\nWhen read_nonblock raises an exception kind of IO::WaitReadable,\nread_nonblock should not be called\nuntil io is readable for avoiding busy loop.\nThis can be done as follows.\n emulates blocking read (readpartial).\n  begin\n    result = io.read_nonblock(maxlen)\n  rescue IO::WaitReadable\n    IO.select([io])\n    retry\n  end\n\nAlthough IO#read_nonblock doesn't raise IO::WaitWritable.\nOpenSSL::Buffering#read_nonblock can raise IO::WaitWritable.\nIf IO and SSL should be used polymorphically,\nIO::WaitWritable should be rescued too.\nSee the document of OpenSSL::Buffering#read_nonblock for sample code.\n\nNote that this method is identical to readpartial\nexcept the non-blocking flag is set.\n
readbyte IO.readbyte()\nReads a byte as with `IO#getbyte`, but raises an\n`EOFError` on end of file.\n
readchar IO.readchar()\nReads a one-character string from <em>ios</em>. Raises an\n`EOFError` on end of file.\n\n   f = File.new("testfile")\n   f.readchar   #=> "h"\n   f.readchar   #=> "e"\n
readline IO.readline(*args)\nReads a line as with `IO#gets`, but raises an\n`EOFError` on end of file.\n
readlines IO.readlines(*args)\nReads all of the lines in <em>ios</em>, and returns them in\n<i>anArray</i>. Lines are separated by the optional <i>sep</i>. If\n<i>sep</i> is `nil`, the rest of the stream is returned\nas a single record.  If the first argument is an integer, or\noptional second argument is given, the returning string would not be\nlonger than the given value in bytes. The stream must be opened for\nreading or an `IOError` will be raised.\n\n   f = File.new("testfile")\n   f.readlines[0]   #=> "This is line one\\n"\n
readpartial IO.readpartial(*args)\nReads at most <i>maxlen</i> bytes from the I/O stream.\nIt blocks only if <em>ios</em> has no data immediately available.\nIt doesn't block if some data available.\nIf the optional <i>outbuf</i> argument is present,\nit must reference a String, which will receive the data.\nIt raises `EOFError` on end of file.\n\nreadpartial is designed for streams such as pipe, socket, tty, etc.\nIt blocks only when no data immediately available.\nThis means that it blocks only when following all conditions hold.\n* the byte buffer in the IO object is empty.\n* the content of the stream is empty.\n* the stream is not reached to EOF.\n\nWhen readpartial blocks, it waits data or EOF on the stream.\nIf some data is reached, readpartial returns with the data.\nIf EOF is reached, readpartial raises EOFError.\n\nWhen readpartial doesn't blocks, it returns or raises immediately.\nIf the byte buffer is not empty, it returns the data in the buffer.\nOtherwise if the stream has some content,\nit returns the data in the stream.\nOtherwise if the stream is reached to EOF, it raises EOFError.\n\n   r, w = IO.pipe           #               buffer          pipe content\n   w << "abc"               #               ""              "abc".\n   r.readpartial(4096)      #=> "abc"       ""              ""\n   r.readpartial(4096)      # blocks because buffer and pipe is empty.\n\n   r, w = IO.pipe           #               buffer          pipe content\n   w << "abc"               #               ""              "abc"\n   w.close                  #               ""              "abc" EOF\n   r.readpartial(4096)      #=> "abc"       ""              EOF\n   r.readpartial(4096)      # raises EOFError\n\n   r, w = IO.pipe           #               buffer          pipe content\n   w << "abc\\ndef\\n"        #               ""              "abc\\ndef\\n"\n   r.gets                   #=> "abc\\n"     "def\\n"         ""\n   w << "ghi\\n"             #               "def\\n"         "ghi\\n"\n   r.readpartial(4096)      #=> "def\\n"     ""              "ghi\\n"\n   r.readpartial(4096)      #=> "ghi\\n"     ""              ""\n\nNote that readpartial behaves similar to sysread.\nThe differences are:\n* If the byte buffer is not empty, read from the byte buffer instead of\n"sysread for buffered IO (IOError)".\n* It doesn't cause Errno::EWOULDBLOCK and Errno::EINTR.  When readpartial meets\nEWOULDBLOCK and EINTR by read system call, readpartial retry the system call.\n\nThe later means that readpartial is nonblocking-flag insensitive.\nIt blocks on the situation IO#sysread causes Errno::EWOULDBLOCK as if the\nfd is blocking mode.\n
ready? IO.ready?()\nReturns true if input available without blocking, or false.\nReturns nil if no information available.\n
reopen IO.reopen(p1, p2 = v2)\nReassociates <em>ios</em> with the I/O stream given in\n<i>other_IO</i> or to a new stream opened on <i>path</i>. This may\ndynamically change the actual class of this stream.\n\n   f1 = File.new("testfile")\n   f2 = File.new("testfile")\n   f2.readlines[0]   #=> "This is line one\\n"\n   f2.reopen(f1)     #=> #<File:testfile>\n   f2.readlines[0]   #=> "This is line one\\n"\n
rewind IO.rewind()\nPositions <em>ios</em> to the beginning of input, resetting\n`lineno` to zero.\n\n   f = File.new("testfile")\n   f.readline   #=> "This is line one\\n"\n   f.rewind     #=> 0\n   f.lineno     #=> 0\n   f.readline   #=> "This is line one\\n"\n\nNote that it cannot be used with streams such as pipes, ttys, and sockets.\n
scanf IO.scanf(str)\nScans the current string until the match is exhausted,\nyielding each match as it is encountered in the string.\nA block is not necessary though, as the results will simply\nbe aggregated into the final array.\n\n  "123 456".block_scanf("%d")\n => [123, 456]\n\nIf a block is given, the value from that is returned from\nthe yield is added to an output array.\n\n  "123 456".block_scanf("%d) do |digit,| # the ',' unpacks the Array\n    digit + 100\n  end\n => [223, 556]\n\nSee Scanf for details on creating a format string.\n\nYou will need to require 'scanf' to use use IO#scanf.\n
seek IO.seek(p1, p2 = v2)\nSeeks to a given offset <i>anInteger</i> in the stream according to\nthe value of <i>whence</i>:\n\n  IO::SEEK_CUR  | Seeks to _amount_ plus current position\n  --------------+----------------------------------------------------\n  IO::SEEK_END  | Seeks to _amount_ plus end of stream (you probably\n                | want a negative value for _amount_)\n  --------------+----------------------------------------------------\n  IO::SEEK_SET  | Seeks to the absolute location given by _amount_\n\nExample:\n\n   f = File.new("testfile")\n   f.seek(-13, IO::SEEK_END)   #=> 0\n   f.readline                  #=> "And so on...\\n"\n
set_encoding IO.set_encoding(p1, p2 = v2, p3 = {})\nIf single argument is specified, read string from io is tagged\nwith the encoding specified.  If encoding is a colon separated two\nencoding names "A:B", the read string is converted from encoding A\n(external encoding) to encoding B (internal encoding), then tagged\nwith B.  If two arguments are specified, those must be encoding\nobjects or encoding names, and the first one is the external encoding, and the\nsecond one is the internal encoding.\nIf the external encoding and the internal encoding is specified,\noptional hash argument specify the conversion option.\n
stat IO.stat()\nReturns status information for <em>ios</em> as an object of type\n`File::Stat`.\n\n   f = File.new("testfile")\n   s = f.stat\n   "%o" % s.mode   #=> "100644"\n   s.blksize       #=> 4096\n   s.atime         #=> Wed Apr 09 08:53:54 CDT 2003\n
sync IO.sync()\nReturns the current ``sync mode'' of <em>ios</em>. When sync mode is\ntrue, all output is immediately flushed to the underlying operating\nsystem and is not buffered by Ruby internally. See also\n`IO#fsync`.\n\n   f = File.new("testfile")\n   f.sync   #=> false\n
sync= IO.sync=(p1)\nSets the ``sync mode'' to `true` or `false`.\nWhen sync mode is true, all output is immediately flushed to the\nunderlying operating system and is not buffered internally. Returns\nthe new state. See also `IO#fsync`.\n\n   f = File.new("testfile")\n   f.sync = true\n\n<em>(produces no output)</em>\n
sysread IO.sysread(p1, p2 = v2)\nReads <i>maxlen</i> bytes from <em>ios</em> using a low-level\nread and returns them as a string.  Do not mix with other methods\nthat read from <em>ios</em> or you may get unpredictable results.\nIf the optional <i>outbuf</i> argument is present, it must reference\na String, which will receive the data.\nRaises `SystemCallError` on error and\n`EOFError` at end of file.\n\n   f = File.new("testfile")\n   f.sysread(16)   #=> "This is line one"\n
sysseek IO.sysseek(p1, p2 = v2)\nSeeks to a given <i>offset</i> in the stream according to the value\nof <i>whence</i> (see `IO#seek` for values of\n<i>whence</i>). Returns the new offset into the file.\n\n   f = File.new("testfile")\n   f.sysseek(-13, IO::SEEK_END)   #=> 53\n   f.sysread(10)                  #=> "And so on."\n
syswrite IO.syswrite(p1)\nWrites the given string to <em>ios</em> using a low-level write.\nReturns the number of bytes written. Do not mix with other methods\nthat write to <em>ios</em> or you may get unpredictable results.\nRaises `SystemCallError` on error.\n\n   f = File.new("out", "w")\n   f.syswrite("ABCDEF")   #=> 6\n
tell IO.tell()\nReturns the current offset (in bytes) of <em>ios</em>.\n\n   f = File.new("testfile")\n   f.pos    #=> 0\n   f.gets   #=> "This is line one\\n"\n   f.pos    #=> 17\n
to_i IO.to_i()\n\n
to_io IO.to_io()\nReturns <em>ios</em>.\n
tty? IO.tty?()\nReturns `true` if <em>ios</em> is associated with a\nterminal device (tty), `false` otherwise.\n\n   File.new("testfile").isatty   #=> false\n   File.new("/dev/tty").isatty   #=> true\n
ungetbyte IO.ungetbyte(p1)\nPushes back bytes (passed as a parameter) onto <em>ios</em>,\nsuch that a subsequent buffered read will return it. Only one byte\nmay be pushed back before a subsequent read operation (that is,\nyou will be able to read only the last of several bytes that have been pushed\nback). Has no effect with unbuffered reads (such as `IO#sysread`).\n\n   f = File.new("testfile")   #=> #<File:testfile>\n   b = f.getbyte              #=> 0x38\n   f.ungetbyte(b)             #=> nil\n   f.getbyte                  #=> 0x38\n
ungetc IO.ungetc(p1)\nPushes back one character (passed as a parameter) onto <em>ios</em>,\nsuch that a subsequent buffered character read will return it. Only one\ncharacter\nmay be pushed back before a subsequent read operation (that is,\nyou will be able to read only the last of several characters that have\nbeen pushed\nback). Has no effect with unbuffered reads (such as `IO#sysread`).\n\n   f = File.new("testfile")   #=> #<File:testfile>\n   c = f.getc                 #=> "8"\n   f.ungetc(c)                #=> nil\n   f.getc                     #=> "8"\n
wait IO.wait(p1 = v1)\nWaits until input is available or times out and returns self or nil when\nEOF is reached.\n
winsize IO.winsize()\nReturns console size.\n\nYou must require 'io/console' to use this method.\n
winsize= IO.winsize=(p1)\nTries to set console size.  The effect depends on the platform and\nthe running environment.\n\nYou must require 'io/console' to use this method.\n
write IO.write(p1)\nWrites the given string to <em>ios</em>. The stream must be opened\nfor writing. If the argument is not a string, it will be converted\nto a string using `to_s`. Returns the number of bytes\nwritten.\n\n   count = $stdout.write("This is a test\\n")\n   puts "That was #{count} bytes of data"\n\n<em>produces:</em>\n\n   This is a test\n   That was 15 bytes of data\n
write_nonblock IO.write_nonblock(p1)\nWrites the given string to <em>ios</em> using\nthe write(2) system call after O_NONBLOCK is set for\nthe underlying file descriptor.\n\nIt returns the number of bytes written.\n\nwrite_nonblock just calls the write(2) system call.\nIt causes all errors the write(2) system call causes: Errno::EWOULDBLOCK,\nErrno::EINTR, etc.\nThe result may also be smaller than string.length (partial write).\nThe caller should care such errors and partial write.\n\nIf the exception is Errno::EWOULDBLOCK or Errno::AGAIN,\nit is extended by IO::WaitWritable.\nSo IO::WaitWritable can be used to rescue the exceptions for retrying\nwrite_nonblock.\n Creates a pipe.\n  r, w = IO.pipe\n write_nonblock writes only 65536 bytes and return 65536.\n (The pipe size is 65536 bytes on this environment.)\n  s = "a" * 100000\n  p w.write_nonblock(s)     #=> 65536\n write_nonblock cannot write a byte and raise EWOULDBLOCK (EAGAIN).\n  p w.write_nonblock("b")   # Resource temporarily unavailable (Errno::EAGAIN)\n\nIf the write buffer is not empty, it is flushed at first.\n\nWhen write_nonblock raises an exception kind of IO::WaitWritable,\nwrite_nonblock should not be called\nuntil io is writable for avoiding busy loop.\nThis can be done as follows.\n\n  begin\n    result = io.write_nonblock(string)\n  rescue IO::WaitWritable, Errno::EINTR\n    IO.select(nil, [io])\n    retry\n  end\n\nNote that this doesn't guarantee to write all data in string.\nThe length written is reported as result and it should be checked later.\n\nOn some platforms such as Windows, write_nonblock is not supported\naccording to the kind of the IO object.\nIn such cases, write_nonblock raises `Errno::EBADF`.\n
new Array.new(p1 = v1, p2 = v2)\nReturns a new array.\n\nIn the first form, if no arguments are sent, the new array will be empty.\nWhen a +size+ and an optional +obj+ are sent, an array is created with\n+size+ copies of +obj+.  Take notice that all elements will reference the\nsame object +obj+.\n\nThe second form creates a copy of the array passed as a parameter (the\narray is generated by calling to_ary on the parameter).\n\n  first_array = ["Matz", "Guido"]\n\n  second_array = Array.new(first_array) #=> ["Matz", "Guido"]\n\n  first_array.equal? second_array       #=> false\n\nIn the last form, an array of the given size is created.  Each element in\nthis array is created by passing the element's index to the given block\nand storing the return value.\n\n  Array.new(3){ |index| index ** 2 }\n => [0, 1, 4]\n\n== Common gotchas\n\nWhen sending the second parameter, the same object will be used as the\nvalue for all the array elements:\n\n   a = Array.new(2, Hash.new)\n => [{}, {}]\n\n   a[0]['cat'] = 'feline'\n   a # => [{"cat"=>"feline"}, {"cat"=>"feline"}]\n\n   a[1]['cat'] = 'Felix'\n   a # => [{"cat"=>"Felix"}, {"cat"=>"Felix"}]\n\nSince all the Array elements store the same hash, changes to one of them\nwill affect them all.\n\nIf multiple copies are what you want, you should use the block\nversion which uses the result of that block each time an element\nof the array needs to be initialized:\n\n   a = Array.new(2) { Hash.new }\n   a[0]['cat'] = 'feline'\n   a # => [{"cat"=>"feline"}, {}]\n
try_convert Array.try_convert(p1)\nTries to convert +obj+ into an array, using +to_ary+ method.  Returns the\nconverted array or +nil+ if +obj+ cannot be converted for any reason.\nThis method can be used to check if an argument is an array.\n\n   Array.try_convert([1])   #=> [1]\n   Array.try_convert("1")   #=> nil\n\n   if tmp = Array.try_convert(arg)\n the argument is an array\n   elsif tmp = String.try_convert(arg)\n the argument is a string\n   end\n
abbrev Array.abbrev(pattern = nil)\nCalculates the set of unambiguous abbreviations for the strings in\n+self+. If passed a pattern or a string, only the strings matching\nthe pattern or starting with the string are considered.\n\n  %w{ car cone }.abbrev   #=> { "ca" => "car", "car" => "car",\n                                "co" => "cone", "con" => cone",\n                                "cone" => "cone" }\n
assoc Array.assoc(p1)\nSearches through an array whose elements are also arrays\ncomparing _obj_ with the first element of each contained array\nusing obj.==.\nReturns the first contained array that matches (that\nis, the first associated array),\nor +nil+ if no match is found.\nSee also `Array#rassoc`.\n\n   s1 = [ "colors", "red", "blue", "green" ]\n   s2 = [ "letters", "a", "b", "c" ]\n   s3 = "foo"\n   a  = [ s1, s2, s3 ]\n   a.assoc("letters")  #=> [ "letters", "a", "b", "c" ]\n   a.assoc("foo")      #=> nil\n
at Array.at(p1)\nReturns the element at _index_. A\nnegative index counts from the end of +self+.  Returns +nil+\nif the index is out of range. See also `Array#[]`.\n\n   a = [ "a", "b", "c", "d", "e" ]\n   a.at(0)     #=> "a"\n   a.at(-1)    #=> "e"\n
clear Array.clear()\nRemoves all elements from +self+.\n\n   a = [ "a", "b", "c", "d", "e" ]\n   a.clear    #=> [ ]\n
collect Array.collect()\nInvokes <i>block</i> once for each element of +self+. Creates a\nnew array containing the values returned by the block.\nSee also `Enumerable#collect`.\n\nIf no block is given, an enumerator is returned instead.\n\n   a = [ "a", "b", "c", "d" ]\n   a.collect {|x| x + "!" }   #=> ["a!", "b!", "c!", "d!"]\n   a                          #=> ["a", "b", "c", "d"]\n
collect! Array.collect!()\nInvokes the block once for each element of +self+, replacing the\nelement with the value returned by _block_.\nSee also `Enumerable#collect`.\n\nIf no block is given, an enumerator is returned instead.\n\n   a = [ "a", "b", "c", "d" ]\n   a.collect! {|x| x + "!" }\n   a             #=>  [ "a!", "b!", "c!", "d!" ]\n
combination Array.combination(p1)\nWhen invoked with a block, yields all combinations of length <i>n</i>\nof elements from <i>ary</i> and then returns <i>ary</i> itself.\nThe implementation makes no guarantees about the order in which\nthe combinations are yielded.\n\nIf no block is given, an enumerator is returned instead.\n\nExamples:\n\n    a = [1, 2, 3, 4]\n    a.combination(1).to_a  #=> [[1],[2],[3],[4]]\n    a.combination(2).to_a  #=> [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\n    a.combination(3).to_a  #=> [[1,2,3],[1,2,4],[1,3,4],[2,3,4]]\n    a.combination(4).to_a  #=> [[1,2,3,4]]\n    a.combination(0).to_a  #=> [[]] # one combination of length 0\n    a.combination(5).to_a  #=> []   # no combinations of length 5\n
compact Array.compact()\nReturns a copy of +self+ with all +nil+ elements removed.\n\n   [ "a", nil, "b", nil, "c", nil ].compact\n=> [ "a", "b", "c" ]\n
compact! Array.compact!()\nRemoves +nil+ elements from the array.\nReturns +nil+ if no changes were made, otherwise returns\n<i>ary</i>.\n\n   [ "a", nil, "b", nil, "c" ].compact! #=> [ "a", "b", "c" ]\n   [ "a", "b", "c" ].compact!           #=> nil\n
concat Array.concat(p1)\nAppends the elements of <i>other_ary</i> to +self+.\n\n   [ "a", "b" ].concat( ["c", "d"] ) #=> [ "a", "b", "c", "d" ]\n
count Array.count(p1)\nReturns the number of elements.  If an argument is given, counts\nthe number of elements which equals to <i>obj</i>.  If a block is\ngiven, counts the number of elements yielding a true value.\n\n   ary = [1, 2, 4, 2]\n   ary.count             #=> 4\n   ary.count(2)          #=> 2\n   ary.count{|x|x%2==0}  #=> 3\n
cycle Array.cycle(p1 = v1)\nCalls <i>block</i> for each element repeatedly _n_ times or\nforever if none or +nil+ is given.  If a non-positive number is\ngiven or the array is empty, does nothing.  Returns +nil+ if the\nloop has finished without getting interrupted.\n\nIf no block is given, an enumerator is returned instead.\n\n   a = ["a", "b", "c"]\n   a.cycle {|x| puts x }  # print, a, b, c, a, b, c,.. forever.\n   a.cycle(2) {|x| puts x }  # print, a, b, c, a, b, c.\n
dclone Array.dclone()\nprovides a unified +clone+ operation, for REXML::XPathParser\nto use across multiple Object+ types\n
delete Array.delete(p1)\nDeletes items from +self+ that are equal to <i>obj</i>.\nIf any items are found, returns <i>obj</i>.   If\nthe item is not found, returns `nil`. If the optional\ncode block is given, returns the result of <i>block</i> if the item\nis not found.  (To remove `nil` elements and\nget an informative return value, use #compact!)\n\n   a = [ "a", "b", "b", "b", "c" ]\n   a.delete("b")                   #=> "b"\n   a                               #=> ["a", "c"]\n   a.delete("z")                   #=> nil\n   a.delete("z") { "not found" }   #=> "not found"\n
delete_at Array.delete_at(p1)\nDeletes the element at the specified index, returning that element,\nor `nil` if the index is out of range. See also\n`Array#slice!`.\n\n   a = %w( ant bat cat dog )\n   a.delete_at(2)    #=> "cat"\n   a                 #=> ["ant", "bat", "dog"]\n   a.delete_at(99)   #=> nil\n
delete_if Array.delete_if()\nDeletes every element of +self+ for which <i>block</i> evaluates\nto true.\nThe array is changed instantly every time the block is called and\nnot after the iteration is over.\nSee also `Array#reject!`\n\nIf no block is given, an enumerator is returned instead.\n\n   a = [ "a", "b", "c" ]\n   a.delete_if {|x| x >= "b" }   #=> ["a"]\n
drop Array.drop(p1)\nDrops first n elements from +ary+ and returns the rest of\nthe elements in an array.\n\n   a = [1, 2, 3, 4, 5, 0]\n   a.drop(3)             #=> [4, 5, 0]\n
drop_while Array.drop_while()\nDrops elements up to, but not including, the first element for\nwhich the block returns +nil+ or +false+ and returns an array\ncontaining the remaining elements.\n\nIf no block is given, an enumerator is returned instead.\n\n   a = [1, 2, 3, 4, 5, 0]\n   a.drop_while {|i| i < 3 }   #=> [3, 4, 5, 0]\n
each Array.each()\nCalls <i>block</i> once for each element in +self+, passing that\nelement as a parameter.\n\nIf no block is given, an enumerator is returned instead.\n\n   a = [ "a", "b", "c" ]\n   a.each {|x| print x, " -- " }\n\nproduces:\n\n   a -- b -- c --\n
each_index Array.each_index()\nSame as `Array#each`, but passes the index of the element\ninstead of the element itself.\n\nIf no block is given, an enumerator is returned instead.\n\n   a = [ "a", "b", "c" ]\n   a.each_index {|x| print x, " -- " }\n\nproduces:\n\n   0 -- 1 -- 2 --\n
empty? Array.empty?()\nReturns `true` if +self+ contains no elements.\n\n   [].empty?   #=> true\n
eql? Array.eql?(p1)\nReturns `true` if +self+ and _other_ are the same object,\nor are both arrays with the same content.\n
fetch Array.fetch(p1, p2 = v2)\nTries to return the element at position <i>index</i>. If the index\nlies outside the array, the first form throws an\n`IndexError` exception, the second form returns\n<i>default</i>, and the third form returns the value of invoking\nthe block, passing in the index. Negative values of <i>index</i>\ncount from the end of the array.\n\n   a = [ 11, 22, 33, 44 ]\n   a.fetch(1)               #=> 22\n   a.fetch(-1)              #=> 44\n   a.fetch(4, 'cat')        #=> "cat"\n   a.fetch(4) { |i| i*i }   #=> 16\n
fill Array.fill(p1 = v1, p2 = v2)\nThe first three forms set the selected elements of +self+ (which\nmay be the entire array) to <i>obj</i>. A <i>start</i> of\n`nil` is equivalent to zero. A <i>length</i> of\n`nil` is equivalent to <i>self.length</i>. The last three\nforms fill the array with the value of the block. The block is\npassed the absolute index of each element to be filled.\nNegative values of <i>start</i> count from the end of the array.\n\n   a = [ "a", "b", "c", "d" ]\n   a.fill("x")              #=> ["x", "x", "x", "x"]\n   a.fill("z", 2, 2)        #=> ["x", "x", "z", "z"]\n   a.fill("y", 0..1)        #=> ["y", "y", "z", "z"]\n   a.fill {|i| i*i}         #=> [0, 1, 4, 9]\n   a.fill(-2) {|i| i*i*i}   #=> [0, 1, 8, 27]\n
find_index Array.find_index(p1)\nReturns the index of the first object in +self+ such that the object is\n`==` to <i>obj</i>. If a block is given instead of an\nargument, returns index of first object for which <em>block</em> is true.\nReturns `nil` if no match is found.\nSee also `Array#rindex`.\n\nIf neither block nor argument is given, an enumerator is returned instead.\n\n   a = [ "a", "b", "c" ]\n   a.index("b")        #=> 1\n   a.index("z")        #=> nil\n   a.index{|x|x=="b"}  #=> 1\n\nThis is an alias of `#find_index`.\n
first Array.first(*args)\nReturns the first element, or the first +n+ elements, of the array.\nIf the array is empty, the first form returns `nil`, and the\nsecond form returns an empty array.\n\n   a = [ "q", "r", "s", "t" ]\n   a.first     #=> "q"\n   a.first(2)  #=> ["q", "r"]\n
flatten Array.flatten(p1 = v1)\nReturns a new array that is a one-dimensional flattening of this\narray (recursively). That is, for every element that is an array,\nextract its elements into the new array.  If the optional\n<i>level</i> argument determines the level of recursion to flatten.\n\n   s = [ 1, 2, 3 ]           #=> [1, 2, 3]\n   t = [ 4, 5, 6, [7, 8] ]   #=> [4, 5, 6, [7, 8]]\n   a = [ s, t, 9, 10 ]       #=> [[1, 2, 3], [4, 5, 6, [7, 8]], 9, 10]\n   a.flatten                 #=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n   a = [ 1, 2, [3, [4, 5] ] ]\n   a.flatten(1)              #=> [1, 2, 3, [4, 5]]\n
flatten! Array.flatten!(p1 = v1)\nFlattens +self+ in place.\nReturns `nil` if no modifications were made (i.e.,\n<i>ary</i> contains no subarrays.)  If the optional <i>level</i>\nargument determines the level of recursion to flatten.\n\n   a = [ 1, 2, [3, [4, 5] ] ]\n   a.flatten!   #=> [1, 2, 3, 4, 5]\n   a.flatten!   #=> nil\n   a            #=> [1, 2, 3, 4, 5]\n   a = [ 1, 2, [3, [4, 5] ] ]\n   a.flatten!(1) #=> [1, 2, 3, [4, 5]]\n
frozen? Array.frozen?()\nReturn `true` if this array is frozen (or temporarily frozen\nwhile being sorted).\n
hash Array.hash()\nCompute a hash-code for this array. Two arrays with the same content\nwill have the same hash code (and will compare using `eql?`).\n
include? Array.include?(p1)\nReturns `true` if the given object is present in\n+self+ (that is, if any object `==` <i>anObject</i>),\n`false` otherwise.\n\n   a = [ "a", "b", "c" ]\n   a.include?("b")   #=> true\n   a.include?("z")   #=> false\n
index Array.index(p1)\nReturns the index of the first object in +self+ such that the object is\n`==` to <i>obj</i>. If a block is given instead of an\nargument, returns index of first object for which <em>block</em> is true.\nReturns `nil` if no match is found.\nSee also `Array#rindex`.\n\nIf neither block nor argument is given, an enumerator is returned instead.\n\n   a = [ "a", "b", "c" ]\n   a.index("b")        #=> 1\n   a.index("z")        #=> nil\n   a.index{|x|x=="b"}  #=> 1\n\nThis is an alias of `#find_index`.\n
initialize_copy Array.initialize_copy(p1)\nReplaces the contents of +self+ with the contents of\n<i>other_ary</i>, truncating or expanding if necessary.\n\n   a = [ "a", "b", "c", "d", "e" ]\n   a.replace([ "x", "y", "z" ])   #=> ["x", "y", "z"]\n   a                              #=> ["x", "y", "z"]\n
insert Array.insert(*args)\nInserts the given values before the element with the given index\n(which may be negative).\n\n   a = %w{ a b c d }\n   a.insert(2, 99)         #=> ["a", "b", 99, "c", "d"]\n   a.insert(-2, 1, 2, 3)   #=> ["a", "b", 99, "c", 1, 2, 3, "d"]\n
inspect Array.inspect()\nCreates a string representation of +self+.\n
join Array.join(p1 = v1)\nReturns a string created by converting each element of the array to\na string, separated by <i>sep</i>.\n\n   [ "a", "b", "c" ].join        #=> "abc"\n   [ "a", "b", "c" ].join("-")   #=> "a-b-c"\n
keep_if Array.keep_if()\nDeletes every element of +self+ for which <i>block</i> evaluates\nto false.\nSee also `Array#select!`\n\nIf no block is given, an enumerator is returned instead.\n\n   a = %w{ a b c d e f }\n   a.keep_if {|v| v =~ /[aeiou]/}   #=> ["a", "e"]\n
last Array.last(*args)\nReturns the last element(s) of +self+. If the array is empty,\nthe first form returns `nil`.\n\n   a = [ "w", "x", "y", "z" ]\n   a.last     #=> "z"\n   a.last(2)  #=> ["y", "z"]\n
length Array.length()\nReturns the number of elements in +self+. May be zero.\n\n   [ 1, 2, 3, 4, 5 ].length   #=> 5\n
map Array.map()\nInvokes <i>block</i> once for each element of +self+. Creates a\nnew array containing the values returned by the block.\nSee also `Enumerable#collect`.\n\nIf no block is given, an enumerator is returned instead.\n\n   a = [ "a", "b", "c", "d" ]\n   a.collect {|x| x + "!" }   #=> ["a!", "b!", "c!", "d!"]\n   a                          #=> ["a", "b", "c", "d"]\n
map! Array.map!()\nInvokes the block once for each element of +self+, replacing the\nelement with the value returned by _block_.\nSee also `Enumerable#collect`.\n\nIf no block is given, an enumerator is returned instead.\n\n   a = [ "a", "b", "c", "d" ]\n   a.collect! {|x| x + "!" }\n   a             #=>  [ "a!", "b!", "c!", "d!" ]\n
pack Array.pack(p1)\nPacks the contents of <i>arr</i> into a binary sequence according to\nthe directives in <i>aTemplateString</i> (see the table below)\nDirectives ``A,'' ``a,'' and ``Z'' may be followed by a count,\nwhich gives the width of the resulting field. The remaining\ndirectives also may take a count, indicating the number of array\nelements to convert. If the count is an asterisk\n(```*`''), all remaining array elements will be\nconverted. Any of the directives ```sSiIlL`'' may be\nfollowed by an underscore (```_`'') or\nexclamation mark (```!`'') to use the underlying\nplatform's native size for the specified type; otherwise, they use a\nplatform-independent size. Spaces are ignored in the template\nstring. See also `String#unpack`.\n\n   a = [ "a", "b", "c" ]\n   n = [ 65, 66, 67 ]\n   a.pack("A3A3A3")   #=> "a  b  c  "\n   a.pack("a3a3a3")   #=> "a\000\000b\000\000c\000\000"\n   n.pack("ccc")      #=> "ABC"\n\nDirectives for +pack+.\n\n Integer      | Array   |\n Directive    | Element | Meaning\n ---------------------------------------------------------------------------\n    C         | Integer | 8-bit unsigned (unsigned char)\n    S         | Integer | 16-bit unsigned, native endian (uint16_t)\n    L         | Integer | 32-bit unsigned, native endian (uint32_t)\n    Q         | Integer | 64-bit unsigned, native endian (uint64_t)\n              |         |\n    c         | Integer | 8-bit signed (signed char)\n    s         | Integer | 16-bit signed, native endian (int16_t)\n    l         | Integer | 32-bit signed, native endian (int32_t)\n    q         | Integer | 64-bit signed, native endian (int64_t)\n              |         |\n    S_, S!    | Integer | unsigned short, native endian\n    I, I_, I! | Integer | unsigned int, native endian\n    L_, L!    | Integer | unsigned long, native endian\n              |         |\n    s_, s!    | Integer | signed short, native endian\n    i, i_, i! | Integer | signed int, native endian\n    l_, l!    | Integer | signed long, native endian\n              |         |\n    S> L> Q>  | Integer | same as the directives without ">" except\n    s> l> q>  |         | big endian\n    S!> I!>   |         | (available since Ruby 1.9.3)\n    L!>       |         | "S>" is same as "n"\n    s!> i!>   |         | "L>" is same as "N"\n    l!>       |         |\n              |         |\n    S< L< Q<  | Integer | same as the directives without "<" except\n    s< l< q<  |         | little endian\n    S!< I!<   |         | (available since Ruby 1.9.3)\n    L!<       |         | "S<" is same as "v"\n    s!< i!<   |         | "L<" is same as "V"\n    l!<       |         |\n              |         |\n    n         | Integer | 16-bit unsigned, network (big-endian) byte order\n    N         | Integer | 32-bit unsigned, network (big-endian) byte order\n    v         | Integer | 16-bit unsigned, VAX (little-endian) byte order\n    V         | Integer | 32-bit unsigned, VAX (little-endian) byte order\n              |         |\n    U         | Integer | UTF-8 character\n    w         | Integer | BER-compressed integer\n\n Float        |         |\n Directive    |         | Meaning\n ---------------------------------------------------------------------------\n    D, d      | Float   | double-precision, native format\n    F, f      | Float   | single-precision, native format\n    E         | Float   | double-precision, little-endian byte order\n    e         | Float   | single-precision, little-endian byte order\n    G         | Float   | double-precision, network (big-endian) byte order\n    g         | Float   | single-precision, network (big-endian) byte order\n\n String       |         |\n Directive    |         | Meaning\n ---------------------------------------------------------------------------\n    A         | String  | arbitrary binary string (space padded, count\n    is width)\n    a         | String  | arbitrary binary string (null padded, count is width)\n    Z         | String  | same as ``a'', except that null is added with *\n    B         | String  | bit string (MSB first)\n    b         | String  | bit string (LSB first)\n    H         | String  | hex string (high nibble first)\n    h         | String  | hex string (low nibble first)\n    u         | String  | UU-encoded string\n    M         | String  | quoted printable, MIME encoding (see RFC2045)\n    m         | String  | base64 encoded string (see RFC 2045, count is width)\n              |         | (if count is 0, no line feed are added, see RFC 4648)\n    P         | String  | pointer to a structure (fixed-length string)\n    p         | String  | pointer to a null-terminated string\n\n Misc.        |         |\n Directive    |         | Meaning\n ---------------------------------------------------------------------------\n    @         | ---     | moves to absolute position\n    X         | ---     | back up a byte\n    x         | ---     | null byte\n
permutation Array.permutation(p1 = v1)\nWhen invoked with a block, yield all permutations of length <i>n</i>\nof the elements of <i>ary</i>, then return the array itself.\nIf <i>n</i> is not specified, yield all permutations of all elements.\nThe implementation makes no guarantees about the order in which\nthe permutations are yielded.\n\nIf no block is given, an enumerator is returned instead.\n\nExamples:\n\n    a = [1, 2, 3]\n    a.permutation.to_a     #=>\n    [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n    a.permutation(1).to_a  #=> [[1],[2],[3]]\n    a.permutation(2).to_a  #=> [[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]\n    a.permutation(3).to_a  #=>\n    [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n    a.permutation(0).to_a  #=> [[]] # one permutation of length 0\n    a.permutation(4).to_a  #=> []   # no permutations of length 4\n
pop Array.pop(*args)\nRemoves the last element from +self+ and returns it, or\n`nil` if the array is empty.\n\nIf a number _n_ is given, returns an array of the last n elements\n(or less) just like `array.slice!(-n, n)` does.\n\n   a = [ "a", "b", "c", "d" ]\n   a.pop     #=> "d"\n   a.pop(2)  #=> ["b", "c"]\n   a         #=> ["a"]\n
pretty_print Array.pretty_print(q)\n\n
pretty_print_cycle Array.pretty_print_cycle(q)\n\n
product Array.product(*args)\nReturns an array of all combinations of elements from all arrays.\nThe length of the returned array is the product of the length\nof +self+ and the argument arrays.\nIf given a block, <i>product</i> will yield all combinations\nand return +self+ instead.\n\n   [1,2,3].product([4,5])     #=> [[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]]\n   [1,2].product([1,2])       #=> [[1,1],[1,2],[2,1],[2,2]]\n   [1,2].product([3,4],[5,6]) #=> [[1,3,5],[1,3,6],[1,4,5],[1,4,6],\n     [2,3,5],[2,3,6],[2,4,5],[2,4,6]]\n   [1,2].product()            #=> [[1],[2]]\n   [1,2].product([])          #=> []\n
push Array.push(*args)\nAppend---Pushes the given object(s) on to the end of this array. This\nexpression returns the array itself, so several appends\nmay be chained together.\n\n   a = [ "a", "b", "c" ]\n   a.push("d", "e", "f")\n=> ["a", "b", "c", "d", "e", "f"]\n
rassoc Array.rassoc(p1)\nSearches through the array whose elements are also arrays. Compares\n_obj_ with the second element of each contained array using\n`==`. Returns the first contained array that matches. See\nalso `Array#assoc`.\n\n   a = [ [ 1, "one"], [2, "two"], [3, "three"], ["ii", "two"] ]\n   a.rassoc("two")    #=> [2, "two"]\n   a.rassoc("four")   #=> nil\n
reject Array.reject()\nReturns a new array containing the items in +self+\nfor which the block is not true.\nSee also `Array#delete_if`\n\nIf no block is given, an enumerator is returned instead.\n
reject! Array.reject!()\nEquivalent to `Array#delete_if`, deleting elements from\n+self+ for which the block evaluates to true, but returns\n`nil` if no changes were made.\nThe array is changed instantly every time the block is called and\nnot after the iteration is over.\nSee also `Enumerable#reject` and `Array#delete_if`.\n\nIf no block is given, an enumerator is returned instead.\n
repeated_combination Array.repeated_combination(p1)\nWhen invoked with a block, yields all repeated combinations of\nlength <i>n</i> of elements from <i>ary</i> and then returns\n<i>ary</i> itself.\nThe implementation makes no guarantees about the order in which\nthe repeated combinations are yielded.\n\nIf no block is given, an enumerator is returned instead.\n\nExamples:\n\n    a = [1, 2, 3]\n    a.repeated_combination(1).to_a  #=> [[1], [2], [3]]\n    a.repeated_combination(2).to_a  #=> [[1,1],[1,2],[1,3],[2,2],[2,3],[3,3]]\n    a.repeated_combination(3).to_a  #=>\n    [[1,1,1],[1,1,2],[1,1,3],[1,2,2],[1,2,3],\n    [1,3,3],[2,2,2],[2,2,3],[2,3,3],[3,3,3]]\n    a.repeated_combination(4).to_a  #=>\n    [[1,1,1,1],[1,1,1,2],[1,1,1,3],[1,1,2,2],[1,1,2,3],\n    [1,1,3,3],[1,2,2,2],[1,2,2,3],[1,2,3,3],[1,3,3,3],\n    [2,2,2,2],[2,2,2,3],[2,2,3,3],[2,3,3,3],[3,3,3,3]]\n    a.repeated_combination(0).to_a  #=> [[]] # one combination of length 0\n
repeated_permutation Array.repeated_permutation(p1)\nWhen invoked with a block, yield all repeated permutations of length\n<i>n</i> of the elements of <i>ary</i>, then return the array itself.\nThe implementation makes no guarantees about the order in which\nthe repeated permutations are yielded.\n\nIf no block is given, an enumerator is returned instead.\n\nExamples:\n\n    a = [1, 2]\n    a.repeated_permutation(1).to_a  #=> [[1], [2]]\n    a.repeated_permutation(2).to_a  #=> [[1,1],[1,2],[2,1],[2,2]]\n    a.repeated_permutation(3).to_a  #=> [[1,1,1],[1,1,2],[1,2,1],[1,2,2],\n    [2,1,1],[2,1,2],[2,2,1],[2,2,2]]\n    a.repeated_permutation(0).to_a  #=> [[]] # one permutation of length 0\n
replace Array.replace(p1)\nReplaces the contents of +self+ with the contents of\n<i>other_ary</i>, truncating or expanding if necessary.\n\n   a = [ "a", "b", "c", "d", "e" ]\n   a.replace([ "x", "y", "z" ])   #=> ["x", "y", "z"]\n   a                              #=> ["x", "y", "z"]\n
reverse Array.reverse()\nReturns a new array containing +self+'s elements in reverse order.\n\n   [ "a", "b", "c" ].reverse   #=> ["c", "b", "a"]\n   [ 1 ].reverse               #=> [1]\n
reverse! Array.reverse!()\nReverses +self+ in place.\n\n   a = [ "a", "b", "c" ]\n   a.reverse!       #=> ["c", "b", "a"]\n   a                #=> ["c", "b", "a"]\n
reverse_each Array.reverse_each()\nSame as `Array#each`, but traverses +self+ in reverse\norder.\n\n   a = [ "a", "b", "c" ]\n   a.reverse_each {|x| print x, " " }\n\nproduces:\n\n   c b a\n
rindex Array.rindex(p1)\nReturns the index of the last object in +self+\n`==` to <i>obj</i>. If a block is given instead of an\nargument, returns index of first object for which <em>block</em> is\ntrue, starting from the last object.\nReturns `nil` if no match is found.\nSee also `Array#index`.\n\nIf neither block nor argument is given, an enumerator is returned instead.\n\n   a = [ "a", "b", "b", "b", "c" ]\n   a.rindex("b")             #=> 3\n   a.rindex("z")             #=> nil\n   a.rindex { |x| x == "b" } #=> 3\n
rotate Array.rotate(p1 = v1)\nReturns new array by rotating +self+ so that the element at\n+cnt+ in +self+ is the first element of the new array. If +cnt+\nis negative then it rotates in the opposite direction.\n\n   a = [ "a", "b", "c", "d" ]\n   a.rotate         #=> ["b", "c", "d", "a"]\n   a                #=> ["a", "b", "c", "d"]\n   a.rotate(2)      #=> ["c", "d", "a", "b"]\n   a.rotate(-3)     #=> ["b", "c", "d", "a"]\n
rotate! Array.rotate!(p1 = v1)\nRotates +self+ in place so that the element at +cnt+ comes first,\nand returns +self+.  If +cnt+ is negative then it rotates in\nthe opposite direction.\n\n   a = [ "a", "b", "c", "d" ]\n   a.rotate!        #=> ["b", "c", "d", "a"]\n   a                #=> ["b", "c", "d", "a"]\n   a.rotate!(2)     #=> ["d", "a", "b", "c"]\n   a.rotate!(-3)    #=> ["a", "b", "c", "d"]\n
sample Array.sample(p1)\nChoose a random element or +n+ random elements from the array. The elements\nare chosen by using random and unique indices into the array in order to\nensure that an element doesn't repeat itself unless the array already\ncontained duplicate elements. If the array is empty the first form returns\n`nil` and the second form returns an empty array.\n\nIf +rng+ is given, it will be used as the random number generator.\n
select Array.select()\nInvokes the block passing in successive elements from +self+,\nreturning an array containing those elements for which the block\nreturns a true value (equivalent to `Enumerable#select`).\n\nIf no block is given, an enumerator is returned instead.\n\n   a = %w{ a b c d e f }\n   a.select {|v| v =~ /[aeiou]/}   #=> ["a", "e"]\n
select! Array.select!()\nInvokes the block passing in successive elements from\n+self+, deleting elements for which the block returns a\nfalse value. It returns +self+ if changes were made,\notherwise it returns `nil`.\nSee also `Array#keep_if`\n\nIf no block is given, an enumerator is returned instead.\n
shelljoin Array.shelljoin()\nBuilds a command line string from an argument list +array+ joining\nall elements escaped for Bourne shell and separated by a space.\nSee Shellwords::shelljoin for details.\n
shift Array.shift(*args)\nReturns the first element of +self+ and removes it (shifting all\nother elements down by one). Returns `nil` if the array\nis empty.\n\nIf a number _n_ is given, returns an array of the first n elements\n(or less) just like `array.slice!(0, n)` does.\n\n   args = [ "-m", "-q", "filename" ]\n   args.shift     #=> "-m"\n   args           #=> ["-q", "filename"]\n\n   args = [ "-m", "-q", "filename" ]\n   args.shift(2)  #=> ["-m", "-q"]\n   args           #=> ["filename"]\n
shuffle Array.shuffle(*args)\nReturns a new array with elements of this array shuffled.\n\n   a = [ 1, 2, 3 ]           #=> [1, 2, 3]\n   a.shuffle                 #=> [2, 3, 1]\n\nIf +rng+ is given, it will be used as the random number generator.\n\n   a.shuffle(random: Random.new(1))  #=> [1, 3, 2]\n
shuffle! Array.shuffle!(*args)\nShuffles elements in +self+ in place.\nIf +rng+ is given, it will be used as the random number generator.\n
size Array.size()\n\n
slice Array.slice(p1, p2 = v2)\nElement Reference---Returns the element at _index_,\nor returns a subarray starting at _start_ and\ncontinuing for _length_ elements, or returns a subarray\nspecified by _range_.\nNegative indices count backward from the end of the\narray (-1 is the last element). Returns +nil+ if the index\n(or starting index) are out of range.\n\n   a = [ "a", "b", "c", "d", "e" ]\n   a[2] +  a[0] + a[1]    #=> "cab"\n   a[6]                   #=> nil\n   a[1, 2]                #=> [ "b", "c" ]\n   a[1..3]                #=> [ "b", "c", "d" ]\n   a[4..7]                #=> [ "e" ]\n   a[6..10]               #=> nil\n   a[-3, 3]               #=> [ "c", "d", "e" ]\n special cases\n   a[5]                   #=> nil\n   a[5, 1]                #=> []\n   a[5..10]               #=> []\n
slice! Array.slice!(p1, p2 = v2)\nDeletes the element(s) given by an index (optionally with a length)\nor by a range. Returns the deleted object (or objects), or\n`nil` if the index is out of range.\n\n   a = [ "a", "b", "c" ]\n   a.slice!(1)     #=> "b"\n   a               #=> ["a", "c"]\n   a.slice!(-1)    #=> "c"\n   a               #=> ["a"]\n   a.slice!(100)   #=> nil\n   a               #=> ["a"]\n
sort Array.sort()\nReturns a new array created by sorting +self+. Comparisons for\nthe sort will be done using the `<=>` operator or using\nan optional code block. The block implements a comparison between\n<i>a</i> and <i>b</i>, returning -1, 0, or +1. See also\n`Enumerable#sort_by`.\n\n   a = [ "d", "a", "e", "c", "b" ]\n   a.sort                    #=> ["a", "b", "c", "d", "e"]\n   a.sort {|x,y| y <=> x }   #=> ["e", "d", "c", "b", "a"]\n
sort! Array.sort!()\nSorts +self+. Comparisons for\nthe sort will be done using the `<=>` operator or using\nan optional code block. The block implements a comparison between\n<i>a</i> and <i>b</i>, returning -1, 0, or +1. See also\n`Enumerable#sort_by`.\n\n   a = [ "d", "a", "e", "c", "b" ]\n   a.sort!                    #=> ["a", "b", "c", "d", "e"]\n   a.sort! {|x,y| y <=> x }   #=> ["e", "d", "c", "b", "a"]\n
sort_by! Array.sort_by!()\nSorts +self+ in place using a set of keys generated by mapping the\nvalues in +self+ through the given block.\n\nIf no block is given, an enumerator is returned instead.\n
take Array.take(p1)\nReturns first n elements from <i>ary</i>.\n\n   a = [1, 2, 3, 4, 5, 0]\n   a.take(3)             #=> [1, 2, 3]\n
take_while Array.take_while()\nPasses elements to the block until the block returns +nil+ or +false+,\nthen stops iterating and returns an array of all prior elements.\n\nIf no block is given, an enumerator is returned instead.\n\n   a = [1, 2, 3, 4, 5, 0]\n   a.take_while {|i| i < 3 }   #=> [1, 2]\n
to_a Array.to_a()\nReturns +self+. If called on a subclass of Array, converts\nthe receiver to an Array object.\n
to_ary Array.to_ary()\nReturns +self+.\n
to_csv Array.to_csv(options = Hash.new)\nEquivalent to <tt>CSV::generate_line(self, options)</tt>.\n
to_s Array.to_s()\n\n
transpose Array.transpose()\nAssumes that +self+ is an array of arrays and transposes the\nrows and columns.\n\n   a = [[1,2], [3,4], [5,6]]\n   a.transpose   #=> [[1, 3, 5], [2, 4, 6]]\n
uniq Array.uniq()\nReturns a new array by removing duplicate values in +self+. If a block\nis given, it will use the return value of the block for comparison.\n\n   a = [ "a", "a", "b", "b", "c" ]\n   a.uniq   # => ["a", "b", "c"]\n\n   b = [["student","sam"], ["student","george"], ["teacher","matz"]]\n   b.uniq { |s| s.first } # => [["student", "sam"], ["teacher", "matz"]]\n
uniq! Array.uniq!()\nRemoves duplicate elements from +self+. If a block is given,\nit will use the return value of the block for comparison.\nReturns `nil` if no changes are made (that is, no\nduplicates are found).\n\n   a = [ "a", "a", "b", "b", "c" ]\n   a.uniq!   # => ["a", "b", "c"]\n\n   b = [ "a", "b", "c" ]\n   b.uniq!   # => nil\n\n   c = [["student","sam"], ["student","george"], ["teacher","matz"]]\n   c.uniq! { |s| s.first } # => [["student", "sam"], ["teacher", "matz"]]\n
unshift Array.unshift(*args)\nPrepends objects to the front of +self+,\nmoving other elements upwards.\n\n   a = [ "b", "c", "d" ]\n   a.unshift("a")   #=> ["a", "b", "c", "d"]\n   a.unshift(1, 2)  #=> [ 1, 2, "a", "b", "c", "d"]\n
values_at Array.values_at(*args)\nReturns an array containing the elements in\n+self+ corresponding to the given selector(s). The selectors\nmay be either integer indices or ranges.\nSee also `Array#select`.\n\n   a = %w{ a b c d e f }\n   a.values_at(1, 3, 5)\n   a.values_at(1, 3, 5, 7)\n   a.values_at(-1, -3, -5, -7)\n   a.values_at(1..3, 2...5)\n
zip Array.zip(*args)\nConverts any arguments to arrays, then merges elements of\n+self+ with corresponding elements from each argument. This\ngenerates a sequence of `self.size` <em>n</em>-element\narrays, where <em>n</em> is one more that the count of arguments. If\nthe size of any argument is less than `enumObj.size`,\n`nil` values are supplied. If a block is given, it is\ninvoked for each output array, otherwise an array of arrays is\nreturned.\n\n   a = [ 4, 5, 6 ]\n   b = [ 7, 8, 9 ]\n   [1,2,3].zip(a, b)      #=> [[1, 4, 7], [2, 5, 8], [3, 6, 9]]\n   [1,2].zip(a,b)         #=> [[1, 4, 7], [2, 5, 8]]\n   a.zip([1,2],[8])       #=> [[4,1,8], [5,2,nil], [6,nil,nil]]\n
json_create Rational.json_create(object)\n\n
as_json Rational.as_json(*)\n\n
ceil Rational.ceil(*args)\nReturns the truncated value (toward positive infinity).\n\nFor example:\n\n   Rational(3).ceil      #=> 3\n   Rational(2, 3).ceil   #=> 1\n   Rational(-3, 2).ceil  #=> -1\n\n          decimal      -  1  2  3 . 4  5  6\n                         ^  ^  ^  ^   ^  ^\n         precision      -3 -2 -1  0  +1 +2\n\n   '%f' % Rational('-123.456').ceil(+1)  #=> "-123.400000"\n   '%f' % Rational('-123.456').ceil(-1)  #=> "-120.000000"\n
denominator Rational.denominator()\nReturns the denominator (always positive).\n\nFor example:\n\n   Rational(7).denominator             #=> 1\n   Rational(7, 1).denominator          #=> 1\n   Rational(9, -4).denominator         #=> 4\n   Rational(-2, -10).denominator       #=> 5\n   rat.numerator.gcd(rat.denominator)  #=> 1\n
fdiv Rational.fdiv(p1)\nPerforms division and returns the value as a float.\n\nFor example:\n\n   Rational(2, 3).fdiv(1)       #=> 0.6666666666666666\n   Rational(2, 3).fdiv(0.5)     #=> 1.3333333333333333\n   Rational(2).fdiv(3)          #=> 0.6666666666666666\n
floor Rational.floor(*args)\nReturns the truncated value (toward negative infinity).\n\nFor example:\n\n   Rational(3).floor      #=> 3\n   Rational(2, 3).floor   #=> 0\n   Rational(-3, 2).floor  #=> -1\n\n          decimal      -  1  2  3 . 4  5  6\n                         ^  ^  ^  ^   ^  ^\n         precision      -3 -2 -1  0  +1 +2\n\n   '%f' % Rational('-123.456').floor(+1)  #=> "-123.500000"\n   '%f' % Rational('-123.456').floor(-1)  #=> "-130.000000"\n
inspect Rational.inspect()\nReturns the value as a string for inspection.\n\nFor example:\n\n   Rational(2).inspect      #=> "(2/1)"\n   Rational(-8, 6).inspect  #=> "(-4/3)"\n   Rational('0.5').inspect  #=> "(1/2)"\n
numerator Rational.numerator()\nReturns the numerator.\n\nFor example:\n\n   Rational(7).numerator        #=> 7\n   Rational(7, 1).numerator     #=> 7\n   Rational(9, -4).numerator    #=> -9\n   Rational(-2, -10).numerator  #=> 1\n
quo Rational.quo(p1)\nPerforms division.\n\nFor example:\n\n   Rational(2, 3)  / Rational(2, 3)   #=> (1/1)\n   Rational(900)   / Rational(1)      #=> (900/1)\n   Rational(-2, 9) / Rational(-9, 2)  #=> (4/81)\n   Rational(9, 8)  / 4                #=> (9/32)\n   Rational(20, 9) / 9.8              #=> 0.22675736961451246\n
rationalize Rational.rationalize(p1 = v1)\nReturns a simpler approximation of the value if an optional\nargument eps is given (rat-|eps| <= result <= rat+|eps|), self\notherwise.\n\nFor example:\n\n   r = Rational(5033165, 16777216)\n   r.rationalize                    #=> (5033165/16777216)\n   r.rationalize(Rational('0.01'))  #=> (3/10)\n   r.rationalize(Rational('0.1'))   #=> (1/3)\n
round Rational.round(*args)\nReturns the truncated value (toward the nearest integer;\n0.5 => 1; -0.5 => -1).\n\nFor example:\n\n   Rational(3).round      #=> 3\n   Rational(2, 3).round   #=> 1\n   Rational(-3, 2).round  #=> -2\n\n          decimal      -  1  2  3 . 4  5  6\n                         ^  ^  ^  ^   ^  ^\n         precision      -3 -2 -1  0  +1 +2\n\n   '%f' % Rational('-123.456').round(+1)  #=> "-123.500000"\n   '%f' % Rational('-123.456').round(-1)  #=> "-120.000000"\n
to_d Rational.to_d(precision=0)\nConverts a Rational to a BigDecimal. Takes an optional parameter +sig+ to\nlimit the amount of significant digits.\nIf a negative precision is given, raise ArgumentError.\nThe zero precision and implicit precision is deprecated.\n\n  r = (22/7.0).to_r\n => (7077085128725065/2251799813685248)\n  r.to_d\n => #<BigDecimal:1a52bd8,'0.3142857142 8571427937 0154144999 105E1',45(63)>\n  r.to_d(3)\n => #<BigDecimal:1a44d08,'0.314E1',18(36)>\n
to_f Rational.to_f()\nReturn the value as a float.\n\nFor example:\n\n   Rational(2).to_f      #=> 2.0\n   Rational(9, 4).to_f   #=> 2.25\n   Rational(-3, 4).to_f  #=> -0.75\n   Rational(20, 3).to_f  #=> 6.666666666666667\n
to_i Rational.to_i()\nReturns the truncated value as an integer.\n\nEquivalent to\n   rat.truncate.\n\nFor example:\n\n   Rational(2, 3).to_i   #=> 0\n   Rational(3).to_i      #=> 3\n   Rational(300.6).to_i  #=> 300\n   Rational(98,71).to_i  #=> 1\n   Rational(-30,2).to_i  #=> -15\n
to_json Rational.to_json(*)\n\n
to_r Rational.to_r()\nReturns self.\n\nFor example:\n\n   Rational(2).to_r      #=> (2/1)\n   Rational(-8, 6).to_r  #=> (-4/3)\n
to_s Rational.to_s()\nReturns the value as a string.\n\nFor example:\n\n   Rational(2).to_s      #=> "2/1"\n   Rational(-8, 6).to_s  #=> "-4/3"\n   Rational('0.5').to_s  #=> "1/2"\n
truncate Rational.truncate(*args)\nReturns the truncated value (toward zero).\n\nFor example:\n\n   Rational(3).truncate      #=> 3\n   Rational(2, 3).truncate   #=> 0\n   Rational(-3, 2).truncate  #=> -1\n\n          decimal      -  1  2  3 . 4  5  6\n                         ^  ^  ^  ^   ^  ^\n         precision      -3 -2 -1  0  +1 +2\n\n   '%f' % Rational('-123.456').truncate(+1)  #=>  "-123.400000"\n   '%f' % Rational('-123.456').truncate(-1)  #=>  "-120.000000"\n
each_prime Integer.each_prime(ubound)\nIterates the given block over all prime numbers.\n\nSee +Prime+#each for more details.\n
from_prime_division Integer.from_prime_division(pd)\nRe-composes a prime factorization and returns the product.\n\nSee Prime#int_from_prime_division for more details.\n
ceil Integer.ceil()\nAs <i>int</i> is already an `Integer`, all these\nmethods simply return the receiver.\n
chr Integer.chr(*args)\nReturns a string containing the character represented by the\nreceiver's value according to +encoding+.\n\n   65.chr    #=> "A"\n   230.chr   #=> "\346"\n   255.chr(Encoding::UTF_8)   #=> "\303\277"\n
denominator Integer.denominator()\nReturns 1.\n
downto Integer.downto(p1)\nIterates <em>block</em>, passing decreasing values from <i>int</i>\ndown to and including <i>limit</i>.\n\nIf no block is given, an enumerator is returned instead.\n\n   5.downto(1) { |n| print n, ".. " }\n   print "  Liftoff!\\n"\n\n<em>produces:</em>\n\n   5.. 4.. 3.. 2.. 1..   Liftoff!\n
even? Integer.even?()\nReturns `true` if <i>int</i> is an even number.\n
floor Integer.floor()\nAs <i>int</i> is already an `Integer`, all these\nmethods simply return the receiver.\n
gcd Integer.gcd(p1)\nReturns the greatest common divisor (always positive).  0.gcd(x)\nand x.gcd(0) return abs(x).\n\nFor example:\n\n   2.gcd(2)                    #=> 2\n   3.gcd(-7)                   #=> 1\n   ((1<<31)-1).gcd((1<<61)-1)  #=> 1\n
gcdlcm Integer.gcdlcm(p1)\nReturns an array; [int.gcd(int2), int.lcm(int2)].\n\nFor example:\n\n   2.gcdlcm(2)                    #=> [2, 2]\n   3.gcdlcm(-7)                   #=> [1, 21]\n   ((1<<31)-1).gcdlcm((1<<61)-1)  #=> [1, 4951760154835678088235319297]\n
integer? Integer.integer?()\nAlways returns `true`.\n
lcm Integer.lcm(p1)\nReturns the least common multiple (always positive).  0.lcm(x) and\nx.lcm(0) return zero.\n\nFor example:\n\n   2.lcm(2)                    #=> 2\n   3.lcm(-7)                   #=> 21\n   ((1<<31)-1).lcm((1<<61)-1)  #=> 4951760154835678088235319297\n
next Integer.next()\nReturns the `Integer` equal to <i>int</i> + 1.\n\n   1.next      #=> 2\n   (-1).next   #=> 0\n
numerator Integer.numerator()\nReturns self.\n
odd? Integer.odd?()\nReturns `true` if <i>int</i> is an odd number.\n
ord Integer.ord()\nReturns the int itself.\n\n   ?a.ord    #=> 97\n\nThis method is intended for compatibility to\ncharacter constant in Ruby 1.9.\nFor example, ?a.ord returns 97 both in 1.8 and 1.9.\n
pred Integer.pred()\nReturns the `Integer` equal to <i>int</i> - 1.\n\n   1.pred      #=> 0\n   (-1).pred   #=> -2\n
prime? Integer.prime?()\nReturns true if +self+ is a prime number, false for a composite.\n
prime_division Integer.prime_division(generator = Prime::Generator23.new)\nReturns the factorization of +self+.\n\nSee Prime#prime_division for more details.\n
rationalize Integer.rationalize(p1 = v1)\nReturns the value as a rational.  An optional argument eps is\nalways ignored.\n
round Integer.round(p1)\nRounds <i>flt</i> to a given precision in decimal digits (default 0 digits).\nPrecision may be negative.  Returns a floating point number when +ndigits+\nis positive, +self+ for zero, and round down for negative.\n\n   1.round        #=> 1\n   1.round(2)     #=> 1.0\n   15.round(-1)   #=> 20\n
succ Integer.succ()\nReturns the `Integer` equal to <i>int</i> + 1.\n\n   1.next      #=> 2\n   (-1).next   #=> 0\n
times Integer.times()\nIterates block <i>int</i> times, passing in values from zero to\n<i>int</i> - 1.\n\nIf no block is given, an enumerator is returned instead.\n\n   5.times do |i|\n     print i, " "\n   end\n\n<em>produces:</em>\n\n   0 1 2 3 4\n
to_bn Integer.to_bn()\n\n
to_d Integer.to_d()\nConvert +int+ to a BigDecimal and return it.\n\n    require 'bigdecimal'\n    require 'bigdecimal/util'\n\n    42.to_d\n => #<BigDecimal:1008ef070,'0.42E2',9(36)>\n
to_i Integer.to_i()\nAs <i>int</i> is already an `Integer`, all these\nmethods simply return the receiver.\n
to_int Integer.to_int()\nAs <i>int</i> is already an `Integer`, all these\nmethods simply return the receiver.\n
to_r Integer.to_r()\nReturns the value as a rational.\n\nFor example:\n\n   1.to_r        #=> (1/1)\n   (1<<64).to_r  #=> (18446744073709551616/1)\n
truncate Integer.truncate()\nAs <i>int</i> is already an `Integer`, all these\nmethods simply return the receiver.\n
upto Integer.upto(p1)\nIterates <em>block</em>, passing in integer values from <i>int</i>\nup to and including <i>limit</i>.\n\nIf no block is given, an enumerator is returned instead.\n\n   5.upto(10) { |i| print i, " " }\n\n<em>produces:</em>\n\n   5 6 7 8 9 10\n
abs Numeric.abs()\nReturns the absolute value of <i>num</i>.\n\n   12.abs         #=> 12\n   (-34.56).abs   #=> 34.56\n   -34.56.abs     #=> 34.56\n
abs2 Numeric.abs2()\nReturns square of self.\n
angle Numeric.angle()\nReturns 0 if the value is positive, pi otherwise.\n
arg Numeric.arg()\nReturns 0 if the value is positive, pi otherwise.\n
ceil Numeric.ceil()\nReturns the smallest `Integer` greater than or equal to\n<i>num</i>. Class `Numeric` achieves this by converting\nitself to a `Float` then invoking\n`Float#ceil`.\n\n   1.ceil        #=> 1\n   1.2.ceil      #=> 2\n   (-1.2).ceil   #=> -1\n   (-1.0).ceil   #=> -1\n
coerce Numeric.coerce(p1)\nIf <i>aNumeric</i> is the same type as <i>num</i>, returns an array\ncontaining <i>aNumeric</i> and <i>num</i>. Otherwise, returns an\narray with both <i>aNumeric</i> and <i>num</i> represented as\n`Float` objects. This coercion mechanism is used by\nRuby to handle mixed-type numeric operations: it is intended to\nfind a compatible common type between the two operands of the operator.\n\n   1.coerce(2.5)   #=> [2.5, 1.0]\n   1.2.coerce(3)   #=> [3.0, 1.2]\n   1.coerce(2)     #=> [2, 1]\n
conj Numeric.conj()\nReturns self.\n
conjugate Numeric.conjugate()\nReturns self.\n
denominator Numeric.denominator()\nReturns the denominator (always positive).\n
div Numeric.div(p1)\nUses `/` to perform division, then converts the result to\nan integer. `numeric` does not define the `/`\noperator; this is left to subclasses.\n\nEquivalent to\n<i>num</i>.`divmod(`<i>aNumeric</i>`)[0]`.\n\nSee `Numeric#divmod`.\n
divmod Numeric.divmod(p1)\nReturns an array containing the quotient and modulus obtained by\ndividing <i>num</i> by <i>numeric</i>. If `q, r =\nx.divmod(y)`, then\n\n    q = floor(x/y)\n    x = q*y+r\n\nThe quotient is rounded toward -infinity, as shown in the following table:\n\n   a    |  b  |  a.divmod(b)  |   a/b   | a.modulo(b) | a.remainder(b)\n  ------+-----+---------------+---------+-------------+---------------\n   13   |  4  |   3,    1     |   3     |    1        |     1\n  ------+-----+---------------+---------+-------------+---------------\n   13   | -4  |  -4,   -3     |  -4     |   -3        |     1\n  ------+-----+---------------+---------+-------------+---------------\n  -13   |  4  |  -4,    3     |  -4     |    3        |    -1\n  ------+-----+---------------+---------+-------------+---------------\n  -13   | -4  |   3,   -1     |   3     |   -1        |    -1\n  ------+-----+---------------+---------+-------------+---------------\n   11.5 |  4  |   2,    3.5   |   2.875 |    3.5      |     3.5\n  ------+-----+---------------+---------+-------------+---------------\n   11.5 | -4  |  -3,   -0.5   |  -2.875 |   -0.5      |     3.5\n  ------+-----+---------------+---------+-------------+---------------\n  -11.5 |  4  |  -3,    0.5   |  -2.875 |    0.5      |    -3.5\n  ------+-----+---------------+---------+-------------+---------------\n  -11.5 | -4  |   2,   -3.5   |   2.875 |   -3.5      |    -3.5\n\nExamples\n\n   11.divmod(3)         #=> [3, 2]\n   11.divmod(-3)        #=> [-4, -1]\n   11.divmod(3.5)       #=> [3, 0.5]\n   (-11).divmod(3.5)    #=> [-4, 3.0]\n   (11.5).divmod(3.5)   #=> [3, 1.0]\n
eql? Numeric.eql?(p1)\nReturns `true` if <i>num</i> and <i>numeric</i> are the\nsame type and have equal values.\n\n   1 == 1.0          #=> true\n   1.eql?(1.0)       #=> false\n   (1.0).eql?(1.0)   #=> true\n
fdiv Numeric.fdiv(p1)\nReturns float division.\n
floor Numeric.floor()\nReturns the largest integer less than or equal to <i>num</i>.\n`Numeric` implements this by converting <i>anInteger</i>\nto a `Float` and invoking `Float#floor`.\n\n   1.floor      #=> 1\n   (-1).floor   #=> -1\n
i Numeric.i()\nReturns the corresponding imaginary number.\nNot available for complex numbers.\n
imag Numeric.imag()\nReturns zero.\n
imaginary Numeric.imaginary()\nReturns zero.\n
integer? Numeric.integer?()\nReturns `true` if <i>num</i> is an `Integer`\n(including `Fixnum` and `Bignum`).\n
magnitude Numeric.magnitude()\nReturns the absolute value of <i>num</i>.\n\n   12.abs         #=> 12\n   (-34.56).abs   #=> 34.56\n   -34.56.abs     #=> 34.56\n
modulo Numeric.modulo(p1)\n   x.modulo(y) means x-y*(x/y).floor\n\nEquivalent to\n<i>num</i>.`divmod(`<i>aNumeric</i>`)[1]`.\n\nSee `Numeric#divmod`.\n
nonzero? Numeric.nonzero?()\nReturns +self+ if <i>num</i> is not zero, `nil`\notherwise. This behavior is useful when chaining comparisons:\n\n   a = %w( z Bb bB bb BB a aA Aa AA A )\n   b = a.sort {|a,b| (a.downcase <=> b.downcase).nonzero? || a <=> b }\n   b   #=> ["A", "a", "AA", "Aa", "aA", "BB", "Bb", "bB", "bb", "z"]\n
numerator Numeric.numerator()\nReturns the numerator.\n
phase Numeric.phase()\nReturns 0 if the value is positive, pi otherwise.\n
polar Numeric.polar()\nReturns an array; [num.abs, num.arg].\n
quo Numeric.quo(p1)\nReturns most exact division (rational for integers, float for floats).\n
real Numeric.real()\nReturns self.\n
real? Numeric.real?()\nReturns `true` if <i>num</i> is a `Real`\n(i.e. non `Complex`).\n
rect Numeric.rect()\nReturns an array; [num, 0].\n
rectangular Numeric.rectangular()\nReturns an array; [num, 0].\n
remainder Numeric.remainder(p1)\n   x.remainder(y) means x-y*(x/y).truncate\n\nSee `Numeric#divmod`.\n
round Numeric.round(*args)\nRounds <i>num</i> to a given precision in decimal digits (default 0 digits).\nPrecision may be negative.  Returns a floating point number when <i>ndigits</i>\nis more than zero.  `Numeric` implements this by converting itself\nto a `Float` and invoking `Float#round`.\n
singleton_method_added Numeric.singleton_method_added(p1)\nTrap attempts to add methods to `Numeric` objects. Always\nraises a `TypeError`\n
step Numeric.step(*args)\nInvokes <em>block</em> with the sequence of numbers starting at\n<i>num</i>, incremented by <i>step</i> (default 1) on each\ncall. The loop finishes when the value to be passed to the block\nis greater than <i>limit</i> (if <i>step</i> is positive) or less\nthan <i>limit</i> (if <i>step</i> is negative). If all the\narguments are integers, the loop operates using an integer\ncounter. If any of the arguments are floating point numbers, all\nare converted to floats, and the loop is executed <i>floor(n +\nn*epsilon)+ 1</i> times, where <i>n = (limit -\nnum)/step</i>. Otherwise, the loop starts at <i>num</i>, uses\neither the `<` or `>` operator to compare\nthe counter against <i>limit</i>, and increments itself using the\n`+` operator.\n\nIf no block is given, an enumerator is returned instead.\n\n   1.step(10, 2) { |i| print i, " " }\n   Math::E.step(Math::PI, 0.2) { |f| print f, " " }\n\n<em>produces:</em>\n\n   1 3 5 7 9\n   2.71828182845905 2.91828182845905 3.11828182845905\n
to_c Numeric.to_c()\nReturns the value as a complex.\n
to_int Numeric.to_int()\nInvokes the child class's `to_i` method to convert\n<i>num</i> to an integer.\n
truncate Numeric.truncate()\nReturns <i>num</i> truncated to an integer. `Numeric`\nimplements this by converting its value to a float and invoking\n`Float#truncate`.\n
zero? Numeric.zero?()\nReturns `true` if <i>num</i> has a zero value.\n
abs Float.abs()\nReturns the absolute value of <i>flt</i>.\n\n   (-34.56).abs   #=> 34.56\n   -34.56.abs     #=> 34.56\n
angle Float.angle()\nReturns 0 if the value is positive, pi otherwise.\n
arg Float.arg()\nReturns 0 if the value is positive, pi otherwise.\n
ceil Float.ceil()\nReturns the smallest `Integer` greater than or equal to\n<i>flt</i>.\n\n   1.2.ceil      #=> 2\n   2.0.ceil      #=> 2\n   (-1.2).ceil   #=> -1\n   (-2.0).ceil   #=> -2\n
coerce Float.coerce(p1)\nReturns an array with both <i>aNumeric</i> and <i>flt</i> represented\nas `Float` objects.\nThis is achieved by converting <i>aNumeric</i> to a `Float`.\n\n   1.2.coerce(3)       #=> [3.0, 1.2]\n   2.5.coerce(1.1)     #=> [1.1, 2.5]\n
dclone Float.dclone()\nprovides a unified +clone+ operation, for REXML::XPathParser\nto use across multiple Object types\n
denominator Float.denominator()\nReturns the denominator (always positive).  The result is machine\ndependent.\n\nSee numerator.\n
divmod Float.divmod(p1)\nSee `Numeric#divmod`.\n
eql? Float.eql?(p1)\nReturns `true` only if <i>obj</i> is a\n`Float` with the same value as <i>flt</i>. Contrast this\nwith `Float#==`, which performs type conversions.\n\n   1.0.eql?(1)   #=> false\n
fdiv Float.fdiv(p1)\nReturns float / numeric.\n
finite? Float.finite?()\nReturns `true` if <i>flt</i> is a valid IEEE floating\npoint number (it is not infinite, and `nan?` is\n`false`).\n
floor Float.floor()\nReturns the largest integer less than or equal to <i>flt</i>.\n\n   1.2.floor      #=> 1\n   2.0.floor      #=> 2\n   (-1.2).floor   #=> -2\n   (-2.0).floor   #=> -2\n
hash Float.hash()\nReturns a hash code for this float.\n
infinite? Float.infinite?()\nReturns `nil`, -1, or +1 depending on whether <i>flt</i>\nis finite, -infinity, or +infinity.\n\n   (0.0).infinite?        #=> nil\n   (-1.0/0.0).infinite?   #=> -1\n   (+1.0/0.0).infinite?   #=> 1\n
magnitude Float.magnitude()\nReturns the absolute value of <i>flt</i>.\n\n   (-34.56).abs   #=> 34.56\n   -34.56.abs     #=> 34.56\n
modulo Float.modulo(p1)\nReturn the modulo after division of `flt` by `other`.\n\n   6543.21.modulo(137)      #=> 104.21\n   6543.21.modulo(137.24)   #=> 92.9299999999996\n
nan? Float.nan?()\nReturns `true` if <i>flt</i> is an invalid IEEE floating\npoint number.\n\n   a = -1.0      #=> -1.0\n   a.nan?        #=> false\n   a = 0.0/0.0   #=> NaN\n   a.nan?        #=> true\n
numerator Float.numerator()\nReturns the numerator.  The result is machine dependent.\n\nFor example:\n\n   n = 0.3.numerator    #=> 5404319552844595\n   d = 0.3.denominator  #=> 18014398509481984\n   n.fdiv(d)            #=> 0.3\n
phase Float.phase()\nReturns 0 if the value is positive, pi otherwise.\n
power! Float.power!(p1)\n\n
quo Float.quo(p1)\nReturns float / numeric.\n
rationalize Float.rationalize(p1 = v1)\nReturns a simpler approximation of the value (flt-|eps| <= result\n<= flt+|eps|).  if eps is not given, it will be chosen\nautomatically.\n\nFor example:\n\n   0.3.rationalize          #=> (3/10)\n   1.333.rationalize        #=> (1333/1000)\n   1.333.rationalize(0.01)  #=> (4/3)\n
round Float.round(p1 = v1)\nRounds <i>flt</i> to a given precision in decimal digits (default 0 digits).\nPrecision may be negative.  Returns a floating point number when ndigits\nis more than zero.\n\n   1.4.round      #=> 1\n   1.5.round      #=> 2\n   1.6.round      #=> 2\n   (-1.5).round   #=> -2\n\n   1.234567.round(2)  #=> 1.23\n   1.234567.round(3)  #=> 1.235\n   1.234567.round(4)  #=> 1.2346\n   1.234567.round(5)  #=> 1.23457\n\n   34567.89.round(-5) #=> 0\n   34567.89.round(-4) #=> 30000\n   34567.89.round(-3) #=> 35000\n   34567.89.round(-2) #=> 34600\n   34567.89.round(-1) #=> 34570\n   34567.89.round(0)  #=> 34568\n   34567.89.round(1)  #=> 34567.9\n   34567.89.round(2)  #=> 34567.89\n   34567.89.round(3)  #=> 34567.89\n
to_d Float.to_d(precision=nil)\nConvert +flt+ to a BigDecimal and return it.\n\n    require 'bigdecimal'\n    require 'bigdecimal/util'\n\n    0.5.to_d\n => #<BigDecimal:1dc69e0,'0.5E0',9(18)>\n
to_f Float.to_f()\nAs `flt` is already a float, returns +self+.\n
to_i Float.to_i()\nReturns <i>flt</i> truncated to an `Integer`.\n
to_int Float.to_int()\nReturns <i>flt</i> truncated to an `Integer`.\n
to_r Float.to_r()\nReturns the value as a rational.\n\nNOTE: 0.3.to_r isn't the same as '0.3'.to_r.  The latter is\nequivalent to '3/10'.to_r, but the former isn't so.\n\nFor example:\n\n   2.0.to_r    #=> (2/1)\n   2.5.to_r    #=> (5/2)\n   -0.75.to_r  #=> (-3/4)\n   0.0.to_r    #=> (0/1)\n
to_s Float.to_s()\nReturns a string containing a representation of self. As well as a\nfixed or exponential form of the number, the call may return\n```NaN`'', ```Infinity`'', and\n```-Infinity`''.\n
truncate Float.truncate()\nReturns <i>flt</i> truncated to an `Integer`.\n
zero? Float.zero?()\nReturns `true` if <i>flt</i> is 0.0.\n
inspect NilClass.inspect()\nAlways returns the string "nil".\n
nil? NilClass.nil?()\ncall_seq:\n  nil.nil?               -> true\n\nOnly the object <i>nil</i> responds `true` to `nil?`.\n
rationalize NilClass.rationalize(p1 = v1)\nReturns zero as a rational.  An optional argument eps is always\nignored.\n
to_a NilClass.to_a()\nAlways returns an empty array.\n\n   nil.to_a   #=> []\n
to_c NilClass.to_c()\nReturns zero as a complex.\n
to_f NilClass.to_f()\nAlways returns zero.\n\n   nil.to_f   #=> 0.0\n
to_i NilClass.to_i()\nAlways returns zero.\n\n   nil.to_i   #=> 0\n
to_r NilClass.to_r()\nReturns zero as a rational.\n
to_s NilClass.to_s()\nAlways returns the empty string.\n
new Proc.new(*args)\nCreates a new `Proc` object, bound to the current\ncontext. `Proc::new` may be called without a block only\nwithin a method with an attached block, in which case that block is\nconverted to the `Proc` object.\n\n   def proc_from\n     Proc.new\n   end\n   proc = proc_from { "hello" }\n   proc.call   #=> "hello"\n
arity Proc.arity()\nReturns the number of arguments that would not be ignored. If the block\nis declared to take no arguments, returns 0. If the block is known\nto take exactly n arguments, returns n. If the block has optional\narguments, return -n-1, where n is the number of mandatory\narguments. A `proc` with no argument declarations\nis the same a block declaring `||` as its arguments.\n\n   Proc.new {}.arity          #=>  0\n   Proc.new {||}.arity        #=>  0\n   Proc.new {|a|}.arity       #=>  1\n   Proc.new {|a,b|}.arity     #=>  2\n   Proc.new {|a,b,c|}.arity   #=>  3\n   Proc.new {|*a|}.arity      #=> -1\n   Proc.new {|a,*b|}.arity    #=> -2\n   Proc.new {|a,*b, c|}.arity    #=> -3\n
binding Proc.binding()\nReturns the binding associated with <i>prc</i>. Note that\n`Kernel#eval` accepts either a `Proc` or a\n`Binding` object as its second parameter.\n\n   def fred(param)\n     proc {}\n   end\n\n   b = fred(99)\n   eval("param", b.binding)   #=> 99\n
call Proc.call(*args)\nInvokes the block, setting the block's parameters to the values in\n<i>params</i> using something close to method calling semantics.\nGenerates a warning if multiple values are passed to a proc that\nexpects just one (previously this silently converted the parameters\nto an array).  Note that prc.() invokes prc.call() with the parameters\ngiven.  It's a syntax sugar to hide "call".\n\nFor procs created using `lambda` or `->()` an error\nis generated if the wrong number of parameters are passed to a Proc with\nmultiple parameters.  For procs created using `Proc.new` or\n`Kernel.proc`, extra parameters are silently discarded.\n\nReturns the value of the last expression evaluated in the block. See\nalso `Proc#yield`.\n\n   a_proc = Proc.new {|a, *b| b.collect {|i| i*a }}\n   a_proc.call(9, 1, 2, 3)   #=> [9, 18, 27]\n   a_proc[9, 1, 2, 3]        #=> [9, 18, 27]\n   a_proc = lambda {|a,b| a}\n   a_proc.call(1,2,3)\n\n<em>produces:</em>\n\n   prog.rb:4:in `block in <main>': wrong number of arguments (3 for 2)\n   (ArgumentError)\n    from prog.rb:5:in `call'\n    from prog.rb:5:in `<main>'\n
curry Proc.curry(p1 = v1)\nReturns a curried proc. If the optional <i>arity</i> argument is given,\nit determines the number of arguments.\nA curried proc receives some arguments. If a sufficient number of\narguments are supplied, it passes the supplied arguments to the original\nproc and returns the result. Otherwise, returns another curried proc that\ntakes the rest of arguments.\n\n   b = proc {|x, y, z| (x||0) + (y||0) + (z||0) }\n   p b.curry[1][2][3]           #=> 6\n   p b.curry[1, 2][3, 4]        #=> 6\n   p b.curry(5)[1][2][3][4][5]  #=> 6\n   p b.curry(5)[1, 2][3, 4][5]  #=> 6\n   p b.curry(1)[1]              #=> 1\n\n   b = proc {|x, y, z, *w| (x||0) + (y||0) + (z||0) + w.inject(0, &:+) }\n   p b.curry[1][2][3]           #=> 6\n   p b.curry[1, 2][3, 4]        #=> 10\n   p b.curry(5)[1][2][3][4][5]  #=> 15\n   p b.curry(5)[1, 2][3, 4][5]  #=> 15\n   p b.curry(1)[1]              #=> 1\n\n   b = lambda {|x, y, z| (x||0) + (y||0) + (z||0) }\n   p b.curry[1][2][3]           #=> 6\n   p b.curry[1, 2][3, 4]        #=> wrong number of arguments (4 for 3)\n   p b.curry(5)                 #=> wrong number of arguments (5 for 3)\n   p b.curry(1)                 #=> wrong number of arguments (1 for 3)\n\n   b = lambda {|x, y, z, *w| (x||0) + (y||0) + (z||0) + w.inject(0, &:+) }\n   p b.curry[1][2][3]           #=> 6\n   p b.curry[1, 2][3, 4]        #=> 10\n   p b.curry(5)[1][2][3][4][5]  #=> 15\n   p b.curry(5)[1, 2][3, 4][5]  #=> 15\n   p b.curry(1)                 #=> wrong number of arguments (1 for 3)\n\n   b = proc { :foo }\n   p b.curry[]                  #=> :foo\n
eql? Proc.eql?(p1)\nReturns `true` if <i>prc</i> is the same object as\n<i>other_proc</i>, or if they are both procs with the same body.\n
hash Proc.hash()\nReturns a hash value corresponding to proc body.\n
lambda? Proc.lambda?()\nReturns +true+ for a Proc object for which argument handling is rigid.\nSuch procs are typically generated by +lambda+.\n\nA Proc object generated by +proc+ ignores extra arguments.\n\n  proc {|a,b| [a,b] }.call(1,2,3)    #=> [1,2]\n\nIt provides +nil+ for missing arguments.\n\n  proc {|a,b| [a,b] }.call(1)        #=> [1,nil]\n\nIt expands a single array argument.\n\n  proc {|a,b| [a,b] }.call([1,2])    #=> [1,2]\n\nA Proc object generated by +lambda+ doesn't have such tricks.\n\n  lambda {|a,b| [a,b] }.call(1,2,3)  #=> ArgumentError\n  lambda {|a,b| [a,b] }.call(1)      #=> ArgumentError\n  lambda {|a,b| [a,b] }.call([1,2])  #=> ArgumentError\n\nProc#lambda? is a predicate for the tricks.\nIt returns +true+ if no tricks apply.\n\n  lambda {}.lambda?            #=> true\n  proc {}.lambda?              #=> false\n\nProc.new is the same as +proc+.\n\n  Proc.new {}.lambda?          #=> false\n\n+lambda+, +proc+ and Proc.new preserve the tricks of\na Proc object given by `&` argument.\n\n  lambda(&lambda {}).lambda?   #=> true\n  proc(&lambda {}).lambda?     #=> true\n  Proc.new(&lambda {}).lambda? #=> true\n\n  lambda(&proc {}).lambda?     #=> false\n  proc(&proc {}).lambda?       #=> false\n  Proc.new(&proc {}).lambda?   #=> false\n\nA Proc object generated by `&` argument has the tricks\n\n  def n(&b) b.lambda? end\n  n {}                         #=> false\n\nThe `&` argument preserves the tricks if a Proc object\nis given by `&` argument.\n\n  n(&lambda {})                #=> true\n  n(&proc {})                  #=> false\n  n(&Proc.new {})              #=> false\n\nA Proc object converted from a method has no tricks.\n\n  def m() end\n  method(:m).to_proc.lambda?   #=> true\n\n  n(&method(:m))               #=> true\n  n(&method(:m).to_proc)       #=> true\n\n+define_method+ is treated the same as method definition.\nThe defined method has no tricks.\n\n  class C\n    define_method(:d) {}\n  end\n  C.new.d(1,2)       #=> ArgumentError\n  C.new.method(:d).to_proc.lambda?   #=> true\n\n+define_method+ always defines a method without the tricks,\neven if a non-lambda Proc object is given.\nThis is the only exception for which the tricks are not preserved.\n\n  class C\n    define_method(:e, &proc {})\n  end\n  C.new.e(1,2)       #=> ArgumentError\n  C.new.method(:e).to_proc.lambda?   #=> true\n\nThis exception insures that methods never have tricks\nand makes it easy to have wrappers to define methods that behave as usual.\n\n  class C\n    def self.def2(name, &body)\n      define_method(name, &body)\n    end\n\n    def2(:f) {}\n  end\n  C.new.f(1,2)       #=> ArgumentError\n\nThe wrapper <i>def2</i> defines a method which has no tricks.\n
parameters Proc.parameters()\nReturns the parameter information of this proc.\n\n   prc = lambda{|x, y=42, *other|}\n   prc.parameters  #=> [[:req, :x], [:opt, :y], [:rest, :other]]\n
source_location Proc.source_location()\nReturns the Ruby source filename and line number containing this proc\nor +nil+ if this proc was not defined in Ruby (i.e. native)\n
to_proc Proc.to_proc()\nPart of the protocol for converting objects to `Proc`\nobjects. Instances of class `Proc` simply return\nthemselves.\n
to_s Proc.to_s()\nReturns the unique identifier for this proc, along with\nan indication of where the proc was defined.\n
yield Proc.yield(*args)\nInvokes the block, setting the block's parameters to the values in\n<i>params</i> using something close to method calling semantics.\nGenerates a warning if multiple values are passed to a proc that\nexpects just one (previously this silently converted the parameters\nto an array).  Note that prc.() invokes prc.call() with the parameters\ngiven.  It's a syntax sugar to hide "call".\n\nFor procs created using `lambda` or `->()` an error\nis generated if the wrong number of parameters are passed to a Proc with\nmultiple parameters.  For procs created using `Proc.new` or\n`Kernel.proc`, extra parameters are silently discarded.\n\nReturns the value of the last expression evaluated in the block. See\nalso `Proc#yield`.\n\n   a_proc = Proc.new {|a, *b| b.collect {|i| i*a }}\n   a_proc.call(9, 1, 2, 3)   #=> [9, 18, 27]\n   a_proc[9, 1, 2, 3]        #=> [9, 18, 27]\n   a_proc = lambda {|a,b| a}\n   a_proc.call(1,2,3)\n\n<em>produces:</em>\n\n   prog.rb:4:in `block in <main>': wrong number of arguments (3 for 2)\n   (ArgumentError)\n    from prog.rb:5:in `call'\n    from prog.rb:5:in `<main>'\n
exit_value LocalJumpError.exit_value()\ncall_seq:\n  local_jump_error.exit_value  -> obj\n\nReturns the exit value associated with this +LocalJumpError+.\n
reason LocalJumpError.reason()\nThe reason this block was terminated:\n:break, :redo, :retry, :next, :return, or :noreason.\n
arity Method.arity()\nReturns an indication of the number of arguments accepted by a\nmethod. Returns a nonnegative integer for methods that take a fixed\nnumber of arguments. For Ruby methods that take a variable number of\narguments, returns -n-1, where n is the number of required\narguments. For methods written in C, returns -1 if the call takes a\nvariable number of arguments.\n\n   class C\n     def one;    end\n     def two(a); end\n     def three(*a);  end\n     def four(a, b); end\n     def five(a, b, *c);    end\n     def six(a, b, *c, &d); end\n   end\n   c = C.new\n   c.method(:one).arity     #=> 0\n   c.method(:two).arity     #=> 1\n   c.method(:three).arity   #=> -1\n   c.method(:four).arity    #=> 2\n   c.method(:five).arity    #=> -3\n   c.method(:six).arity     #=> -3\n\n   "cat".method(:size).arity      #=> 0\n   "cat".method(:replace).arity   #=> 1\n   "cat".method(:squeeze).arity   #=> -1\n   "cat".method(:count).arity     #=> -1\n
call Method.call(*args)\nInvokes the <i>meth</i> with the specified arguments, returning the\nmethod's return value.\n\n   m = 12.method("+")\n   m.call(3)    #=> 15\n   m.call(20)   #=> 32\n
clone Method.clone()\nMISSING: documentation\n
eql? Method.eql?(p1)\nTwo method objects are equal if they are bound to the same\nobject and refer to the same method definition.\n
hash Method.hash()\nReturns a hash value corresponding to the method object.\n
inspect Method.inspect()\nReturns the name of the underlying method.\n\n  "cat".method(:count).inspect   #=> "#<Method: String#count>"\n
name Method.name()\nReturns the name of the method.\n
owner Method.owner()\nReturns the class or module that defines the method.\n
parameters Method.parameters()\nReturns the parameter information of this method.\n
receiver Method.receiver()\nReturns the bound receiver of the method object.\n
source_location Method.source_location()\nReturns the Ruby source filename and line number containing this method\nor nil if this method was not defined in Ruby (i.e. native)\n
to_proc Method.to_proc()\nReturns a `Proc` object corresponding to this method.\n
to_s Method.to_s()\nReturns the name of the underlying method.\n\n  "cat".method(:count).inspect   #=> "#<Method: String#count>"\n
unbind Method.unbind()\nDissociates <i>meth</i> from its current receiver. The resulting\n`UnboundMethod` can subsequently be bound to a new object\nof the same class (see `UnboundMethod`).\n
arity UnboundMethod.arity()\nReturns an indication of the number of arguments accepted by a\nmethod. Returns a nonnegative integer for methods that take a fixed\nnumber of arguments. For Ruby methods that take a variable number of\narguments, returns -n-1, where n is the number of required\narguments. For methods written in C, returns -1 if the call takes a\nvariable number of arguments.\n\n   class C\n     def one;    end\n     def two(a); end\n     def three(*a);  end\n     def four(a, b); end\n     def five(a, b, *c);    end\n     def six(a, b, *c, &d); end\n   end\n   c = C.new\n   c.method(:one).arity     #=> 0\n   c.method(:two).arity     #=> 1\n   c.method(:three).arity   #=> -1\n   c.method(:four).arity    #=> 2\n   c.method(:five).arity    #=> -3\n   c.method(:six).arity     #=> -3\n\n   "cat".method(:size).arity      #=> 0\n   "cat".method(:replace).arity   #=> 1\n   "cat".method(:squeeze).arity   #=> -1\n   "cat".method(:count).arity     #=> -1\n
bind UnboundMethod.bind(p1)\nBind <i>umeth</i> to <i>obj</i>. If `Klass` was the class\nfrom which <i>umeth</i> was obtained,\n`obj.kind_of?(Klass)` must be true.\n\n   class A\n     def test\n       puts "In test, class = #{self.class}"\n     end\n   end\n   class B < A\n   end\n   class C < B\n   end\n\n   um = B.instance_method(:test)\n   bm = um.bind(C.new)\n   bm.call\n   bm = um.bind(B.new)\n   bm.call\n   bm = um.bind(A.new)\n   bm.call\n\n<em>produces:</em>\n\n   In test, class = C\n   In test, class = B\n   prog.rb:16:in `bind': bind argument must be an instance of B (TypeError)\n    from prog.rb:16\n
clone UnboundMethod.clone()\nMISSING: documentation\n
eql? UnboundMethod.eql?(p1)\nTwo method objects are equal if they are bound to the same\nobject and refer to the same method definition.\n
hash UnboundMethod.hash()\nReturns a hash value corresponding to the method object.\n
inspect UnboundMethod.inspect()\nReturns the name of the underlying method.\n\n  "cat".method(:count).inspect   #=> "#<Method: String#count>"\n
name UnboundMethod.name()\nReturns the name of the method.\n
owner UnboundMethod.owner()\nReturns the class or module that defines the method.\n
parameters UnboundMethod.parameters()\nReturns the parameter information of this method.\n
source_location UnboundMethod.source_location()\nReturns the Ruby source filename and line number containing this method\nor nil if this method was not defined in Ruby (i.e. native)\n
to_s UnboundMethod.to_s()\nReturns the name of the underlying method.\n\n  "cat".method(:count).inspect   #=> "#<Method: String#count>"\n
eval Binding.eval(p1, p2 = v2, p3 = v3)\nEvaluates the Ruby expression(s) in <em>string</em>, in the\n<em>binding</em>'s context.  If the optional <em>filename</em> and\n<em>lineno</em> parameters are present, they will be used when\nreporting syntax errors.\n\n   def get_binding(param)\n     return binding\n   end\n   b = get_binding("hello")\n   b.eval("param")   #=> "hello"\n
new Class.new(p1 = v1)\nCreates a new anonymous (unnamed) class with the given superclass\n(or `Object` if no parameter is given). You can give a\nclass a name by assigning the class object to a constant.\n\nIf a block is given, it is passed the class object, and the block\nis evaluated in the context of this class using\n`class_eval`.\n\n   fred = Class.new do\n     def meth1\n       "hello"\n     end\n     def meth2\n       "bye"\n     end\n   end\n\n   a = fred.new     #=> #<#<Class:0x100381890>:0x100376b98>\n   a.meth1          #=> "hello"\n   a.meth2          #=> "bye"\n\nAssign the class to a constant (name starting uppercase) if you\nwant to treat it like a regular class.\n
allocate Class.allocate()\nAllocates space for a new object of <i>class</i>'s class and does not\ncall initialize on the new instance. The returned object must be an\ninstance of <i>class</i>.\n\n    klass = Class.new do\n      def initialize(*args)\n        @initialized = true\n      end\n\n      def initialized?\n        @initialized || false\n      end\n    end\n\n    klass.allocate.initialized? #=> false\n
json_creatable? Class.json_creatable?()\nReturns true if this class can be used to create an instance\nfrom a serialised JSON string. The class has to implement a class\nmethod _json_create_ that expects a hash as first parameter. The hash\nshould include the required data.\n
new Class.new(*args)\nCalls `allocate` to create a new object of\n<i>class</i>'s class, then invokes that object's\n`initialize` method, passing it <i>args</i>.\nThis is the method that ends up getting called whenever\nan object is constructed using .new.\n
superclass Class.superclass()\nReturns the superclass of <i>class</i>, or `nil`.\n\n   File.superclass          #=> IO\n   IO.superclass            #=> Object\n   Object.superclass        #=> BasicObject\n   class Foo; end\n   class Bar < Foo; end\n   Bar.superclass           #=> Foo\n\nreturns nil when the given class hasn't a parent class:\n\n   BasicObject.superclass   #=> nil\n
coredump? Process::Status.coredump?()\nReturns +true+ if _stat_ generated a coredump\nwhen it terminated. Not available on all platforms.\n
exited? Process::Status.exited?()\nReturns +true+ if _stat_ exited normally (for\nexample using an `exit()` call or finishing the\nprogram).\n
exitstatus Process::Status.exitstatus()\nReturns the least significant eight bits of the return code of\n_stat_. Only available if `exited?` is\n+true+.\n\n   fork { }           #=> 26572\n   Process.wait       #=> 26572\n   $?.exited?         #=> true\n   $?.exitstatus      #=> 0\n\n   fork { exit 99 }   #=> 26573\n   Process.wait       #=> 26573\n   $?.exited?         #=> true\n   $?.exitstatus      #=> 99\n
inspect Process::Status.inspect()\nOverride the inspection method.\n\n  system("false")\n  p $?.inspect #=> "#<Process::Status: pid 12861 exit 1>"\n
pid Process::Status.pid()\nReturns the process ID that this status object represents.\n\n   fork { exit }   #=> 26569\n   Process.wait    #=> 26569\n   $?.pid          #=> 26569\n
signaled? Process::Status.signaled?()\nReturns +true+ if _stat_ terminated because of\nan uncaught signal.\n
stopped? Process::Status.stopped?()\nReturns +true+ if this process is stopped. This is only\nreturned if the corresponding `wait` call had the\n`WUNTRACED` flag set.\n
stopsig Process::Status.stopsig()\nReturns the number of the signal that caused _stat_ to stop\n(or +nil+ if self is not stopped).\n
success? Process::Status.success?()\nReturns +true+ if _stat_ is successful, +false+ if not.\nReturns +nil+ if `exited?` is not +true+.\n
termsig Process::Status.termsig()\nReturns the number of the signal that caused _stat_ to\nterminate (or +nil+ if self was not terminated by an\nuncaught signal).\n
to_i Process::Status.to_i()\nReturns the bits in _stat_ as a `Fixnum`. Poking\naround in these bits is platform dependent.\n\n   fork { exit 0xab }         #=> 26566\n   Process.wait               #=> 26566\n   sprintf('%04x', $?.to_i)   #=> "ab00"\n
to_s Process::Status.to_s()\nShow pid and exit status as a string.\n\n  system("false")\n  p $?.to_s         #=> "pid 12766 exit 1"\n
to_s TrueClass.to_s()\nThe string representation of `true` is "true".\n
to_s FalseClass.to_s()\n'nuf said...\n
compile RubyVM::InstructionSequence.compile(p1, p2 = v2, p3 = v3, p4 = v4, p5 = v5)\n\n
compile_file RubyVM::InstructionSequence.compile_file(p1, p2 = v2)\n\n
compile_option RubyVM::InstructionSequence.compile_option()\n\n
compile_option= RubyVM::InstructionSequence.compile_option=(p1)\n\n
disasm RubyVM::InstructionSequence.disasm(p1)\n\n
disassemble RubyVM::InstructionSequence.disassemble(p1)\n\n
load RubyVM::InstructionSequence.load(p1, p2 = v2)\n\n
new RubyVM::InstructionSequence.new(p1, p2 = v2, p3 = v3, p4 = v4, p5 = v5)\n\n
disasm RubyVM::InstructionSequence.disasm()\n\n
disassemble RubyVM::InstructionSequence.disassemble()\n\n
eval RubyVM::InstructionSequence.eval()\n\n
inspect RubyVM::InstructionSequence.inspect()\n\n
to_a RubyVM::InstructionSequence.to_a()\n\n
abs Fixnum.abs()\nReturns the absolute value of <i>fix</i>.\n\n   -12345.abs   #=> 12345\n   12345.abs    #=> 12345\n
dclone Fixnum.dclone()\nprovides a unified +clone+ operation, for REXML::XPathParser\nto use across multiple Object types\n
div Fixnum.div(p1)\nPerforms integer division: returns integer value.\n
divmod Fixnum.divmod(p1)\nSee `Numeric#divmod`.\n
even? Fixnum.even?()\nReturns `true` if <i>fix</i> is an even number.\n
fdiv Fixnum.fdiv(p1)\nReturns the floating point result of dividing <i>fix</i> by\n<i>numeric</i>.\n\n   654321.fdiv(13731)      #=> 47.6528293642124\n   654321.fdiv(13731.24)   #=> 47.6519964693647\n
magnitude Fixnum.magnitude()\nReturns the absolute value of <i>fix</i>.\n\n   -12345.abs   #=> 12345\n   12345.abs    #=> 12345\n
modulo Fixnum.modulo(p1)\nReturns `fix` modulo `other`.\nSee `numeric.divmod` for more information.\n
odd? Fixnum.odd?()\nReturns `true` if <i>fix</i> is an odd number.\n
power! Fixnum.power!(p1)\n\n
size Fixnum.size()\nReturns the number of <em>bytes</em> in the machine representation\nof a `Fixnum`.\n\n   1.size            #=> 4\n   -1.size           #=> 4\n   2147483647.size   #=> 4\n
succ Fixnum.succ()\nReturns the `Integer` equal to <i>int</i> + 1.\n\n   1.next      #=> 2\n   (-1).next   #=> 0\n
to_f Fixnum.to_f()\nConverts <i>fix</i> to a `Float`.\n
to_s Fixnum.to_s(p1 = v1)\nReturns a string containing the representation of <i>fix</i> radix\n<i>base</i> (between 2 and 36).\n\n   12345.to_s       #=> "12345"\n   12345.to_s(2)    #=> "11000000111001"\n   12345.to_s(8)    #=> "30071"\n   12345.to_s(10)   #=> "12345"\n   12345.to_s(16)   #=> "3039"\n   12345.to_s(36)   #=> "9ix"\n
zero? Fixnum.zero?()\nReturns `true` if <i>fix</i> is zero.\n
exception Exception.exception(*args)\nWith no argument, or if the argument is the same as the receiver,\nreturn the receiver. Otherwise, create a new\nexception object of the same class as the receiver, but with a\nmessage equal to `string.to_str`.\n
json_create Exception.json_create(object)\nDeserializes JSON string by constructing new Exception object with message\n<tt>m</tt> and backtrace <tt>b</tt> serialized with <tt>to_json</tt>\n
new Exception.new(p1 = v1)\nConstruct a new Exception object, optionally passing in\na message.\n
as_json Exception.as_json(*)\nReturns a hash, that will be turned into a JSON object and represent this\nobject.\n
backtrace Exception.backtrace()\nReturns any backtrace associated with the exception. The backtrace\nis an array of strings, each containing either ``filename:lineNo: in\n`method''' or ``filename:lineNo.''\n\n   def a\n     raise "boom"\n   end\n\n   def b\n     a()\n   end\n\n   begin\n     b()\n   rescue => detail\n     print detail.backtrace.join("\\n")\n   end\n\n<em>produces:</em>\n\n   prog.rb:2:in `a'\n   prog.rb:6:in `b'\n   prog.rb:10\n
exception Exception.exception(*args)\nWith no argument, or if the argument is the same as the receiver,\nreturn the receiver. Otherwise, create a new\nexception object of the same class as the receiver, but with a\nmessage equal to `string.to_str`.\n
inspect Exception.inspect()\nReturn this exception's class name an message\n
message Exception.message()\nReturns the result of invoking `exception.to_s`.\nNormally this returns the exception's message or name. By\nsupplying a to_str method, exceptions are agreeing to\nbe used where Strings are expected.\n
set_backtrace Exception.set_backtrace(p1)\nSets the backtrace information associated with <i>exc</i>. The\nargument must be an array of `String` objects in the\nformat described in `Exception#backtrace`.\n
to_json Exception.to_json(*args)\nStores class name (Exception) with message <tt>m</tt> and backtrace array\n<tt>b</tt> as JSON string\n
to_s Exception.to_s()\nReturns exception's message (or the name of the exception if\nno message is set).\n
new SystemExit.new(*args)\nCreate a new +SystemExit+ exception with the given status.\n
status SystemExit.status()\nReturn the status value associated with this system exit.\n
success? SystemExit.success?()\nReturns +true+ if exiting successful, +false+ if not.\n
new NameError.new(*args)\nConstruct a new NameError exception. If given the <i>name</i>\nparameter may subsequently be examined using the `NameError.name`\nmethod.\n
name NameError.name()\nReturn the name associated with this NameError exception.\n
to_s NameError.to_s()\nProduce a nicely-formatted string representing the +NameError+.\n
new NoMethodError.new(*args)\nConstruct a NoMethodError exception for a method of the given name\ncalled with the given arguments. The name may be accessed using\nthe `#name` method on the resulting object, and the\narguments using the `#args` method.\n
args NoMethodError.args()\nReturn the arguments passed in as the third parameter to\nthe constructor.\n
new SystemCallError.new(p1, p2 = v2)\nIf _errno_ corresponds to a known system error code, constructs\nthe appropriate `Errno` class for that error, otherwise\nconstructs a generic `SystemCallError` object. The\nerror number is subsequently available via the `errno`\nmethod.\n
errno SystemCallError.errno()\nReturn this SystemCallError's error number.\n
abs Bignum.abs()\nReturns the absolute value of <i>big</i>.\n\n   -1234567890987654321.abs   #=> 1234567890987654321\n
coerce Bignum.coerce(p1)\nMISSING: documentation\n
div Bignum.div(p1)\nPerforms integer division: returns integer value.\n
divmod Bignum.divmod(p1)\nSee `Numeric#divmod`.\n
eql? Bignum.eql?(p1)\nReturns `true` only if <i>obj</i> is a\n`Bignum` with the same value as <i>big</i>. Contrast this\nwith `Bignum#==`, which performs type conversions.\n\n   68719476736.eql?(68719476736.0)   #=> false\n
even? Bignum.even?()\nReturns `true` if <i>big</i> is an even number.\n
fdiv Bignum.fdiv(p1)\nReturns the floating point result of dividing <i>big</i> by\n<i>numeric</i>.\n\n   -1234567890987654321.fdiv(13731)      #=> -89910996357705.5\n   -1234567890987654321.fdiv(13731.24)   #=> -89909424858035.7\n
hash Bignum.hash()\nCompute a hash based on the value of _big_.\n
magnitude Bignum.magnitude()\nReturns the absolute value of <i>big</i>.\n\n   -1234567890987654321.abs   #=> 1234567890987654321\n
modulo Bignum.modulo(p1)\nReturns big modulo other. See Numeric.divmod for more\ninformation.\n
odd? Bignum.odd?()\nReturns `true` if <i>big</i> is an odd number.\n
power! Bignum.power!(p1)\n\n
remainder Bignum.remainder(p1)\nReturns the remainder after dividing <i>big</i> by <i>numeric</i>.\n\n   -1234567890987654321.remainder(13731)      #=> -6966\n   -1234567890987654321.remainder(13731.24)   #=> -9906.22531493148\n
size Bignum.size()\nReturns the number of bytes in the machine representation of\n<i>big</i>.\n\n   (256**10 - 1).size   #=> 12\n   (256**20 - 1).size   #=> 20\n   (256**40 - 1).size   #=> 40\n
to_f Bignum.to_f()\nConverts <i>big</i> to a `Float`. If <i>big</i> doesn't\nfit in a `Float`, the result is infinity.\n
to_s Bignum.to_s(p1 = v1)\nReturns a string containing the representation of <i>big</i> radix\n<i>base</i> (2 through 36).\n\n   12345654321.to_s         #=> "12345654321"\n   12345654321.to_s(2)      #=> "1011011111110110111011110000110001"\n   12345654321.to_s(8)      #=> "133766736061"\n   12345654321.to_s(16)     #=> "2dfdbbc31"\n   78546939656932.to_s(36)  #=> "rubyrules"\n
chdir Dir.chdir(p1 = v1)\nChanges the current working directory of the process to the given\nstring. When called without an argument, changes the directory to\nthe value of the environment variable `HOME`, or\n`LOGDIR`. `SystemCallError` (probably\n`Errno::ENOENT`) if the target directory does not exist.\n\nIf a block is given, it is passed the name of the new current\ndirectory, and the block is executed with that as the current\ndirectory. The original working directory is restored when the block\nexits. The return value of `chdir` is the value of the\nblock. `chdir` blocks can be nested, but in a\nmulti-threaded program an error will be raised if a thread attempts\nto open a `chdir` block while another thread has one\nopen.\n\n   Dir.chdir("/var/spool/mail")\n   puts Dir.pwd\n   Dir.chdir("/tmp") do\n     puts Dir.pwd\n     Dir.chdir("/usr") do\n       puts Dir.pwd\n     end\n     puts Dir.pwd\n   end\n   puts Dir.pwd\n\n<em>produces:</em>\n\n   /var/spool/mail\n   /tmp\n   /usr\n   /tmp\n   /var/spool/mail\n
chroot Dir.chroot(p1)\nChanges this process's idea of the file system root. Only a\nprivileged process may make this call. Not available on all\nplatforms. On Unix systems, see `chroot(2)` for more\ninformation.\n
delete Dir.delete(p1)\nDeletes the named directory. Raises a subclass of\n`SystemCallError` if the directory isn't empty.\n
entries Dir.entries(*args)\nReturns an array containing all of the filenames in the given\ndirectory. Will raise a `SystemCallError` if the named\ndirectory doesn't exist.\n\n   Dir.entries("testdir")   #=> [".", "..", "config.h", "main.rb"]\n
exist? Dir.exist?(p1)\nReturns `true` if the named file is a directory,\nor a symlink that points at a directory, and `false`\notherwise.\n\n   File.directory?(".")\n
exists? Dir.exists?(p1)\nReturns `true` if the named file is a directory,\nor a symlink that points at a directory, and `false`\notherwise.\n\n   File.directory?(".")\n
foreach Dir.foreach(*args)\nCalls the block once for each entry in the named directory, passing\nthe filename of each entry as a parameter to the block.\n\nIf no block is given, an enumerator is returned instead.\n\n   Dir.foreach("testdir") {|x| puts "Got #{x}" }\n\n<em>produces:</em>\n\n   Got .\n   Got ..\n   Got config.h\n   Got main.rb\n
getwd Dir.getwd()\nReturns the path to the current working directory of this process as\na string.\n\n   Dir.chdir("/tmp")   #=> 0\n   Dir.getwd           #=> "/tmp"\n
glob Dir.glob(p1, p2 = v2)\nReturns the filenames found by expanding <i>pattern</i> which is\nan +Array+ of the patterns or the pattern +String+, either as an\n<i>array</i> or as parameters to the block. Note that this pattern\nis not a regexp (it's closer to a shell glob). See\n`File::fnmatch` for the meaning of the <i>flags</i>\nparameter. Note that case sensitivity depends on your system (so\n`File::FNM_CASEFOLD` is ignored), as does the order\nin which the results are returned.\n\n`*`::        Matches any file. Can be restricted by\n                        other values in the glob. `*`\n                        will match all files; `c*` will\n                        match all files beginning with\n                        `c`; `*c` will match\n                        all files ending with `c`; and\n                        `\*c\*` will match all files that\n                        have `c` in them (including at\n                        the beginning or end). Equivalent to\n                        `/ .* /x` in regexp. Note, this\n                        will not match Unix-like hidden files (dotfiles).\n                        In order to include those in the match results,\n                        you must use something like "{*,.*}".\n`**`::       Matches directories recursively.\n`?`::        Matches any one character. Equivalent to\n                        `/.{1}/` in regexp.\n`[set]`::    Matches any one character in +set+.\n                        Behaves exactly like character sets in\n                        Regexp, including set negation\n                        (`[^a-z]`).\n`{p,q}`::    Matches either literal `p` or\n                        literal `q`. Matching literals\n                        may be more than one character in length.\n                        More than two literals may be specified.\n                        Equivalent to pattern alternation in\n                        regexp.\n`\`::        Escapes the next metacharacter.\n                        Note that this means you cannot use backslash\n                        in windows\n                        as part of a glob, i.e. Dir["c:\\foo*"] will not work\n                        use Dir["c:/foo*"] instead\n\n   Dir["config.?"]                     #=> ["config.h"]\n   Dir.glob("config.?")                #=> ["config.h"]\n   Dir.glob("*.[a-z][a-z]")            #=> ["main.rb"]\n   Dir.glob("*.[^r]*")                 #=> ["config.h"]\n   Dir.glob("*.{rb,h}")                #=> ["main.rb", "config.h"]\n   Dir.glob("*")                       #=> ["config.h", "main.rb"]\n   Dir.glob("*", File::FNM_DOTMATCH)   #=> [".", "..", "config.h", "main.rb"]\n\n   rbfiles = File.join("**", "*.rb")\n   Dir.glob(rbfiles)                   #=> ["main.rb",\n    "lib/song.rb",\n    "lib/song/karaoke.rb"]\n   libdirs = File.join("**", "lib")\n   Dir.glob(libdirs)                   #=> ["lib"]\n\n   librbfiles = File.join("**", "lib", "**", "*.rb")\n   Dir.glob(librbfiles)                #=> ["lib/song.rb",\n    "lib/song/karaoke.rb"]\n\n   librbfiles = File.join("**", "lib", "*.rb")\n   Dir.glob(librbfiles)                #=> ["lib/song.rb"]\n
home Dir.home(p1 = v1)\nReturns the home directory of the current user or the named user\nif given.\n
mkdir Dir.mkdir(p1, p2 = v2)\nMakes a new directory named by <i>string</i>, with permissions\nspecified by the optional parameter <i>anInteger</i>. The\npermissions may be modified by the value of\n`File::umask`, and are ignored on NT. Raises a\n`SystemCallError` if the directory cannot be created. See\nalso the discussion of permissions in the class documentation for\n`File`.\n\n  Dir.mkdir(File.join(Dir.home, ".foo"), 0700) #=> 0\n
mktmpdir Dir.mktmpdir(prefix_suffix=nil, *rest)\nDir.mktmpdir creates a temporary directory.\n\nThe directory is created with 0700 permission.\n\nThe prefix and suffix of the name of the directory is specified by\nthe optional first argument, <i>prefix_suffix</i>.\n- If it is not specified or nil, "d" is used as the prefix and no suffix\nis used.\n- If it is a string, it is used as the prefix and no suffix is used.\n- If it is an array, first element is used as the prefix and second element\nis used as a suffix.\n\n Dir.mktmpdir {|dir| dir is ".../d..." }\n Dir.mktmpdir("foo") {|dir| dir is ".../foo..." }\n Dir.mktmpdir(["foo", "bar"]) {|dir| dir is ".../foo...bar" }\n\nThe directory is created under Dir.tmpdir or\nthe optional second argument <i>tmpdir</i> if non-nil value is given.\n\n Dir.mktmpdir {|dir| dir is "#{Dir.tmpdir}/d..." }\n Dir.mktmpdir(nil, "/var/tmp") {|dir| dir is "/var/tmp/d..." }\n\nIf a block is given,\nit is yielded with the path of the directory.\nThe directory and its contents are removed\nusing FileUtils.remove_entry_secure before Dir.mktmpdir returns.\nThe value of the block is returned.\n\n Dir.mktmpdir {|dir|\n use the directory...\n   open("#{dir}/foo", "w") { ... }\n }\n\nIf a block is not given,\nThe path of the directory is returned.\nIn this case, Dir.mktmpdir doesn't remove the directory.\n\n dir = Dir.mktmpdir\n begin\n use the directory...\n   open("#{dir}/foo", "w") { ... }\n ensure\n remove the directory.\n   FileUtils.remove_entry_secure dir\n end\n
new Dir.new(p1, p2 = {})\nReturns a new directory object for the named directory.\n
open Dir.open(*args)\nWith no block, `open` is a synonym for\n`Dir::new`. If a block is present, it is passed\n<i>aDir</i> as a parameter. The directory is closed at the end of\nthe block, and `Dir::open` returns the value of the\nblock.\n
pwd Dir.pwd()\nReturns the path to the current working directory of this process as\na string.\n\n   Dir.chdir("/tmp")   #=> 0\n   Dir.getwd           #=> "/tmp"\n
rmdir Dir.rmdir(p1)\nDeletes the named directory. Raises a subclass of\n`SystemCallError` if the directory isn't empty.\n
tmpdir Dir.tmpdir()\nReturns the operating system's temporary file path.\n
unlink Dir.unlink(p1)\nDeletes the named directory. Raises a subclass of\n`SystemCallError` if the directory isn't empty.\n
close Dir.close()\nCloses the directory stream. Any further attempts to access\n<em>dir</em> will raise an `IOError`.\n\n   d = Dir.new("testdir")\n   d.close   #=> nil\n
each Dir.each()\nCalls the block once for each entry in this directory, passing the\nfilename of each entry as a parameter to the block.\n\nIf no block is given, an enumerator is returned instead.\n\n   d = Dir.new("testdir")\n   d.each  {|x| puts "Got #{x}" }\n\n<em>produces:</em>\n\n   Got .\n   Got ..\n   Got config.h\n   Got main.rb\n
inspect Dir.inspect()\nReturn a string describing this Dir object.\n
path Dir.path()\nReturns the path parameter passed to <em>dir</em>'s constructor.\n\n   d = Dir.new("..")\n   d.path   #=> ".."\n
pos Dir.pos()\nReturns the current position in <em>dir</em>. See also\n`Dir#seek`.\n\n   d = Dir.new("testdir")\n   d.tell   #=> 0\n   d.read   #=> "."\n   d.tell   #=> 12\n
pos= Dir.pos=(p1)\nSynonym for `Dir#seek`, but returns the position\nparameter.\n\n   d = Dir.new("testdir")   #=> #<Dir:0x401b3c40>\n   d.read                   #=> "."\n   i = d.pos                #=> 12\n   d.read                   #=> ".."\n   d.pos = i                #=> 12\n   d.read                   #=> ".."\n
read Dir.read()\nReads the next entry from <em>dir</em> and returns it as a string.\nReturns `nil` at the end of the stream.\n\n   d = Dir.new("testdir")\n   d.read   #=> "."\n   d.read   #=> ".."\n   d.read   #=> "config.h"\n
rewind Dir.rewind()\nRepositions <em>dir</em> to the first entry.\n\n   d = Dir.new("testdir")\n   d.read     #=> "."\n   d.rewind   #=> #<Dir:0x401b3fb0>\n   d.read     #=> "."\n
seek Dir.seek(p1)\nSeeks to a particular location in <em>dir</em>. <i>integer</i>\nmust be a value returned by `Dir#tell`.\n\n   d = Dir.new("testdir")   #=> #<Dir:0x401b3c40>\n   d.read                   #=> "."\n   i = d.tell               #=> 12\n   d.read                   #=> ".."\n   d.seek(i)                #=> #<Dir:0x401b3c40>\n   d.read                   #=> ".."\n
tell Dir.tell()\nReturns the current position in <em>dir</em>. See also\n`Dir#seek`.\n\n   d = Dir.new("testdir")\n   d.tell   #=> 0\n   d.read   #=> "."\n   d.tell   #=> 12\n
to_path Dir.to_path()\nReturns the path parameter passed to <em>dir</em>'s constructor.\n\n   d = Dir.new("..")\n   d.path   #=> ".."\n
current Fiber.current()\nReturns the current fiber. You need to `require 'fiber'`\nbefore using this method. If you are not running in the context of\na fiber this method will return the root fiber.\n
yield Fiber.yield(*args)\nYields control back to the context that resumed the fiber, passing\nalong any arguments that were passed to it. The fiber will resume\nprocessing at this point when `resume` is called next.\nAny arguments passed to the next `resume` will be the\nvalue that this `Fiber.yield` expression evaluates to.\n
alive? Fiber.alive?()\nReturns true if the fiber can still be resumed (or transferred\nto). After finishing execution of the fiber block this method will\nalways return false. You need to `require 'fiber'`\nbefore using this method.\n
resume Fiber.resume(*args)\nResumes the fiber from the point at which the last `Fiber.yield`\nwas called, or starts running it if it is the first call to\n`resume`. Arguments passed to resume will be the value of\nthe `Fiber.yield` expression or will be passed as block\nparameters to the fiber's block if this is the first `resume`.\n\nAlternatively, when resume is called it evaluates to the arguments passed\nto the next `Fiber.yield` statement inside the fiber's block\nor to the block value if it runs to completion without any\n`Fiber.yield`\n
transfer Fiber.transfer(*args)\nTransfer control to another fiber, resuming it from where it last\nstopped or starting it if it was not resumed before. The calling\nfiber will be suspended much like in a call to\n`Fiber.yield`. You need to `require 'fiber'`\nbefore using this method.\n\nThe fiber which receives the transfer call is treats it much like\na resume call. Arguments passed to transfer are treated like those\npassed to resume.\n\nYou cannot resume a fiber that transferred control to another one.\nThis will cause a double resume error. You need to transfer control\nback to this fiber before it can yield and resume.\n
call Continuation.call(*args)\nInvokes the continuation. The program continues from the end of the\n`callcc` block. If no arguments are given, the original\n`callcc` returns `nil`. If one argument is\ngiven, `callcc` returns it. Otherwise, an array\ncontaining <i>args</i> is returned.\n\n   callcc {|cont|  cont.call }           #=> nil\n   callcc {|cont|  cont.call 1 }         #=> 1\n   callcc {|cont|  cont.call 1, 2, 3 }   #=> [1, 2, 3]\n
_load Time._load(p1)\nUnmarshal a dumped +Time+ object.\n
at Time.at(p1, p2 = v2)\nCreates a new time object with the value given by <i>time</i>,\nthe given number of <i>seconds_with_frac</i>, or\n<i>seconds</i> and <i>microseconds_with_frac</i> from the Epoch.\n<i>seconds_with_frac</i> and <i>microseconds_with_frac</i>\ncan be Integer, Float, Rational, or other Numeric.\nnon-portable feature allows the offset to be negative on some systems.\n\n   Time.at(0)            #=> 1969-12-31 18:00:00 -0600\n   Time.at(Time.at(0))   #=> 1969-12-31 18:00:00 -0600\n   Time.at(946702800)    #=> 1999-12-31 23:00:00 -0600\n   Time.at(-284061600)   #=> 1960-12-31 00:00:00 -0600\n   Time.at(946684800.2).usec #=> 200000\n   Time.at(946684800, 123456.789).nsec #=> 123456789\n
gm Time.gm(*args)\nCreates a time based on given values, interpreted as UTC (GMT). The\nyear must be specified. Other values default to the minimum value\nfor that field (and may be `nil` or omitted). Months may\nbe specified by numbers from 1 to 12, or by the three-letter English\nmonth names. Hours are specified on a 24-hour clock (0..23). Raises\nan `ArgumentError` if any values are out of range. Will\nalso accept ten arguments in the order output by\n`Time#to_a`.\n<i>sec_with_frac</i> and <i>usec_with_frac</i> can have a fractional part.\n\n   Time.utc(2000,"jan",1,20,15,1)  #=> 2000-01-01 20:15:01 UTC\n   Time.gm(2000,"jan",1,20,15,1)   #=> 2000-01-01 20:15:01 UTC\n
httpdate Time.httpdate(date)\nParses +date+ as HTTP-date defined by RFC 2616 and converts it to a Time\nobject.\n\nArgumentError is raised if +date+ is not compliant with RFC 2616 or Time\nclass cannot represent specified date.\n\nSee #httpdate for more information on this format.\n\ntime library should be required to use this method as follows.\n\n    require 'time'\n
iso8601 Time.iso8601(date)\n\n
json_create Time.json_create(object)\nDeserializes JSON string by converting time since epoch to Time\n
local Time.local(*args)\nSame as `Time::gm`, but interprets the values in the\nlocal time zone.\n\n   Time.local(2000,"jan",1,20,15,1)   #=> 2000-01-01 20:15:01 -0600\n
mktime Time.mktime(*args)\nSame as `Time::gm`, but interprets the values in the\nlocal time zone.\n\n   Time.local(2000,"jan",1,20,15,1)   #=> 2000-01-01 20:15:01 -0600\n
new Time.new(*args)\nReturns a `Time` object.\n\nIt is initialized to the current system time if no argument.\n<b>Note:</b> The object created will be created using the\nresolution available on your system clock, and so may include\nfractional seconds.\n\nIf one or more arguments specified, the time is initialized\nto the specified time.\n_sec_ may have fraction if it is a rational.\n\n_utc_offset_ is the offset from UTC.\nIt is a string such as "+09:00" or a number of seconds such as 32400.\n\n   a = Time.new      #=> 2007-11-19 07:50:02 -0600\n   b = Time.new      #=> 2007-11-19 07:50:02 -0600\n   a == b            #=> false\n   "%.6f" % a.to_f   #=> "1195480202.282373"\n   "%.6f" % b.to_f   #=> "1195480202.283415"\n\n   Time.new(2008,6,21, 13,30,0, "+09:00") #=> 2008-06-21 13:30:00 +0900\n A trip for RubyConf 2007\n   t1 = Time.new(2007,11,1,15,25,0, "+09:00") # JST (Narita)\n   t2 = Time.new(2007,11,1,12, 5,0, "-05:00") # CDT (Minneapolis)\n   t3 = Time.new(2007,11,1,13,25,0, "-05:00") # CDT (Minneapolis)\n   t4 = Time.new(2007,11,1,16,53,0, "-04:00") # EDT (Charlotte)\n   t5 = Time.new(2007,11,5, 9,24,0, "-05:00") # EST (Charlotte)\n   t6 = Time.new(2007,11,5,11,21,0, "-05:00") # EST (Detroit)\n   t7 = Time.new(2007,11,5,13,45,0, "-05:00") # EST (Detroit)\n   t8 = Time.new(2007,11,6,17,10,0, "+09:00") # JST (Narita)\n   p((t2-t1)/3600.0)                          #=> 10.666666666666666\n   p((t4-t3)/3600.0)                          #=> 2.466666666666667\n   p((t6-t5)/3600.0)                          #=> 1.95\n   p((t8-t7)/3600.0)                          #=> 13.416666666666666\n
now Time.now()\nSynonym for `Time.new`. Returns a +Time+ object\ninitialized to the current system time.\n
parse Time.parse(date, now=self.now)\nParses +date+ using Date._parse and converts it to a Time object.\n\nIf a block is given, the year described in +date+ is converted by the\nblock.  For example:\n\n    Time.parse(...) {|y| 0 <= y && y < 100 ? (y >= 69 ? y + 1900 : y + 2000)\n    : y}\n\nIf the upper components of the given time are broken or missing, they are\nsupplied with those of +now+.  For the lower components, the minimum\nvalues (1 or 0) are assumed if broken or missing.  For example:\n Suppose it is "Thu Nov 29 14:33:20 GMT 2001" now and\n your timezone is GMT:\n    now = Time.parse("Thu Nov 29 14:33:20 GMT 2001")\n    Time.parse("16:30", now)     #=> 2001-11-29 16:30:00 +0900\n    Time.parse("7/23", now)      #=> 2001-07-23 00:00:00 +0900\n    Time.parse("Aug 31", now)    #=> 2001-08-31 00:00:00 +0900\n    Time.parse("Aug 2000", now)  #=> 2000-08-01 00:00:00 +0900\n\nSince there are numerous conflicts among locally defined timezone\nabbreviations all over the world, this method is not made to\nunderstand all of them.  For example, the abbreviation "CST" is\nused variously as:\n\n    -06:00 in America/Chicago,\n    -05:00 in America/Havana,\n    +08:00 in Asia/Harbin,\n    +09:30 in Australia/Darwin,\n    +10:30 in Australia/Adelaide,\n    etc.\n\nBased on the fact, this method only understands the timezone\nabbreviations described in RFC 822 and the system timezone, in the\norder named. (i.e. a definition in RFC 822 overrides the system\ntimezone definition.)  The system timezone is taken from\n<tt>Time.local(year, 1, 1).zone</tt> and\n<tt>Time.local(year, 7, 1).zone</tt>.\nIf the extracted timezone abbreviation does not match any of them,\nit is ignored and the given time is regarded as a local time.\n\nArgumentError is raised if Date._parse cannot extract information from\n+date+ or Time class cannot represent specified date.\n\nThis method can be used as fail-safe for other parsing methods as:\n\n  Time.rfc2822(date) rescue Time.parse(date)\n  Time.httpdate(date) rescue Time.parse(date)\n  Time.xmlschema(date) rescue Time.parse(date)\n\nA failure for Time.parse should be checked, though.\n\ntime library should be required to use this method as follows.\n\n    require 'time'\n
rfc2822 Time.rfc2822(date)\nParses +date+ as date-time defined by RFC 2822 and converts it to a Time\nobject.  The format is identical to the date format defined by RFC 822 and\nupdated by RFC 1123.\n\nArgumentError is raised if +date+ is not compliant with RFC 2822\nor Time class cannot represent specified date.\n\nSee #rfc2822 for more information on this format.\n\ntime library should be required to use this method as follows.\n\n    require 'time'\n
rfc822 Time.rfc822(date)\n\n
strptime Time.strptime(date, format, now=self.now)\nParses +date+ using Date._strptime and converts it to a Time object.\n\nIf a block is given, the year described in +date+ is converted by the\nblock.  For example:\n\n    Time.strptime(...) {|y| y < 100 ? (y >= 69 ? y + 1900 : y + 2000) : y}\n
utc Time.utc(*args)\nCreates a time based on given values, interpreted as UTC (GMT). The\nyear must be specified. Other values default to the minimum value\nfor that field (and may be `nil` or omitted). Months may\nbe specified by numbers from 1 to 12, or by the three-letter English\nmonth names. Hours are specified on a 24-hour clock (0..23). Raises\nan `ArgumentError` if any values are out of range. Will\nalso accept ten arguments in the order output by\n`Time#to_a`.\n<i>sec_with_frac</i> and <i>usec_with_frac</i> can have a fractional part.\n\n   Time.utc(2000,"jan",1,20,15,1)  #=> 2000-01-01 20:15:01 UTC\n   Time.gm(2000,"jan",1,20,15,1)   #=> 2000-01-01 20:15:01 UTC\n
w3cdtf Time.w3cdtf(date)\n\n
xmlschema Time.xmlschema(date)\nParses +date+ as dateTime defined by XML Schema and converts it to a Time\nobject.  The format is restricted version of the format defined by ISO\n8601.\n\nArgumentError is raised if +date+ is not compliant with the format or Time\nclass cannot represent specified date.\n\nSee #xmlschema for more information on this format.\n\ntime library should be required to use this method as follows.\n\n    require 'time'\n
zone_offset Time.zone_offset(zone, year=self.now.year)\n\n
_dump Time._dump(p1 = v1)\nDump _time_ for marshaling.\n
as_json Time.as_json(*)\nReturns a hash, that will be turned into a JSON object and represent this\nobject.\n
asctime Time.asctime()\nReturns a canonical string representation of <i>time</i>.\n\n   Time.now.asctime   #=> "Wed Apr  9 08:56:03 2003"\n
ctime Time.ctime()\nReturns a canonical string representation of <i>time</i>.\n\n   Time.now.asctime   #=> "Wed Apr  9 08:56:03 2003"\n
day Time.day()\nReturns the day of the month (1..n) for <i>time</i>.\n\n   t = Time.now   #=> 2007-11-19 08:27:03 -0600\n   t.day          #=> 19\n   t.mday         #=> 19\n
dst? Time.dst?()\nReturns `true` if <i>time</i> occurs during Daylight\nSaving Time in its time zone.\n CST6CDT:\n   Time.local(2000, 1, 1).zone    #=> "CST"\n   Time.local(2000, 1, 1).isdst   #=> false\n   Time.local(2000, 1, 1).dst?    #=> false\n   Time.local(2000, 7, 1).zone    #=> "CDT"\n   Time.local(2000, 7, 1).isdst   #=> true\n   Time.local(2000, 7, 1).dst?    #=> true\n Asia/Tokyo:\n   Time.local(2000, 1, 1).zone    #=> "JST"\n   Time.local(2000, 1, 1).isdst   #=> false\n   Time.local(2000, 1, 1).dst?    #=> false\n   Time.local(2000, 7, 1).zone    #=> "JST"\n   Time.local(2000, 7, 1).isdst   #=> false\n   Time.local(2000, 7, 1).dst?    #=> false\n
eql? Time.eql?(p1)\nReturn `true` if <i>time</i> and <i>other_time</i> are\nboth `Time` objects with the same seconds and fractional\nseconds.\n
friday? Time.friday?()\nReturns `true` if <i>time</i> represents Friday.\n\n   t = Time.local(1987, 12, 18)     #=> 1987-12-18 00:00:00 -0600\n   t.friday?                        #=> true\n
getgm Time.getgm()\nReturns a new `new_time` object representing <i>time</i> in\nUTC.\n\n   t = Time.local(2000,1,1,20,15,1)   #=> 2000-01-01 20:15:01 -0600\n   t.gmt?                             #=> false\n   y = t.getgm                        #=> 2000-01-02 02:15:01 UTC\n   y.gmt?                             #=> true\n   t == y                             #=> true\n
getlocal Time.getlocal(p1 = v1)\nReturns a new `new_time` object representing <i>time</i> in\nlocal time (using the local time zone in effect for this process).\n\nIf _utc_offset_ is given, it is used instead of the local time.\n\n   t = Time.utc(2000,1,1,20,15,1)  #=> 2000-01-01 20:15:01 UTC\n   t.utc?                          #=> true\n\n   l = t.getlocal                  #=> 2000-01-01 14:15:01 -0600\n   l.utc?                          #=> false\n   t == l                          #=> true\n\n   j = t.getlocal("+09:00")        #=> 2000-01-02 05:15:01 +0900\n   j.utc?                          #=> false\n   t == j                          #=> true\n
getutc Time.getutc()\nReturns a new `new_time` object representing <i>time</i> in\nUTC.\n\n   t = Time.local(2000,1,1,20,15,1)   #=> 2000-01-01 20:15:01 -0600\n   t.gmt?                             #=> false\n   y = t.getgm                        #=> 2000-01-02 02:15:01 UTC\n   y.gmt?                             #=> true\n   t == y                             #=> true\n
gmt? Time.gmt?()\nReturns `true` if <i>time</i> represents a time in UTC\n(GMT).\n\n   t = Time.now                        #=> 2007-11-19 08:15:23 -0600\n   t.utc?                              #=> false\n   t = Time.gm(2000,"jan",1,20,15,1)   #=> 2000-01-01 20:15:01 UTC\n   t.utc?                              #=> true\n\n   t = Time.now                        #=> 2007-11-19 08:16:03 -0600\n   t.gmt?                              #=> false\n   t = Time.gm(2000,1,1,20,15,1)       #=> 2000-01-01 20:15:01 UTC\n   t.gmt?                              #=> true\n
gmt_offset Time.gmt_offset()\nReturns the offset in seconds between the timezone of <i>time</i>\nand UTC.\n\n   t = Time.gm(2000,1,1,20,15,1)   #=> 2000-01-01 20:15:01 UTC\n   t.gmt_offset                    #=> 0\n   l = t.getlocal                  #=> 2000-01-01 14:15:01 -0600\n   l.gmt_offset                    #=> -21600\n
gmtime Time.gmtime()\nConverts <i>time</i> to UTC (GMT), modifying the receiver.\n\n   t = Time.now   #=> 2007-11-19 08:18:31 -0600\n   t.gmt?         #=> false\n   t.gmtime       #=> 2007-11-19 14:18:31 UTC\n   t.gmt?         #=> true\n\n   t = Time.now   #=> 2007-11-19 08:18:51 -0600\n   t.utc?         #=> false\n   t.utc          #=> 2007-11-19 14:18:51 UTC\n   t.utc?         #=> true\n
gmtoff Time.gmtoff()\nReturns the offset in seconds between the timezone of <i>time</i>\nand UTC.\n\n   t = Time.gm(2000,1,1,20,15,1)   #=> 2000-01-01 20:15:01 UTC\n   t.gmt_offset                    #=> 0\n   l = t.getlocal                  #=> 2000-01-01 14:15:01 -0600\n   l.gmt_offset                    #=> -21600\n
hash Time.hash()\nReturn a hash code for this time object.\n
hour Time.hour()\nReturns the hour of the day (0..23) for <i>time</i>.\n\n   t = Time.now   #=> 2007-11-19 08:26:20 -0600\n   t.hour         #=> 8\n
httpdate Time.httpdate()\nReturns a string which represents the time as rfc1123-date of HTTP-date\ndefined by RFC 2616:\n\n  day-of-week, DD month-name CCYY hh:mm:ss GMT\n\nNote that the result is always UTC (GMT).\n\ntime library should be required to use this method as follows.\n\n    require 'time'\n
inspect Time.inspect()\nReturns a string representing <i>time</i>. Equivalent to calling\n`Time#strftime` with a format string of\n```%Y-%m-%d` `%H:%M:%S` `%z`''\nfor a local time and\n```%Y-%m-%d` `%H:%M:%S` `UTC`''\nfor a UTC time.\n\n   Time.now.to_s       #=> "2007-10-05 16:09:51 +0900"\n   Time.now.utc.to_s   #=> "2007-10-05 07:09:51 UTC"\n
isdst Time.isdst()\nReturns `true` if <i>time</i> occurs during Daylight\nSaving Time in its time zone.\n CST6CDT:\n   Time.local(2000, 1, 1).zone    #=> "CST"\n   Time.local(2000, 1, 1).isdst   #=> false\n   Time.local(2000, 1, 1).dst?    #=> false\n   Time.local(2000, 7, 1).zone    #=> "CDT"\n   Time.local(2000, 7, 1).isdst   #=> true\n   Time.local(2000, 7, 1).dst?    #=> true\n Asia/Tokyo:\n   Time.local(2000, 1, 1).zone    #=> "JST"\n   Time.local(2000, 1, 1).isdst   #=> false\n   Time.local(2000, 1, 1).dst?    #=> false\n   Time.local(2000, 7, 1).zone    #=> "JST"\n   Time.local(2000, 7, 1).isdst   #=> false\n   Time.local(2000, 7, 1).dst?    #=> false\n
iso8601 Time.iso8601(fraction_digits=0)\n\n
localtime Time.localtime(p1 = v1)\nConverts <i>time</i> to local time (using the local time zone in\neffect for this process) modifying the receiver.\n\nIf _utc_offset_ is given, it is used instead of the local time.\n\n   t = Time.utc(2000, "jan", 1, 20, 15, 1) #=> 2000-01-01 20:15:01 UTC\n   t.utc?                                  #=> true\n\n   t.localtime                             #=> 2000-01-01 14:15:01 -0600\n   t.utc?                                  #=> false\n\n   t.localtime("+09:00")                   #=> 2000-01-02 05:15:01 +0900\n   t.utc?                                  #=> false\n
marshal_dump Time.marshal_dump()\nundocumented\n
marshal_load Time.marshal_load(p1)\nundocumented\n
mday Time.mday()\nReturns the day of the month (1..n) for <i>time</i>.\n\n   t = Time.now   #=> 2007-11-19 08:27:03 -0600\n   t.day          #=> 19\n   t.mday         #=> 19\n
min Time.min()\nReturns the minute of the hour (0..59) for <i>time</i>.\n\n   t = Time.now   #=> 2007-11-19 08:25:51 -0600\n   t.min          #=> 25\n
mon Time.mon()\nReturns the month of the year (1..12) for <i>time</i>.\n\n   t = Time.now   #=> 2007-11-19 08:27:30 -0600\n   t.mon          #=> 11\n   t.month        #=> 11\n
monday? Time.monday?()\nReturns `true` if <i>time</i> represents Monday.\n\n   t = Time.local(2003, 8, 4)       #=> 2003-08-04 00:00:00 -0500\n   p t.monday?                      #=> true\n
month Time.month()\nReturns the month of the year (1..12) for <i>time</i>.\n\n   t = Time.now   #=> 2007-11-19 08:27:30 -0600\n   t.mon          #=> 11\n   t.month        #=> 11\n
nsec Time.nsec()\nReturns just the number of nanoseconds for <i>time</i>.\n\n   t = Time.now        #=> 2007-11-17 15:18:03 +0900\n   "%10.9f" % t.to_f   #=> "1195280283.536151409"\n   t.nsec              #=> 536151406\n\nThe lowest digit of to_f and nsec is different because\nIEEE 754 double is not accurate enough to represent\nnanoseconds from the Epoch.\nThe accurate value is returned by nsec.\n
rake_original_time_compare Time.rake_original_time_compare(p1)\n\n
rfc2822 Time.rfc2822()\nReturns a string which represents the time as date-time defined by RFC 2822:\n\n  day-of-week, DD month-name CCYY hh:mm:ss zone\n\nwhere zone is [+-]hhmm.\n\nIf +self+ is a UTC time, -0000 is used as zone.\n\ntime library should be required to use this method as follows.\n\n    require 'time'\n
rfc822 Time.rfc822()\n\n
round Time.round(p1 = v1)\nRounds sub seconds to a given precision in decimal digits (0 digits by\ndefault).\nIt returns a new time object.\n_ndigits_ should be zero or positive integer.\n\n    require 'time'\n\n    t = Time.utc(2010,3,30, 5,43,"25.123456789".to_r)\n    p t.iso8601(10)           #=> "2010-03-30T05:43:25.1234567890Z"\n    p t.round.iso8601(10)     #=> "2010-03-30T05:43:25.0000000000Z"\n    p t.round(0).iso8601(10)  #=> "2010-03-30T05:43:25.0000000000Z"\n    p t.round(1).iso8601(10)  #=> "2010-03-30T05:43:25.1000000000Z"\n    p t.round(2).iso8601(10)  #=> "2010-03-30T05:43:25.1200000000Z"\n    p t.round(3).iso8601(10)  #=> "2010-03-30T05:43:25.1230000000Z"\n    p t.round(4).iso8601(10)  #=> "2010-03-30T05:43:25.1235000000Z"\n    p t.round(5).iso8601(10)  #=> "2010-03-30T05:43:25.1234600000Z"\n    p t.round(6).iso8601(10)  #=> "2010-03-30T05:43:25.1234570000Z"\n    p t.round(7).iso8601(10)  #=> "2010-03-30T05:43:25.1234568000Z"\n    p t.round(8).iso8601(10)  #=> "2010-03-30T05:43:25.1234567900Z"\n    p t.round(9).iso8601(10)  #=> "2010-03-30T05:43:25.1234567890Z"\n    p t.round(10).iso8601(10) #=> "2010-03-30T05:43:25.1234567890Z"\n\n    t = Time.utc(1999,12,31, 23,59,59)\n    p((t + 0.4).round.iso8601(3))    #=> "1999-12-31T23:59:59.000Z"\n    p((t + 0.49).round.iso8601(3))   #=> "1999-12-31T23:59:59.000Z"\n    p((t + 0.5).round.iso8601(3))    #=> "2000-01-01T00:00:00.000Z"\n    p((t + 1.4).round.iso8601(3))    #=> "2000-01-01T00:00:00.000Z"\n    p((t + 1.49).round.iso8601(3))   #=> "2000-01-01T00:00:00.000Z"\n    p((t + 1.5).round.iso8601(3))    #=> "2000-01-01T00:00:01.000Z"\n\n    t = Time.utc(1999,12,31, 23,59,59)\n    p (t + 0.123456789).round(4).iso8601(6)  #=> "1999-12-31T23:59:59.123500Z"\n
saturday? Time.saturday?()\nReturns `true` if <i>time</i> represents Saturday.\n\n   t = Time.local(2006, 6, 10)      #=> 2006-06-10 00:00:00 -0500\n   t.saturday?                      #=> true\n
sec Time.sec()\nReturns the second of the minute (0..60)<em>[Yes, seconds really can\nrange from zero to 60. This allows the system to inject leap seconds\nevery now and then to correct for the fact that years are not really\na convenient number of hours long.]</em> for <i>time</i>.\n\n   t = Time.now   #=> 2007-11-19 08:25:02 -0600\n   t.sec          #=> 2\n
strftime Time.strftime(p1)\nFormats <i>time</i> according to the directives in the given format\nstring.\nThe directives begins with a percent (%) character.\nAny text not listed as a directive will be passed through to the\noutput string.\n\nThe directive consists of a percent (%) character,\nzero or more flags, optional minimum field width,\noptional modifier and a conversion specifier\nas follows.\n\n  %<flags><width><modifier><conversion>\n\nFlags:\n  -  don't pad a numerical output.\n  _  use spaces for padding.\n  0  use zeros for padding.\n  ^  upcase the result string.\n  change case.\n  :  use colons for %z.\n\nThe minimum field width specifies the minimum width.\n\nThe modifier is "E" and "O".\nThey are ignored.\n\nFormat directives:\n\n  Date (Year, Month, Day):\n    %Y - Year with century (can be negative, 4 digits at least)\n            -0001, 0000, 1995, 2009, 14292, etc.\n    %C - year / 100 (round down.  20 in 2009)\n    %y - year % 100 (00..99)\n\n    %m - Month of the year, zero-padded (01..12)\n            %_m  blank-padded ( 1..12)\n            %-m  no-padded (1..12)\n    %B - The full month name (``January'')\n            %^B  uppercased (``JANUARY'')\n    %b - The abbreviated month name (``Jan'')\n            %^b  uppercased (``JAN'')\n    %h - Equivalent to %b\n\n    %d - Day of the month, zero-padded (01..31)\n            %-d  no-padded (1..31)\n    %e - Day of the month, blank-padded ( 1..31)\n\n    %j - Day of the year (001..366)\n\n  Time (Hour, Minute, Second, Subsecond):\n    %H - Hour of the day, 24-hour clock, zero-padded (00..23)\n    %k - Hour of the day, 24-hour clock, blank-padded ( 0..23)\n    %I - Hour of the day, 12-hour clock, zero-padded (01..12)\n    %l - Hour of the day, 12-hour clock, blank-padded ( 1..12)\n    %P - Meridian indicator, lowercase (``am'' or ``pm'')\n    %p - Meridian indicator, uppercase (``AM'' or ``PM'')\n\n    %M - Minute of the hour (00..59)\n\n    %S - Second of the minute (00..60)\n\n    %L - Millisecond of the second (000..999)\n    %N - Fractional seconds digits, default is 9 digits (nanosecond)\n            %3N  millisecond (3 digits)\n            %6N  microsecond (6 digits)\n            %9N  nanosecond (9 digits)\n            %12N picosecond (12 digits)\n\n  Time zone:\n    %z - Time zone as hour and minute offset from UTC (e.g. +0900)\n            %:z - hour and minute offset from UTC with a colon (e.g. +09:00)\n            %::z - hour, minute and second offset from UTC (e.g. +09:00:00)\n    %Z - Time zone abbreviation name\n\n  Weekday:\n    %A - The full weekday name (``Sunday'')\n            %^A  uppercased (``SUNDAY'')\n    %a - The abbreviated name (``Sun'')\n            %^a  uppercased (``SUN'')\n    %u - Day of the week (Monday is 1, 1..7)\n    %w - Day of the week (Sunday is 0, 0..6)\n\n  ISO 8601 week-based year and week number:\n  The week 1 of YYYY starts with a Monday and includes YYYY-01-04.\n  The days in the year before the first week are in the last week of\n  the previous year.\n    %G - The week-based year\n    %g - The last 2 digits of the week-based year (00..99)\n    %V - Week number of the week-based year (01..53)\n\n  Week number:\n  The week 1 of YYYY starts with a Sunday or Monday (according to %U\n  or %W).  The days in the year before the first week are in week 0.\n    %U - Week number of the year.  The week starts with Sunday.  (00..53)\n    %W - Week number of the year.  The week starts with Monday.  (00..53)\n\n  Seconds since the Epoch:\n    %s - Number of seconds since 1970-01-01 00:00:00 UTC.\n\n  Literal string:\n    %n - Newline character (\\n)\n    %t - Tab character (\t)\n    %% - Literal ``%'' character\n\n  Combination:\n    %c - date and time (%a %b %e %T %Y)\n    %D - Date (%m/%d/%y)\n    %F - The ISO 8601 date format (%Y-%m-%d)\n    %v - VMS date (%e-%^b-%4Y)\n    %x - Same as %D\n    %X - Same as %T\n    %r - 12-hour time (%I:%M:%S %p)\n    %R - 24-hour time (%H:%M)\n    %T - 24-hour time (%H:%M:%S)\n\nThis method is similar to strftime() function defined in ISO C and POSIX.\nSeveral directives (%a, %A, %b, %B, %c, %p, %r, %x, %X, %E*, %O* and %Z)\nare locale dependent in the function.\nHowever this method is locale independent since Ruby 1.9.\nSo, the result may differ even if a same format string is used in other\nsystems such as C.\nIt is good practice to avoid %x and %X because there are corresponding\nlocale independent representations, %D and %T.\n\nExamples:\n\n  t = Time.new(2007,11,19,8,37,48,"-06:00") #=> 2007-11-19 08:37:48 -0600\n  t.strftime("Printed on %m/%d/%Y")   #=> "Printed on 11/19/2007"\n  t.strftime("at %I:%M%p")            #=> "at 08:37AM"\n\nVarious ISO 8601 formats:\n  %Y%m%d           => 20071119                  Calendar date (basic)\n  %F               => 2007-11-19                Calendar date (extended)\n  %Y-%m            => 2007-11                   Calendar date, reduced\n  accuracy, specific month\n  %Y               => 2007                      Calendar date, reduced\n  accuracy, specific year\n  %C               => 20                        Calendar date, reduced\n  accuracy, specific century\n  %Y%j             => 2007323                   Ordinal date (basic)\n  %Y-%j            => 2007-323                  Ordinal date (extended)\n  %GW%V%u          => 2007W471                  Week date (basic)\n  %G-W%V-%u        => 2007-W47-1                Week date (extended)\n  %GW%V            => 2007W47                   Week date, reduced accuracy,\n  specific week (basic)\n  %G-W%V           => 2007-W47                  Week date, reduced accuracy,\n  specific week (extended)\n  %H%M%S           => 083748                    Local time (basic)\n  %T               => 08:37:48                  Local time (extended)\n  %H%M             => 0837                      Local time, reduced accuracy,\n  specific minute (basic)\n  %H:%M            => 08:37                     Local time, reduced accuracy,\n  specific minute (extended)\n  %H               => 08                        Local time, reduced accuracy,\n  specific hour\n  %H%M%S,%L        => 083748,000                Local time with decimal\n  fraction, comma as decimal sign (basic)\n  %T,%L            => 08:37:48,000              Local time with decimal\n  fraction, comma as decimal sign (extended)\n  %H%M%S.%L        => 083748.000                Local time with decimal\n  fraction, full stop as decimal sign (basic)\n  %T.%L            => 08:37:48.000              Local time with decimal\n  fraction, full stop as decimal sign (extended)\n  %H%M%S%z         => 083748-0600               Local time and the difference\n  from UTC (basic)\n  %T%:z            => 08:37:48-06:00            Local time and the difference\n  from UTC (extended)\n  %Y%m%dT%H%M%S%z  => 20071119T083748-0600      Date and time of day for\n  calendar date (basic)\n  %FT%T%:z         => 2007-11-19T08:37:48-06:00 Date and time of day for\n  calendar date (extended)\n  %Y%jT%H%M%S%z    => 2007323T083748-0600       Date and time of day for\n  ordinal date (basic)\n  %Y-%jT%T%:z      => 2007-323T08:37:48-06:00   Date and time of day for\n  ordinal date (extended)\n  %GW%V%uT%H%M%S%z => 2007W471T083748-0600      Date and time of day for\n  week date (basic)\n  %G-W%V-%uT%T%:z  => 2007-W47-1T08:37:48-06:00 Date and time of day for\n  week date (extended)\n  %Y%m%dT%H%M      => 20071119T0837             Calendar date and local time\n  (basic)\n  %FT%R            => 2007-11-19T08:37          Calendar date and local time\n  (extended)\n  %Y%jT%H%MZ       => 2007323T0837Z             Ordinal date and UTC of day\n  (basic)\n  %Y-%jT%RZ        => 2007-323T08:37Z           Ordinal date and UTC of day\n  (extended)\n  %GW%V%uT%H%M%z   => 2007W471T0837-0600        Week date and local time\n  and difference from UTC (basic)\n  %G-W%V-%uT%R%:z  => 2007-W47-1T08:37-06:00    Week date and local time\n  and difference from UTC (extended)\n
subsec Time.subsec()\nReturns just the fraction for <i>time</i>.\n\nThe result is possibly rational.\n\n   t = Time.now        #=> 2009-03-26 22:33:12 +0900\n   "%10.9f" % t.to_f   #=> "1238074392.940563917"\n   t.subsec            #=> (94056401/100000000)\n\nThe lowest digit of to_f and subsec is different because\nIEEE 754 double is not accurate enough to represent\nthe rational.\nThe accurate value is returned by subsec.\n
succ Time.succ()\nReturn a new time object, one second later than `time`.\nTime#succ is obsolete since 1.9.2 for time is not a discrete value.\n\n    t = Time.now       #=> 2007-11-19 08:23:57 -0600\n    t.succ             #=> 2007-11-19 08:23:58 -0600\n
sunday? Time.sunday?()\nReturns `true` if <i>time</i> represents Sunday.\n\n   t = Time.local(1990, 4, 1)       #=> 1990-04-01 00:00:00 -0600\n   t.sunday?                        #=> true\n
thursday? Time.thursday?()\nReturns `true` if <i>time</i> represents Thursday.\n\n   t = Time.local(1995, 12, 21)     #=> 1995-12-21 00:00:00 -0600\n   p t.thursday?                    #=> true\n
to_a Time.to_a()\nReturns a ten-element <i>array</i> of values for <i>time</i>:\n{`[ sec, min, hour, day, month, year, wday, yday, isdst, zone\n]`}. See the individual methods for an explanation of the\nvalid ranges of each value. The ten elements can be passed directly\nto `Time::utc` or `Time::local` to create a\nnew `Time`.\n\n   t = Time.now     #=> 2007-11-19 08:36:01 -0600\n   now = t.to_a     #=> [1, 36, 8, 19, 11, 2007, 1, 323, false, "CST"]\n
to_date Time.to_date()\nReturns a Date object which denotes self.\n
to_datetime Time.to_datetime()\nReturns a DateTime object which denotes self.\n
to_f Time.to_f()\nReturns the value of <i>time</i> as a floating point number of\nseconds since the Epoch.\n\n   t = Time.now\n   "%10.5f" % t.to_f   #=> "1270968744.77658"\n   t.to_i              #=> 1270968744\n\nNote that IEEE 754 double is not accurate enough to represent\nnumber of nanoseconds from the Epoch.\n
to_i Time.to_i()\nReturns the value of <i>time</i> as an integer number of seconds\nsince the Epoch.\n\n   t = Time.now\n   "%10.5f" % t.to_f   #=> "1270968656.89607"\n   t.to_i              #=> 1270968656\n
to_json Time.to_json(*args)\nStores class name (Time) with number of seconds since epoch and number of\nmicroseconds for Time as JSON string\n
to_r Time.to_r()\nReturns the value of <i>time</i> as a rational number of seconds\nsince the Epoch.\n\n   t = Time.now\n   p t.to_r            #=> (1270968792716287611/1000000000)\n\nThis methods is intended to be used to get an accurate value\nrepresenting nanoseconds from the Epoch.  You can use this\nto convert time to another Epoch.\n
to_s Time.to_s()\nReturns a string representing <i>time</i>. Equivalent to calling\n`Time#strftime` with a format string of\n```%Y-%m-%d` `%H:%M:%S` `%z`''\nfor a local time and\n```%Y-%m-%d` `%H:%M:%S` `UTC`''\nfor a UTC time.\n\n   Time.now.to_s       #=> "2007-10-05 16:09:51 +0900"\n   Time.now.utc.to_s   #=> "2007-10-05 07:09:51 UTC"\n
to_time Time.to_time()\nReturns a copy of self as local mode.\n
tuesday? Time.tuesday?()\nReturns `true` if <i>time</i> represents Tuesday.\n\n   t = Time.local(1991, 2, 19)      #=> 1991-02-19 00:00:00 -0600\n   p t.tuesday?                     #=> true\n
tv_nsec Time.tv_nsec()\nReturns just the number of nanoseconds for <i>time</i>.\n\n   t = Time.now        #=> 2007-11-17 15:18:03 +0900\n   "%10.9f" % t.to_f   #=> "1195280283.536151409"\n   t.nsec              #=> 536151406\n\nThe lowest digit of to_f and nsec is different because\nIEEE 754 double is not accurate enough to represent\nnanoseconds from the Epoch.\nThe accurate value is returned by nsec.\n
tv_sec Time.tv_sec()\nReturns the value of <i>time</i> as an integer number of seconds\nsince the Epoch.\n\n   t = Time.now\n   "%10.5f" % t.to_f   #=> "1270968656.89607"\n   t.to_i              #=> 1270968656\n
tv_usec Time.tv_usec()\nReturns just the number of microseconds for <i>time</i>.\n\n   t = Time.now        #=> 2007-11-19 08:03:26 -0600\n   "%10.6f" % t.to_f   #=> "1195481006.775195"\n   t.usec              #=> 775195\n
usec Time.usec()\nReturns just the number of microseconds for <i>time</i>.\n\n   t = Time.now        #=> 2007-11-19 08:03:26 -0600\n   "%10.6f" % t.to_f   #=> "1195481006.775195"\n   t.usec              #=> 775195\n
utc Time.utc()\nConverts <i>time</i> to UTC (GMT), modifying the receiver.\n\n   t = Time.now   #=> 2007-11-19 08:18:31 -0600\n   t.gmt?         #=> false\n   t.gmtime       #=> 2007-11-19 14:18:31 UTC\n   t.gmt?         #=> true\n\n   t = Time.now   #=> 2007-11-19 08:18:51 -0600\n   t.utc?         #=> false\n   t.utc          #=> 2007-11-19 14:18:51 UTC\n   t.utc?         #=> true\n
utc? Time.utc?()\nReturns `true` if <i>time</i> represents a time in UTC\n(GMT).\n\n   t = Time.now                        #=> 2007-11-19 08:15:23 -0600\n   t.utc?                              #=> false\n   t = Time.gm(2000,"jan",1,20,15,1)   #=> 2000-01-01 20:15:01 UTC\n   t.utc?                              #=> true\n\n   t = Time.now                        #=> 2007-11-19 08:16:03 -0600\n   t.gmt?                              #=> false\n   t = Time.gm(2000,1,1,20,15,1)       #=> 2000-01-01 20:15:01 UTC\n   t.gmt?                              #=> true\n
utc_offset Time.utc_offset()\nReturns the offset in seconds between the timezone of <i>time</i>\nand UTC.\n\n   t = Time.gm(2000,1,1,20,15,1)   #=> 2000-01-01 20:15:01 UTC\n   t.gmt_offset                    #=> 0\n   l = t.getlocal                  #=> 2000-01-01 14:15:01 -0600\n   l.gmt_offset                    #=> -21600\n
w3cdtf Time.w3cdtf()\n\n
wday Time.wday()\nReturns an integer representing the day of the week, 0..6, with\nSunday == 0.\n\n   t = Time.now   #=> 2007-11-20 02:35:35 -0600\n   t.wday         #=> 2\n   t.sunday?      #=> false\n   t.monday?      #=> false\n   t.tuesday?     #=> true\n   t.wednesday?   #=> false\n   t.thursday?    #=> false\n   t.friday?      #=> false\n   t.saturday?    #=> false\n
wednesday? Time.wednesday?()\nReturns `true` if <i>time</i> represents Wednesday.\n\n   t = Time.local(1993, 2, 24)      #=> 1993-02-24 00:00:00 -0600\n   p t.wednesday?                   #=> true\n
xmlschema Time.xmlschema(fraction_digits=0)\nReturns a string which represents the time as dateTime defined by XML\nSchema:\n\n  CCYY-MM-DDThh:mm:ssTZD\n  CCYY-MM-DDThh:mm:ss.sssTZD\n\nwhere TZD is Z or [+-]hh:mm.\n\nIf self is a UTC time, Z is used as TZD.  [+-]hh:mm is used otherwise.\n\n+fractional_seconds+ specifies a number of digits of fractional seconds.\nIts default value is 0.\n\ntime library should be required to use this method as follows.\n\n    require 'time'\n
yday Time.yday()\nReturns an integer representing the day of the year, 1..366.\n\n   t = Time.now   #=> 2007-11-19 08:32:31 -0600\n   t.yday         #=> 323\n
year Time.year()\nReturns the year for <i>time</i> (including the century).\n\n   t = Time.now   #=> 2007-11-19 08:27:51 -0600\n   t.year         #=> 2007\n
zone Time.zone()\nReturns the name of the time zone used for <i>time</i>. As of Ruby\n1.8, returns ``UTC'' rather than ``GMT'' for UTC times.\n\n   t = Time.gm(2000, "jan", 1, 20, 15, 1)\n   t.zone   #=> "UTC"\n   t = Time.local(2000, "jan", 1, 20, 15, 1)\n   t.zone   #=> "CST"\n
destination_encoding Encoding::UndefinedConversionError.destination_encoding()\nReturns the destination encoding as an encoding object.\n
destination_encoding_name Encoding::UndefinedConversionError.destination_encoding_name()\nReturns the destination encoding name as a string.\n
error_char Encoding::UndefinedConversionError.error_char()\nReturns the one-character string which cause\nEncoding::UndefinedConversionError.\n\n ec = Encoding::Converter.new("ISO-8859-1", "EUC-JP")\n begin\n   ec.convert("\xa0")\n rescue Encoding::UndefinedConversionError\n   puts $!.error_char.dump   #=> "\xC2\xA0"\n   p $!.error_char.encoding  #=> #<Encoding:UTF-8>\n end\n
source_encoding Encoding::UndefinedConversionError.source_encoding()\nReturns the source encoding as an encoding object.\n\nNote that the result may not be equal to the source encoding of\nthe encoding converter if the conversion has multiple steps.\n\n ec = Encoding::Converter.new("ISO-8859-1", "EUC-JP") # ISO-8859-1 -> UTF-8\n -> EUC-JP\n begin\n   ec.convert("\xa0") # NO-BREAK SPACE, which is available in UTF-8 but not\n   in EUC-JP.\n rescue Encoding::UndefinedConversionError\n   p $!.source_encoding              #=> #<Encoding:UTF-8>\n   p $!.destination_encoding         #=> #<Encoding:EUC-JP>\n   p $!.source_encoding_name         #=> "UTF-8"\n   p $!.destination_encoding_name    #=> "EUC-JP"\n end\n
source_encoding_name Encoding::UndefinedConversionError.source_encoding_name()\nReturns the source encoding name as a string.\n
destination_encoding Encoding::InvalidByteSequenceError.destination_encoding()\nReturns the destination encoding as an encoding object.\n
destination_encoding_name Encoding::InvalidByteSequenceError.destination_encoding_name()\nReturns the destination encoding name as a string.\n
error_bytes Encoding::InvalidByteSequenceError.error_bytes()\nReturns the discarded bytes when Encoding::InvalidByteSequenceError occurs.\n\n ec = Encoding::Converter.new("EUC-JP", "ISO-8859-1")\n begin\n   ec.convert("abc\xA1\xFFdef")\n rescue Encoding::InvalidByteSequenceError\n   p $!      #=> #<Encoding::InvalidByteSequenceError: "\xA1" followed by\n   "\xFF" on EUC-JP>\n   puts $!.error_bytes.dump          #=> "\xA1"\n   puts $!.readagain_bytes.dump      #=> "\xFF"\n end\n
incomplete_input? Encoding::InvalidByteSequenceError.incomplete_input?()\nReturns true if the invalid byte sequence error is caused by\npremature end of string.\n\n ec = Encoding::Converter.new("EUC-JP", "ISO-8859-1")\n\n begin\n   ec.convert("abc\xA1z")\n rescue Encoding::InvalidByteSequenceError\n   p $!      #=> #<Encoding::InvalidByteSequenceError: "\xA1" followed by\n   "z" on EUC-JP>\n   p $!.incomplete_input?    #=> false\n end\n\n begin\n   ec.convert("abc\xA1")\n   ec.finish\n rescue Encoding::InvalidByteSequenceError\n   p $!      #=> #<Encoding::InvalidByteSequenceError: incomplete "\xA1"\n   on EUC-JP>\n   p $!.incomplete_input?    #=> true\n end\n
readagain_bytes Encoding::InvalidByteSequenceError.readagain_bytes()\nReturns the bytes to be read again when Encoding::InvalidByteSequenceError\noccurs.\n
source_encoding Encoding::InvalidByteSequenceError.source_encoding()\nReturns the source encoding as an encoding object.\n\nNote that the result may not be equal to the source encoding of\nthe encoding converter if the conversion has multiple steps.\n\n ec = Encoding::Converter.new("ISO-8859-1", "EUC-JP") # ISO-8859-1 -> UTF-8\n -> EUC-JP\n begin\n   ec.convert("\xa0") # NO-BREAK SPACE, which is available in UTF-8 but not\n   in EUC-JP.\n rescue Encoding::UndefinedConversionError\n   p $!.source_encoding              #=> #<Encoding:UTF-8>\n   p $!.destination_encoding         #=> #<Encoding:EUC-JP>\n   p $!.source_encoding_name         #=> "UTF-8"\n   p $!.destination_encoding_name    #=> "EUC-JP"\n end\n
source_encoding_name Encoding::InvalidByteSequenceError.source_encoding_name()\nReturns the source encoding name as a string.\n
asciicompat_encoding Encoding::Converter.asciicompat_encoding(p1)\nReturns the corresponding ASCII compatible encoding.\n\nReturns nil if the argument is an ASCII compatible encoding.\n\n"corresponding ASCII compatible encoding" is a ASCII compatible encoding which\ncan represents exactly the same characters as the given ASCII incompatible\nencoding.\nSo, no conversion undefined error occurs when converting between the two\nencodings.\n\n  Encoding::Converter.asciicompat_encoding("ISO-2022-JP") #=>\n  #<Encoding:stateless-ISO-2022-JP>\n  Encoding::Converter.asciicompat_encoding("UTF-16BE") #=> #<Encoding:UTF-8>\n  Encoding::Converter.asciicompat_encoding("UTF-8") #=> nil\n
new Encoding::Converter.new(*args)\npossible options elements:\n  hash form:\n    :invalid => nil            # raise error on invalid byte sequence (default)\n    :invalid => :replace       # replace invalid byte sequence\n    :undef => nil              # raise error on undefined conversion (default)\n    :undef => :replace         # replace undefined conversion\n    :replace => string         # replacement string ("?" or "\uFFFD" if\n    not specified)\n    :newline => :universal     # decorator for converting CRLF and CR to LF\n    :newline => :crlf          # decorator for converting LF to CRLF\n    :newline => :cr            # decorator for converting LF to CR\n    :universal_newline => true # decorator for converting CRLF and CR to LF\n    :crlf_newline => true      # decorator for converting LF to CRLF\n    :cr_newline => true        # decorator for converting LF to CR\n    :xml => :text              # escape as XML CharData.\n    :xml => :attr              # escape as XML AttValue\n  integer form:\n    Encoding::Converter::INVALID_REPLACE\n    Encoding::Converter::UNDEF_REPLACE\n    Encoding::Converter::UNDEF_HEX_CHARREF\n    Encoding::Converter::UNIVERSAL_NEWLINE_DECORATOR\n    Encoding::Converter::CRLF_NEWLINE_DECORATOR\n    Encoding::Converter::CR_NEWLINE_DECORATOR\n    Encoding::Converter::XML_TEXT_DECORATOR\n    Encoding::Converter::XML_ATTR_CONTENT_DECORATOR\n    Encoding::Converter::XML_ATTR_QUOTE_DECORATOR\n\nEncoding::Converter.new creates an instance of Encoding::Converter.\n\nSource_encoding and destination_encoding should be a string or\nEncoding object.\n\nopt should be nil, a hash or an integer.\n\nconvpath should be an array.\nconvpath may contain\n- two-element arrays which contain encodings or encoding names, or\n- strings representing decorator names.\n\nEncoding::Converter.new optionally takes an option.\nThe option should be a hash or an integer.\nThe option hash can contain :invalid => nil, etc.\nThe option integer should be logical-or of constants such as\nEncoding::Converter::INVALID_REPLACE, etc.\n\n[:invalid => nil]\n  Raise error on invalid byte sequence.  This is a default behavior.\n[:invalid => :replace]\n  Replace invalid byte sequence by replacement string.\n[:undef => nil]\n  Raise an error if a character in source_encoding is not defined in\n  destination_encoding.\n  This is a default behavior.\n[:undef => :replace]\n  Replace undefined character in destination_encoding with replacement string.\n[:replace => string]\n  Specify the replacement string.\n  If not specified, "\uFFFD" is used for Unicode encodings and "?" for others.\n[:universal_newline => true]\n  Convert CRLF and CR to LF.\n[:crlf_newline => true]\n  Convert LF to CRLF.\n[:cr_newline => true]\n  Convert LF to CR.\n[:xml => :text]\n  Escape as XML CharData.\n  This form can be used as a HTML 4.0 #PCDATA.\n  - '&' -> '&amp;'\n  - '<' -> '&lt;'\n  - '>' -> '&gt;'\n  - undefined characters in destination_encoding -> hexadecimal CharRef such\n  as &#xHH;\n[:xml => :attr]\n  Escape as XML AttValue.\n  The converted result is quoted as "...".\n  This form can be used as a HTML 4.0 attribute value.\n  - '&' -> '&amp;'\n  - '<' -> '&lt;'\n  - '>' -> '&gt;'\n  - '"' -> '&quot;'\n  - undefined characters in destination_encoding -> hexadecimal CharRef such\n  as &#xHH;\n\nExamples:\n UTF-16BE to UTF-8\n  ec = Encoding::Converter.new("UTF-16BE", "UTF-8")\n Usually, decorators such as newline conversion are inserted last.\n  ec = Encoding::Converter.new("UTF-16BE", "UTF-8", :universal_newline => true)\n  p ec.convpath #=> [[#<Encoding:UTF-16BE>, #<Encoding:UTF-8>],\n    "universal_newline"]\n But, if the last encoding is ASCII incompatible,\n decorators are inserted before the last conversion.\n  ec = Encoding::Converter.new("UTF-8", "UTF-16BE", :crlf_newline => true)\n  p ec.convpath #=> ["crlf_newline",\n    [#<Encoding:UTF-8>, #<Encoding:UTF-16BE>]]\n Conversion path can be specified directly.\n  ec = Encoding::Converter.new(["universal_newline", ["EUC-JP", "UTF-8"],\n  ["UTF-8", "UTF-16BE"]])\n  p ec.convpath #=> ["universal_newline",\n    [#<Encoding:EUC-JP>, #<Encoding:UTF-8>],\n    [#<Encoding:UTF-8>, #<Encoding:UTF-16BE>]]\n
search_convpath Encoding::Converter.search_convpath(*args)\nReturns a conversion path.\n\n p Encoding::Converter.search_convpath("ISO-8859-1", "EUC-JP")\n=> [[#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>],\n    [#<Encoding:UTF-8>, #<Encoding:EUC-JP>]]\n\n p Encoding::Converter.search_convpath("ISO-8859-1", "EUC-JP",\n universal_newline: true)\n or\n p Encoding::Converter.search_convpath("ISO-8859-1", "EUC-JP", newline:\n :universal)\n=> [[#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>],\n    [#<Encoding:UTF-8>, #<Encoding:EUC-JP>],\n    "universal_newline"]\n\n p Encoding::Converter.search_convpath("ISO-8859-1", "UTF-32BE",\n universal_newline: true)\n or\n p Encoding::Converter.search_convpath("ISO-8859-1", "UTF-32BE", newline:\n :universal)\n=> [[#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>],\n    "universal_newline",\n    [#<Encoding:UTF-8>, #<Encoding:UTF-32BE>]]\n
convert Encoding::Converter.convert(p1)\nConvert source_string and return destination_string.\n\nsource_string is assumed as a part of source.\ni.e.  :partial_input=>true is specified internally.\nfinish method should be used last.\n\n  ec = Encoding::Converter.new("utf-8", "euc-jp")\n  puts ec.convert("\u3042").dump     #=> "\xA4\xA2"\n  puts ec.finish.dump                #=> ""\n\n  ec = Encoding::Converter.new("euc-jp", "utf-8")\n  puts ec.convert("\xA4").dump       #=> ""\n  puts ec.convert("\xA2").dump       #=> "\xE3\x81\x82"\n  puts ec.finish.dump                #=> ""\n\n  ec = Encoding::Converter.new("utf-8", "iso-2022-jp")\n  puts ec.convert("\xE3").dump       #=> "".force_encoding("ISO-2022-JP")\n  puts ec.convert("\x81").dump       #=> "".force_encoding("ISO-2022-JP")\n  puts ec.convert("\x82").dump       #=>\n  "\e$B$\"".force_encoding("ISO-2022-JP")\n  puts ec.finish.dump                #=> "\e(B".force_encoding("ISO-2022-JP")\n\nIf a conversion error occur,\nEncoding::UndefinedConversionError or\nEncoding::InvalidByteSequenceError is raised.\nEncoding::Converter#convert doesn't supply methods to recover or restart\nfrom these exceptions.\nWhen you want to handle these conversion errors,\nuse Encoding::Converter#primitive_convert.\n
convpath Encoding::Converter.convpath()\nReturns the conversion path of ec.\n\nThe result is an array of conversions.\n\n  ec = Encoding::Converter.new("ISO-8859-1", "EUC-JP", crlf_newline: true)\n  p ec.convpath\n=> [[#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>],\n    [#<Encoding:UTF-8>, #<Encoding:EUC-JP>],\n    "crlf_newline"]\n\nEach element of the array is a pair of encodings or a string.\nA pair means an encoding conversion.\nA string means a decorator.\n\nIn the above example, [#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>] means\na converter from ISO-8859-1 to UTF-8.\n"crlf_newline" means newline converter from LF to CRLF.\n
destination_encoding Encoding::Converter.destination_encoding()\nReturns the destination encoding as an Encoding object.\n
finish Encoding::Converter.finish()\nFinishes the converter.\nIt returns the last part of the converted string.\n\n  ec = Encoding::Converter.new("utf-8", "iso-2022-jp")\n  p ec.convert("\u3042")     #=> "\e$B$\""\n  p ec.finish                #=> "\e(B"\n
insert_output Encoding::Converter.insert_output(p1)\nInserts string into the encoding converter.\nThe string will be converted to the destination encoding and\noutput on later conversions.\n\nIf the destination encoding is stateful,\nstring is converted according to the state and the state is updated.\n\nThis method should be used only when a conversion error occurs.\n\n ec = Encoding::Converter.new("utf-8", "iso-8859-1")\n src = "HIRAGANA LETTER A is \u{3042}."\n dst = ""\n p ec.primitive_convert(src, dst)    #=> :undefined_conversion\n puts "[#{dst.dump}, #{src.dump}]"   #=> ["HIRAGANA LETTER A is ", "."]\n ec.insert_output("<err>")\n p ec.primitive_convert(src, dst)    #=> :finished\n puts "[#{dst.dump}, #{src.dump}]"   #=> ["HIRAGANA LETTER A is <err>.", ""]\n\n ec = Encoding::Converter.new("utf-8", "iso-2022-jp")\n src = "\u{306F 3041 3068 2661 3002}" # U+2661 is not representable in\n iso-2022-jp\n dst = ""\n p ec.primitive_convert(src, dst)    #=> :undefined_conversion\n puts "[#{dst.dump}, #{src.dump}]"   #=>\n ["\e$B$O$!$H".force_encoding("ISO-2022-JP"), "\xE3\x80\x82"]\n ec.insert_output "?"                # state change required to output "?".\n p ec.primitive_convert(src, dst)    #=> :finished\n puts "[#{dst.dump}, #{src.dump}]"   #=>\n ["\e$B$O$!$H\e(B?\e$B!#\e(B".force_encoding("ISO-2022-JP"), ""]\n
inspect Encoding::Converter.inspect()\nReturns a printable version of <i>ec</i>\n\n  ec = Encoding::Converter.new("iso-8859-1", "utf-8")\n  puts ec.inspect    #=> #<Encoding::Converter: ISO-8859-1 to UTF-8>\n
last_error Encoding::Converter.last_error()\nReturns an exception object for the last conversion.\nReturns nil if the last conversion did not produce an error.\n\n"error" means that\nEncoding::InvalidByteSequenceError and Encoding::UndefinedConversionError for\nEncoding::Converter#convert and\n:invalid_byte_sequence, :incomplete_input and :undefined_conversion for\nEncoding::Converter#primitive_convert.\n\n ec = Encoding::Converter.new("utf-8", "iso-8859-1")\n p ec.primitive_convert(src="\xf1abcd", dst="")       #=>\n :invalid_byte_sequence\n p ec.last_error      #=> #<Encoding::InvalidByteSequenceError: "\xF1"\n followed by "a" on UTF-8>\n p ec.primitive_convert(src, dst, nil, 1)             #=>\n :destination_buffer_full\n p ec.last_error      #=> nil\n
primitive_convert Encoding::Converter.primitive_convert(p1, p2, p3 = v3, p4 = v4, p5 = v5,\np6 = {})\npossible opt elements:\n  hash form:\n    :partial_input => true           # source buffer may be part of larger\n    source\n    :after_output => true            # stop conversion after output before\n    input\n  integer form:\n    Encoding::Converter::PARTIAL_INPUT\n    Encoding::Converter::AFTER_OUTPUT\n\npossible results:\n   :invalid_byte_sequence\n   :incomplete_input\n   :undefined_conversion\n   :after_output\n   :destination_buffer_full\n   :source_buffer_empty\n   :finished\n\nprimitive_convert converts source_buffer into destination_buffer.\n\nsource_buffer should be a string or nil.\nnil means a empty string.\n\ndestination_buffer should be a string.\n\ndestination_byteoffset should be an integer or nil.\nnil means the end of destination_buffer.\nIf it is omitted, nil is assumed.\n\ndestination_bytesize should be an integer or nil.\nnil means unlimited.\nIf it is omitted, nil is assumed.\n\nopt should be nil, a hash or an integer.\nnil means no flags.\nIf it is omitted, nil is assumed.\n\nprimitive_convert converts the content of source_buffer from beginning\nand store the result into destination_buffer.\n\ndestination_byteoffset and destination_bytesize specify the region which\nthe converted result is stored.\ndestination_byteoffset specifies the start position in destination_buffer\nin bytes.\nIf destination_byteoffset is nil,\ndestination_buffer.bytesize is used for appending the result.\ndestination_bytesize specifies maximum number of bytes.\nIf destination_bytesize is nil,\ndestination size is unlimited.\nAfter conversion, destination_buffer is resized to\ndestination_byteoffset + actually produced number of bytes.\nAlso destination_buffer's encoding is set to destination_encoding.\n\nprimitive_convert drops the converted part of source_buffer.\nthe dropped part is converted in destination_buffer or\nbuffered in Encoding::Converter object.\n\nprimitive_convert stops conversion when one of following condition met.\n- invalid byte sequence found in source buffer (:invalid_byte_sequence)\n- unexpected end of source buffer (:incomplete_input)\n  this occur only when :partial_input is not specified.\n- character not representable in output encoding (:undefined_conversion)\n- after some output is generated, before input is done (:after_output)\n  this occur only when :after_output is specified.\n- destination buffer is full (:destination_buffer_full)\n  this occur only when destination_bytesize is non-nil.\n- source buffer is empty (:source_buffer_empty)\n  this occur only when :partial_input is specified.\n- conversion is finished (:finished)\n\nexample:\n  ec = Encoding::Converter.new("UTF-8", "UTF-16BE")\n  ret = ec.primitive_convert(src="pi", dst="", nil, 100)\n  p [ret, src, dst] #=> [:finished, "", "\x00p\x00i"]\n\n  ec = Encoding::Converter.new("UTF-8", "UTF-16BE")\n  ret = ec.primitive_convert(src="pi", dst="", nil, 1)\n  p [ret, src, dst] #=> [:destination_buffer_full, "i", "\x00"]\n  ret = ec.primitive_convert(src, dst="", nil, 1)\n  p [ret, src, dst] #=> [:destination_buffer_full, "", "p"]\n  ret = ec.primitive_convert(src, dst="", nil, 1)\n  p [ret, src, dst] #=> [:destination_buffer_full, "", "\x00"]\n  ret = ec.primitive_convert(src, dst="", nil, 1)\n  p [ret, src, dst] #=> [:finished, "", "i"]\n
primitive_errinfo Encoding::Converter.primitive_errinfo()\nprimitive_errinfo returns important information regarding the last error\nas a 5-element array:\n\n  [result, enc1, enc2, error_bytes, readagain_bytes]\n\nresult is the last result of primitive_convert.\n\nOther elements are only meaningful when result is\n:invalid_byte_sequence, :incomplete_input or :undefined_conversion.\n\nenc1 and enc2 indicate a conversion step as a pair of strings.\nFor example, a converter from EUC-JP to ISO-8859-1 converts\na string as follows: EUC-JP -> UTF-8 -> ISO-8859-1.\nSo [enc1, enc2] is either ["EUC-JP", "UTF-8"] or ["UTF-8", "ISO-8859-1"].\n\nerror_bytes and readagain_bytes indicate the byte sequences which caused\nthe error.\nerror_bytes is discarded portion.\nreadagain_bytes is buffered portion which is read again on next conversion.\n\nExample:\n \xff is invalid as EUC-JP.\n  ec = Encoding::Converter.new("EUC-JP", "Shift_JIS")\n  ec.primitive_convert(src="\xff", dst="", nil, 10)\n  p ec.primitive_errinfo\n=> [:invalid_byte_sequence, "EUC-JP", "UTF-8", "\xFF", ""]\n HIRAGANA LETTER A (\xa4\xa2 in EUC-JP) is not representable in ISO-8859-1.\n Since this error is occur in UTF-8 to ISO-8859-1 conversion,\n error_bytes is HIRAGANA LETTER A in UTF-8 (\xE3\x81\x82).\n  ec = Encoding::Converter.new("EUC-JP", "ISO-8859-1")\n  ec.primitive_convert(src="\xa4\xa2", dst="", nil, 10)\n  p ec.primitive_errinfo\n=> [:undefined_conversion, "UTF-8", "ISO-8859-1", "\xE3\x81\x82", ""]\n partial character is invalid\n  ec = Encoding::Converter.new("EUC-JP", "ISO-8859-1")\n  ec.primitive_convert(src="\xa4", dst="", nil, 10)\n  p ec.primitive_errinfo\n=> [:incomplete_input, "EUC-JP", "UTF-8", "\xA4", ""]\n Encoding::Converter::PARTIAL_INPUT prevents invalid errors by\n partial characters.\n  ec = Encoding::Converter.new("EUC-JP", "ISO-8859-1")\n  ec.primitive_convert(src="\xa4", dst="", nil, 10,\n  Encoding::Converter::PARTIAL_INPUT)\n  p ec.primitive_errinfo\n=> [:source_buffer_empty, nil, nil, nil, nil]\n \xd8\x00\x00@ is invalid as UTF-16BE because\n no low surrogate after high surrogate (\xd8\x00).\n It is detected by 3rd byte (\00) which is part of next character.\n So the high surrogate (\xd8\x00) is discarded and\n the 3rd byte is read again later.\n Since the byte is buffered in ec, it is dropped from src.\n  ec = Encoding::Converter.new("UTF-16BE", "UTF-8")\n  ec.primitive_convert(src="\xd8\x00\x00@", dst="", nil, 10)\n  p ec.primitive_errinfo\n=> [:invalid_byte_sequence, "UTF-16BE", "UTF-8", "\xD8\x00", "\x00"]\n  p src\n=> "@"\n Similar to UTF-16BE, \x00\xd8@\x00 is invalid as UTF-16LE.\n The problem is detected by 4th byte.\n  ec = Encoding::Converter.new("UTF-16LE", "UTF-8")\n  ec.primitive_convert(src="\x00\xd8@\x00", dst="", nil, 10)\n  p ec.primitive_errinfo\n=> [:invalid_byte_sequence, "UTF-16LE", "UTF-8", "\x00\xD8", "@\x00"]\n  p src\n=> ""\n
putback Encoding::Converter.putback(p1 = v1)\ncall-seq\n  ec.putback                    -> string\n  ec.putback(max_numbytes)      -> string\n\nPut back the bytes which will be converted.\n\nThe bytes are caused by invalid_byte_sequence error.\nWhen invalid_byte_sequence error, some bytes are discarded and\nsome bytes are buffered to be converted later.\nThe latter bytes can be put back.\nIt can be observed by\nEncoding::InvalidByteSequenceError#readagain_bytes and\nEncoding::Converter#primitive_errinfo.\n\n  ec = Encoding::Converter.new("utf-16le", "iso-8859-1")\n  src = "\x00\xd8\x61\x00"\n  dst = ""\n  p ec.primitive_convert(src, dst)   #=> :invalid_byte_sequence\n  p ec.primitive_errinfo     #=> [:invalid_byte_sequence, "UTF-16LE", "UTF-8",\n  "\x00\xD8", "a\x00"]\n  p ec.putback               #=> "a\x00"\n  p ec.putback               #=> ""          # no more bytes to put back\n
replacement Encoding::Converter.replacement()\nReturns the replacement string.\n\n ec = Encoding::Converter.new("euc-jp", "us-ascii")\n p ec.replacement    #=> "?"\n\n ec = Encoding::Converter.new("euc-jp", "utf-8")\n p ec.replacement    #=> "\uFFFD"\n
replacement= Encoding::Converter.replacement=(p1)\nSets the replacement string.\n\n ec = Encoding::Converter.new("utf-8", "us-ascii", :undef => :replace)\n ec.replacement = "<undef>"\n p ec.convert("a \u3042 b")      #=> "a <undef> b"\n
source_encoding Encoding::Converter.source_encoding()\nReturns the source encoding as an Encoding object.\n
compile Regexp.compile(*args)\nSynonym for `Regexp.new`\n
escape Regexp.escape(p1)\nEscapes any characters that would have special meaning in a regular\nexpression. Returns a new escaped string, or self if no characters are\nescaped.  For any string,\n`Regexp.new(Regexp.escape(<i>str</i>))=~<i>str</i>` will be true.\n\n   Regexp.escape('\*?{}.')   #=> \\\*\?\{\}\.\n
json_create Regexp.json_create(object)\nDeserializes JSON string by constructing new Regexp object with source\n<tt>s</tt> (Regexp or String) and options <tt>o</tt> serialized by\n<tt>to_json</tt>\n
last_match Regexp.last_match(p1 = v1)\nThe first form returns the `MatchData` object generated by the\nlast successful pattern match. Equivalent to reading the global variable\n`$~`. The second form returns the <i>n</i>th field in this\n`MatchData` object.\n<em>n</em> can be a string or symbol to reference a named capture.\n\nNote that the `last_match` is local to the thread and method scope\nof the method that did the pattern match.\n\n   /c(.)t/ =~ 'cat'        #=> 0\n   Regexp.last_match       #=> #<MatchData "cat" 1:"a">\n   Regexp.last_match(0)    #=> "cat"\n   Regexp.last_match(1)    #=> "a"\n   Regexp.last_match(2)    #=> nil\n\n   /(?<lhs>\w+)\s*=\s*(?<rhs>\w+)/ =~ "var = val"\n   Regexp.last_match       #=> #<MatchData "var = val" lhs:"var" rhs:"val">\n   Regexp.last_match(:lhs) #=> "var"\n   Regexp.last_match(:rhs) #=> "val"\n
new Regexp.new(*args)\nConstructs a new regular expression from <i>pattern</i>, which can be either\na `String` or a `Regexp` (in which case that regexp's\noptions are propagated, and new options may not be specified (a change as of\nRuby 1.8). If <i>options</i> is a `Fixnum`, it should be one or\nmore of the constants `Regexp::EXTENDED`,\n`Regexp::IGNORECASE`, and `Regexp::MULTILINE`,\n<em>or</em>-ed together. Otherwise, if <i>options</i> is not\n`nil`, the regexp will be case insensitive.\nWhen the <i>lang</i> parameter is `n' or `N' sets the regexp no encoding.\n\n   r1 = Regexp.new('^a-z+:\\s+\w+')           #=> /^a-z+:\s+\w+/\n   r2 = Regexp.new('cat', true)               #=> /cat/i\n   r3 = Regexp.new('dog', Regexp::EXTENDED)   #=> /dog/x\n   r4 = Regexp.new(r2)                        #=> /cat/i\n
quote Regexp.quote(p1)\nEscapes any characters that would have special meaning in a regular\nexpression. Returns a new escaped string, or self if no characters are\nescaped.  For any string,\n`Regexp.new(Regexp.escape(<i>str</i>))=~<i>str</i>` will be true.\n\n   Regexp.escape('\*?{}.')   #=> \\\*\?\{\}\.\n
try_convert Regexp.try_convert(p1)\nTry to convert <i>obj</i> into a Regexp, using to_regexp method.\nReturns converted regexp or nil if <i>obj</i> cannot be converted\nfor any reason.\n\n   Regexp.try_convert(/re/)         #=> /re/\n   Regexp.try_convert("re")         #=> nil\n\n   o = Object.new\n   Regexp.try_convert(o)            #=> nil\n   def o.to_regexp() /foo/ end\n   Regexp.try_convert(o)            #=> /foo/\n
union Regexp.union(*args)\nReturn a `Regexp` object that is the union of the given\n<em>pattern</em>s, i.e., will match any of its parts. The <em>pattern</em>s\ncan be Regexp objects, in which case their options will be preserved, or\nStrings. If no patterns are given, returns `/(?!)/`.\nThe behavior is unspecified if any given <em>pattern</em> contains capture.\n\n   Regexp.union                         #=> /(?!)/\n   Regexp.union("penzance")             #=> /penzance/\n   Regexp.union("a+b*c")                #=> /a\+b\*c/\n   Regexp.union("skiing", "sledding")   #=> /skiing|sledding/\n   Regexp.union(["skiing", "sledding"]) #=> /skiing|sledding/\n   Regexp.union(/dogs/, /cats/i)        #=> /(?-mix:dogs)|(?i-mx:cats)/\n
as_json Regexp.as_json(*)\nReturns a hash, that will be turned into a JSON object and represent this\nobject.\n
casefold? Regexp.casefold?()\nReturns the value of the case-insensitive flag.\n\n    /a/.casefold?           #=> false\n    /a/i.casefold?          #=> true\n    /(?i:a)/.casefold?      #=> false\n
encoding Regexp.encoding()\nReturns the Encoding object that represents the encoding of obj.\n
eql? Regexp.eql?(p1)\nEquality---Two regexps are equal if their patterns are identical, they have\nthe same character set code, and their `casefold?` values are the\nsame.\n\n   /abc/  == /abc/x   #=> false\n   /abc/  == /abc/i   #=> false\n   /abc/  == /abc/n   #=> false\n   /abc/u == /abc/n   #=> false\n
fixed_encoding? Regexp.fixed_encoding?()\nReturns false if rxp is applicable to\na string with any ASCII compatible encoding.\nReturns true otherwise.\n\n    r = /a/\n    r.fixed_encoding?                               #=> false\n    r =~ "\u{6666} a"                               #=> 2\n    r =~ "\xa1\xa2 a".force_encoding("euc-jp")      #=> 2\n    r =~ "abc".force_encoding("euc-jp")             #=> 0\n\n    r = /a/u\n    r.fixed_encoding?                               #=> true\n    r.encoding                                      #=> #<Encoding:UTF-8>\n    r =~ "\u{6666} a"                               #=> 2\n    r =~ "\xa1\xa2".force_encoding("euc-jp")        #=> ArgumentError\n    r =~ "abc".force_encoding("euc-jp")             #=> 0\n\n    r = /\u{6666}/\n    r.fixed_encoding?                               #=> true\n    r.encoding                                      #=> #<Encoding:UTF-8>\n    r =~ "\u{6666} a"                               #=> 0\n    r =~ "\xa1\xa2".force_encoding("euc-jp")        #=> ArgumentError\n    r =~ "abc".force_encoding("euc-jp")             #=> nil\n
hash Regexp.hash()\nProduce a hash based on the text and options of this regular expression.\n
inspect Regexp.inspect()\nProduce a nicely formatted string-version of _rxp_. Perhaps surprisingly,\n`#inspect` actually produces the more natural version of\nthe string than `#to_s`.\n\n     /ab+c/ix.inspect        #=> "/ab+c/ix"\n
match Regexp.match(p1, p2 = v2)\nReturns a `MatchData` object describing the match, or\n`nil` if there was no match. This is equivalent to retrieving the\nvalue of the special variable `$~` following a normal match.\nIf the second parameter is present, it specifies the position in the string\nto begin the search.\n\n   /(.)(.)(.)/.match("abc")[2]   #=> "b"\n   /(.)(.)/.match("abc", 1)[2]   #=> "c"\n\nIf a block is given, invoke the block with MatchData if match succeed, so\nthat you can write\n\n   pat.match(str) {|m| ...}\n\ninstead of\n\n   if m = pat.match(str)\n     ...\n   end\n\nThe return value is a value from block execution in this case.\n
named_captures Regexp.named_captures()\nReturns a hash representing information about named captures of <i>rxp</i>.\n\nA key of the hash is a name of the named captures.\nA value of the hash is an array which is list of indexes of corresponding\nnamed captures.\n\n   /(?<foo>.)(?<bar>.)/.named_captures\n=> {"foo"=>[1], "bar"=>[2]}\n\n   /(?<foo>.)(?<foo>.)/.named_captures\n=> {"foo"=>[1, 2]}\n\nIf there are no named captures, an empty hash is returned.\n\n   /(.)(.)/.named_captures\n=> {}\n
names Regexp.names()\nReturns a list of names of captures as an array of strings.\n\n    /(?<foo>.)(?<bar>.)(?<baz>.)/.names\n=> ["foo", "bar", "baz"]\n\n    /(?<foo>.)(?<foo>.)/.names\n=> ["foo"]\n\n    /(.)(.)/.names\n=> []\n
options Regexp.options()\nReturns the set of bits corresponding to the options used when creating this\nRegexp (see `Regexp::new` for details. Note that additional bits\nmay be set in the returned options: these are used internally by the regular\nexpression code. These extra bits are ignored if the options are passed to\n`Regexp::new`.\n\n   Regexp::IGNORECASE                  #=> 1\n   Regexp::EXTENDED                    #=> 2\n   Regexp::MULTILINE                   #=> 4\n\n   /cat/.options                       #=> 0\n   /cat/ix.options                     #=> 3\n   Regexp.new('cat', true).options     #=> 1\n   /\xa1\xa2/e.options                 #=> 16\n\n   r = /cat/ix\n   Regexp.new(r.source, r.options)     #=> /cat/ix\n
source Regexp.source()\nReturns the original string of the pattern.\n\n    /ab+c/ix.source #=> "ab+c"\n\nNote that escape sequences are retained as is.\n\n   /\x20\+/.source  #=> "\\x20\\+"\n
to_json Regexp.to_json(*)\nStores class name (Regexp) with options <tt>o</tt> and source <tt>s</tt>\n(Regexp or String) as JSON string\n
to_s Regexp.to_s()\nReturns a string containing the regular expression and its options (using the\n`(?opts:source)` notation. This string can be fed back in to\n`Regexp::new` to a regular expression with the same semantics as\nthe original. (However, `Regexp#==` may not return true when\ncomparing the two, as the source of the regular expression itself may\ndiffer, as the example shows).  `Regexp#inspect` produces a\ngenerally more readable version of <i>rxp</i>.\n\n    r1 = /ab+c/ix           #=> /ab+c/ix\n    s1 = r1.to_s            #=> "(?ix-m:ab+c)"\n    r2 = Regexp.new(s1)     #=> /(?ix-m:ab+c)/\n    r1 == r2                #=> false\n    r1.source               #=> "ab+c"\n    r2.source               #=> "(?ix-m:ab+c)"\n
begin MatchData.begin(p1)\nReturns the offset of the start of the <em>n</em>th element of the match\narray in the string.\n<em>n</em> can be a string or symbol to reference a named capture.\n\n   m = /(.)(.)(\d+)(\d)/.match("THX1138.")\n   m.begin(0)       #=> 1\n   m.begin(2)       #=> 2\n\n   m = /(?<foo>.)(.)(?<bar>.)/.match("hoge")\n   p m.begin(:foo)  #=> 0\n   p m.begin(:bar)  #=> 2\n
captures MatchData.captures()\nReturns the array of captures; equivalent to `mtch.to_a[1..-1]`.\n\n   f1,f2,f3,f4 = /(.)(.)(\d+)(\d)/.match("THX1138.").captures\n   f1    #=> "H"\n   f2    #=> "X"\n   f3    #=> "113"\n   f4    #=> "8"\n
end MatchData.end(p1)\nReturns the offset of the character immediately following the end of the\n<em>n</em>th element of the match array in the string.\n<em>n</em> can be a string or symbol to reference a named capture.\n\n   m = /(.)(.)(\d+)(\d)/.match("THX1138.")\n   m.end(0)         #=> 7\n   m.end(2)         #=> 3\n\n   m = /(?<foo>.)(.)(?<bar>.)/.match("hoge")\n   p m.end(:foo)    #=> 1\n   p m.end(:bar)    #=> 3\n
eql? MatchData.eql?(p1)\nEquality---Two matchdata are equal if their target strings,\npatterns, and matched positions are identical.\n
hash MatchData.hash()\nProduce a hash based on the target string, regexp and matched\npositions of this matchdata.\n
inspect MatchData.inspect()\nReturns a printable version of <i>mtch</i>.\n\n    puts /.$/.match("foo").inspect\n=> #<MatchData "o">\n\n    puts /(.)(.)(.)/.match("foo").inspect\n=> #<MatchData "foo" 1:"f" 2:"o" 3:"o">\n\n    puts /(.)(.)?(.)/.match("fo").inspect\n=> #<MatchData "fo" 1:"f" 2:nil 3:"o">\n\n    puts /(?<foo>.)(?<bar>.)(?<baz>.)/.match("hoge").inspect\n=> #<MatchData "hog" foo:"h" bar:"o" baz:"g">\n
length MatchData.length()\nReturns the number of elements in the match array.\n\n   m = /(.)(.)(\d+)(\d)/.match("THX1138.")\n   m.length   #=> 5\n   m.size     #=> 5\n
names MatchData.names()\nReturns a list of names of captures as an array of strings.\nIt is same as mtch.regexp.names.\n\n    /(?<foo>.)(?<bar>.)(?<baz>.)/.match("hoge").names\n=> ["foo", "bar", "baz"]\n\n    m = /(?<x>.)(?<y>.)?/.match("a") #=> #<MatchData "a" x:"a" y:nil>\n    m.names                          #=> ["x", "y"]\n
offset MatchData.offset(p1)\nReturns a two-element array containing the beginning and ending offsets of\nthe <em>n</em>th match.\n<em>n</em> can be a string or symbol to reference a named capture.\n\n   m = /(.)(.)(\d+)(\d)/.match("THX1138.")\n   m.offset(0)      #=> [1, 7]\n   m.offset(4)      #=> [6, 7]\n\n   m = /(?<foo>.)(.)(?<bar>.)/.match("hoge")\n   p m.offset(:foo) #=> [0, 1]\n   p m.offset(:bar) #=> [2, 3]\n
post_match MatchData.post_match()\nReturns the portion of the original string after the current match.\nEquivalent to the special variable `$'`.\n\n   m = /(.)(.)(\d+)(\d)/.match("THX1138: The Movie")\n   m.post_match   #=> ": The Movie"\n
pre_match MatchData.pre_match()\nReturns the portion of the original string before the current match.\nEquivalent to the special variable `$``.\n\n   m = /(.)(.)(\d+)(\d)/.match("THX1138.")\n   m.pre_match   #=> "T"\n
pretty_print MatchData.pretty_print(q)\n\n
regexp MatchData.regexp()\nReturns the regexp.\n\n    m = /a.*b/.match("abc")\n    m.regexp #=> /a.*b/\n
size MatchData.size()\nReturns the number of elements in the match array.\n\n   m = /(.)(.)(\d+)(\d)/.match("THX1138.")\n   m.length   #=> 5\n   m.size     #=> 5\n
string MatchData.string()\nReturns a frozen copy of the string passed in to `match`.\n\n   m = /(.)(.)(\d+)(\d)/.match("THX1138.")\n   m.string   #=> "THX1138."\n
to_a MatchData.to_a()\nReturns the array of matches.\n\n   m = /(.)(.)(\d+)(\d)/.match("THX1138.")\n   m.to_a   #=> ["HX1138", "H", "X", "113", "8"]\n\nBecause `to_a` is called when expanding\n`*`<em>variable</em>, there's a useful assignment\nshortcut for extracting matched fields. This is slightly slower than\naccessing the fields directly (as an intermediate array is\ngenerated).\n\n   all,f1,f2,f3 = *(/(.)(.)(\d+)(\d)/.match("THX1138."))\n   all   #=> "HX1138"\n   f1    #=> "H"\n   f2    #=> "X"\n   f3    #=> "113"\n
to_s MatchData.to_s()\nReturns the entire matched string.\n\n   m = /(.)(.)(\d+)(\d)/.match("THX1138.")\n   m.to_s   #=> "HX1138"\n
values_at MatchData.values_at(*args)\nUses each <i>index</i> to access the matching values, returning an array of\nthe corresponding matches.\n\n   m = /(.)(.)(\d+)(\d)/.match("THX1138: The Movie")\n   m.to_a               #=> ["HX1138", "H", "X", "113", "8"]\n   m.values_at(0, 2, -2)   #=> ["HX1138", "X", "113"]\n
generic? Complex.generic?(other)\n\n
json_create Complex.json_create(object)\n\n
polar Complex.polar(p1, p2 = v2)\nReturns a complex object which denotes the given polar form.\n\n  Complex.polar(3, 0)           #=> (3.0+0.0i)\n  Complex.polar(3, Math::PI/2)  #=> (1.836909530733566e-16+3.0i)\n  Complex.polar(3, Math::PI)    #=> (-3.0+3.673819061467132e-16i)\n  Complex.polar(3, -Math::PI/2) #=> (1.836909530733566e-16-3.0i)\n
rect Complex.rect(p1, p2 = v2)\nReturns a complex object which denotes the given rectangular form.\n
rectangular Complex.rectangular(p1, p2 = v2)\nReturns a complex object which denotes the given rectangular form.\n
abs Complex.abs()\nReturns the absolute part of its polar form.\n
abs2 Complex.abs2()\nReturns square of the absolute value.\n
angle Complex.angle()\nReturns the angle part of its polar form.\n\n  Complex.polar(3, Math::PI/2).arg #=> 1.5707963267948966\n
arg Complex.arg()\nReturns the angle part of its polar form.\n\n  Complex.polar(3, Math::PI/2).arg #=> 1.5707963267948966\n
as_json Complex.as_json(*)\n\n
conj Complex.conj()\nReturns the complex conjugate.\n
conjugate Complex.conjugate()\nReturns the complex conjugate.\n
denominator Complex.denominator()\nReturns the denominator (lcm of both denominator - real and imag).\n\nSee numerator.\n
fdiv Complex.fdiv(p1)\nPerforms division as each part is a float, never returns a float.\n\nFor example:\n\n    Complex(11,22).fdiv(3)  #=> (3.6666666666666665+7.333333333333333i)\n
imag Complex.imag()\nReturns the imaginary part.\n
imaginary Complex.imaginary()\nReturns the imaginary part.\n
inspect Complex.inspect()\nReturns the value as a string for inspection.\n
magnitude Complex.magnitude()\nReturns the absolute part of its polar form.\n
numerator Complex.numerator()\nReturns the numerator.\n\nFor example:\n\n       1   2       3+4i  <-  numerator\n       - + -i  ->  ----\n       2   3        6    <-  denominator\n\n   c = Complex('1/2+2/3i')  #=> ((1/2)+(2/3)*i)\n   n = c.numerator          #=> (3+4i)\n   d = c.denominator        #=> 6\n   n / d                    #=> ((1/2)+(2/3)*i)\n   Complex(Rational(n.real, d), Rational(n.imag, d))\n=> ((1/2)+(2/3)*i)\nSee denominator.\n
phase Complex.phase()\nReturns the angle part of its polar form.\n\n  Complex.polar(3, Math::PI/2).arg #=> 1.5707963267948966\n
polar Complex.polar()\nReturns an array; [cmp.abs, cmp.arg].\n
quo Complex.quo(p1)\nPerforms division.\n\nFor example:\n\n    Complex(10.0) / 3  #=> (3.3333333333333335+(0/1)*i)\n    Complex(10)   / 3  #=> ((10/3)+(0/1)*i)  # not (3+0i)\n
rationalize Complex.rationalize(p1 = v1)\nIf the imaginary part is exactly 0, returns the real part as a Rational,\notherwise a RangeError is raised.\n
real Complex.real()\nReturns the real part.\n
real? Complex.real?()\nReturns false.\n
rect Complex.rect()\nReturns an array; [cmp.real, cmp.imag].\n
rectangular Complex.rectangular()\nReturns an array; [cmp.real, cmp.imag].\n
to_f Complex.to_f()\nReturns the value as a float if possible.\n
to_i Complex.to_i()\nReturns the value as an integer if possible.\n
to_json Complex.to_json(*)\n\n
to_r Complex.to_r()\nIf the imaginary part is exactly 0, returns the real part as a Rational,\notherwise a RangeError is raised.\n
to_s Complex.to_s()\nReturns the value as a string.\n
argv ARGF.argv()\nReturns the +ARGV+ array, which contains the arguments passed to your\nscript, one per element.\n\nFor example:\n\n    $ ruby argf.rb -v glark.txt\n\n    ARGF.argv   #=> ["-v", "glark.txt"]\n
binmode ARGF.binmode()\nPuts +ARGF+ into binary mode. Once a stream is in binary mode, it cannot\nbe reset to non-binary mode. This option has the following effects:\n\n*  Newline conversion is disabled.\n*  Encoding conversion is disabled.\n*  Content is treated as ASCII-8BIT.\n
binmode? ARGF.binmode?()\n Returns true if +ARGF+ is being read in binary mode; false otherwise. (To\n enable binary mode use +ARGF.binmode+.\n\nFor example:\n\n    ARGF.binmode?  #=> false\n    ARGF.binmode\n    ARGF.binmode?  #=> true\n
bytes ARGF.bytes()\n Iterates over each byte of each file in +ARGV+.\n A byte is returned as a +Fixnum+ in the range 0..255.\n\n This method allows you to treat the files supplied on the command line as\n a single file consisting of the concatenation of each named file. After\n the last byte of the first file has been returned, the first byte of the\n second file is returned. The +ARGF.filename+ method can be used to\n determine the filename of the current byte.\n\n If no block is given, an enumerator is returned instead.\n\nFor example:\n\n    ARGF.bytes.to_a  #=> [35, 32, ... 95, 10]\n
chars ARGF.chars()\nIterates over each character of each file in +ARGF+.\n\nThis method allows you to treat the files supplied on the command line as\na single file consisting of the concatenation of each named file. After\nthe last character of the first file has been returned, the first\ncharacter of the second file is returned. The +ARGF.filename+ method can\nbe used to determine the name of the file in which the current character\nappears.\n\nIf no block is given, an enumerator is returned instead.\n
close ARGF.close()\n Closes the current file and skips to the next in the stream. Trying to\n close a file that has already been closed causes an +IOError+ to be\n raised.\n\nFor example:\n\n    $ ruby argf.rb foo bar\n\n    ARGF.filename  #=> "foo"\n    ARGF.close\n    ARGF.filename  #=> "bar"\n    ARGF.close\n    ARGF.close     #=> closed stream (IOError)\n
closed? ARGF.closed?()\nReturns _true_ if the current file has been closed; _false_ otherwise. Use\n+ARGF.close+ to actually close the current file.\n
codepoints ARGF.codepoints()\nIterates over each codepoint of each file in +ARGF+.\n\nThis method allows you to treat the files supplied on the command line as\na single file consisting of the concatenation of each named file. After\nthe last codepoint of the first file has been returned, the first\ncodepoint of the second file is returned. The +ARGF.filename+ method can\nbe used to determine the name of the file in which the current codepoint\nappears.\n\nIf no block is given, an enumerator is returned instead.\n
each ARGF.each(*args)\nReturns an enumerator which iterates over each line (separated by _sep_,\nwhich defaults to your platform's newline character) of each file in\n+ARGV+. If a block is supplied, each line in turn will be yielded to the\nblock, otherwise an enumerator is returned.\nThe optional _limit_ argument is a +Fixnum+ specifying the maximum\nlength of each line; longer lines will be split according to this limit.\n\nThis method allows you to treat the files supplied on the command line as\na single file consisting of the concatenation of each named file. After\nthe last line of the first file has been returned, the first line of the\nsecond file is returned. The +ARGF.filename+ and +ARGF.lineno+ methods can\nbe used to determine the filename and line number, respectively, of the\ncurrent line.\n\nFor example, the following code prints out each line of each named file\nprefixed with its line number, displaying the filename once per file:\n\n   ARGF.lines do |line|\n     puts ARGF.filename if ARGF.lineno == 1\n     puts "#{ARGF.lineno}: #{line}"\n   end\n
each_byte ARGF.each_byte()\n Iterates over each byte of each file in +ARGV+.\n A byte is returned as a +Fixnum+ in the range 0..255.\n\n This method allows you to treat the files supplied on the command line as\n a single file consisting of the concatenation of each named file. After\n the last byte of the first file has been returned, the first byte of the\n second file is returned. The +ARGF.filename+ method can be used to\n determine the filename of the current byte.\n\n If no block is given, an enumerator is returned instead.\n\nFor example:\n\n    ARGF.bytes.to_a  #=> [35, 32, ... 95, 10]\n
each_char ARGF.each_char()\nIterates over each character of each file in +ARGF+.\n\nThis method allows you to treat the files supplied on the command line as\na single file consisting of the concatenation of each named file. After\nthe last character of the first file has been returned, the first\ncharacter of the second file is returned. The +ARGF.filename+ method can\nbe used to determine the name of the file in which the current character\nappears.\n\nIf no block is given, an enumerator is returned instead.\n
each_codepoint ARGF.each_codepoint()\nIterates over each codepoint of each file in +ARGF+.\n\nThis method allows you to treat the files supplied on the command line as\na single file consisting of the concatenation of each named file. After\nthe last codepoint of the first file has been returned, the first\ncodepoint of the second file is returned. The +ARGF.filename+ method can\nbe used to determine the name of the file in which the current codepoint\nappears.\n\nIf no block is given, an enumerator is returned instead.\n
each_line ARGF.each_line(*args)\nReturns an enumerator which iterates over each line (separated by _sep_,\nwhich defaults to your platform's newline character) of each file in\n+ARGV+. If a block is supplied, each line in turn will be yielded to the\nblock, otherwise an enumerator is returned.\nThe optional _limit_ argument is a +Fixnum+ specifying the maximum\nlength of each line; longer lines will be split according to this limit.\n\nThis method allows you to treat the files supplied on the command line as\na single file consisting of the concatenation of each named file. After\nthe last line of the first file has been returned, the first line of the\nsecond file is returned. The +ARGF.filename+ and +ARGF.lineno+ methods can\nbe used to determine the filename and line number, respectively, of the\ncurrent line.\n\nFor example, the following code prints out each line of each named file\nprefixed with its line number, displaying the filename once per file:\n\n   ARGF.lines do |line|\n     puts ARGF.filename if ARGF.lineno == 1\n     puts "#{ARGF.lineno}: #{line}"\n   end\n
eof ARGF.eof()\nReturns true if the current file in +ARGF+ is at end of file, i.e. it has\nno data to read. The stream must be opened for reading or an +IOError+\nwill be raised.\n\n   $ echo "eof" | ruby argf.rb\n\n   ARGF.eof?                 #=> false\n   3.times { ARGF.readchar }\n   ARGF.eof?                 #=> false\n   ARGF.readchar             #=> "\\n"\n   ARGF.eof?                 #=> true\n
eof? ARGF.eof?()\nReturns true if the current file in +ARGF+ is at end of file, i.e. it has\nno data to read. The stream must be opened for reading or an +IOError+\nwill be raised.\n\n   $ echo "eof" | ruby argf.rb\n\n   ARGF.eof?                 #=> false\n   3.times { ARGF.readchar }\n   ARGF.eof?                 #=> false\n   ARGF.readchar             #=> "\\n"\n   ARGF.eof?                 #=> true\n
external_encoding ARGF.external_encoding()\n Returns the external encoding for files read from +ARGF+ as an +Encoding+\n object. The external encoding is the encoding of the text as stored in a\n file. Contrast with +ARGF.internal_encoding+, which is the encoding used\n to represent this text within Ruby.\n\n To set the external encoding use +ARGF.set_encoding+.\n\nFor example:\n\n    ARGF.external_encoding  #=>  #<Encoding:UTF-8>\n
file ARGF.file()\nReturns the current file as an +IO+ or +File+ object. #<IO:<STDIN>> is\nreturned when the current file is STDIN.\n\nFor example:\n\n   $ echo "foo" > foo\n   $ echo "bar" > bar\n\n   $ ruby argf.rb foo bar\n\n   ARGF.file      #=> #<File:foo>\n   ARGF.read(5)   #=> "foo\\nb"\n   ARGF.file      #=> #<File:bar>\n
filename ARGF.filename()\nReturns the current filename. "-" is returned when the current file is\nSTDIN.\n\nFor example:\n\n   $ echo "foo" > foo\n   $ echo "bar" > bar\n   $ echo "glark" > glark\n\n   $ ruby argf.rb foo bar glark\n\n   ARGF.filename  #=> "foo"\n   ARGF.read(5)   #=> "foo\\nb"\n   ARGF.filename  #=> "bar"\n   ARGF.skip\n   ARGF.filename  #=> "glark"\n
fileno ARGF.fileno()\nReturns an integer representing the numeric file descriptor for\nthe current file. Raises an +ArgumentError+ if there isn't a current file.\n\n   ARGF.fileno    #=> 3\n
getbyte ARGF.getbyte()\nGets the next 8-bit byte (0..255) from +ARGF+. Returns +nil+ if called at\nthe end of the stream.\n\nFor example:\n\n   $ echo "foo" > file\n   $ ruby argf.rb file\n\n   ARGF.getbyte #=> 102\n   ARGF.getbyte #=> 111\n   ARGF.getbyte #=> 111\n   ARGF.getbyte #=> 10\n   ARGF.getbyte #=> nil\n
getc ARGF.getc()\nReads the next character from +ARGF+ and returns it as a +String+. Returns\n+nil+ at the end of the stream.\n\n+ARGF+ treats the files named on the command line as a single file created\nby concatenating their contents. After returning the last character of the\nfirst file, it returns the first character of the second file, and so on.\n\nFor example:\n\n   $ echo "foo" > file\n   $ ruby argf.rb file\n\n   ARGF.getc  #=> "f"\n   ARGF.getc  #=> "o"\n   ARGF.getc  #=> "o"\n   ARGF.getc  #=> "\\n"\n   ARGF.getc  #=> nil\n   ARGF.getc  #=> nil\n
gets ARGF.gets(*args)\nReturns the next line from the current file in +ARGF+.\n\nBy default lines are assumed to be separated by +$/+; to use a different\ncharacter as a separator, supply it as a +String+ for the _sep_ argument.\n\nThe optional  _limit_ argument specifies how many characters of each line\nto return. By default all characters are returned.\n
inplace_mode ARGF.inplace_mode()\nReturns the file extension appended to the names of modified files under\ninplace-edit mode. This value can be set using +ARGF.inplace_mode=+ or\npassing the +-i+ switch to the Ruby binary.\n
inplace_mode= ARGF.inplace_mode=(p1)\n Sets the filename extension for inplace editing mode to the given String.\n Each file being edited has this value appended to its filename. The\n modified file is saved under this new name.\n\n For example:\n\n     $ ruby argf.rb file.txt\n\n     ARGF.inplace_mode = '.bak'\n     ARGF.lines do |line|\n       print line.sub("foo","bar")\n     end\n\nEach line of _file.txt_ has the first occurrence of "foo" replaced with\n"bar", then the new line is written out to _file.txt.bak_.\n
internal_encoding ARGF.internal_encoding()\nReturns the internal encoding for strings read from +ARGF+ as an\n+Encoding+ object.\n\nIf +ARGF.set_encoding+ has been called with two encoding names, the second\nis returned. Otherwise, if +Encoding.default_external+ has been set, that\nvalue is returned. Failing that, if a default external encoding was\nspecified on the command-line, that value is used. If the encoding is\nunknown, nil is returned.\n
lineno ARGF.lineno()\nReturns the current line number of ARGF as a whole. This value\ncan be set manually with +ARGF.lineno=+.\n\nFor example:\n\n    ARGF.lineno   #=> 0\n    ARGF.readline #=> "This is line 1\\n"\n    ARGF.lineno   #=> 1\n
lineno= ARGF.lineno=(p1)\nSets the line number of +ARGF+ as a whole to the given +Integer+.\n\n+ARGF+ sets the line number automatically as you read data, so normally\nyou will not need to set it explicitly. To access the current line number\nuse +ARGF.lineno+.\n\nFor example:\n\n    ARGF.lineno      #=> 0\n    ARGF.readline    #=> "This is line 1\\n"\n    ARGF.lineno      #=> 1\n    ARGF.lineno = 0  #=> nil\n    ARGF.lineno      #=> 0\n
lines ARGF.lines(*args)\nReturns an enumerator which iterates over each line (separated by _sep_,\nwhich defaults to your platform's newline character) of each file in\n+ARGV+. If a block is supplied, each line in turn will be yielded to the\nblock, otherwise an enumerator is returned.\nThe optional _limit_ argument is a +Fixnum+ specifying the maximum\nlength of each line; longer lines will be split according to this limit.\n\nThis method allows you to treat the files supplied on the command line as\na single file consisting of the concatenation of each named file. After\nthe last line of the first file has been returned, the first line of the\nsecond file is returned. The +ARGF.filename+ and +ARGF.lineno+ methods can\nbe used to determine the filename and line number, respectively, of the\ncurrent line.\n\nFor example, the following code prints out each line of each named file\nprefixed with its line number, displaying the filename once per file:\n\n   ARGF.lines do |line|\n     puts ARGF.filename if ARGF.lineno == 1\n     puts "#{ARGF.lineno}: #{line}"\n   end\n
path ARGF.path()\nReturns the current filename. "-" is returned when the current file is\nSTDIN.\n\nFor example:\n\n   $ echo "foo" > foo\n   $ echo "bar" > bar\n   $ echo "glark" > glark\n\n   $ ruby argf.rb foo bar glark\n\n   ARGF.filename  #=> "foo"\n   ARGF.read(5)   #=> "foo\\nb"\n   ARGF.filename  #=> "bar"\n   ARGF.skip\n   ARGF.filename  #=> "glark"\n
pos ARGF.pos()\nReturns the current offset (in bytes) of the current file in +ARGF+.\n\n   ARGF.pos    #=> 0\n   ARGF.gets   #=> "This is line one\\n"\n   ARGF.pos    #=> 17\n
pos= ARGF.pos=(p1)\nSeeks to the position given by _position_ (in bytes) in +ARGF+.\n\nFor example:\n\n    ARGF.pos = 17\n    ARGF.gets   #=> "This is line two\\n"\n
print ARGF.print(*args)\nWrites the given object(s) to <em>ios</em>. The stream must be\nopened for writing. If the output field separator (`$,`)\nis not `nil`, it will be inserted between each object.\nIf the output record separator (`$\\`)\nis not `nil`, it will be appended to the output. If no\narguments are given, prints `$_`. Objects that aren't\nstrings will be converted by calling their `to_s` method.\nWith no argument, prints the contents of the variable `$_`.\nReturns `nil`.\n\n   $stdout.print("This is ", 100, " percent.\\n")\n\n<em>produces:</em>\n\n   This is 100 percent.\n
printf ARGF.printf(*args)\nFormats and writes to <em>ios</em>, converting parameters under\ncontrol of the format string. See `Kernel#sprintf`\nfor details.\n
putc ARGF.putc(p1)\nIf <i>obj</i> is `Numeric`, write the character whose code is\nthe least-significant byte of <i>obj</i>, otherwise write the first byte\nof the string representation of <i>obj</i> to <em>ios</em>. Note: This\nmethod is not safe for use with multi-byte characters as it will truncate\nthem.\n\n   $stdout.putc "A"\n   $stdout.putc 65\n\n<em>produces:</em>\n\n   AA\n
puts ARGF.puts(*args)\nWrites the given objects to <em>ios</em> as with\n`IO#print`. Writes a record separator (typically a\nnewline) after any that do not already end with a newline sequence.\nIf called with an array argument, writes each element on a new line.\nIf called without arguments, outputs a single record separator.\n\n   $stdout.puts("this", "is", "a", "test")\n\n<em>produces:</em>\n\n   this\n   is\n   a\n   test\n
read ARGF.read(p1 = v1, p2 = v2)\n Reads _length_ bytes from ARGF. The files named on the command line\n are concatenated and treated as a single file by this method, so when\n called without arguments the contents of this pseudo file are returned in\n their entirety.\n\n _length_ must be a non-negative integer or nil. If it is a positive\n integer, +read+ tries to read at most _length_ bytes. It returns nil\n if an EOF was encountered before anything could be read. Fewer than\n _length_ bytes may be returned if an EOF is encountered during the read.\n\n If _length_ is omitted or is _nil_, it reads until EOF. A String is\n returned even if EOF is encountered before any data is read.\n\n If _length_ is zero, it returns _""_.\n\n If the optional _buffer_ argument is present, it must reference a String,\n which will receive the data.\n\nFor example:\n\n    $ echo "small" > small.txt\n    $ echo "large" > large.txt\n    $ ./glark.rb small.txt large.txt\n\n    ARGF.read      #=> "small\\nlarge"\n    ARGF.read(200) #=> "small\\nlarge"\n    ARGF.read(2)   #=> "sm"\n    ARGF.read(0)   #=> ""\n\n Note that this method behaves like fread() function in C.  If you need the\n behavior like read(2) system call, consider +ARGF.readpartial+.\n
read_nonblock ARGF.read_nonblock(*args)\nReads at most _maxlen_ bytes from the ARGF stream in non-blocking mode.\n
readbyte ARGF.readbyte()\nReads the next 8-bit byte from ARGF and returns it as a +Fixnum+. Raises\nan +EOFError+ after the last byte of the last file has been read.\n\nFor example:\n\n   $ echo "foo" > file\n   $ ruby argf.rb file\n\n   ARGF.readbyte  #=> 102\n   ARGF.readbyte  #=> 111\n   ARGF.readbyte  #=> 111\n   ARGF.readbyte  #=> 10\n   ARGF.readbyte  #=> end of file reached (EOFError)\n
readchar ARGF.readchar()\nReads the next character from +ARGF+ and returns it as a +String+. Raises\nan +EOFError+ after the last character of the last file has been read.\n\nFor example:\n\n   $ echo "foo" > file\n   $ ruby argf.rb file\n\n   ARGF.readchar  #=> "f"\n   ARGF.readchar  #=> "o"\n   ARGF.readchar  #=> "o"\n   ARGF.readchar  #=> "\\n"\n   ARGF.readchar  #=> end of file reached (EOFError)\n
readline ARGF.readline(*args)\nReturns the next line from the current file in +ARGF+.\n\nBy default lines are assumed to be separated by +$/+; to use a different\ncharacter as a separator, supply it as a +String+ for the _sep_ argument.\n\nThe optional  _limit_ argument specifies how many characters of each line\nto return. By default all characters are returned.\n\nAn +EOFError+ is raised at the end of the file.\n
readlines ARGF.readlines(*args)\nReads +ARGF+'s current file in its entirety, returning an +Array+ of its\nlines, one line per element. Lines are assumed to be separated by _sep_.\n\n   lines = ARGF.readlines\n   lines[0]                #=> "This is line one\\n"\n
readpartial ARGF.readpartial(*args)\nReads at most _maxlen_ bytes from the ARGF stream. It blocks only if\n+ARGF+ has no data immediately available. If the optional _outbuf_\nargument is present, it must reference a String, which will receive the\ndata. It raises `EOFError` on end of file.\n\n+readpartial+ is designed for streams such as pipes, sockets, and ttys. It\nblocks only when no data is immediately available. This means that it\nblocks only when following all conditions hold:\n\n* The byte buffer in the +IO+ object is empty.\n* The content of the stream is empty.\n* The stream has not reached EOF.\n\nWhen +readpartial+ blocks, it waits for data or EOF. If some data is read,\n+readpartial+ returns with the data. If EOF is reached, readpartial raises\nan +EOFError+.\n\nWhen +readpartial+ doesn't block, it returns or raises immediately.  If\nthe byte buffer is not empty, it returns the data in the buffer. Otherwise, if\nthe stream has some content, it returns the data in the stream. If the\nstream reaches EOF an +EOFError+ is raised.\n
rewind ARGF.rewind()\nPositions the current file to the beginning of input, resetting\n+ARGF.lineno+ to zero.\n\n   ARGF.readline   #=> "This is line one\\n"\n   ARGF.rewind     #=> 0\n   ARGF.lineno     #=> 0\n   ARGF.readline   #=> "This is line one\\n"\n
seek ARGF.seek(*args)\nSeeks to offset _amount_ (an +Integer+) in the +ARGF+ stream according to\nthe value of _whence_. See +IO#seek+ for further details.\n
set_encoding ARGF.set_encoding(*args)\nIf single argument is specified, strings read from ARGF are tagged with\nthe encoding specified.\n\nIf two encoding names separated by a colon are given, e.g. "ascii:utf-8",\nthe read string is converted from the first encoding (external encoding)\nto the second encoding (internal encoding), then tagged with the second\nencoding.\n\nIf two arguments are specified, they must be encoding objects or encoding\nnames. Again, the first specifies the external encoding; the second\nspecifies the internal encoding.\n\nIf the external encoding and the internal encoding are specified, the\noptional +Hash+ argument can be used to adjust the conversion process. The\nstructure of this hash is explained in the +String#encode+ documentation.\n\nFor example:\n\n    ARGF.set_encoding('ascii')         # Tag the input as US-ASCII text\n    ARGF.set_encoding(Encoding::UTF_8) # Tag the input as UTF-8 text\n    ARGF.set_encoding('utf-8','ascii') # Transcode the input from US-ASCII\n to UTF-8.\n
skip ARGF.skip()\n Sets the current file to the next file in ARGV. If there aren't any more\n files it has no effect.\n\nFor example:\n\n    $ ruby argf.rb foo bar\n    ARGF.filename  #=> "foo"\n    ARGF.skip\n    ARGF.filename  #=> "bar"\n
tell ARGF.tell()\nReturns the current offset (in bytes) of the current file in +ARGF+.\n\n   ARGF.pos    #=> 0\n   ARGF.gets   #=> "This is line one\\n"\n   ARGF.pos    #=> 17\n
to_a ARGF.to_a(*args)\nReads +ARGF+'s current file in its entirety, returning an +Array+ of its\nlines, one line per element. Lines are assumed to be separated by _sep_.\n\n   lines = ARGF.readlines\n   lines[0]                #=> "This is line one\\n"\n
to_i ARGF.to_i()\nReturns an integer representing the numeric file descriptor for\nthe current file. Raises an +ArgumentError+ if there isn't a current file.\n\n   ARGF.fileno    #=> 3\n
to_io ARGF.to_io()\nReturns an +IO+ object representing the current file. This will be a\n+File+ object unless the current file is a stream such as STDIN.\n\nFor example:\n\n   ARGF.to_io    #=> #<File:glark.txt>\n   ARGF.to_io    #=> #<IO:<STDIN>>\n
to_s ARGF.to_s()\nReturns "ARGF".\n
to_write_io ARGF.to_write_io()\nReturns IO instance tied to _ARGF_ for writing if inplace mode is\nenabled.\n
write ARGF.write(p1)\nWrites _string_ if inplace mode.\n
new Hash.new(p1 = v1)\nReturns a new, empty hash. If this hash is subsequently accessed by\na key that doesn't correspond to a hash entry, the value returned\ndepends on the style of `new` used to create the hash. In\nthe first form, the access returns `nil`. If\n<i>obj</i> is specified, this single object will be used for\nall <em>default values</em>. If a block is specified, it will be\ncalled with the hash object and the key, and should return the\ndefault value. It is the block's responsibility to store the value\nin the hash if required.\n\n   h = Hash.new("Go Fish")\n   h["a"] = 100\n   h["b"] = 200\n   h["a"]           #=> 100\n   h["c"]           #=> "Go Fish"\n The following alters the single default object\n   h["c"].upcase!   #=> "GO FISH"\n   h["d"]           #=> "GO FISH"\n   h.keys           #=> ["a", "b"]\n While this creates a new default object each time\n   h = Hash.new { |hash, key| hash[key] = "Go Fish: #{key}" }\n   h["c"]           #=> "Go Fish: c"\n   h["c"].upcase!   #=> "GO FISH: C"\n   h["d"]           #=> "Go Fish: d"\n   h.keys           #=> ["c", "d"]\n
try_convert Hash.try_convert(p1)\nTry to convert <i>obj</i> into a hash, using to_hash method.\nReturns converted hash or nil if <i>obj</i> cannot be converted\nfor any reason.\n\n   Hash.try_convert({1=>2})   # => {1=>2}\n   Hash.try_convert("1=>2")   # => nil\n
assoc Hash.assoc(p1)\nSearches through the hash comparing _obj_ with the key using `==`.\nReturns the key-value pair (two elements array) or +nil+\nif no match is found.  See `Array#assoc`.\n\n   h = {"colors"  => ["red", "blue", "green"],\n        "letters" => ["a", "b", "c" ]}\n   h.assoc("letters")  #=> ["letters", ["a", "b", "c"]]\n   h.assoc("foo")      #=> nil\n
clear Hash.clear()\nRemoves all key-value pairs from <i>hsh</i>.\n\n   h = { "a" => 100, "b" => 200 }   #=> {"a"=>100, "b"=>200}\n   h.clear                          #=> {}\n
compare_by_identity Hash.compare_by_identity()\nMakes <i>hsh</i> compare its keys by their identity, i.e. it\nwill consider exact same objects as same keys.\n\n   h1 = { "a" => 100, "b" => 200, :c => "c" }\n   h1["a"]        #=> 100\n   h1.compare_by_identity\n   h1.compare_by_identity? #=> true\n   h1["a"]        #=> nil  # different objects.\n   h1[:c]         #=> "c"  # same symbols are all same.\n
compare_by_identity? Hash.compare_by_identity?()\nReturns `true` if <i>hsh</i> will compare its keys by\ntheir identity.  Also see `Hash#compare_by_identity`.\n
default Hash.default(p1 = v1)\nReturns the default value, the value that would be returned by\n<i>hsh</i>[<i>key</i>] if <i>key</i> did not exist in <i>hsh</i>.\nSee also `Hash::new` and `Hash#default=`.\n\n   h = Hash.new                            #=> {}\n   h.default                               #=> nil\n   h.default(2)                            #=> nil\n\n   h = Hash.new("cat")                     #=> {}\n   h.default                               #=> "cat"\n   h.default(2)                            #=> "cat"\n\n   h = Hash.new {|h,k| h[k] = k.to_i*10}   #=> {}\n   h.default                               #=> nil\n   h.default(2)                            #=> 20\n
default= Hash.default=(p1)\nSets the default value, the value returned for a key that does not\nexist in the hash. It is not possible to set the default to a\n`Proc` that will be executed on each key lookup.\n\n   h = { "a" => 100, "b" => 200 }\n   h.default = "Go fish"\n   h["a"]     #=> 100\n   h["z"]     #=> "Go fish"\n This doesn't do what you might hope...\n   h.default = proc do |hash, key|\n     hash[key] = key + key\n   end\n   h[2]       #=> #<Proc:0x401b3948@-:6>\n   h["cat"]   #=> #<Proc:0x401b3948@-:6>\n
default_proc Hash.default_proc()\nIf `Hash::new` was invoked with a block, return that\nblock, otherwise return `nil`.\n\n   h = Hash.new {|h,k| h[k] = k*k }   #=> {}\n   p = h.default_proc                 #=> #<Proc:0x401b3d08@-:1>\n   a = []                             #=> []\n   p.call(a, 2)\n   a                                  #=> [nil, nil, 4]\n
default_proc= Hash.default_proc=(p1)\nSets the default proc to be executed on each key lookup.\n\n   h.default_proc = proc do |hash, key|\n     hash[key] = key + key\n   end\n   h[2]       #=> 4\n   h["cat"]   #=> "catcat"\n
delete Hash.delete(p1)\nDeletes and returns a key-value pair from <i>hsh</i> whose key is\nequal to <i>key</i>. If the key is not found, returns the\n<em>default value</em>. If the optional code block is given and the\nkey is not found, pass in the key and return the result of\n<i>block</i>.\n\n   h = { "a" => 100, "b" => 200 }\n   h.delete("a")                              #=> 100\n   h.delete("z")                              #=> nil\n   h.delete("z") { |el| "#{el} not found" }   #=> "z not found"\n
delete_if Hash.delete_if()\nDeletes every key-value pair from <i>hsh</i> for which <i>block</i>\nevaluates to `true`.\n\nIf no block is given, an enumerator is returned instead.\n\n   h = { "a" => 100, "b" => 200, "c" => 300 }\n   h.delete_if {|key, value| key >= "b" }   #=> {"a"=>100}\n
each Hash.each()\nCalls <i>block</i> once for each key in <i>hsh</i>, passing the key-value\npair as parameters.\n\nIf no block is given, an enumerator is returned instead.\n\n   h = { "a" => 100, "b" => 200 }\n   h.each {|key, value| puts "#{key} is #{value}" }\n\n<em>produces:</em>\n\n   a is 100\n   b is 200\n
each_key Hash.each_key()\nCalls <i>block</i> once for each key in <i>hsh</i>, passing the key\nas a parameter.\n\nIf no block is given, an enumerator is returned instead.\n\n   h = { "a" => 100, "b" => 200 }\n   h.each_key {|key| puts key }\n\n<em>produces:</em>\n\n   a\n   b\n
each_pair Hash.each_pair()\nCalls <i>block</i> once for each key in <i>hsh</i>, passing the key-value\npair as parameters.\n\nIf no block is given, an enumerator is returned instead.\n\n   h = { "a" => 100, "b" => 200 }\n   h.each {|key, value| puts "#{key} is #{value}" }\n\n<em>produces:</em>\n\n   a is 100\n   b is 200\n
each_value Hash.each_value()\nCalls <i>block</i> once for each key in <i>hsh</i>, passing the\nvalue as a parameter.\n\nIf no block is given, an enumerator is returned instead.\n\n   h = { "a" => 100, "b" => 200 }\n   h.each_value {|value| puts value }\n\n<em>produces:</em>\n\n   100\n   200\n
empty? Hash.empty?()\nReturns `true` if <i>hsh</i> contains no key-value pairs.\n\n   {}.empty?   #=> true\n
eql? Hash.eql?(p1)\nReturns `true` if <i>hash</i> and <i>other</i> are\nboth hashes with the same content.\n
fetch Hash.fetch(p1, p2 = v2)\nReturns a value from the hash for the given key. If the key can't be\nfound, there are several options: With no other arguments, it will\nraise an `KeyError` exception; if <i>default</i> is\ngiven, then that will be returned; if the optional code block is\nspecified, then that will be run and its result returned.\n\n   h = { "a" => 100, "b" => 200 }\n   h.fetch("a")                            #=> 100\n   h.fetch("z", "go fish")                 #=> "go fish"\n   h.fetch("z") { |el| "go fish, #{el}"}   #=> "go fish, z"\n\nThe following example shows that an exception is raised if the key\nis not found and a default value is not supplied.\n\n   h = { "a" => 100, "b" => 200 }\n   h.fetch("z")\n\n<em>produces:</em>\n\n   prog.rb:2:in `fetch': key not found (KeyError)\n    from prog.rb:2\n
flatten Hash.flatten(*args)\nReturns a new array that is a one-dimensional flattening of this\nhash. That is, for every key or value that is an array, extract\nits elements into the new array.  Unlike Array#flatten, this\nmethod does not flatten recursively by default.  The optional\n<i>level</i> argument determines the level of recursion to flatten.\n\n   a =  {1=> "one", 2 => [2,"two"], 3 => "three"}\n   a.flatten    # => [1, "one", 2, [2, "two"], 3, "three"]\n   a.flatten(2) # => [1, "one", 2, 2, "two", 3, "three"]\n
has_key? Hash.has_key?(p1)\nReturns `true` if the given key is present in <i>hsh</i>.\n\n   h = { "a" => 100, "b" => 200 }\n   h.has_key?("a")   #=> true\n   h.has_key?("z")   #=> false\n
has_value? Hash.has_value?(p1)\nReturns `true` if the given value is present for some key\nin <i>hsh</i>.\n\n   h = { "a" => 100, "b" => 200 }\n   h.has_value?(100)   #=> true\n   h.has_value?(999)   #=> false\n
hash Hash.hash()\nCompute a hash-code for this hash. Two hashes with the same content\nwill have the same hash code (and will compare using `eql?`).\n
include? Hash.include?(p1)\nReturns `true` if the given key is present in <i>hsh</i>.\n\n   h = { "a" => 100, "b" => 200 }\n   h.has_key?("a")   #=> true\n   h.has_key?("z")   #=> false\n
initialize_copy Hash.initialize_copy(p1)\nReplaces the contents of <i>hsh</i> with the contents of\n<i>other_hash</i>.\n\n   h = { "a" => 100, "b" => 200 }\n   h.replace({ "c" => 300, "d" => 400 })   #=> {"c"=>300, "d"=>400}\n
inspect Hash.inspect()\nReturn the contents of this hash as a string.\n\n    h = { "c" => 300, "a" => 100, "d" => 400, "c" => 300  }\n    h.to_s   #=> "{\"c\"=>300, \"a\"=>100, \"d\"=>400}"\n
invert Hash.invert()\nReturns a new hash created by using <i>hsh</i>'s values as keys, and\nthe keys as values.\n\n   h = { "n" => 100, "m" => 100, "y" => 300, "d" => 200, "a" => 0 }\n   h.invert   #=> {0=>"a", 100=>"m", 200=>"d", 300=>"y"}\n
keep_if Hash.keep_if()\nDeletes every key-value pair from <i>hsh</i> for which <i>block</i>\nevaluates to false.\n\nIf no block is given, an enumerator is returned instead.\n
key Hash.key(p1)\nReturns the key of an occurrence of a given value. If the value is\nnot found, returns `nil`.\n\n   h = { "a" => 100, "b" => 200, "c" => 300, "d" => 300 }\n   h.key(200)   #=> "b"\n   h.key(300)   #=> "c"\n   h.key(999)   #=> nil\n
key? Hash.key?(p1)\nReturns `true` if the given key is present in <i>hsh</i>.\n\n   h = { "a" => 100, "b" => 200 }\n   h.has_key?("a")   #=> true\n   h.has_key?("z")   #=> false\n
keys Hash.keys()\nReturns a new array populated with the keys from this hash. See also\n`Hash#values`.\n\n   h = { "a" => 100, "b" => 200, "c" => 300, "d" => 400 }\n   h.keys   #=> ["a", "b", "c", "d"]\n
length Hash.length()\nReturns the number of key-value pairs in the hash.\n\n   h = { "d" => 100, "a" => 200, "v" => 300, "e" => 400 }\n   h.length        #=> 4\n   h.delete("a")   #=> 200\n   h.length        #=> 3\n
member? Hash.member?(p1)\nReturns `true` if the given key is present in <i>hsh</i>.\n\n   h = { "a" => 100, "b" => 200 }\n   h.has_key?("a")   #=> true\n   h.has_key?("z")   #=> false\n
merge Hash.merge(p1)\nReturns a new hash containing the contents of <i>other_hash</i> and\nthe contents of <i>hsh</i>. If no block is specified, the value for\nentries with duplicate keys will be that of <i>other_hash</i>. Otherwise\nthe value for each duplicate key is determined by calling the block\nwith the key, its value in <i>hsh</i> and its value in <i>other_hash</i>.\n\n   h1 = { "a" => 100, "b" => 200 }\n   h2 = { "b" => 254, "c" => 300 }\n   h1.merge(h2)   #=> {"a"=>100, "b"=>254, "c"=>300}\n   h1.merge(h2){|key, oldval, newval| newval - oldval}\n=> {"a"=>100, "b"=>54,  "c"=>300}\n   h1             #=> {"a"=>100, "b"=>200}\n
merge! Hash.merge!(p1)\nAdds the contents of <i>other_hash</i> to <i>hsh</i>.  If no\nblock is specified, entries with duplicate keys are overwritten\nwith the values from <i>other_hash</i>, otherwise the value\nof each duplicate key is determined by calling the block with\nthe key, its value in <i>hsh</i> and its value in <i>other_hash</i>.\n\n   h1 = { "a" => 100, "b" => 200 }\n   h2 = { "b" => 254, "c" => 300 }\n   h1.merge!(h2)   #=> {"a"=>100, "b"=>254, "c"=>300}\n\n   h1 = { "a" => 100, "b" => 200 }\n   h2 = { "b" => 254, "c" => 300 }\n   h1.merge!(h2) { |key, v1, v2| v1 }\n=> {"a"=>100, "b"=>200, "c"=>300}\n
pretty_print Hash.pretty_print(q)\n\n
pretty_print_cycle Hash.pretty_print_cycle(q)\n\n
rassoc Hash.rassoc(p1)\nSearches through the hash comparing _obj_ with the value using `==`.\nReturns the first key-value pair (two-element array) that matches. See\nalso `Array#rassoc`.\n\n   a = {1=> "one", 2 => "two", 3 => "three", "ii" => "two"}\n   a.rassoc("two")    #=> [2, "two"]\n   a.rassoc("four")   #=> nil\n
rehash Hash.rehash()\nRebuilds the hash based on the current hash values for each key. If\nvalues of key objects have changed since they were inserted, this\nmethod will reindex <i>hsh</i>. If `Hash#rehash` is\ncalled while an iterator is traversing the hash, an\n`RuntimeError` will be raised in the iterator.\n\n   a = [ "a", "b" ]\n   c = [ "c", "d" ]\n   h = { a => 100, c => 300 }\n   h[a]       #=> 100\n   a[0] = "z"\n   h[a]       #=> nil\n   h.rehash   #=> {["z", "b"]=>100, ["c", "d"]=>300}\n   h[a]       #=> 100\n
reject Hash.reject()\nSame as `Hash#delete_if`, but works on (and returns) a\ncopy of the <i>hsh</i>. Equivalent to\n`<i>hsh</i>.dup.delete_if`.\n
reject! Hash.reject!()\nEquivalent to `Hash#delete_if`, but returns\n`nil` if no changes were made.\n
replace Hash.replace(p1)\nReplaces the contents of <i>hsh</i> with the contents of\n<i>other_hash</i>.\n\n   h = { "a" => 100, "b" => 200 }\n   h.replace({ "c" => 300, "d" => 400 })   #=> {"c"=>300, "d"=>400}\n
select Hash.select()\nReturns a new hash consisting of entries for which the block returns true.\n\nIf no block is given, an enumerator is returned instead.\n\n   h = { "a" => 100, "b" => 200, "c" => 300 }\n   h.select {|k,v| k > "a"}  #=> {"b" => 200, "c" => 300}\n   h.select {|k,v| v < 200}  #=> {"a" => 100}\n
select! Hash.select!()\nEquivalent to `Hash#keep_if`, but returns\n`nil` if no changes were made.\n
shift Hash.shift()\nRemoves a key-value pair from <i>hsh</i> and returns it as the\ntwo-item array `[` <i>key, value</i> `]`, or\nthe hash's default value if the hash is empty.\n\n   h = { 1 => "a", 2 => "b", 3 => "c" }\n   h.shift   #=> [1, "a"]\n   h         #=> {2=>"b", 3=>"c"}\n
size Hash.size()\nReturns the number of key-value pairs in the hash.\n\n   h = { "d" => 100, "a" => 200, "v" => 300, "e" => 400 }\n   h.length        #=> 4\n   h.delete("a")   #=> 200\n   h.length        #=> 3\n
store Hash.store(p1, p2)\nElement Assignment---Associates the value given by\n<i>value</i> with the key given by <i>key</i>.\n<i>key</i> should not have its value changed while it is in\nuse as a key (a `String` passed as a key will be\nduplicated and frozen).\n\n   h = { "a" => 100, "b" => 200 }\n   h["a"] = 9\n   h["c"] = 4\n   h   #=> {"a"=>9, "b"=>200, "c"=>4}\n
to_a Hash.to_a()\nConverts <i>hsh</i> to a nested array of `[` <i>key,\nvalue</i> `]` arrays.\n\n   h = { "c" => 300, "a" => 100, "d" => 400, "c" => 300  }\n   h.to_a   #=> [["c", 300], ["a", 100], ["d", 400]]\n
to_hash Hash.to_hash()\nReturns +self+.\n
to_s Hash.to_s()\n\n
update Hash.update(p1)\nAdds the contents of <i>other_hash</i> to <i>hsh</i>.  If no\nblock is specified, entries with duplicate keys are overwritten\nwith the values from <i>other_hash</i>, otherwise the value\nof each duplicate key is determined by calling the block with\nthe key, its value in <i>hsh</i> and its value in <i>other_hash</i>.\n\n   h1 = { "a" => 100, "b" => 200 }\n   h2 = { "b" => 254, "c" => 300 }\n   h1.merge!(h2)   #=> {"a"=>100, "b"=>254, "c"=>300}\n\n   h1 = { "a" => 100, "b" => 200 }\n   h2 = { "b" => 254, "c" => 300 }\n   h1.merge!(h2) { |key, v1, v2| v1 }\n=> {"a"=>100, "b"=>200, "c"=>300}\n
value? Hash.value?(p1)\nReturns `true` if the given value is present for some key\nin <i>hsh</i>.\n\n   h = { "a" => 100, "b" => 200 }\n   h.has_value?(100)   #=> true\n   h.has_value?(999)   #=> false\n
values Hash.values()\nReturns a new array populated with the values from <i>hsh</i>. See\nalso `Hash#keys`.\n\n   h = { "a" => 100, "b" => 200, "c" => 300 }\n   h.values   #=> [100, 200, 300]\n
values_at Hash.values_at(*args)\nReturn an array containing the values associated with the given keys.\nAlso see `Hash.select`.\n\n  h = { "cat" => "feline", "dog" => "canine", "cow" => "bovine" }\n  h.values_at("cow", "cat")  #=> ["bovine", "feline"]\n
assoc ENV.assoc(p1)\nReturns an Array of the name and value of the environment variable with\n+name+ or +nil+ if the name cannot be found.\n
clear ENV.clear()\nRemoves every environment variable.\n
delete ENV.delete(p1)\nDeletes the environment variable with +name+ and returns the value of the\nvariable.  If a block is given it will be called when the named environment\ndoes not exist.\n
delete_if ENV.delete_if()\nDeletes every environment variable for which the block evaluates to +true+.\n\nIf no block is given an enumerator is returned instead.\n
each ENV.each()\nYields each environment variable +name+ and +value+.\n\nIf no block is given an Enumerator is returned.\n
each_key ENV.each_key()\nYields each environment variable name.\n\nAn Enumerator is returned if no block is given.\n
each_pair ENV.each_pair()\nYields each environment variable +name+ and +value+.\n\nIf no block is given an Enumerator is returned.\n
each_value ENV.each_value()\nYields each environment variable +value+.\n\nAn Enumerator is returned if no block was given.\n
empty? ENV.empty?()\nReturns true when there are no environment variables\n
fetch ENV.fetch(p1, p2 = v2)\nRetrieves the environment variable +name+.\n\nIf the given name does not exist and neither +default+ nor a block a\nprovided an IndexError is raised.  If a block is given it is called with\nthe missing name to provide a value.  If a default value is given it will\nbe returned when no block is given.\n
has_key? ENV.has_key?(p1)\nReturns +true+ if there is an environment variable with the given +name+.\n
has_value? ENV.has_value?(p1)\nReturns +true+ if there is an environment variable with the given +value+.\n
include? ENV.include?(p1)\nReturns +true+ if there is an environment variable with the given +name+.\n
index ENV.index(p1)\nDeprecated method that is equivalent to ENV.key\n
inspect ENV.inspect()\nReturns the contents of the environment as a String.\n
invert ENV.invert()\nReturns a new hash created by using environment variable names as values\nand values as names.\n
keep_if ENV.keep_if()\nDeletes every environment variable where the block evaluates to +false+.\n\nReturns an enumerator if no block was given.\n
key ENV.key(p1)\nReturns the name of the environment variable with +value+.  If the value is\nnot found +nil+ is returned.\n
key? ENV.key?(p1)\nReturns +true+ if there is an environment variable with the given +name+.\n
keys ENV.keys()\nReturns every environment variable name in an Array\n
length ENV.length()\nReturns the number of environment variables.\n
member? ENV.member?(p1)\nReturns +true+ if there is an environment variable with the given +name+.\n
pretty_print ENV.pretty_print(q)\n\n
rassoc ENV.rassoc(p1)\nReturns an Array of the name and value of the environment variable with\n+value+ or +nil+ if the value cannot be found.\n
rehash ENV.rehash()\nRe-hashing the environment variables does nothing.  It is provided for\ncompatibility with Hash.\n
reject ENV.reject()\nSame as ENV#delete_if, but works on (and returns) a copy of the\nenvironment.\n
reject! ENV.reject!()\nEquivalent to ENV#delete_if but returns +nil+ if no changes were made.\n\nReturns an Enumerator if no block was given.\n
replace ENV.replace(p1)\nReplaces the contents of the environment variables with the contents of\n+hash+.\n
select ENV.select()\nReturns a copy of the environment for entries where the block returns true.\n\nReturns an Enumerator if no block was given.\n
select! ENV.select!()\nEquivalent to ENV#keep_if but returns +nil+ if no changes were made.\n
shift ENV.shift()\nRemoves an environment variable name-value pair from ENV and returns it as\nan Array.  Returns +nil+ if when the environment is empty.\n
size ENV.size()\nReturns the number of environment variables.\n
store ENV.store(p1, p2)\nSets the environment variable +name+ to +value+.  If the value given is\n+nil+ the environment variable is deleted.\n
to_a ENV.to_a()\nConverts the environment variables into an array of names and value arrays.\n\n  ENV.to_a # => [["TERM" => "xterm-color"], ["SHELL" => "/bin/bash"], ...]\n
to_hash ENV.to_hash()\nCreates a hash with a copy of the environment variables.\n
to_s ENV.to_s()\nReturns "ENV"\n
update ENV.update(p1)\nAdds the contents of +hash+ to the environment variables.  If no block is\nspecified entries with duplicate keys are overwritten, otherwise the value\nof each duplicate name is determined by calling the block with the key, its\nvalue from the environment and its value from the hash.\n
value? ENV.value?(p1)\nReturns +true+ if there is an environment variable with the given +value+.\n
values ENV.values()\nReturns every environment variable value as an Array\n
values_at ENV.values_at(*args)\nReturns an array containing the environment variable values associated with\nthe given names.  See also ENV.select.\n
alias_command Shell.alias_command(ali, command, *opts, &block)\n\n
cd Shell.cd(path)\n\n
debug= Shell.debug=(val)\n\n
def_system_command Shell.def_system_command(command, path = command)\ncommand definitions\n
default_record_separator Shell.default_record_separator()\n\n
default_record_separator= Shell.default_record_separator=(rs)\n\n
default_system_path Shell.default_system_path()\n\n
default_system_path= Shell.default_system_path=(path)\n\n
install_system_commands Shell.install_system_commands(pre = "sys_")\n\n
new Shell.new(pwd = Dir.pwd, umask = nil)\n\n
notify Shell.notify(*opts, &block)\n\n
unalias_command Shell.unalias_command(ali)\n\n
undef_system_command Shell.undef_system_command(command)\n\n
cd Shell.cd(path = nil, verbose = @verbose)\n\n
chdir Shell.chdir(path = nil, verbose = @verbose)\nIf called as iterator, it restores the current directory when the\nblock ends.\n
debug= Shell.debug=(val)\n\n
expand_path Shell.expand_path(path)\n\n
inspect Shell.inspect()\n\n
jobs Shell.jobs()\nprocess management\n
kill Shell.kill(sig, command)\n\n
popd Shell.popd()\n\n
popdir Shell.popdir()\n\n
pushd Shell.pushd(path = nil, verbose = @verbose)\n\n
pushdir Shell.pushdir(path = nil, verbose = @verbose)\n\n
system_path= Shell.system_path=(path)\n\n
add_delegate_command_to_shell Shell::CommandProcessor.add_delegate_command_to_shell(id)\n\n
alias_command Shell::CommandProcessor.alias_command(ali, command, *opts, &block)\n\n
alias_map Shell::CommandProcessor.alias_map()\n\n
def_builtin_commands Shell::CommandProcessor.def_builtin_commands(delegation_class, command_specs)\nCommandProcessor.def_builtin_commands(delegation_class, command_specs)\n    delegation_class: Class or Module\n    command_specs: [[command_name, [argument,...]],...]\n       command_name: String\n       arguments:    String\n          FILENAME?? -> expand_path(filename??)\n          *FILENAME?? -> filename??.collect{|f|expand_path(f)}.join(", ")\n  define command_name(argument,...) as\n      delegation_class.command_name(argument,...)\n
def_system_command Shell::CommandProcessor.def_system_command(command, path = command)\nCommandProcessor.def_system_command(command, path)\n    command:  String\n    path:     String\n  define 'command()' method as method.\n
initialize Shell::CommandProcessor.initialize()\n\n
install_builtin_commands Shell::CommandProcessor.install_builtin_commands()\ndefine default builtin commands\n
install_system_commands Shell::CommandProcessor.install_system_commands(pre = "sys_")\nCommandProcessor.install_system_commands(pre)\n      pre: String - command name prefix\ndefines every command which belongs in default_system_path via\nCommandProcessor.command().  It doesn't define already defined\nmethods twice.  By default, "pre_" is prefixes to each method\nname.  Characters that may not be used in a method name are\nall converted to '_'.  Definition errors are just ignored.\n
method_added Shell::CommandProcessor.method_added(id)\n\n
new Shell::CommandProcessor.new(shell)\n\n
run_config Shell::CommandProcessor.run_config()\ninclude run file.\n
unalias_command Shell::CommandProcessor.unalias_command(ali)\n\n
undef_system_command Shell::CommandProcessor.undef_system_command(command)\n\n
append Shell::CommandProcessor.append(to, filter)\n\n
cat Shell::CommandProcessor.cat(*filenames)\n\n
check_point Shell::CommandProcessor.check_point()\nProcessCommand#transact\n
concat Shell::CommandProcessor.concat(*jobs)\n\n
echo Shell::CommandProcessor.echo(*strings)\n\n
expand_path Shell::CommandProcessor.expand_path(path)\nCommandProcessor#expand_path(path)\n    path:   String\n    return: String\n  returns the absolute path for <path>\n
find_system_command Shell::CommandProcessor.find_system_command(command)\nprivate functions\n
finish_all_jobs Shell::CommandProcessor.finish_all_jobs()\n\n
foreach Shell::CommandProcessor.foreach(path = nil, *rs)\nFile related commands\nShell#foreach\nShell#open\nShell#unlink\nShell#test\n\n-\n\nCommandProcessor#foreach(path, rs)\n    path: String\n    rs:   String - record separator\n    iterator\n  Same as:\n    File#foreach (when path is file)\n    Dir#foreach (when path is directory)\n  path is relative to pwd\n
glob Shell::CommandProcessor.glob(pattern)\ndef sort(*filenames)\n  Sort.new(self, *filenames)\nend\n
mkdir Shell::CommandProcessor.mkdir(*path)\nDir related methods\n\nShell#mkdir\nShell#rmdir\n
notify Shell::CommandProcessor.notify(*opts, &block)\n%pwd, %cwd -> @pwd\n
open Shell::CommandProcessor.open(path, mode = nil, perm = 0666, &b)\nCommandProcessor#open(path, mode)\n    path:   String\n    mode:   String\n    return: File or Dir\n  Same as:\n    File#open (when path is file)\n    Dir#open  (when path is directory)\n  mode has an effect only when path is a file\n
out Shell::CommandProcessor.out(dev = STDOUT, &block)\ninternal commands\n
rehash Shell::CommandProcessor.rehash()\nProcessCommand#rehash\n  clear command hash table.\n
rmdir Shell::CommandProcessor.rmdir(*path)\nCommandProcessor#rmdir(*path)\n    path: String\n  same as Dir.rmdir()\n
system Shell::CommandProcessor.system(command, *opts)\nCommandProcessor#system(command, *opts)\n    command: String\n    opts:    String\n    return:  SystemCommand\n  Same as system() function\n  example:\n    print sh.system("ls", "-l")\n    sh.system("ls", "-l") | sh.head > STDOUT\n
tee Shell::CommandProcessor.tee(file)\n\n
test Shell::CommandProcessor.test(command, file1, file2=nil)\n\n
top_level_test Shell::CommandProcessor.top_level_test(command, file1, file2=nil)\nCommandProcessor#test(command, file1, file2)\nCommandProcessor#[command, file1, file2]\n    command: char or String or Symbol\n    file1:   String\n    file2:   String(optional)\n    return: Boolean\n  same as:\n    test()           (when command is char or length 1 string or symbol)\n    FileTest.command (others)\n  example:\n    sh[?e, "foo"]\n    sh[:e, "foo"]\n    sh["e", "foo"]\n    sh[:exists?, "foo"]\n    sh["exists?", "foo"]\n
transact Shell::CommandProcessor.transact(&block)\n\n
unlink Shell::CommandProcessor.unlink(path)\nCommandProcessor#unlink(path)\n  same as:\n    Dir#unlink  (when path is directory)\n    File#unlink (when path is file)\n
new Shell::Filter.new(sh)\n\n
each Shell::Filter.each(rs = nil)\n\n
input= Shell::Filter.input=(filter)\n\n
inspect Shell::Filter.inspect()\n\n
to_a Shell::Filter.to_a()\n\n
to_s Shell::Filter.to_s()\n\n
activate Shell::ProcessController.activate(pc)\n\n
active_process_controllers Shell::ProcessController.active_process_controllers()\n\n
block_output_synchronize Shell::ProcessController.block_output_synchronize(&b)\n\n
each_active_object Shell::ProcessController.each_active_object()\n\n
inactivate Shell::ProcessController.inactivate(pc)\n\n
new Shell::ProcessController.new(shell)\n\n
wait_to_finish_all_process_controllers Shell::ProcessController.wait_to_finish_all_process_controllers()\n\n
active_job? Shell::ProcessController.active_job?(job)\n\n
active_jobs Shell::ProcessController.active_jobs()\n\n
active_jobs_exist? Shell::ProcessController.active_jobs_exist?()\n\n
add_schedule Shell::ProcessController.add_schedule(command)\nschedule a command\n
jobs Shell::ProcessController.jobs()\n\n
jobs_exist? Shell::ProcessController.jobs_exist?()\n\n
kill_job Shell::ProcessController.kill_job(sig, command)\nkill a job\n
sfork Shell::ProcessController.sfork(command, &block)\nsimple fork\n
start_job Shell::ProcessController.start_job(command = nil)\nstart a job\n
terminate_job Shell::ProcessController.terminate_job(command)\nterminate a job\n
wait_all_jobs_execution Shell::ProcessController.wait_all_jobs_execution()\nwait for all jobs to terminate\n
waiting_job? Shell::ProcessController.waiting_job?(job)\n\n
waiting_jobs Shell::ProcessController.waiting_jobs()\n\n
waiting_jobs_exist? Shell::ProcessController.waiting_jobs_exist?()\n\n
active? Shell::BuiltInCommand.active?()\n\n
wait? Shell::BuiltInCommand.wait?()\n\n
new Shell::Void.new(sh, *opts)\n\n
each Shell::Void.each(rs = nil)\n\n
new Shell::Echo.new(sh, *strings)\n\n
each Shell::Echo.each(rs = nil)\n\n
new Shell::Cat.new(sh, *filenames)\n\n
each Shell::Cat.each(rs = nil)\n\n
new Shell::Glob.new(sh, pattern)\n\n
each Shell::Glob.each(rs = nil)\n\n
new Shell::AppendIO.new(sh, io, filter)\n\n
input= Shell::AppendIO.input=(filter)\n\n
new Shell::AppendFile.new(sh, to_filename, filter)\n\n
input= Shell::AppendFile.input=(filter)\n\n
new Shell::Tee.new(sh, filename)\n\n
each Shell::Tee.each(rs = nil)\n\n
new Shell::Concat.new(sh, *jobs)\n\n
each Shell::Concat.each(rs = nil)\n\n
new Shell::SystemCommand.new(sh, command, *opts)\n\n
active? Shell::SystemCommand.active?()\n\n
each Shell::SystemCommand.each(rs = nil)\n\n
flush Shell::SystemCommand.flush()\n\n
input= Shell::SystemCommand.input=(inp)\n\n
kill Shell::SystemCommand.kill(sig)\n\n
notify Shell::SystemCommand.notify(*opts, &block)\nex)\n   if you wish to output:\n      "shell: job(#{@command}:#{@pid}) close pipe-out."\n   then\n      mes: "job(%id) close pipe-out."\n   yorn: Boolean(@shell.debug? or @shell.verbose?)\n
start Shell::SystemCommand.start()\n\n
start_export Shell::SystemCommand.start_export()\n\n
start_import Shell::SystemCommand.start_import()\n\n
super_each Shell::SystemCommand.super_each(rs = nil)\n\n
terminate Shell::SystemCommand.terminate()\n\n
wait? Shell::SystemCommand.wait?()\n\n
new IPAddr.new(addr = '::', family = Socket::AF_UNSPEC)\nCreates a new ipaddr object either from a human readable IP\naddress representation in string, or from a packed in_addr value\nfollowed by an address family.\n\nIn the former case, the following are the valid formats that will\nbe recognized: "address", "address/prefixlen" and "address/mask",\nwhere IPv6 address may be enclosed in square brackets (`[' and\n`]').  If a prefixlen or a mask is specified, it returns a masked\nIP address.  Although the address family is determined\nautomatically from a specified string, you can specify one\nexplicitly by the optional second argument.\n\nOtherwise an IP address is generated from a packed in_addr value\nand an address family.\n\nThe IPAddr class defines many methods and operators, and some of\nthose, such as &, |, include? and ==, accept a string, or a packed\nin_addr value instead of an IPAddr object.\n
new_ntoh IPAddr.new_ntoh(addr)\nCreates a new ipaddr containing the given network byte ordered\nstring form of an IP address.\n
ntop IPAddr.ntop(addr)\nConvert a network byte ordered string form of an IP address into\nhuman readable form.\n
eql? IPAddr.eql?(other)\nChecks equality used by Hash.\n
hash IPAddr.hash()\nReturns a hash value used by Hash, Set, and Array classes\n
hton IPAddr.hton()\nReturns a network byte ordered string form of the IP address.\n
include? IPAddr.include?(other)\nReturns true if the given ipaddr is in the range.\n\ne.g.:\n  require 'ipaddr'\n  net1 = IPAddr.new("192.168.2.0/24")\n  net2 = IPAddr.new("192.168.2.100")\n  net3 = IPAddr.new("192.168.3.0")\n  p net1.include?(net2)     #=> true\n  p net1.include?(net3)     #=> false\n
inspect IPAddr.inspect()\nReturns a string containing a human-readable representation of the\nipaddr. ("#<IPAddr: family:address/mask>")\n
ip6_arpa IPAddr.ip6_arpa()\nReturns a string for DNS reverse lookup compatible with RFC3172.\n
ip6_int IPAddr.ip6_int()\nReturns a string for DNS reverse lookup compatible with RFC1886.\n
ipv4? IPAddr.ipv4?()\nReturns true if the ipaddr is an IPv4 address.\n
ipv4_compat IPAddr.ipv4_compat()\nReturns a new ipaddr built by converting the native IPv4 address\ninto an IPv4-compatible IPv6 address.\n
ipv4_compat? IPAddr.ipv4_compat?()\nReturns true if the ipaddr is an IPv4-compatible IPv6 address.\n
ipv4_mapped IPAddr.ipv4_mapped()\nReturns a new ipaddr built by converting the native IPv4 address\ninto an IPv4-mapped IPv6 address.\n
ipv4_mapped? IPAddr.ipv4_mapped?()\nReturns true if the ipaddr is an IPv4-mapped IPv6 address.\n
ipv6? IPAddr.ipv6?()\nReturns true if the ipaddr is an IPv6 address.\n
mask IPAddr.mask(prefixlen)\nReturns a new ipaddr built by masking IP address with the given\nprefixlen/netmask. (e.g. 8, 64, "255.255.255.0", etc.)\n
mask! IPAddr.mask!(mask)\nSet current netmask to given mask.\n
native IPAddr.native()\nReturns a new ipaddr built by converting the IPv6 address into a\nnative IPv4 address.  If the IP address is not an IPv4-mapped or\nIPv4-compatible IPv6 address, returns self.\n
reverse IPAddr.reverse()\nReturns a string for DNS reverse lookup.  It returns a string in\nRFC3172 form for an IPv6 address.\n
set IPAddr.set(addr, *family)\nSet +@addr+, the internal stored ip address, to given +addr+. The\nparameter +addr+ is validated using the first +family+ member,\nwhich is +Socket::AF_INET+ or +Socket::AF_INET6+.\n
succ IPAddr.succ()\nReturns the successor to the ipaddr.\n
to_i IPAddr.to_i()\nReturns the integer representation of the ipaddr.\n
to_range IPAddr.to_range()\nCreates a Range object for the network address.\n
to_s IPAddr.to_s()\nReturns a string containing the IP address representation.\n
to_string IPAddr.to_string()\nReturns a string containing the IP address representation in\ncanonical form.\n
accept_loop Socket.accept_loop(*sockets)\nyield socket and client address for each a connection accepted via given\nsockets.\n\nThe arguments are a list of sockets.\nThe individual argument should be a socket or an array of sockets.\n\nThis method yields the block sequentially.\nIt means that the next connection is not accepted until the block returns.\nSo concurrent mechanism, thread for example, should be used to service\nmultiple clients at a time.\n
getaddrinfo Socket.getaddrinfo(p1, p2, p3 = v3, p4 = v4, p5 = v5, p6 = v6, p7 = v7)\nObtains address information for _nodename_:_servname_.\n\n_family_ should be an address family such as: :INET, :INET6, :UNIX, etc.\n\n_socktype_ should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.\n\n_protocol_ should be a protocol defined in the family.\n0 is default protocol for the family.\n\n_flags_ should be bitwise OR of Socket::AI_* constants.\n\n  Socket.getaddrinfo("www.ruby-lang.org", "http", nil, :STREAM)\n=> [["AF_INET", 80, "carbon.ruby-lang.org", "221.186.184.68", 2, 1, 6]] #\nPF_INET/SOCK_STREAM/IPPROTO_TCP\n\n  Socket.getaddrinfo("localhost", nil)\n=> [["AF_INET", 0, "localhost", "127.0.0.1", 2, 1, 6],  #\nPF_INET/SOCK_STREAM/IPPROTO_TCP\n    ["AF_INET", 0, "localhost", "127.0.0.1", 2, 2, 17], #\n    PF_INET/SOCK_DGRAM/IPPROTO_UDP\n    ["AF_INET", 0, "localhost", "127.0.0.1", 2, 3, 0]]  #\n    PF_INET/SOCK_RAW/IPPROTO_IP\n\n_reverse_lookup_ directs the form of the third element, and has to\nbe one of below.\nIf it is ommitted, the default value is +nil+.\n\n  +true+, +:hostname+:  hostname is obtained from numeric address using\n  reverse lookup, which may take a time.\n  +false+, +:numeric+:  hostname is same as numeric address.\n  +nil+:              obey to the current +do_not_reverse_lookup+ flag.\n\nIf Addrinfo object is preferred, use Addrinfo.getaddrinfo.\n
gethostbyaddr Socket.gethostbyaddr(p1, p2 = v2)\nObtains the host information for _address_.\n\n  p Socket.gethostbyaddr([221,186,184,68].pack("CCCC"))\n=> ["carbon.ruby-lang.org", [], 2, "\xDD\xBA\xB8D"]\n
gethostbyname Socket.gethostbyname(p1)\nObtains the host information for _hostname_.\n\n  p Socket.gethostbyname("hal") #=> ["localhost", ["hal"], 2,\n  "\x7F\x00\x00\x01"]\n
gethostname Socket.gethostname()\nReturns the hostname.\n\n  p Socket.gethostname #=> "hal"\n\nNote that it is not guaranteed to be able to convert to IP address using\ngethostbyname, getaddrinfo, etc.\nIf you need local IP address, use Socket.ip_address_list.\n
getnameinfo Socket.getnameinfo(p1, p2 = v2)\nObtains name information for _sockaddr_.\n\n_sockaddr_ should be one of follows.\n- packed sockaddr string such as Socket.sockaddr_in(80, "127.0.0.1")\n- 3-elements array such as ["AF_INET", 80, "127.0.0.1"]\n- 4-elements array such as ["AF_INET", 80, ignored, "127.0.0.1"]\n\n_flags_ should be bitwise OR of Socket::NI_* constants.\n\nNote that the last form is compatible with IPSocket#{addr,peeraddr}.\n\n  Socket.getnameinfo(Socket.sockaddr_in(80, "127.0.0.1"))       #=>\n  ["localhost", "www"]\n  Socket.getnameinfo(["AF_INET", 80, "127.0.0.1"])              #=>\n  ["localhost", "www"]\n  Socket.getnameinfo(["AF_INET", 80, "localhost", "127.0.0.1"]) #=>\n  ["localhost", "www"]\n\nIf Addrinfo object is preferred, use Addrinfo#getnameinfo.\n
getservbyname Socket.getservbyname(p1, p2 = v2)\nObtains the port number for _service_name_.\n\nIf _protocol_name_ is not given, "tcp" is assumed.\n\n  Socket.getservbyname("smtp")          #=> 25\n  Socket.getservbyname("shell")         #=> 514\n  Socket.getservbyname("syslog", "udp") #=> 514\n
getservbyport Socket.getservbyport(p1, p2 = v2)\nObtains the port number for _port_.\n\nIf _protocol_name_ is not given, "tcp" is assumed.\n\n  Socket.getservbyport(80)         #=> "www"\n  Socket.getservbyport(514, "tcp") #=> "shell"\n  Socket.getservbyport(514, "udp") #=> "syslog"\n
ip_address_list Socket.ip_address_list()\nReturns local IP addresses as an array.\n\nThe array contains Addrinfo objects.\n\n pp Socket.ip_address_list\n=> [#<Addrinfo: 127.0.0.1>,\n<Addrinfo: 192.168.0.128>,\n<Addrinfo: ::1>,\n      ...]\n
new Socket.new(p1, p2, p3 = v3)\nCreates a new socket object.\n\n_domain_ should be a communications domain such as: :INET, :INET6, :UNIX, etc.\n\n_socktype_ should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.\n\n_protocol_ should be a protocol defined in the domain.\nThis is optional.\nIf it is not given, 0 is used internally.\n\n  Socket.new(:INET, :STREAM) # TCP socket\n  Socket.new(:INET, :DGRAM)  # UDP socket\n  Socket.new(:UNIX, :STREAM) # UNIX stream socket\n  Socket.new(:UNIX, :DGRAM)  # UNIX datagram socket\n
pack_sockaddr_in Socket.pack_sockaddr_in(p1, p2)\nPacks _port_ and _host_ as an AF_INET/AF_INET6 sockaddr string.\n\n  Socket.sockaddr_in(80, "127.0.0.1")\n=> "\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"\n\n  Socket.sockaddr_in(80, "::1")\n=>\n"\\n\x00\x00P\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00"\n
pack_sockaddr_un Socket.pack_sockaddr_un(p1)\nPacks _path_ as an AF_UNIX sockaddr string.\n\n  Socket.sockaddr_un("/tmp/sock") #=> "\x01\x00/tmp/sock\x00\x00..."\n
pair Socket.pair(p1, p2, p3 = v3)\nCreates a pair of sockets connected each other.\n\n_domain_ should be a communications domain such as: :INET, :INET6, :UNIX, etc.\n\n_socktype_ should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.\n\n_protocol_ should be a protocol defined in the domain.\n0 is default protocol for the domain.\n\n  s1, s2 = Socket.pair(:UNIX, :DGRAM, 0)\n  s1.send "a", 0\n  s1.send "b", 0\n  p s2.recv(10) #=> "a"\n  p s2.recv(10) #=> "b"\n
sockaddr_in Socket.sockaddr_in(p1, p2)\nPacks _port_ and _host_ as an AF_INET/AF_INET6 sockaddr string.\n\n  Socket.sockaddr_in(80, "127.0.0.1")\n=> "\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"\n\n  Socket.sockaddr_in(80, "::1")\n=>\n"\\n\x00\x00P\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00"\n
sockaddr_un Socket.sockaddr_un(p1)\nPacks _path_ as an AF_UNIX sockaddr string.\n\n  Socket.sockaddr_un("/tmp/sock") #=> "\x01\x00/tmp/sock\x00\x00..."\n
socketpair Socket.socketpair(p1, p2, p3 = v3)\nCreates a pair of sockets connected each other.\n\n_domain_ should be a communications domain such as: :INET, :INET6, :UNIX, etc.\n\n_socktype_ should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.\n\n_protocol_ should be a protocol defined in the domain.\n0 is default protocol for the domain.\n\n  s1, s2 = Socket.pair(:UNIX, :DGRAM, 0)\n  s1.send "a", 0\n  s1.send "b", 0\n  p s2.recv(10) #=> "a"\n  p s2.recv(10) #=> "b"\n
tcp Socket.tcp(host, port, local_host=nil, local_port=nil)\ncreates a new socket object connected to host:port using TCP/IP.\n\nIf local_host:local_port is given,\nthe socket is bound to it.\n\nIf a block is given, the block is called with the socket.\nThe value of the block is returned.\nThe socket is closed when this method returns.\n\nIf no block is given, the socket is returned.\n\n  Socket.tcp("www.ruby-lang.org", 80) {|sock|\n    sock.print "GET / HTTP/1.0\r\\nHost: www.ruby-lang.org\r\\n\r\\n"\n    sock.close_write\n    puts sock.read\n  }\n
tcp_server_loop Socket.tcp_server_loop(host=nil, port)\ncreates a TCP/IP server on _port_ and calls the block for each connection\naccepted.\nThe block is called with a socket and a client_address as an Addrinfo object.\n\nIf _host_ is specified, it is used with _port_ to determine the server\naddresses.\n\nThe socket is *not* closed when the block returns.\nSo application should close it explicitly.\n\nThis method calls the block sequentially.\nIt means that the next connection is not accepted until the block returns.\nSo concurrent mechanism, thread for example, should be used to service\nmultiple clients at a time.\n\nNote that Addrinfo.getaddrinfo is used to determine the server socket\naddresses.\nWhen Addrinfo.getaddrinfo returns two or more addresses,\nIPv4 and IPv6 address for example,\nall of them are used.\nSocket.tcp_server_loop succeeds if one socket can be used at least.\n Sequential echo server.\n It services only one client at a time.\n  Socket.tcp_server_loop(16807) {|sock, client_addrinfo|\n    begin\n      IO.copy_stream(sock, sock)\n    ensure\n      sock.close\n    end\n  }\n Threaded echo server\n It services multiple clients at a time.\n Note that it may accept connections too much.\n  Socket.tcp_server_loop(16807) {|sock, client_addrinfo|\n    Thread.new {\n      begin\n        IO.copy_stream(sock, sock)\n      ensure\n        sock.close\n      end\n    }\n  }\n
tcp_server_sockets Socket.tcp_server_sockets(host=nil, port)\ncreates TCP/IP server sockets for _host_ and _port_.\n_host_ is optional.\n\nIf no block given,\nit returns an array of listening sockets.\n\nIf a block is given, the block is called with the sockets.\nThe value of the block is returned.\nThe socket is closed when this method returns.\n\nIf _port_ is 0, actual port number is choosen dynamically.\nHowever all sockets in the result has same port number.\n tcp_server_sockets returns two sockets.\n  sockets = Socket.tcp_server_sockets(1296)\n  p sockets #=> [#<Socket:fd 3>, #<Socket:fd 4>]\n The sockets contains IPv6 and IPv4 sockets.\n  sockets.each {|s| p s.local_address }\n=> #<Addrinfo: [::]:1296 TCP>\n   #<Addrinfo: 0.0.0.0:1296 TCP>\n IPv6 and IPv4 socket has same port number, 53114, even if it is choosen\n dynamically.\n  sockets = Socket.tcp_server_sockets(0)\n  sockets.each {|s| p s.local_address }\n=> #<Addrinfo: [::]:53114 TCP>\n   #<Addrinfo: 0.0.0.0:53114 TCP>\n The block is called with the sockets.\n  Socket.tcp_server_sockets(0) {|sockets|\n    p sockets #=> [#<Socket:fd 3>, #<Socket:fd 4>]\n  }\n
udp_server_loop Socket.udp_server_loop(host=nil, port)\ncreates a UDP/IP server on _port_ and calls the block for each message arrived.\nThe block is called with the message and its source information.\n\nThis method allocates sockets internally using _port_.\nIf _host_ is specified, it is used conjunction with _port_ to determine the\nserver addresses.\n\nThe _msg_ is a string.\n\nThe _msg_src_ is a Socket::UDPSource object.\nIt is used for reply.\n UDP/IP echo server.\n  Socket.udp_server_loop(9261) {|msg, msg_src|\n    msg_src.reply msg\n  }\n
udp_server_loop_on Socket.udp_server_loop_on(sockets)\nRun UDP/IP server loop on the given sockets.\n\nThe return value of Socket.udp_server_sockets is appropriate for the argument.\n\nIt calls the block for each message received.\n
udp_server_recv Socket.udp_server_recv(sockets)\nReceive UDP/IP packets from the given _sockets_.\nFor each packet received, the block is called.\n\nThe block receives _msg_ and _msg_src_.\n_msg_ is a string which is the payload of the received packet.\n_msg_src_ is a Socket::UDPSource object which is used for reply.\n\nSocket.udp_server_loop can be implemented using this method as follows.\n\n  udp_server_sockets(host, port) {|sockets|\n    loop {\n      readable, _, _ = IO.select(sockets)\n      udp_server_recv(readable) {|msg, msg_src| ... }\n    }\n  }\n
udp_server_sockets Socket.udp_server_sockets(host=nil, port)\nCreates UDP/IP sockets for a UDP server.\n\nIf no block given, it returns an array of sockets.\n\nIf a block is given, the block is called with the sockets.\nThe value of the block is returned.\nThe sockets are closed when this method returns.\n\nIf _port_ is zero, some port is choosen.\nBut the choosen port is used for the all sockets.\n UDP/IP echo server\n  Socket.udp_server_sockets(0) {|sockets|\n    p sockets.first.local_address.ip_port     #=> 32963\n    Socket.udp_server_loop_on(sockets) {|msg, msg_src|\n      msg_src.reply msg\n    }\n  }\n
unix Socket.unix(path)\ncreates a new socket connected to path using UNIX socket socket.\n\nIf a block is given, the block is called with the socket.\nThe value of the block is returned.\nThe socket is closed when this method returns.\n\nIf no block is given, the socket is returned.\n talk to /tmp/sock socket.\n  Socket.unix("/tmp/sock") {|sock|\n    t = Thread.new { IO.copy_stream(sock, STDOUT) }\n    IO.copy_stream(STDIN, sock)\n    t.join\n  }\n
unix_server_loop Socket.unix_server_loop(path)\ncreates a UNIX socket server on _path_.\nIt calls the block for each socket accepted.\n\nIf _host_ is specified, it is used with _port_ to determine the server ports.\n\nThe socket is *not* closed when the block returns.\nSo application should close it.\n\nThis method deletes the socket file pointed by _path_ at first if\nthe file is a socket file and it is owned by the user of the application.\nThis is safe only if the directory of _path_ is not changed by a malicious\nuser.\nSo don't use /tmp/malicious-users-directory/socket.\nNote that /tmp/socket and /tmp/your-private-directory/socket is safe assuming\nthat /tmp has sticky bit.\n Sequential echo server.\n It services only one client at a time.\n  Socket.unix_server_loop("/tmp/sock") {|sock, client_addrinfo|\n    begin\n      IO.copy_stream(sock, sock)\n    ensure\n      sock.close\n    end\n  }\n
unix_server_socket Socket.unix_server_socket(path)\ncreates a UNIX server socket on _path_\n\nIf no block given, it returns a listening socket.\n\nIf a block is given, it is called with the socket and the block value is\nreturned.\nWhen the block exits, the socket is closed and the socket file is removed.\n\n  socket = Socket.unix_server_socket("/tmp/s")\n  p socket                  #=> #<Socket:fd 3>\n  p socket.local_address    #=> #<Addrinfo: /tmp/s SOCK_STREAM>\n\n  Socket.unix_server_socket("/tmp/sock") {|s|\n    p s                     #=> #<Socket:fd 3>\n    p s.local_address       #=> # #<Addrinfo: /tmp/sock SOCK_STREAM>\n  }\n
unpack_sockaddr_in Socket.unpack_sockaddr_in(p1)\nUnpacks _sockaddr_ into port and ip_address.\n\n_sockaddr_ should be a string or an addrinfo for AF_INET/AF_INET6.\n\n  sockaddr = Socket.sockaddr_in(80, "127.0.0.1")\n  p sockaddr #=>\n  "\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"\n  p Socket.unpack_sockaddr_in(sockaddr) #=> [80, "127.0.0.1"]\n
unpack_sockaddr_un Socket.unpack_sockaddr_un(p1)\nUnpacks _sockaddr_ into path.\n\n_sockaddr_ should be a string or an addrinfo for AF_UNIX.\n\n  sockaddr = Socket.sockaddr_un("/tmp/sock")\n  p Socket.unpack_sockaddr_un(sockaddr) #=> "/tmp/sock"\n
accept Socket.accept()\nAccepts a next connection.\nReturns a new Socket object and Addrinfo object.\n\n  serv = Socket.new(:INET, :STREAM, 0)\n  serv.listen(5)\n  c = Socket.new(:INET, :STREAM, 0)\n  c.connect(serv.connect_address)\n  p serv.accept #=> [#<Socket:fd 6>, #<Addrinfo: 127.0.0.1:48555 TCP>]\n
accept_nonblock Socket.accept_nonblock()\nAccepts an incoming connection using accept(2) after\nO_NONBLOCK is set for the underlying file descriptor.\nIt returns an array containing the accepted socket\nfor the incoming connection, _client_socket_,\nand an Addrinfo, _client_addrinfo_.\n\n=== Example\n In one script, start this first\n     require 'socket'\n     include Socket::Constants\n     socket = Socket.new(AF_INET, SOCK_STREAM, 0)\n     sockaddr = Socket.sockaddr_in(2200, 'localhost')\n     socket.bind(sockaddr)\n     socket.listen(5)\n     begin # emulate blocking accept\n       client_socket, client_addrinfo = socket.accept_nonblock\n     rescue IO::WaitReadable, Errno::EINTR\n       IO.select([socket])\n       retry\n     end\n     puts "The client said, '#{client_socket.readline.chomp}'"\n     client_socket.puts "Hello from script one!"\n     socket.close\n In another script, start this second\n     require 'socket'\n     include Socket::Constants\n     socket = Socket.new(AF_INET, SOCK_STREAM, 0)\n     sockaddr = Socket.sockaddr_in(2200, 'localhost')\n     socket.connect(sockaddr)\n     socket.puts "Hello from script 2."\n     puts "The server said, '#{socket.readline.chomp}'"\n     socket.close\n\nRefer to Socket#accept for the exceptions that may be thrown if the call\nto _accept_nonblock_ fails.\n\nSocket#accept_nonblock may raise any error corresponding to accept(2) failure,\nincluding Errno::EWOULDBLOCK.\n\nIf the exception is Errno::EWOULDBLOCK, Errno::AGAIN, Errno::ECONNABORTED\nor Errno::EPROTO,\nit is extended by IO::WaitReadable.\nSo IO::WaitReadable can be used to rescue the exceptions for retrying\naccept_nonblock.\n\n=== See\n* Socket#accept\n
bind Socket.bind(p1)\nBinds to the given local address.\n\n=== Parameter\n* +local_sockaddr+ - the +struct+ sockaddr contained in a string or an\nAddrinfo object\n\n=== Example\n     require 'socket'\n use Addrinfo\n     socket = Socket.new(:INET, :STREAM, 0)\n     socket.bind(Addrinfo.tcp("127.0.0.1", 2222))\n     p socket.local_address #=> #<Addrinfo: 127.0.0.1:2222 TCP>\n use struct sockaddr\n     include Socket::Constants\n     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )\n     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )\n     socket.bind( sockaddr )\n\n=== Unix-based Exceptions\nOn unix-based based systems the following system exceptions may be raised if\nthe call to _bind_ fails:\n* Errno::EACCES - the specified _sockaddr_ is protected and the current\n  user does not have permission to bind to it\n* Errno::EADDRINUSE - the specified _sockaddr_ is already in use\n* Errno::EADDRNOTAVAIL - the specified _sockaddr_ is not available from the\n  local machine\n* Errno::EAFNOSUPPORT - the specified _sockaddr_ is not a valid address for\n  the family of the calling +socket+\n* Errno::EBADF - the _sockaddr_ specified is not a valid file descriptor\n* Errno::EFAULT - the _sockaddr_ argument cannot be accessed\n* Errno::EINVAL - the +socket+ is already bound to an address, and the\n  protocol does not support binding to the new _sockaddr_ or the +socket+\n  has been shut down.\n* Errno::EINVAL - the address length is not a valid length for the address\n  family\n* Errno::ENAMETOOLONG - the pathname resolved had a length which exceeded\n  PATH_MAX\n* Errno::ENOBUFS - no buffer space is available\n* Errno::ENOSR - there were insufficient STREAMS resources available to\n  complete the operation\n* Errno::ENOTSOCK - the +socket+ does not refer to a socket\n* Errno::EOPNOTSUPP - the socket type of the +socket+ does not support\n  binding to an address\n\nOn unix-based based systems if the address family of the calling +socket+ is\nSocket::AF_UNIX the follow exceptions may be raised if the call to _bind_\nfails:\n* Errno::EACCES - search permission is denied for a component of the prefix\n  path or write access to the +socket+ is denied\n* Errno::EDESTADDRREQ - the _sockaddr_ argument is a null pointer\n* Errno::EISDIR - same as Errno::EDESTADDRREQ\n* Errno::EIO - an i/o error occurred\n* Errno::ELOOP - too many symbolic links were encountered in translating\n  the pathname in _sockaddr_\n* Errno::ENAMETOOLLONG - a component of a pathname exceeded NAME_MAX\n  characters, or an entire pathname exceeded PATH_MAX characters\n* Errno::ENOENT - a component of the pathname does not name an existing file\n  or the pathname is an empty string\n* Errno::ENOTDIR - a component of the path prefix of the pathname in _sockaddr_\n  is not a directory\n* Errno::EROFS - the name would reside on a read only filesystem\n\n=== Windows Exceptions\nOn Windows systems the following system exceptions may be raised if\nthe call to _bind_ fails:\n* Errno::ENETDOWN-- the network is down\n* Errno::EACCES - the attempt to connect the datagram socket to the\n  broadcast address failed\n* Errno::EADDRINUSE - the socket's local address is already in use\n* Errno::EADDRNOTAVAIL - the specified address is not a valid address for this\n  computer\n* Errno::EFAULT - the socket's internal address or address length parameter\n  is too small or is not a valid part of the user space addressed\n* Errno::EINVAL - the +socket+ is already bound to an address\n* Errno::ENOBUFS - no buffer space is available\n* Errno::ENOTSOCK - the +socket+ argument does not refer to a socket\n\n=== See\n* bind manual pages on unix-based systems\n* bind function in Microsoft's Winsock functions reference\n
connect Socket.connect(p1)\nRequests a connection to be made on the given +remote_sockaddr+. Returns 0 if\nsuccessful, otherwise an exception is raised.\n\n=== Parameter\n* +remote_sockaddr+ - the +struct+ sockaddr contained in a string or\nAddrinfo object\n\n=== Example:\n Pull down Google's web page\n     require 'socket'\n     include Socket::Constants\n     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )\n     sockaddr = Socket.pack_sockaddr_in( 80, 'www.google.com' )\n     socket.connect( sockaddr )\n     socket.write( "GET / HTTP/1.0\r\\n\r\\n" )\n     results = socket.read\n\n=== Unix-based Exceptions\nOn unix-based systems the following system exceptions may be raised if\nthe call to _connect_ fails:\n* Errno::EACCES - search permission is denied for a component of the prefix\n  path or write access to the +socket+ is denied\n* Errno::EADDRINUSE - the _sockaddr_ is already in use\n* Errno::EADDRNOTAVAIL - the specified _sockaddr_ is not available from the\n  local machine\n* Errno::EAFNOSUPPORT - the specified _sockaddr_ is not a valid address for\n  the address family of the specified +socket+\n* Errno::EALREADY - a connection is already in progress for the specified\n  socket\n* Errno::EBADF - the +socket+ is not a valid file descriptor\n* Errno::ECONNREFUSED - the target _sockaddr_ was not listening for connections\n  refused the connection request\n* Errno::ECONNRESET - the remote host reset the connection request\n* Errno::EFAULT - the _sockaddr_ cannot be accessed\n* Errno::EHOSTUNREACH - the destination host cannot be reached (probably\n  because the host is down or a remote router cannot reach it)\n* Errno::EINPROGRESS - the O_NONBLOCK is set for the +socket+ and the\n  connection cannot be immediately established; the connection will be\n  established asynchronously\n* Errno::EINTR - the attempt to establish the connection was interrupted by\n  delivery of a signal that was caught; the connection will be established\n  asynchronously\n* Errno::EISCONN - the specified +socket+ is already connected\n* Errno::EINVAL - the address length used for the _sockaddr_ is not a valid\n  length for the address family or there is an invalid family in _sockaddr_\n* Errno::ENAMETOOLONG - the pathname resolved had a length which exceeded\n  PATH_MAX\n* Errno::ENETDOWN - the local interface used to reach the destination is down\n* Errno::ENETUNREACH - no route to the network is present\n* Errno::ENOBUFS - no buffer space is available\n* Errno::ENOSR - there were insufficient STREAMS resources available to\n  complete the operation\n* Errno::ENOTSOCK - the +socket+ argument does not refer to a socket\n* Errno::EOPNOTSUPP - the calling +socket+ is listening and cannot be connected\n* Errno::EPROTOTYPE - the _sockaddr_ has a different type than the socket\n  bound to the specified peer address\n* Errno::ETIMEDOUT - the attempt to connect time out before a connection\n  was made.\n\nOn unix-based systems if the address family of the calling +socket+ is\nAF_UNIX the follow exceptions may be raised if the call to _connect_\nfails:\n* Errno::EIO - an i/o error occurred while reading from or writing to the\n  file system\n* Errno::ELOOP - too many symbolic links were encountered in translating\n  the pathname in _sockaddr_\n* Errno::ENAMETOOLLONG - a component of a pathname exceeded NAME_MAX\n  characters, or an entire pathname exceeded PATH_MAX characters\n* Errno::ENOENT - a component of the pathname does not name an existing file\n  or the pathname is an empty string\n* Errno::ENOTDIR - a component of the path prefix of the pathname in _sockaddr_\n  is not a directory\n\n=== Windows Exceptions\nOn Windows systems the following system exceptions may be raised if\nthe call to _connect_ fails:\n* Errno::ENETDOWN - the network is down\n* Errno::EADDRINUSE - the socket's local address is already in use\n* Errno::EINTR - the socket was cancelled\n* Errno::EINPROGRESS - a blocking socket is in progress or the service provider\n  is still processing a callback function. Or a nonblocking connect call is\n  in progress on the +socket+.\n* Errno::EALREADY - see Errno::EINVAL\n* Errno::EADDRNOTAVAIL - the remote address is not a valid address, such as\n  ADDR_ANY TODO check ADDRANY TO INADDR_ANY\n* Errno::EAFNOSUPPORT - addresses in the specified family cannot be used with\n  with this +socket+\n* Errno::ECONNREFUSED - the target _sockaddr_ was not listening for connections\n  refused the connection request\n* Errno::EFAULT - the socket's internal address or address length parameter\n  is too small or is not a valid part of the user space address\n* Errno::EINVAL - the +socket+ is a listening socket\n* Errno::EISCONN - the +socket+ is already connected\n* Errno::ENETUNREACH - the network cannot be reached from this host at\nthis time\n* Errno::EHOSTUNREACH - no route to the network is present\n* Errno::ENOBUFS - no buffer space is available\n* Errno::ENOTSOCK - the +socket+ argument does not refer to a socket\n* Errno::ETIMEDOUT - the attempt to connect time out before a connection\n  was made.\n* Errno::EWOULDBLOCK - the socket is marked as nonblocking and the\n  connection cannot be completed immediately\n* Errno::EACCES - the attempt to connect the datagram socket to the\n  broadcast address failed\n\n=== See\n* connect manual pages on unix-based systems\n* connect function in Microsoft's Winsock functions reference\n
connect_nonblock Socket.connect_nonblock(p1)\nRequests a connection to be made on the given +remote_sockaddr+ after\nO_NONBLOCK is set for the underlying file descriptor.\nReturns 0 if successful, otherwise an exception is raised.\n\n=== Parameter\n* +remote_sockaddr+ - the +struct+ sockaddr contained in a string or\nAddrinfo object\n\n=== Example:\n Pull down Google's web page\n     require 'socket'\n     include Socket::Constants\n     socket = Socket.new(AF_INET, SOCK_STREAM, 0)\n     sockaddr = Socket.sockaddr_in(80, 'www.google.com')\n     begin # emulate blocking connect\n       socket.connect_nonblock(sockaddr)\n     rescue IO::WaitWritable\n       IO.select(nil, [socket]) # wait 3-way handshake completion\n       begin\n         socket.connect_nonblock(sockaddr) # check connection failure\n       rescue Errno::EISCONN\n       end\n     end\n     socket.write("GET / HTTP/1.0\r\\n\r\\n")\n     results = socket.read\n\nRefer to Socket#connect for the exceptions that may be thrown if the call\nto _connect_nonblock_ fails.\n\nSocket#connect_nonblock may raise any error corresponding to connect(2)\nfailure,\nincluding Errno::EINPROGRESS.\n\nIf the exception is Errno::EINPROGRESS,\nit is extended by IO::WaitWritable.\nSo IO::WaitWritable can be used to rescue the exceptions for retrying\nconnect_nonblock.\n\n=== See\n* Socket#connect\n
ipv6only! Socket.ipv6only!()\nenable the socket option IPV6_V6ONLY if IPV6_V6ONLY is available.\n
listen Socket.listen(p1)\nListens for connections, using the specified +int+ as the backlog. A call\nto _listen_ only applies if the +socket+ is of type SOCK_STREAM or\nSOCK_SEQPACKET.\n\n=== Parameter\n* +backlog+ - the maximum length of the queue for pending connections.\n\n=== Example 1\n     require 'socket'\n     include Socket::Constants\n     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )\n     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )\n     socket.bind( sockaddr )\n     socket.listen( 5 )\n\n=== Example 2 (listening on an arbitrary port, unix-based systems only):\n     require 'socket'\n     include Socket::Constants\n     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )\n     socket.listen( 1 )\n\n=== Unix-based Exceptions\nOn unix based systems the above will work because a new +sockaddr+ struct\nis created on the address ADDR_ANY, for an arbitrary port number as handed\noff by the kernel. It will not work on Windows, because Windows requires that\nthe +socket+ is bound by calling _bind_ before it can _listen_.\n\nIf the _backlog_ amount exceeds the implementation-dependent maximum\nqueue length, the implementation's maximum queue length will be used.\n\nOn unix-based based systems the following system exceptions may be raised\nif the\ncall to _listen_ fails:\n* Errno::EBADF - the _socket_ argument is not a valid file descriptor\n* Errno::EDESTADDRREQ - the _socket_ is not bound to a local address, and\n  the protocol does not support listening on an unbound socket\n* Errno::EINVAL - the _socket_ is already connected\n* Errno::ENOTSOCK - the _socket_ argument does not refer to a socket\n* Errno::EOPNOTSUPP - the _socket_ protocol does not support listen\n* Errno::EACCES - the calling process does not have appropriate privileges\n* Errno::EINVAL - the _socket_ has been shut down\n* Errno::ENOBUFS - insufficient resources are available in the system to\n  complete the call\n\n=== Windows Exceptions\nOn Windows systems the following system exceptions may be raised if\nthe call to _listen_ fails:\n* Errno::ENETDOWN - the network is down\n* Errno::EADDRINUSE - the socket's local address is already in use. This\n  usually occurs during the execution of _bind_ but could be delayed\n  if the call to _bind_ was to a partially wildcard address (involving\n  ADDR_ANY) and if a specific address needs to be committed at the\n  time of the call to _listen_\n* Errno::EINPROGRESS - a Windows Sockets 1.1 call is in progress or the\n  service provider is still processing a callback function\n* Errno::EINVAL - the +socket+ has not been bound with a call to _bind_.\n* Errno::EISCONN - the +socket+ is already connected\n* Errno::EMFILE - no more socket descriptors are available\n* Errno::ENOBUFS - no buffer space is available\n* Errno::ENOTSOC - +socket+ is not a socket\n* Errno::EOPNOTSUPP - the referenced +socket+ is not a type that supports\n  the _listen_ method\n\n=== See\n* listen manual pages on unix-based systems\n* listen function in Microsoft's Winsock functions reference\n
recvfrom Socket.recvfrom(*args)\nReceives up to _maxlen_ bytes from +socket+. _flags_ is zero or more\nof the +MSG_+ options. The first element of the results, _mesg_, is the data\nreceived. The second element, _sender_addrinfo_, contains protocol-specific\naddress information of the sender.\n\n=== Parameters\n* +maxlen+ - the maximum number of bytes to receive from the socket\n* +flags+ - zero or more of the +MSG_+ options\n\n=== Example\n In one file, start this first\n     require 'socket'\n     include Socket::Constants\n     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )\n     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )\n     socket.bind( sockaddr )\n     socket.listen( 5 )\n     client, client_addrinfo = socket.accept\n     data = client.recvfrom( 20 )[0].chomp\n     puts "I only received 20 bytes '#{data}'"\n     sleep 1\n     socket.close\n In another file, start this second\n     require 'socket'\n     include Socket::Constants\n     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )\n     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )\n     socket.connect( sockaddr )\n     socket.puts "Watch this get cut short!"\n     socket.close\n\n=== Unix-based Exceptions\nOn unix-based based systems the following system exceptions may be raised\nif the\ncall to _recvfrom_ fails:\n* Errno::EAGAIN - the +socket+ file descriptor is marked as O_NONBLOCK and no\n  data is waiting to be received; or MSG_OOB is set and no out-of-band data\n  is available and either the +socket+ file descriptor is marked as\n  O_NONBLOCK or the +socket+ does not support blocking to wait for\n  out-of-band-data\n* Errno::EWOULDBLOCK - see Errno::EAGAIN\n* Errno::EBADF - the +socket+ is not a valid file descriptor\n* Errno::ECONNRESET - a connection was forcibly closed by a peer\n* Errno::EFAULT - the socket's internal buffer, address or address length\n  cannot be accessed or written\n* Errno::EINTR - a signal interrupted _recvfrom_ before any data was available\n* Errno::EINVAL - the MSG_OOB flag is set and no out-of-band data is available\n* Errno::EIO - an i/o error occurred while reading from or writing to the\n  filesystem\n* Errno::ENOBUFS - insufficient resources were available in the system to\n  perform the operation\n* Errno::ENOMEM - insufficient memory was available to fulfill the request\n* Errno::ENOSR - there were insufficient STREAMS resources available to\n  complete the operation\n* Errno::ENOTCONN - a receive is attempted on a connection-mode socket that\n  is not connected\n* Errno::ENOTSOCK - the +socket+ does not refer to a socket\n* Errno::EOPNOTSUPP - the specified flags are not supported for this\nsocket type\n* Errno::ETIMEDOUT - the connection timed out during connection establishment\n  or due to a transmission timeout on an active connection\n\n=== Windows Exceptions\nOn Windows systems the following system exceptions may be raised if\nthe call to _recvfrom_ fails:\n* Errno::ENETDOWN - the network is down\n* Errno::EFAULT - the internal buffer and from parameters on +socket+ are not\n  part of the user address space, or the internal fromlen parameter is\n  too small to accommodate the peer address\n* Errno::EINTR - the (blocking) call was cancelled by an internal call to\n  the WinSock function WSACancelBlockingCall\n* Errno::EINPROGRESS - a blocking Windows Sockets 1.1 call is in progress or\n  the service provider is still processing a callback function\n* Errno::EINVAL - +socket+ has not been bound with a call to _bind_, or an\n  unknown flag was specified, or MSG_OOB was specified for a socket with\n  SO_OOBINLINE enabled, or (for byte stream-style sockets only) the internal\n  len parameter on +socket+ was zero or negative\n* Errno::EISCONN - +socket+ is already connected. The call to _recvfrom_ is\n  not permitted with a connected socket on a socket that is connection\n  oriented or connectionless.\n* Errno::ENETRESET - the connection has been broken due to the keep-alive\n  activity detecting a failure while the operation was in progress.\n* Errno::EOPNOTSUPP - MSG_OOB was specified, but +socket+ is not stream-style\n  such as type SOCK_STREAM. OOB data is not supported in the communication\n  domain associated with +socket+, or +socket+ is unidirectional and\n  supports only send operations\n* Errno::ESHUTDOWN - +socket+ has been shutdown. It is not possible to\n  call _recvfrom_ on a socket after _shutdown_ has been invoked.\n* Errno::EWOULDBLOCK - +socket+ is marked as nonblocking and a  call to\n  _recvfrom_ would block.\n* Errno::EMSGSIZE - the message was too large to fit into the specified buffer\n  and was truncated.\n* Errno::ETIMEDOUT - the connection has been dropped, because of a network\n  failure or because the system on the other end went down without\n  notice\n* Errno::ECONNRESET - the virtual circuit was reset by the remote side\n  executing a hard or abortive close. The application should close the\n  socket; it is no longer usable. On a UDP-datagram socket this error\n  indicates a previous send operation resulted in an ICMP Port Unreachable\n  message.\n
recvfrom_nonblock Socket.recvfrom_nonblock(*args)\nReceives up to _maxlen_ bytes from +socket+ using recvfrom(2) after\nO_NONBLOCK is set for the underlying file descriptor.\n_flags_ is zero or more of the +MSG_+ options.\nThe first element of the results, _mesg_, is the data received.\nThe second element, _sender_addrinfo_, contains protocol-specific address\ninformation of the sender.\n\nWhen recvfrom(2) returns 0, Socket#recvfrom_nonblock returns\nan empty string as data.\nThe meaning depends on the socket: EOF on TCP, empty packet on UDP, etc.\n\n=== Parameters\n* +maxlen+ - the maximum number of bytes to receive from the socket\n* +flags+ - zero or more of the +MSG_+ options\n\n=== Example\n In one file, start this first\n     require 'socket'\n     include Socket::Constants\n     socket = Socket.new(AF_INET, SOCK_STREAM, 0)\n     sockaddr = Socket.sockaddr_in(2200, 'localhost')\n     socket.bind(sockaddr)\n     socket.listen(5)\n     client, client_addrinfo = socket.accept\n     begin # emulate blocking recvfrom\n       pair = client.recvfrom_nonblock(20)\n     rescue IO::WaitReadable\n       IO.select([client])\n       retry\n     end\n     data = pair[0].chomp\n     puts "I only received 20 bytes '#{data}'"\n     sleep 1\n     socket.close\n In another file, start this second\n     require 'socket'\n     include Socket::Constants\n     socket = Socket.new(AF_INET, SOCK_STREAM, 0)\n     sockaddr = Socket.sockaddr_in(2200, 'localhost')\n     socket.connect(sockaddr)\n     socket.puts "Watch this get cut short!"\n     socket.close\n\nRefer to Socket#recvfrom for the exceptions that may be thrown if the call\nto _recvfrom_nonblock_ fails.\n\nSocket#recvfrom_nonblock may raise any error corresponding to recvfrom(2)\nfailure,\nincluding Errno::EWOULDBLOCK.\n\nIf the exception is Errno::EWOULDBLOCK or Errno::AGAIN,\nit is extended by IO::WaitReadable.\nSo IO::WaitReadable can be used to rescue the exceptions for retrying\nrecvfrom_nonblock.\n\n=== See\n* Socket#recvfrom\n
sysaccept Socket.sysaccept()\nAccepts an incoming connection returning an array containing the (integer)\nfile descriptor for the incoming connection, _client_socket_fd_,\nand an Addrinfo, _client_addrinfo_.\n\n=== Example\n In one script, start this first\n     require 'socket'\n     include Socket::Constants\n     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )\n     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )\n     socket.bind( sockaddr )\n     socket.listen( 5 )\n     client_fd, client_addrinfo = socket.sysaccept\n     client_socket = Socket.for_fd( client_fd )\n     puts "The client said, '#{client_socket.readline.chomp}'"\n     client_socket.puts "Hello from script one!"\n     socket.close\n In another script, start this second\n     require 'socket'\n     include Socket::Constants\n     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )\n     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )\n     socket.connect( sockaddr )\n     socket.puts "Hello from script 2."\n     puts "The server said, '#{socket.readline.chomp}'"\n     socket.close\n\nRefer to Socket#accept for the exceptions that may be thrown if the call\nto _sysaccept_ fails.\n\n=== See\n* Socket#accept\n
dump CSV.dump(ary_of_objs, io = "", options = Hash.new)\nThis method allows you to serialize an Array of Ruby objects to a String or\nFile of CSV data.  This is not as powerful as Marshal or YAML, but perhaps\nuseful for spreadsheet and database interaction.\n\nOut of the box, this method is intended to work with simple data objects or\nStructs.  It will serialize a list of instance variables and/or\nStruct.members().\n\nIf you need need more complicated serialization, you can control the process\nby adding methods to the class to be serialized.\n\nA class method csv_meta() is responsible for returning the first row of the\ndocument (as an Array).  This row is considered to be a Hash of the form\nkey_1,value_1,key_2,value_2,...  CSV::load() expects to find a class key\nwith a value of the stringified class name and CSV::dump() will create this,\nif you do not define this method.  This method is only called on the first\nobject of the Array.\n\nThe next method you can provide is an instance method called csv_headers().\nThis method is expected to return the second line of the document (again as\nan Array), which is to be used to give each column a header.  By default,\nCSV::load() will set an instance variable if the field header starts with an\n@ character or call send() passing the header as the method name and\nthe field value as an argument.  This method is only called on the first\nobject of the Array.\n\nFinally, you can provide an instance method called csv_dump(), which will\nbe passed the headers.  This should return an Array of fields that can be\nserialized for this object.  This method is called once for every object in\nthe Array.\n\nThe +io+ parameter can be used to serialize to a File, and +options+ can be\nanything CSV::new() accepts.\n
filter CSV.filter(*args)\nThis method is a convenience for building Unix-like filters for CSV data.\nEach row is yielded to the provided block which can alter it as needed.\nAfter the block returns, the row is appended to +output+ altered or not.\n\nThe +input+ and +output+ arguments can be anything CSV::new() accepts\n(generally String or IO objects).  If not given, they default to\n<tt>ARGF</tt> and <tt>$stdout</tt>.\n\nThe +options+ parameter is also filtered down to CSV::new() after some\nclever key parsing.  Any key beginning with <tt>:in_</tt> or\n<tt>:input_</tt> will have that leading identifier stripped and will only\nbe used in the +options+ Hash for the +input+ object.  Keys starting with\n<tt>:out_</tt> or <tt>:output_</tt> affect only +output+.  All other keys\nare assigned to both objects.\n\nThe <tt>:output_row_sep</tt> +option+ defaults to\n<tt>$INPUT_RECORD_SEPARATOR</tt> (<tt>$/</tt>).\n
foreach CSV.foreach(path, options = Hash.new, &block)\nThis method is intended as the primary interface for reading CSV files.  You\npass a +path+ and any +options+ you wish to set for the read.  Each row of\nfile will be passed to the provided +block+ in turn.\n\nThe +options+ parameter can be anything CSV::new() understands.  This method\nalso understands an additional <tt>:encoding</tt> parameter that you can use\nto specify the Encoding of the data in the file to be read. You must provide\nthis unless your data is in Encoding::default_external().  CSV will use this\nto determine how to parse the data.  You may provide a second Encoding to\nhave the data transcoded as it is read.  For example,\n<tt>encoding: "UTF-32BE:UTF-8"</tt> would read UTF-32BE data from the file\nbut transcode it to UTF-8 before CSV parses it.\n
generate CSV.generate(*args)\nThis method wraps a String you provide, or an empty default String, in a\nCSV object which is passed to the provided block.  You can use the block to\nappend CSV rows to the String and when the block exits, the final String\nwill be returned.\n\nNote that a passed String *is* modfied by this method.  Call dup() before\npassing if you need a new String.\n\nThe +options+ parameter can be anything CSV::new() understands.  This method\nunderstands an additional <tt>:encoding</tt> parameter when not passed a\nString to set the base Encoding for the output.  CSV needs this hint if you\nplan to output non-ASCII compatible data.\n
generate_line CSV.generate_line(row, options = Hash.new)\nThis method is a shortcut for converting a single row (Array) into a CSV\nString.\n\nThe +options+ parameter can be anything CSV::new() understands.  This method\nunderstands an additional <tt>:encoding</tt> parameter to set the base\nEncoding for the output.  This method will try to guess your Encoding from\nthe first non-+nil+ field in +row+, if possible, but you may need to use\nthis parameter as a backup plan.\n\nThe <tt>:row_sep</tt> +option+ defaults to <tt>$INPUT_RECORD_SEPARATOR</tt>\n(<tt>$/</tt>) when calling this method.\n
instance CSV.instance(data = $stdout, options = Hash.new)\nThis method will return a CSV instance, just like CSV::new(), but the\ninstance will be cached and returned for all future calls to this method for\nthe same +data+ object (tested by Object#object_id()) with the same\n+options+.\n\nIf a block is given, the instance is passed to the block and the return\nvalue becomes the return value of the block.\n
load CSV.load(io_or_str, options = Hash.new)\nThis method is the reading counterpart to CSV::dump().  See that method for\na detailed description of the process.\n\nYou can customize loading by adding a class method called csv_load() which\nwill be passed a Hash of meta information, an Array of headers, and an Array\nof fields for the object the method is expected to return.\n\nRemember that all fields will be Strings after this load.  If you need\nsomething else, use +options+ to setup converters or provide a custom\ncsv_load() implementation.\n
new CSV.new(data, options = Hash.new)\nThis constructor will wrap either a String or IO object passed in +data+ for\nreading and/or writing.  In addition to the CSV instance methods, several IO\nmethods are delegated.  (See CSV::open() for a complete list.)  If you pass\na String for +data+, you can later retrieve it (after writing to it, for\nexample) with CSV.string().\n\nNote that a wrapped String will be positioned at at the beginning (for\nreading).  If you want it at the end (for writing), use CSV::generate().\nIf you want any other positioning, pass a preset StringIO object instead.\n\nYou may set any reading and/or writing preferences in the +options+ Hash.\nAvailable options are:\n\n<b><tt>:col_sep</tt></b>::            The String placed between each field.\n                                      This String will be transcoded into\n                                      the data's Encoding before parsing.\n<b><tt>:row_sep</tt></b>::            The String appended to the end of each\n                                      row.  This can be set to the special\n                                      <tt>:auto</tt> setting, which requests\n                                      that CSV automatically discover this\n                                      from the data.  Auto-discovery reads\n                                      ahead in the data looking for the next\n                                      <tt>"\r\\n"</tt>, <tt>"\\n"</tt>, or\n                                      <tt>"\r"</tt> sequence.  A sequence\n                                      will be selected even if it occurs in\n                                      a quoted field, assuming that you\n                                      would have the same line endings\n                                      there.  If none of those sequences is\n                                      found, +data+ is <tt>ARGF</tt>,\n                                      <tt>STDIN</tt>, <tt>STDOUT</tt>, or\n                                      <tt>STDERR</tt>, or the stream is only\n                                      available for output, the default\n                                      <tt>$INPUT_RECORD_SEPARATOR</tt>\n                                      (<tt>$/</tt>) is used.  Obviously,\n                                      discovery takes a little time.  Set\n                                      manually if speed is important.  Also\n                                      note that IO objects should be opened\n                                      in binary mode on Windows if this\n                                      feature will be used as the\n                                      line-ending translation can cause\n                                      problems with resetting the document\n                                      position to where it was before the\n                                      read ahead. This String will be\n                                      transcoded into the data's Encoding\n                                      before parsing.\n<b><tt>:quote_char</tt></b>::         The character used to quote fields.\n                                      This has to be a single character\n                                      String.  This is useful for\n                                      application that incorrectly use\n                                      <tt>'</tt> as the quote character\n                                      instead of the correct <tt>"</tt>.\n                                      CSV will always consider a double\n                                      sequence this character to be an\n                                      escaped quote. This String will be\n                                      transcoded into the data's Encoding\n                                      before parsing.\n<b><tt>:field_size_limit</tt></b>::   This is a maximum size CSV will read\n                                      ahead looking for the closing quote\n                                      for a field.  (In truth, it reads to\n                                      the first line ending beyond this\n                                      size.)  If a quote cannot be found\n                                      within the limit CSV will raise a\n                                      MalformedCSVError, assuming the data\n                                      is faulty.  You can use this limit to\n                                      prevent what are effectively DoS\n                                      attacks on the parser.  However, this\n                                      limit can cause a legitimate parse to\n                                      fail and thus is set to +nil+, or off,\n                                      by default.\n<b><tt>:converters</tt></b>::         An Array of names from the Converters\n                                      Hash and/or lambdas that handle custom\n                                      conversion.  A single converter\n                                      doesn't have to be in an Array.  All\n                                      built-in converters try to transcode\n                                      fields to UTF-8 before converting.\n                                      The conversion will fail if the data\n                                      cannot be transcoded, leaving the\n                                      field unchanged.\n<b><tt>:unconverted_fields</tt></b>:: If set to +true+, an\n                                      unconverted_fields() method will be\n                                      added to all returned rows (Array or\n                                      CSV::Row) that will return the fields\n                                      as they were before conversion.  Note\n                                      that <tt>:headers</tt> supplied by\n                                      Array or String were not fields of the\n                                      document and thus will have an empty\n                                      Array attached.\n<b><tt>:headers</tt></b>::            If set to <tt>:first_row</tt> or\n                                      +true+, the initial row of the CSV\n                                      file will be treated as a row of\n                                      headers.  If set to an Array, the\n                                      contents will be used as the headers.\n                                      If set to a String, the String is run\n                                      through a call of CSV::parse_line()\n                                      with the same <tt>:col_sep</tt>,\n                                      <tt>:row_sep</tt>, and\n                                      <tt>:quote_char</tt> as this instance\n                                      to produce an Array of headers.  This\n                                      setting causes CSV#shift() to return\n                                      rows as CSV::Row objects instead of\n                                      Arrays and CSV#read() to return\n                                      CSV::Table objects instead of an Array\n                                      of Arrays.\n<b><tt>:return_headers</tt></b>::     When +false+, header rows are silently\n                                      swallowed.  If set to +true+, header\n                                      rows are returned in a CSV::Row object\n                                      with identical headers and\n                                      fields (save that the fields do not go\n                                      through the converters).\n<b><tt>:write_headers</tt></b>::      When +true+ and <tt>:headers</tt> is\n                                      set, a header row will be added to the\n                                      output.\n<b><tt>:header_converters</tt></b>::  Identical in functionality to\n                                      <tt>:converters</tt> save that the\n                                      conversions are only made to header\n                                      rows.  All built-in converters try to\n                                      transcode headers to UTF-8 before\n                                      converting.  The conversion will fail\n                                      if the data cannot be transcoded,\n                                      leaving the header unchanged.\n<b><tt>:skip_blanks</tt></b>::        When set to a +true+ value, CSV will\n                                      skip over any rows with no content.\n<b><tt>:force_quotes</tt></b>::       When set to a +true+ value, CSV will\n                                      quote all CSV fields it creates.\n\nSee CSV::DEFAULT_OPTIONS for the default settings.\n\nOptions cannot be overridden in the instance methods for performance reasons,\nso be sure to set what you want here.\n
open CSV.open(*args)\nThis method opens an IO object, and wraps that with CSV.  This is intended\nas the primary interface for writing a CSV file.\n\nYou must pass a +filename+ and may optionally add a +mode+ for Ruby's\nopen().  You may also pass an optional Hash containing any +options+\nCSV::new() understands as the final argument.\n\nThis method works like Ruby's open() call, in that it will pass a CSV object\nto a provided block and close it when the block terminates, or it will\nreturn the CSV object when no block is provided.  (*Note*: This is different\nfrom the Ruby 1.8 CSV library which passed rows to the block.  Use\nCSV::foreach() for that behavior.)\n\nYou must provide a +mode+ with an embedded Encoding designator unless your\ndata is in Encoding::default_external().  CSV will check the Encoding of the\nunderlying IO object (set by the +mode+ you pass) to determine how to parse\nthe data.   You may provide a second Encoding to have the data transcoded as\nit is read just as you can with a normal call to IO::open().  For example,\n<tt>"rb:UTF-32BE:UTF-8"</tt> would read UTF-32BE data from the file but\ntranscode it to UTF-8 before CSV parses it.\n\nAn opened CSV object will delegate to many IO methods for convenience.  You\nmay call:\n\n* binmode()\n* binmode?()\n* close()\n* close_read()\n* close_write()\n* closed?()\n* eof()\n* eof?()\n* external_encoding()\n* fcntl()\n* fileno()\n* flock()\n* flush()\n* fsync()\n* internal_encoding()\n* ioctl()\n* isatty()\n* path()\n* pid()\n* pos()\n* pos=()\n* reopen()\n* seek()\n* stat()\n* sync()\n* sync=()\n* tell()\n* to_i()\n* to_io()\n* truncate()\n* tty?()\n
parse CSV.parse(*args, &block)\nThis method can be used to easily parse CSV out of a String.  You may either\nprovide a +block+ which will be called with each row of the String in turn,\nor just use the returned Array of Arrays (when no +block+ is given).\n\nYou pass your +str+ to read from, and an optional +options+ Hash containing\nanything CSV::new() understands.\n
parse_line CSV.parse_line(line, options = Hash.new)\nThis method is a shortcut for converting a single line of a CSV String into\na into an Array.  Note that if +line+ contains multiple rows, anything\nbeyond the first row is ignored.\n\nThe +options+ parameter can be anything CSV::new() understands.\n
read CSV.read(path, *options)\nUse to slurp a CSV file into an Array of Arrays.  Pass the +path+ to the\nfile and any +options+ CSV::new() understands.  This method also understands\nan additional <tt>:encoding</tt> parameter that you can use to specify the\nEncoding of the data in the file to be read. You must provide this unless\nyour data is in Encoding::default_external().  CSV will use this to determine\nhow to parse the data.  You may provide a second Encoding to have the data\ntranscoded as it is read.  For example,\n<tt>encoding: "UTF-32BE:UTF-8"</tt> would read UTF-32BE data from the file\nbut transcode it to UTF-8 before CSV parses it.\n
readlines CSV.readlines(*args)\nAlias for CSV::read().\n
table CSV.table(path, options = Hash.new)\nA shortcut for:\n\n  CSV.read( path, { headers:           true,\n                    converters:        :numeric,\n                    header_converters: :symbol }.merge(options) )\n
add_row CSV.add_row(row)\n\n
convert CSV.convert(name = nil, &converter)\nYou can use this method to install a CSV::Converters built-in, or provide a\nblock that handles a custom conversion.\n\nIf you provide a block that takes one argument, it will be passed the field\nand is expected to return the converted value or the field itself.  If your\nblock takes two arguments, it will also be passed a CSV::FieldInfo Struct,\ncontaining details about the field.  Again, the block should return a\nconverted field or the field itself.\n
converters CSV.converters()\nReturns the current list of converters in effect.  See CSV::new for details.\nBuilt-in converters will be returned by name, while others will be returned\nas is.\n
each CSV.each()\nYields each row of the data source in turn.\n\nSupport for Enumerable.\n\nThe data source must be open for reading.\n
force_quotes? CSV.force_quotes?()\nReturns +true+ if all output fields are quoted. See CSV::new for details.\n
gets CSV.gets()\n\n
header_convert CSV.header_convert(name = nil, &converter)\nIdentical to CSV#convert(), but for header rows.\n\nNote that this method must be called before header rows are read to have any\neffect.\n
header_converters CSV.header_converters()\nReturns the current list of converters in effect for headers.  See CSV::new\nfor details.  Built-in converters will be returned by name, while others\nwill be returned as is.\n
header_row? CSV.header_row?()\nReturns +true+ if the next row read will be a header row.\n
headers CSV.headers()\nReturns +nil+ if headers will not be used, +true+ if they will but have not\nyet been read, or the actual headers after they have been read.  See\nCSV::new for details.\n
inspect CSV.inspect()\nReturns a simplified description of the key CSV attributes in an\nASCII compatible String.\n
puts CSV.puts(row)\n\n
read CSV.read()\nSlurps the remaining rows and returns an Array of Arrays.\n\nThe data source must be open for reading.\n
readline CSV.readline()\n\n
readlines CSV.readlines()\n\n
return_headers? CSV.return_headers?()\nReturns +true+ if headers will be returned as a row of results.\nSee CSV::new for details.\n
rewind CSV.rewind()\nRewinds the underlying IO object and resets CSV's lineno() counter.\n
shift CSV.shift()\nThe primary read method for wrapped Strings and IOs, a single row is pulled\nfrom the data source, parsed and returned as an Array of fields (if header\nrows are not used) or a CSV::Row (when header rows are used).\n\nThe data source must be open for reading.\n
skip_blanks? CSV.skip_blanks?()\nReturns +true+ blank lines are skipped by the parser. See CSV::new\nfor details.\n
unconverted_fields? CSV.unconverted_fields?()\nReturns +true+ if unconverted_fields() to parsed results.  See CSV::new\nfor details.\n
write_headers? CSV.write_headers?()\nReturns +true+ if headers are written in output. See CSV::new for details.\n
new CSV::Row.new(headers, fields, header_row = false)\nConstruct a new CSV::Row from +headers+ and +fields+, which are expected\nto be Arrays.  If one Array is shorter than the other, it will be padded\nwith +nil+ objects.\n\nThe optional +header_row+ parameter can be set to +true+ to indicate, via\nCSV::Row.header_row?() and CSV::Row.field_row?(), that this is a header\nrow.  Otherwise, the row is assumes to be a field row.\n\nA CSV::Row object supports the following Array methods through delegation:\n\n* empty?()\n* length()\n* size()\n
delete CSV::Row.delete(header_or_index, minimum_index = 0)\nUsed to remove a pair from the row by +header+ or +index+.  The pair is\nlocated as described in CSV::Row.field().  The deleted pair is returned,\nor +nil+ if a pair could not be found.\n
delete_if CSV::Row.delete_if(&block)\nThe provided +block+ is passed a header and field for each pair in the row\nand expected to return +true+ or +false+, depending on whether the pair\nshould be deleted.\n\nThis method returns the row for chaining.\n
each CSV::Row.each(&block)\nYields each pair of the row as header and field tuples (much like\niterating over a Hash).\n\nSupport for Enumerable.\n\nThis method returns the row for chaining.\n
field CSV::Row.field(header_or_index, minimum_index = 0)\nThis method will fetch the field value by +header+ or +index+.  If a field\nis not found, +nil+ is returned.\n\nWhen provided, +offset+ ensures that a header match occurrs on or later\nthan the +offset+ index.  You can use this to find duplicate headers,\nwithout resorting to hard-coding exact indices.\n
field? CSV::Row.field?(data)\nReturns +true+ if +data+ matches a field in this row, and +false+\notherwise.\n
field_row? CSV::Row.field_row?()\nReturns +true+ if this is a field row.\n
fields CSV::Row.fields(*headers_and_or_indices)\nThis method accepts any number of arguments which can be headers, indices,\nRanges of either, or two-element Arrays containing a header and offset.\nEach argument will be replaced with a field lookup as described in\nCSV::Row.field().\n\nIf called with no arguments, all fields are returned.\n
header? CSV::Row.header?(name)\nReturns +true+ if +name+ is a header for this row, and +false+ otherwise.\n
header_row? CSV::Row.header_row?()\nReturns +true+ if this is a header row.\n
headers CSV::Row.headers()\nReturns the headers of this row.\n
include? CSV::Row.include?(name)\n\n
index CSV::Row.index(header, minimum_index = 0)\nThis method will return the index of a field with the provided +header+.\nThe +offset+ can be used to locate duplicate header names, as described in\nCSV::Row.field().\n
inspect CSV::Row.inspect()\nA summary of fields, by header, in an ASCII compatible String.\n
push CSV::Row.push(*args)\nA shortcut for appending multiple fields.  Equivalent to:\n\n  args.each { |arg| csv_row << arg }\n\nThis method returns the row for chaining.\n
to_csv CSV::Row.to_csv(options = Hash.new)\nReturns the row as a CSV String.  Headers are not used.  Equivalent to:\n\n  csv_row.fields.to_csv( options )\n
to_hash CSV::Row.to_hash()\nCollapses the row into a simple Hash.  Be warning that this discards field\norder and clobbers duplicate fields.\n
to_s CSV::Row.to_s(options = Hash.new)\n\n
values_at CSV::Row.values_at(*headers_and_or_indices)\n\n
new CSV::Table.new(array_of_rows)\nConstruct a new CSV::Table from +array_of_rows+, which are expected\nto be CSV::Row objects.  All rows are assumed to have the same headers.\n\nA CSV::Table object supports the following Array methods through\ndelegation:\n\n* empty?()\n* length()\n* size()\n
by_col CSV::Table.by_col()\nReturns a duplicate table object, in column mode.  This is handy for\nchaining in a single call without changing the table mode, but be aware\nthat this method can consume a fair amount of memory for bigger data sets.\n\nThis method returns the duplicate table for chaining.  Don't chain\ndestructive methods (like []=()) this way though, since you are working\nwith a duplicate.\n
by_col! CSV::Table.by_col!()\nSwitches the mode of this table to column mode.  All calls to indexing and\niteration methods will work with columns until the mode is changed again.\n\nThis method returns the table and is safe to chain.\n
by_col_or_row CSV::Table.by_col_or_row()\nReturns a duplicate table object, in mixed mode.  This is handy for\nchaining in a single call without changing the table mode, but be aware\nthat this method can consume a fair amount of memory for bigger data sets.\n\nThis method returns the duplicate table for chaining.  Don't chain\ndestructive methods (like []=()) this way though, since you are working\nwith a duplicate.\n
by_col_or_row! CSV::Table.by_col_or_row!()\nSwitches the mode of this table to mixed mode.  All calls to indexing and\niteration methods will use the default intelligent indexing system until\nthe mode is changed again.  In mixed mode an index is assumed to be a row\nreference while anything else is assumed to be column access by headers.\n\nThis method returns the table and is safe to chain.\n
by_row CSV::Table.by_row()\nReturns a duplicate table object, in row mode.  This is handy for chaining\nin a single call without changing the table mode, but be aware that this\nmethod can consume a fair amount of memory for bigger data sets.\n\nThis method returns the duplicate table for chaining.  Don't chain\ndestructive methods (like []=()) this way though, since you are working\nwith a duplicate.\n
by_row! CSV::Table.by_row!()\nSwitches the mode of this table to row mode.  All calls to indexing and\niteration methods will work with rows until the mode is changed again.\n\nThis method returns the table and is safe to chain.\n
delete CSV::Table.delete(index_or_header)\nRemoves and returns the indicated column or row.  In the default mixed\nmode indices refer to rows and everything else is assumed to be a column\nheader.  Use by_col!() or by_row!() to force the lookup.\n
delete_if CSV::Table.delete_if(&block)\nRemoves any column or row for which the block returns +true+.  In the\ndefault mixed mode or row mode, iteration is the standard row major\nwalking of rows.  In column mode, interation will +yield+ two element\ntuples containing the column name and an Array of values for that column.\n\nThis method returns the table for chaining.\n
each CSV::Table.each(&block)\nIn the default mixed mode or row mode, iteration is the standard row major\nwalking of rows.  In column mode, interation will +yield+ two element\ntuples containing the column name and an Array of values for that column.\n\nThis method returns the table for chaining.\n
headers CSV::Table.headers()\nReturns the headers for the first row of this table (assumed to match all\nother rows).  An empty Array is returned for empty tables.\n
inspect CSV::Table.inspect()\nShows the mode and size of this table in a US-ASCII String.\n
push CSV::Table.push(*rows)\nA shortcut for appending multiple rows.  Equivalent to:\n\n  rows.each { |row| self << row }\n\nThis method returns the table for chaining.\n
to_a CSV::Table.to_a()\nReturns the table as an Array of Arrays.  Headers will be the first row,\nthen all of the field rows will follow.\n
to_csv CSV::Table.to_csv(options = Hash.new)\nReturns the table as a complete CSV String.  Headers will be listed first,\nthen all of the field rows.\n\nThis method assumes you want the Table.headers(), unless you explicitly\npass <tt>:write_headers => false</tt>.\n
to_s CSV::Table.to_s(options = Hash.new)\n\n
values_at CSV::Table.values_at(*indices_or_headers)\nThe mixed mode default is to treat a list of indices as row access,\nreturning the rows indicated.  Anything else is considered columnar\naccess.  For columnar access, the return set has an Array for each row\nwith the values indicated by the headers in each Array.  You can force\ncolumn or row mode using by_col!() or by_row!().\n\nYou cannot mix column and row access.\n
I Matrix.I(n)\n\n
build Matrix.build(row_size, column_size = row_size)\nCreates a matrix of size +row_size+ x +column_size+.\nIt fills the values by calling the given block,\npassing the current row and column.\nReturns an enumerator if no block is given.\n\n  m = Matrix.build(2, 4) {|row, col| col - row }\n    => Matrix[[0, 1, 2, 3], [-1, 0, 1, 2]]\n  m = Matrix.build(3) { rand }\n    => a 3x3 matrix with random elements\n
column_vector Matrix.column_vector(column)\nCreates a single-column matrix where the values of that column are as given\nin +column+.\n  Matrix.column_vector([4,5,6])\n    => 4\n       5\n       6\n
columns Matrix.columns(columns)\nCreates a matrix using +columns+ as an array of column vectors.\n  Matrix.columns([[25, 93], [-1, 66]])\n     =>  25 -1\n         93 66\n
diagonal Matrix.diagonal(*values)\nCreates a matrix where the diagonal elements are composed of +values+.\n  Matrix.diagonal(9, 5, -3)\n    =>  9  0  0\n        0  5  0\n        0  0 -3\n
empty Matrix.empty(row_size = 0, column_size = 0)\nCreates a empty matrix of +row_size+ x +column_size+.\nAt least one of +row_size+ or +column_size+ must be 0.\n\n  m = Matrix.empty(2, 0)\n  m == Matrix[ [], [] ]\n    => true\n  n = Matrix.empty(0, 3)\n  n == Matrix.columns([ [], [], [] ])\n    => true\n  m * n\n    => Matrix[[0, 0, 0], [0, 0, 0]]\n
identity Matrix.identity(n)\nCreates an +n+ by +n+ identity matrix.\n  Matrix.identity(2)\n    => 1 0\n       0 1\n
new Matrix.new(rows, column_size = rows[0].size)\nMatrix.new is private; use Matrix.rows, columns, [], etc... to create.\n
row_vector Matrix.row_vector(row)\nCreates a single-row matrix where the values of that row are as given in\n+row+.\n  Matrix.row_vector([4,5,6])\n    => 4 5 6\n
rows Matrix.rows(rows, copy = true)\nCreates a matrix where +rows+ is an array of arrays, each of which is a row\nof the matrix.  If the optional argument +copy+ is false, use the given\narrays as the internal structure of the matrix without copying.\n  Matrix.rows([[25, 93], [-1, 66]])\n     =>  25 93\n         -1 66\n
scalar Matrix.scalar(n, value)\nCreates an +n+ by +n+ diagonal matrix where each diagonal element is\n+value+.\n  Matrix.scalar(2, 5)\n    => 5 0\n       0 5\n
unit Matrix.unit(n)\n\n
zero Matrix.zero(row_size, column_size = row_size)\nCreates a zero matrix.\n  Matrix.zero(2)\n    => 0 0\n       0 0\n
clone Matrix.clone()\nReturns a clone of the matrix, so that the contents of each do not reference\nidentical objects.\nThere should be no good reason to do this since Matrices are immutable.\n
coerce Matrix.coerce(other)\nThe coerce method provides support for Ruby type coercion.\nThis coercion mechanism is used by Ruby to handle mixed-type\nnumeric operations: it is intended to find a compatible common\ntype between the two operands of the operator.\nSee also Numeric#coerce.\n
collect Matrix.collect()\nReturns a matrix that is the result of iteration of the given block over all\nelements of the matrix.\n  Matrix[ [1,2], [3,4] ].collect { |e| e**2 }\n    => 1  4\n       9 16\n
column Matrix.column(j)\nReturns column vector number +j+ of the matrix as a Vector (starting at 0\nlike an array).  When a block is given, the elements of that vector are\niterated.\n
column_vectors Matrix.column_vectors()\nReturns an array of the column vectors of the matrix.  See Vector.\n
component Matrix.component(i, j)\n\n
conj Matrix.conj()\n\n
conjugate Matrix.conjugate()\nReturns the conjugate of the matrix.\n  Matrix[[Complex(1,2), Complex(0,1), 0], [1, 2, 3]]\n    => 1+2i   i  0\n          1   2  3\n  Matrix[[Complex(1,2), Complex(0,1), 0], [1, 2, 3]].conjugate\n    => 1-2i  -i  0\n          1   2  3\n
det Matrix.det()\n\n
det_e Matrix.det_e()\n\n
determinant Matrix.determinant()\nReturns the determinant of the matrix.\n\nBeware that using Float values can yield erroneous results\nbecause of their lack of precision.\nConsider using exact types like Rational or BigDecimal instead.\n\n  Matrix[[7,6], [3,9]].determinant\n    => 45\n
determinant_e Matrix.determinant_e()\ndeprecated; use Matrix#determinant\n
diagonal? Matrix.diagonal?()\nReturns +true+ is this is a diagonal matrix.\nRaises an error if matrix is not square.\n
each Matrix.each(which = :all)\nYields all elements of the matrix, starting with those of the first row,\nor returns an Enumerator is no block given.\nElements can be restricted by passing an argument:\n* :all (default): yields all elements\n* :diagonal: yields only elements on the diagonal\n* :off_diagonal: yields all elements except on the diagonal\n* :lower: yields only elements on or below the diagonal\n* :strict_lower: yields only elements below the diagonal\n* :strict_upper: yields only elements above the diagonal\n* :upper: yields only elements on or above the diagonal\n\n  Matrix[ [1,2], [3,4] ].each { |e| puts e }\n => prints the numbers 1 to 4\n  Matrix[ [1,2], [3,4] ].each(:strict_lower).to_a # => [3]\n
each_with_index Matrix.each_with_index(which = :all)\nSame as #each, but the row index and column index in addition to the element\n\n  Matrix[ [1,2], [3,4] ].each_with_index do |e, row, col|\n    puts "#{e} at #{row}, #{col}"\n  end\n => Prints:\n    1 at 0, 0\n    2 at 0, 1\n    3 at 1, 0\n    4 at 1, 1\n
eigen Matrix.eigen()\n\n
eigensystem Matrix.eigensystem()\nReturns the Eigensystem of the matrix; see +EigenvalueDecomposition+.\n  m = Matrix[[1, 2], [3, 4]]\n  v, d, v_inv = m.eigensystem\n  d.diagonal? # => true\n  v.inv == v_inv # => true\n  (v * d * v_inv).round(5) == m # => true\n
element Matrix.element(i, j)\n\n
elements_to_f Matrix.elements_to_f()\n\n
elements_to_i Matrix.elements_to_i()\n\n
elements_to_r Matrix.elements_to_r()\n\n
empty? Matrix.empty?()\nReturns +true+ if this is an empty matrix, i.e. if the number of rows\nor the number of columns is 0.\n
eql? Matrix.eql?(other)\n\n
find_index Matrix.find_index(*args)\n\n
hash Matrix.hash()\nReturns a hash-code for the matrix.\n
hermitian? Matrix.hermitian?()\nReturns +true+ is this is an hermitian matrix.\nRaises an error if matrix is not square.\n
imag Matrix.imag()\n\n
imaginary Matrix.imaginary()\nReturns the imaginary part of the matrix.\n  Matrix[[Complex(1,2), Complex(0,1), 0], [1, 2, 3]]\n    => 1+2i  i  0\n          1  2  3\n  Matrix[[Complex(1,2), Complex(0,1), 0], [1, 2, 3]].imaginary\n    =>   2i  i  0\n          0  0  0\n
index Matrix.index(*args)\nThe index method is specialized to return the index as [row, column]\nIt also accepts an optional +selector+ argument, see #each for details.\n\n  Matrix[ [1,2], [3,4] ].index(&:even?) # => [0, 1]\n  Matrix[ [1,1], [1,1] ].index(1, :strict_lower) # => [1, 0]\n
inspect Matrix.inspect()\nOverrides Object#inspect\n
inv Matrix.inv()\n\n
inverse Matrix.inverse()\nReturns the inverse of the matrix.\n  Matrix[[-1, -1], [0, -1]].inverse\n    => -1  1\n        0 -1\n
lower_triangular? Matrix.lower_triangular?()\nReturns +true+ is this is a lower triangular matrix.\n
lup Matrix.lup()\nReturns the LUP decomposition of the matrix; see +LUPDecomposition+.\n  a = Matrix[[1, 2], [3, 4]]\n  l, u, p = a.lup\n  l.lower_triangular? # => true\n  u.upper_triangular? # => true\n  p.permutation?      # => true\n  l * u == a * p      # => true\n  a.lup.solve([2, 5]) # => Vector[(1/1), (1/2)]\n
lup_decomposition Matrix.lup_decomposition()\n\n
map Matrix.map()\n\n
minor Matrix.minor(*param)\nReturns a section of the matrix.  The parameters are either:\n*  start_row, nrows, start_col, ncols; OR\n*  row_range, col_range\n\n  Matrix.diagonal(9, 5, -3).minor(0..1, 0..2)\n    => 9 0 0\n       0 5 0\n\nLike Array#[], negative indices count backward from the end of the\nrow or column (-1 is the last element). Returns nil if the starting\nrow or column is greater than row_size or column_size respectively.\n
normal? Matrix.normal?()\nReturns +true+ is this is a normal matrix.\nRaises an error if matrix is not square.\n
orthogonal? Matrix.orthogonal?()\nReturns +true+ is this is an orthogonal matrix\nRaises an error if matrix is not square.\n
permutation? Matrix.permutation?()\nReturns +true+ is this is a permutation matrix\nRaises an error if matrix is not square.\n
rank Matrix.rank()\nReturns the rank of the matrix.\nBeware that using Float values can yield erroneous results\nbecause of their lack of precision.\nConsider using exact types like Rational or BigDecimal instead.\n\n  Matrix[[7,6], [3,9]].rank\n    => 2\n
rank_e Matrix.rank_e()\ndeprecated; use Matrix#rank\n
real Matrix.real()\nReturns the real part of the matrix.\n  Matrix[[Complex(1,2), Complex(0,1), 0], [1, 2, 3]]\n    => 1+2i  i  0\n          1  2  3\n  Matrix[[Complex(1,2), Complex(0,1), 0], [1, 2, 3]].real\n    =>    1  0  0\n          1  2  3\n
real? Matrix.real?()\nReturns +true+ if all entries of the matrix are real.\n
rect Matrix.rect()\nReturns an array containing matrices corresponding to the real and imaginary\nparts of the matrix\n\nm.rect == [m.real, m.imag]  # ==> true for all matrices m\n
rectangular Matrix.rectangular()\n\n
regular? Matrix.regular?()\nReturns +true+ if this is a regular (i.e. non-singular) matrix.\n
round Matrix.round(ndigits=0)\nReturns a matrix with entries rounded to the given precision\n(see Float#round)\n
row Matrix.row(i)\nReturns row vector number +i+ of the matrix as a Vector (starting at 0 like\nan array).  When a block is given, the elements of that vector are iterated.\n
row_size Matrix.row_size()\nReturns the number of rows.\n
row_vectors Matrix.row_vectors()\nReturns an array of the row vectors of the matrix.  See Vector.\n
singular? Matrix.singular?()\nReturns +true+ is this is a singular matrix.\n
square? Matrix.square?()\nReturns +true+ is this is a square matrix.\n
symmetric? Matrix.symmetric?()\nReturns +true+ is this is a symmetric matrix.\nRaises an error if matrix is not square.\n
t Matrix.t()\n\n
to_a Matrix.to_a()\nReturns an array of arrays that describe the rows of the matrix.\n
to_s Matrix.to_s()\nOverrides Object#to_s\n
tr Matrix.tr()\n\n
trace Matrix.trace()\nReturns the trace (sum of diagonal elements) of the matrix.\n  Matrix[[7,6], [3,9]].trace\n    => 16\n
transpose Matrix.transpose()\nReturns the transpose of the matrix.\n  Matrix[[1,2], [3,4], [5,6]]\n    => 1 2\n       3 4\n       5 6\n  Matrix[[1,2], [3,4], [5,6]].transpose\n    => 1 3 5\n       2 4 6\n
unitary? Matrix.unitary?()\nReturns +true+ is this is a unitary matrix\nRaises an error if matrix is not square.\n
upper_triangular? Matrix.upper_triangular?()\nReturns +true+ is this is an upper triangular matrix.\n
zero? Matrix.zero?()\nReturns +true+ is this is a matrix with only zero elements\n
new Matrix::EigenvalueDecomposition.new(a)\nConstructs the eigenvalue decomposition for a square matrix +A+\n
d Matrix::EigenvalueDecomposition.d()\n\n
eigenvalue_matrix Matrix::EigenvalueDecomposition.eigenvalue_matrix()\nReturns the block diagonal eigenvalue matrix +D+\n
eigenvalues Matrix::EigenvalueDecomposition.eigenvalues()\nReturns the eigenvalues in an array\n
eigenvector_matrix Matrix::EigenvalueDecomposition.eigenvector_matrix()\nReturns the eigenvector matrix +V+\n
eigenvector_matrix_inv Matrix::EigenvalueDecomposition.eigenvector_matrix_inv()\nReturns the inverse of the eigenvector matrix +V+\n
eigenvectors Matrix::EigenvalueDecomposition.eigenvectors()\nReturns an array of the eigenvectors\n
to_a Matrix::EigenvalueDecomposition.to_a()\n\n
to_ary Matrix::EigenvalueDecomposition.to_ary()\nReturns [eigenvector_matrix, eigenvalue_matrix, eigenvector_matrix_inv]\n
v Matrix::EigenvalueDecomposition.v()\n\n
v_inv Matrix::EigenvalueDecomposition.v_inv()\n\n
new Matrix::LUPDecomposition.new(a)\n\n
det Matrix::LUPDecomposition.det()\nReturns the determinant of +A+, calculated efficiently\nfrom the factorization.\n
determinant Matrix::LUPDecomposition.determinant()\n\n
l Matrix::LUPDecomposition.l()\n\n
p Matrix::LUPDecomposition.p()\nReturns the permutation matrix +P+\n
singular? Matrix::LUPDecomposition.singular?()\nReturns +true+ if +U+, and hence +A+, is singular.\n
solve Matrix::LUPDecomposition.solve(b)\nReturns +m+ so that <tt>A*m = b</tt>,\nor equivalently so that <tt>L*U*m = P*b</tt>\n+b+ can be a Matrix or a Vector\n
to_a Matrix::LUPDecomposition.to_a()\n\n
to_ary Matrix::LUPDecomposition.to_ary()\nReturns +L+, +U+, +P+ in an array\n
u Matrix::LUPDecomposition.u()\nReturns the upper triangular factor +U+\n
new Logger.new(logdev, shift_age = 0, shift_size = 1048576)\n=== Synopsis\n\n  Logger.new(name, shift_age = 7, shift_size = 1048576)\n  Logger.new(name, shift_age = 'weekly')\n\n=== Args\n\n+logdev+::\n  The log device.  This is a filename (String) or IO object (typically\n  +STDOUT+, +STDERR+, or an open file).\n+shift_age+::\n  Number of old log files to keep, *or* frequency of rotation (+daily+,\n  +weekly+ or +monthly+).\n+shift_size+::\n  Maximum logfile size (only applies when +shift_age+ is a number).\n\n=== Description\n\nCreate an instance.\n
add Logger.add(severity, message = nil, progname = nil, &block)\n=== Synopsis\n\n  Logger#add(severity, message = nil, progname = nil) { ... }\n\n=== Args\n\n+severity+::\n  Severity.  Constants are defined in Logger namespace: +DEBUG+, +INFO+,\n  +WARN+, +ERROR+, +FATAL+, or +UNKNOWN+.\n+message+::\n  The log message.  A String or Exception.\n+progname+::\n  Program name string.  Can be omitted.  Treated as a message if no\n  +message+ and +block+ are given.\n+block+::\n  Can be omitted.  Called to get a message string if +message+ is nil.\n\n=== Return\n\n+true+ if successful, +false+ otherwise.\n\nWhen the given severity is not high enough (for this particular logger), log\nno message, and return +true+.\n\n=== Description\n\nLog a message if the given severity is high enough.  This is the generic\nlogging method.  Users will be more inclined to use #debug, #info, #warn,\nerror, and #fatal.\n\n<b>Message format</b>: +message+ can be any object, but it has to be\nconverted to a String in order to log it.  Generally, +inspect+ is used\nif the given object is not a String.\nA special case is an +Exception+ object, which will be printed in detail,\nincluding message, class, and backtrace.  See #msg2str for the\nimplementation if required.\n\n=== Bugs\n\n* Logfile is not locked.\n* Append open does not need to lock file.\n* If the OS which supports multi I/O, records possibly be mixed.\n
close Logger.close()\nClose the logging device.\n
datetime_format Logger.datetime_format()\nReturns the date format being used.  See #datetime_format=\n
datetime_format= Logger.datetime_format=(datetime_format)\nSet date-time format.\n\n+datetime_format+:: A string suitable for passing to +strftime+.\n
debug Logger.debug(progname = nil, &block)\nLog a +DEBUG+ message.\n\nSee #info for more information.\n
debug? Logger.debug?()\nReturns +true+ iff the current severity level allows for the printing of\n+DEBUG+ messages.\n
error Logger.error(progname = nil, &block)\nLog an +ERROR+ message.\n\nSee #info for more information.\n
error? Logger.error?()\nReturns +true+ iff the current severity level allows for the printing of\n+ERROR+ messages.\n
fatal Logger.fatal(progname = nil, &block)\nLog a +FATAL+ message.\n\nSee #info for more information.\n
fatal? Logger.fatal?()\nReturns +true+ iff the current severity level allows for the printing of\n+FATAL+ messages.\n
info Logger.info(progname = nil, &block)\nLog an +INFO+ message.\n\n+message+:: the message to log; does not need to be a String\n+progname+:: in the block form, this is the #progname to use in the\n             the log message.  The default can be set with #progname=\n<tt>&block</tt>:: evaluates to the message to log.  This is not evaluated\n                  unless the logger's level is sufficient\n                  to log the message.  This allows you to create\n                  potentially expensive logging messages that are\n                  only called when the logger is configured to show them.\n\n=== Examples\n\n  logger.info("MainApp") { "Received connection from #{ip}" }\n ...\n  logger.info "Waiting for input from user"\n ...\n  logger.info { "User typed #{input}" }\n\nYou'll probably stick to the second form above, unless you want to provide a\nprogram name (which you can do with #progname= as well).\n\n=== Return\n\nSee #add.\n
info? Logger.info?()\nReturns +true+ iff the current severity level allows for the printing of\n+INFO+ messages.\n
log Logger.log(severity, message = nil, progname = nil, &block)\n\n
unknown Logger.unknown(progname = nil, &block)\nLog an +UNKNOWN+ message.  This will be printed no matter what the logger's\nlevel.\n\nSee #info for more information.\n
warn Logger.warn(progname = nil, &block)\nLog a +WARN+ message.\n\nSee #info for more information.\n
warn? Logger.warn?()\nReturns +true+ iff the current severity level allows for the printing of\n+WARN+ messages.\n
new Logger::Formatter.new()\n\n
call Logger::Formatter.call(severity, time, progname, msg)\n\n
new Logger::LogDevice.new(log = nil, opt = {})\n\n
close Logger::LogDevice.close()\n\n
write Logger::LogDevice.write(message)\n\n
new Logger::Application.new(appname = nil)\n== Synopsis\n\n  Application.new(appname = '')\n\n== Args\n\n+appname+:: Name of the application.\n\n== Description\n\nCreate an instance.  Log device is +STDERR+ by default.  This can be\nchanged with #set_log.\n
level= Logger::Application.level=(level)\nSet the logging threshold, just like <tt>Logger#level=</tt>.\n
log Logger::Application.log(severity, message = nil, &block)\nSee Logger#add.  This application's +appname+ is used.\n
log= Logger::Application.log=(logdev)\n\n
logger Logger::Application.logger()\nLogger for this application.  See the class Logger for an explanation.\n
logger= Logger::Application.logger=(logger)\nSets the logger for this application.  See the class Logger for an\nexplanation.\n
set_log Logger::Application.set_log(logdev, shift_age = 0, shift_size = 1024000)\nSets the log device for this application.  See <tt>Logger.new</tt> for\nan explanation of the arguments.\n
start Logger::Application.start()\nStart the application.  Return the status code.\n
pp PP.pp(obj, out=$>, width=79)\nOutputs +obj+ to +out+ in pretty printed format of\n+width+ columns in width.\n\nIf +out+ is omitted, +$>+ is assumed.\nIf +width+ is omitted, 79 is assumed.\n\nPP.pp returns +out+.\n
singleline_pp PP.singleline_pp(obj, out=$>)\nOutputs +obj+ to +out+ like PP.pp but with no indent and\nnewline.\n\nPP.singleline_pp returns +out+.\n
all_classes RDoc::TopLevel.all_classes()\nReturns all classes discovered by RDoc\n
all_classes_and_modules RDoc::TopLevel.all_classes_and_modules()\nReturns all classes and modules discovered by RDoc\n
all_classes_hash RDoc::TopLevel.all_classes_hash()\nHash of all classes known to RDoc\n
all_files RDoc::TopLevel.all_files()\nAll TopLevels known to RDoc\n
all_files_hash RDoc::TopLevel.all_files_hash()\nHash of all files known to RDoc\n
all_modules RDoc::TopLevel.all_modules()\nReturns all modules discovered by RDoc\n
all_modules_hash RDoc::TopLevel.all_modules_hash()\nHash of all modules known to RDoc\n
classes RDoc::TopLevel.classes()\n\n
classes_hash RDoc::TopLevel.classes_hash()\n\n
complete RDoc::TopLevel.complete(min_visibility)\nPrepares the RDoc code object tree for use by a generator.\n\nIt finds unique classes/modules defined, and replaces classes/modules that\nare aliases for another one by a copy with RDoc::ClassModule#is_alias_for\nset.\n\nIt updates the RDoc::ClassModule#constant_aliases attribute of "real"\nclasses or modules.\n\nIt also completely removes the classes and modules that should be removed\nfrom the documentation and the methods that have a visibility below\n+min_visibility+, which is the <tt>--visibility</tt> option.\n\nSee also RDoc::Context#remove_from_documentation?\n
files RDoc::TopLevel.files()\n\n
files_hash RDoc::TopLevel.files_hash()\n\n
find_class_named RDoc::TopLevel.find_class_named(name)\nFinds the class with +name+ in all discovered classes\n
find_class_named_from RDoc::TopLevel.find_class_named_from(name, from)\nFinds the class with +name+ starting in namespace +from+\n
find_class_or_module RDoc::TopLevel.find_class_or_module(name)\nFinds the class or module with +name+\n
find_file_named RDoc::TopLevel.find_file_named(name)\nFinds the file with +name+ in all discovered files\n
find_module_named RDoc::TopLevel.find_module_named(name)\nFinds the module with +name+ in all discovered modules\n
find_unique RDoc::TopLevel.find_unique(all_hash)\nFinds unique classes/modules defined in +all_hash+,\nand returns them as an array. Performs the alias\nupdates in +all_hash+: see ::complete.\n
fix_basic_object_inheritance RDoc::TopLevel.fix_basic_object_inheritance()\nFixes the erroneous <tt>BasicObject < Object</tt> in 1.9.\n\nBecause we assumed all classes without a stated superclass\ninherit from Object, we have the above wrong inheritance.\n\nWe fix BasicObject right away if we are running in a Ruby\nversion >= 1.9. If not, we may be documenting 1.9 source\nwhile running under 1.8: we search the files of BasicObject\nfor "object.c", and fix the inheritance if we find it.\n
modules RDoc::TopLevel.modules()\n\n
modules_hash RDoc::TopLevel.modules_hash()\n\n
new RDoc::TopLevel.new(file_name)\nCreates a new TopLevel for +file_name+\n
new RDoc::TopLevel.new(file_name)\nCreates a new RDoc::TopLevel with +file_name+ only if one with the same\nname does not exist in all_files.\n
remove_nodoc RDoc::TopLevel.remove_nodoc(all_hash)\nRemoves from +all_hash+ the contexts that are nodoc or have no content.\n\nSee RDoc::Context#remove_from_documentation?\n
reset RDoc::TopLevel.reset()\nEmpties RDoc of stored class, module and file information\n
unique_classes RDoc::TopLevel.unique_classes()\nReturns the unique classes discovered by RDoc.\n\n::complete must have been called prior to using this method.\n
unique_classes_and_modules RDoc::TopLevel.unique_classes_and_modules()\nReturns the unique classes and modules discovered by RDoc.\n::complete must have been called prior to using this method.\n
unique_modules RDoc::TopLevel.unique_modules()\nReturns the unique modules discovered by RDoc.\n::complete must have been called prior to using this method.\n
add_alias RDoc::TopLevel.add_alias(an_alias)\nAdds +an_alias+ to +Object+ instead of +self+.\n
add_constant RDoc::TopLevel.add_constant(constant)\nAdds +constant+ to +Object+ instead of +self+.\n
add_include RDoc::TopLevel.add_include(include)\nAdds +include+ to +Object+ instead of +self+.\n
add_method RDoc::TopLevel.add_method(method)\nAdds +method+ to +Object+ instead of +self+.\n
add_to_classes_or_modules RDoc::TopLevel.add_to_classes_or_modules(mod)\nAdds class or module +mod+. Used in the building phase\nby the ruby parser.\n
base_name RDoc::TopLevel.base_name()\nBase name of this file\n
cvs_url RDoc::TopLevel.cvs_url()\nReturns a URL for this source file on some web repository.  Use the -W\ncommand line option to set.\n
eql? RDoc::TopLevel.eql?(other)\n\n
find_class_or_module RDoc::TopLevel.find_class_or_module(name)\nSee RDoc::TopLevel::find_class_or_module\n
find_local_symbol RDoc::TopLevel.find_local_symbol(symbol)\nFinds a class or module named +symbol+\n
find_module_named RDoc::TopLevel.find_module_named(name)\nFinds a module or class with +name+\n
full_name RDoc::TopLevel.full_name()\nReturns the relative name of this file\n
hash RDoc::TopLevel.hash()\nAn RDoc::TopLevel has the same hash as another with the same\nabsolute_name\n
http_url RDoc::TopLevel.http_url(prefix)\nURL for this with a +prefix+\n
last_modified RDoc::TopLevel.last_modified()\nTime this file was last modified, if known\n
name RDoc::TopLevel.name()\n\n
object_class RDoc::TopLevel.object_class()\nReturns the NormalClass "Object", creating it if not found.\n\nRecords +self+ as a location in "Object".\n
path RDoc::TopLevel.path()\nPath to this file\n
new RDoc::Generator::RI.new(options)\nSet up a new ri generator\n
generate RDoc::Generator::RI.generate(top_levels)\nBuild the initial indices and output objects based on an array of TopLevel\nobjects containing the extracted information.\n
install_siginfo_handler RDoc::Generator::RI.install_siginfo_handler()\nInstalls a siginfo handler that prints the current filename.\n
remove_siginfo_handler RDoc::Generator::RI.remove_siginfo_handler()\nRemoves a siginfo handler and replaces the previous\n
new RDoc::AnyMethod.new(text, name)\nCreates a new AnyMethod with a token stream +text+ and +name+\n
add_alias RDoc::AnyMethod.add_alias(an_alias, context = nil)\nAdds +an_alias+ as an alias for this method in +context+.\n
add_line_numbers RDoc::AnyMethod.add_line_numbers(src)\nPrepend +src+ with line numbers.  Relies on the first line of a source\ncode listing having:\n File xxxxx, line dddd\n\nIf it has, line numbers are added an ', line dddd' is removed.\n
aref_prefix RDoc::AnyMethod.aref_prefix()\nPrefix for +aref+ is 'method'.\n
arglists RDoc::AnyMethod.arglists()\nThe call_seq or the param_seq with method name, if there is no call_seq.\n\nUse this for displaying a method's argument lists.\n
markup_code RDoc::AnyMethod.markup_code()\nTurns the method's token stream into HTML.\n\nPrepends line numbers if +add_line_numbers+ is true.\n
marshal_dump RDoc::AnyMethod.marshal_dump()\nDumps this AnyMethod for use by ri.  See also #marshal_load\n
marshal_load RDoc::AnyMethod.marshal_load(array)\nLoads this AnyMethod from +array+.  For a loaded AnyMethod the following\nmethods will return cached values:\n\n* #full_name\n* #parent_name\n
name RDoc::AnyMethod.name()\nMethod name\n\nIf the method has no assigned name, it extracts it from #call_seq.\n
param_list RDoc::AnyMethod.param_list()\nA list of this method's method and yield parameters.  +call-seq+ params\nare preferred over parsed method and block params.\n
param_seq RDoc::AnyMethod.param_seq()\nPretty parameter list for this method.  If the method's parameters were\ngiven by +call-seq+ it is preferred over the parsed values.\n
new RDoc::Attr.new(text, name, rw, comment, singleton = false)\nCreates a new Attr with body +text+, +name+, read/write status +rw+ and\n+comment+.  +singleton+ marks this as a class attribute.\n
add_alias RDoc::Attr.add_alias(an_alias, context)\nAdd +an_alias+ as an attribute in +context+.\n
aref_prefix RDoc::Attr.aref_prefix()\nThe #aref prefix for attributes\n
definition RDoc::Attr.definition()\nReturns attr_reader, attr_writer or attr_accessor as appropriate.\n
marshal_dump RDoc::Attr.marshal_dump()\nDumps this Attr for use by ri.  See also #marshal_load\n
marshal_load RDoc::Attr.marshal_load(array)\nLoads this Attr from +array+.  For a loaded Attr the following\nmethods will return cached values:\n\n* #full_name\n* #parent_name\n
new RDoc::Alias.new(text, old_name, new_name, comment, singleton = false)\nCreates a new Alias with a token stream of +text+ that aliases +old_name+\nto +new_name+, has +comment+ and is a +singleton+ context.\n
aref RDoc::Alias.aref()\nHTML fragment reference for this alias\n
full_old_name RDoc::Alias.full_old_name()\nFull old name including namespace\n
html_name RDoc::Alias.html_name()\nHTML id-friendly version of +#new_name+.\n
name_prefix RDoc::Alias.name_prefix()\n'::' for the alias of a singleton method/attribute, '#' for instance-level.\n
pretty_name RDoc::Alias.pretty_name()\n\n
pretty_new_name RDoc::Alias.pretty_new_name()\nNew name with prefix '::' or '#'.\n
pretty_old_name RDoc::Alias.pretty_old_name()\nOld name with prefix '::' or '#'.\n
new RDoc::Constant.new(name, value, comment)\nCreates a new constant with +name+, +value+ and +comment+\n
documented? RDoc::Constant.documented?()\nA constant is documented if it has a comment, or is an alias\nfor a documented class or module.\n
path RDoc::Constant.path()\nPath to this constant\n
new RDoc::Context.new()\nCreates an unnamed empty context with public current visibility\n
add_alias RDoc::Context.add_alias(an_alias)\nAdds +an_alias+ that is automatically resolved\n
add_attribute RDoc::Context.add_attribute(attribute)\nAdds +attribute+ if not already there. If it is (as method(s) or attribute),\nupdates the comment if it was empty.\n\nThe attribute is registered only if it defines a new method.\nFor instance, <tt>attr_reader :foo</tt> will not be registered\nif method +foo+ exists, but <tt>attr_accessor :foo</tt> will be registered\nif method +foo+ exists, but <tt>foo=</tt> does not.\n
add_class RDoc::Context.add_class(class_type, given_name, superclass = '::Object')\nAdds a class named +given_name+ with +superclass+.\n\nBoth +given_name+ and +superclass+ may contain '::', and are\ninterpreted relative to the +self+ context. This allows handling correctly\nexamples like these:\n  class RDoc::Gauntlet < Gauntlet\n  module Mod\n    class Object   # implies < ::Object\n    class SubObject < Object  # this is _not_ ::Object\n\nGiven <tt>class Container::Item</tt> RDoc assumes +Container+ is a module\nunless it later sees <tt>class Container</tt>.  +add_class+ automatically\nupgrades +given_name+ to a class in this case.\n
add_class_or_module RDoc::Context.add_class_or_module(mod, self_hash, all_hash)\nAdds the class or module +mod+ to the modules or\nclasses Hash +self_hash+, and to +all_hash+ (either\n<tt>TopLevel::modules_hash</tt> or <tt>TopLevel::classes_hash</tt>),\nunless #done_documenting is +true+. Sets the #parent of +mod+\nto +self+, and its #section to #current_section. Returns +mod+.\n
add_constant RDoc::Context.add_constant(constant)\nAdds +constant+ if not already there. If it is, updates the comment,\nvalue and/or is_alias_for of the known constant if they were empty/nil.\n
add_include RDoc::Context.add_include(include)\nAdds included module +include+ which should be an RDoc::Include\n
add_method RDoc::Context.add_method(method)\nAdds +method+ if not already there. If it is (as method or attribute),\nupdates the comment if it was empty.\n
add_module RDoc::Context.add_module(class_type, name)\nAdds a module named +name+.  If RDoc already knows +name+ is a class then\nthat class is returned instead.  See also #add_class.\n
add_module_alias RDoc::Context.add_module_alias(from, name, file)\nAdds an alias from +from+ (a class or module) to +name+ which was defined\nin +file+.\n
add_require RDoc::Context.add_require(require)\nAdds +require+ to this context's top level\n
add_section RDoc::Context.add_section(title, comment)\nReturns a section with +title+, creating it if it doesn't already exist.\n+comment+ will be appended to the section's comment.\n\nA section with a +title+ of +nil+ will return the default section.\n\nSee also RDoc::Context::Section\n
add_to RDoc::Context.add_to(array, thing)\nAdds +thing+ to the collection +array+\n
any_content RDoc::Context.any_content(includes = true)\nIs there any content?\n\nThis means any of: comment, aliases, methods, attributes, external\naliases, require, constant.\n\nIncludes are also checked unless <tt>includes == false</tt>.\n
child_name RDoc::Context.child_name(name)\nCreates the full name for a child with +name+\n
class_attributes RDoc::Context.class_attributes()\nClass attributes\n
class_method_list RDoc::Context.class_method_list()\nClass methods\n
classes RDoc::Context.classes()\nArray of classes in this context\n
classes_and_modules RDoc::Context.classes_and_modules()\nAll classes and modules in this namespace\n
classes_hash RDoc::Context.classes_hash()\nHash of classes keyed by class name\n
current_section RDoc::Context.current_section()\nThe current documentation section that new items will be added to.  If\ntemporary_section is available it will be used.\n
defined_in? RDoc::Context.defined_in?(file)\nIs part of this thing was defined in +file+?\n
each_attribute RDoc::Context.each_attribute()\nIterator for attributes\n
each_classmodule RDoc::Context.each_classmodule()\nIterator for classes and modules\n
each_constant RDoc::Context.each_constant()\nIterator for constants\n
each_include RDoc::Context.each_include()\nIterator for included modules\n
each_method RDoc::Context.each_method()\nIterator for methods\n
each_section RDoc::Context.each_section()\nIterator for each section's contents sorted by title.  The +section+, the\nsection's +constants+ and the sections +attributes+ are yielded.  The\n+constants+ and +attributes+ collections are sorted.\n\nTo retrieve methods in a section use #methods_by_type with the optional\n+section+ parameter.\n\nNOTE: Do not edit collections yielded by this method\n
find_attribute RDoc::Context.find_attribute(name, singleton)\nFinds an attribute +name+ with singleton value +singleton+.\n
find_attribute_named RDoc::Context.find_attribute_named(name)\nFinds an attribute with +name+ in this context\n
find_class_method_named RDoc::Context.find_class_method_named(name)\nFinds a class method with +name+ in this context\n
find_constant_named RDoc::Context.find_constant_named(name)\nFinds a constant with +name+ in this context\n
find_enclosing_module_named RDoc::Context.find_enclosing_module_named(name)\nFind a module at a higher scope\n
find_external_alias RDoc::Context.find_external_alias(name, singleton)\nFinds an external alias +name+ with singleton value +singleton+.\n
find_external_alias_named RDoc::Context.find_external_alias_named(name)\nFinds an external alias with +name+ in this context\n
find_file_named RDoc::Context.find_file_named(name)\nFinds a file with +name+ in this context\n
find_instance_method_named RDoc::Context.find_instance_method_named(name)\nFinds an instance method with +name+ in this context\n
find_local_symbol RDoc::Context.find_local_symbol(symbol)\nFinds a method, constant, attribute, external alias, module or file\nnamed +symbol+ in this context.\n
find_method RDoc::Context.find_method(name, singleton)\nFinds a method named +name+ with singleton value +singleton+.\n
find_method_named RDoc::Context.find_method_named(name)\nFinds a instance or module method with +name+ in this context\n
find_module_named RDoc::Context.find_module_named(name)\nFind a module with +name+ using ruby's scoping rules\n
find_symbol RDoc::Context.find_symbol(symbol)\nLook up +symbol+, first as a module, then as a local symbol.\n
find_symbol_module RDoc::Context.find_symbol_module(symbol)\nLook up a module named +symbol+.\n
full_name RDoc::Context.full_name()\nThe full name for this context.  This method is overridden by subclasses.\n
fully_documented? RDoc::Context.fully_documented?()\nDoes this context and its methods and constants all have documentation?\n\n(Yes, fully documented doesn't mean everything.)\n
http_url RDoc::Context.http_url(prefix)\nURL for this with a +prefix+\n
initialize_methods_etc RDoc::Context.initialize_methods_etc()\nSets the defaults for methods and so-forth\n
instance_attributes RDoc::Context.instance_attributes()\nInstance attributes\n
instance_method_list RDoc::Context.instance_method_list()\nInstance methods\n
methods_by_type RDoc::Context.methods_by_type(section = nil)\nBreaks method_list into a nested hash by type (<tt>'class'</tt> or\n<tt>'instance'</tt>) and visibility (+:public+, +:protected+, +:private+).\n\nIf +section+ is provided only methods in that RDoc::Context::Section will\nbe returned.\n
methods_matching RDoc::Context.methods_matching(methods, singleton = false, &block)\nYields AnyMethod and Attr entries matching the list of names in +methods+.\n
modules RDoc::Context.modules()\nArray of modules in this context\n
modules_hash RDoc::Context.modules_hash()\nHash of modules keyed by module name\n
name_for_path RDoc::Context.name_for_path()\nName to use to generate the url.\n<tt>#full_name</tt> by default.\n
ongoing_visibility= RDoc::Context.ongoing_visibility=(visibility)\nChanges the visibility for new methods to +visibility+\n
record_location RDoc::Context.record_location(top_level)\nRecord +top_level+ as a file +self+ is in.\n
remove_from_documentation? RDoc::Context.remove_from_documentation?()\nShould we remove this context from the documentation?\n\nThe answer is yes if:\n* #received_nodoc is +true+\n* #any_content is +false+ (not counting includes)\n* All #includes are modules (not a string), and their module has\n  <tt>#remove_from_documentation? == true</tt>\n* All classes and modules have <tt>#remove_from_documentation? == true</tt>\n
remove_invisible RDoc::Context.remove_invisible(min_visibility)\nRemoves methods and attributes with a visibility less than +min_visibility+.\n
resolve_aliases RDoc::Context.resolve_aliases(added)\nTries to resolve unmatched aliases when a method\nor attribute has just been added.\n
sections RDoc::Context.sections()\nSections in this context\n
set_current_section RDoc::Context.set_current_section(title, comment)\nSets the current section to a section with +title+.  See also #add_section\n
set_visibility_for RDoc::Context.set_visibility_for(methods, visibility, singleton = false)\nGiven an array +methods+ of method names, set the visibility of each to\n+visibility+\n
top_level RDoc::Context.top_level()\nReturn the TopLevel that owns us\n
upgrade_to_class RDoc::Context.upgrade_to_class(mod, class_type, enclosing)\nUpgrades NormalModule +mod+ in +enclosing+ to a +class_type+\n
new RDoc::Context::Section.new(parent, title, comment)\nCreates a new section with +title+ and +comment+\n
aref RDoc::Context::Section.aref()\nAnchor reference for linking to this section\n
comment= RDoc::Context::Section.comment=(comment)\nAppends +comment+ to the current comment separated by a rule.\n
extract_comment RDoc::Context::Section.extract_comment(comment)\nExtracts the comment for this section from the original comment block.\nIf the first line contains :section:, strip it and use the rest.\nOtherwise remove lines up to the line containing :section:, and look\nfor those lines again at the end and remove them. This lets us write\n :section: The title\n The body\n
sequence RDoc::Context::Section.sequence()\nSection sequence number (deprecated)\n
new RDoc::Generator::Darkfish.new(options)\nInitialize a few instance variables before we start\n
class_dir RDoc::Generator::Darkfish.class_dir()\nDirectory where generated class HTML files live relative to the output\ndir.\n
debug_msg RDoc::Generator::Darkfish.debug_msg(*msg)\nOutput progress information if debugging is enabled\n
file_dir RDoc::Generator::Darkfish.file_dir()\nDirectory where generated class HTML files live relative to the output\ndir.\n
gen_sub_directories RDoc::Generator::Darkfish.gen_sub_directories()\nCreate the directories the generated docs will live in if they don't\nalready exist.\n
generate RDoc::Generator::Darkfish.generate(top_levels)\nBuild the initial indices and output objects based on an array of TopLevel\nobjects containing the extracted information.\n
generate_class_files RDoc::Generator::Darkfish.generate_class_files()\nGenerate a documentation file for each class\n
generate_file_files RDoc::Generator::Darkfish.generate_file_files()\nGenerate a documentation file for each file\n
generate_index RDoc::Generator::Darkfish.generate_index()\nGenerate an index page which lists all the classes which are documented.\n
get_sorted_module_list RDoc::Generator::Darkfish.get_sorted_module_list(classes)\nReturn a list of the documented modules sorted by salience first, then\nby name.\n
get_svninfo RDoc::Generator::Darkfish.get_svninfo(klass)\nTry to extract Subversion information out of the first constant whose\nvalue looks like a subversion Id tag. If no matching constant is found,\nand empty hash is returned.\n
render_template RDoc::Generator::Darkfish.render_template(template_file, out_file)\nLoad and render the erb template in the given +template_file+ and write\nit out to +out_file+.\n\nBoth +template_file+ and +out_file+ should be Pathname-like objects.\n\nAn io will be yielded which must be captured by binding in the caller.\n
template_for RDoc::Generator::Darkfish.template_for(file)\nRetrieves a cache template for +file+, if present, or fills the cache.\n
template_result RDoc::Generator::Darkfish.template_result(template, context, template_file)\nCreates the result for +template+ with +context+.  If an error is raised a\nPathname +template_file+ will indicate the file where the error occurred.\n
time_delta_string RDoc::Generator::Darkfish.time_delta_string(seconds)\nReturn a string describing the amount of time in the given number of\nseconds in terms a human can understand easily.\n
write_style_sheet RDoc::Generator::Darkfish.write_style_sheet()\nCopy over the stylesheet into the appropriate place in the output\ndirectory.\n
new RDoc::CodeObject.new()\nCreates a new CodeObject that will document itself and its children\n
comment= RDoc::CodeObject.comment=(comment)\nReplaces our comment with +comment+, unless it is empty.\n
display? RDoc::CodeObject.display?()\nShould this CodeObject be shown in documentation?\n
document_children= RDoc::CodeObject.document_children=(document_children)\nEnables or disables documentation of this CodeObject's children unless it\nhas been turned off by :enddoc:\n
document_self= RDoc::CodeObject.document_self=(document_self)\nEnables or disables documentation of this CodeObject unless it has been\nturned off by :enddoc:.  If the argument is +nil+ it means the\ndocumentation is turned off by +:nodoc:+.\n
documented? RDoc::CodeObject.documented?()\nDoes this object have a comment with content or is #received_nodoc true?\n
done_documenting= RDoc::CodeObject.done_documenting=(value)\nTurns documentation on/off, and turns on/off #document_self\nand #document_children.\n\nOnce documentation has been turned off (by +:enddoc:+),\nthe object will refuse to turn #document_self or\ndocument_children on, so +:doc:+ and +:start_doc:+ directives\nwill have no effect in the current file.\n
each_parent RDoc::CodeObject.each_parent()\nYields each parent of this CodeObject.  See also\nRDoc::ClassModule#each_ancestor\n
file_name RDoc::CodeObject.file_name()\nFile name where this CodeObject was found.\n\nSee also RDoc::Context#in_files\n
force_documentation= RDoc::CodeObject.force_documentation=(value)\nForce the documentation of this object unless documentation\nhas been turned off by :endoc:\n
full_name= RDoc::CodeObject.full_name=(full_name)\nSets the full_name overriding any computed full name.\n\nSet to +nil+ to clear RDoc's cached value\n
ignore RDoc::CodeObject.ignore()\nUse this to ignore a CodeObject and all its children until found again\n(#record_location is called).  An ignored item will not be shown in\ndocumentation.\n\nSee github issue #55\n\nThe ignored status is temporary in order to allow implementation details\nto be hidden.  At the end of processing a file RDoc allows all classes\nand modules to add new documentation to previously created classes.\n\nIf a class was ignored (via stopdoc) then reopened later with additional\ndocumentation it should be shown.  If a class was ignored and never\nreopened it should not be shown.  The ignore flag allows this to occur.\n
ignored? RDoc::CodeObject.ignored?()\nHas this class been ignored?\n
parent_file_name RDoc::CodeObject.parent_file_name()\nFile name of our parent\n
parent_name RDoc::CodeObject.parent_name()\nName of our parent\n
record_location RDoc::CodeObject.record_location(top_level)\nRecords the RDoc::TopLevel (file) where this code object was defined\n
start_doc RDoc::CodeObject.start_doc()\nEnable capture of documentation unless documentation has been\nturned off by :endoc:\n
stop_doc RDoc::CodeObject.stop_doc()\nDisable capture of documentation\n
new RDoc::Include.new(name, comment)\nCreates a new Include for +name+ with +comment+\n
full_name RDoc::Include.full_name()\nFull name based on #module\n
module RDoc::Include.module()\nAttempts to locate the included module object.  Returns the name if not\nknown.\n\nThe scoping rules of Ruby to resolve the name of an included module are:\n- first look into the children of the current context;\n- if not found, look into the children of included modules,\n  in reverse inclusion order;\n- if still not found, go up the hierarchy of names.\n
gen_relative_url RDoc::Markup::ToHtml.gen_relative_url(path, target)\nConverts a target url to one that is relative to a given path\n
new RDoc::Markup::ToHtml.new(markup = nil)\nCreates a new formatter that will output HTML\n
accept_blank_line RDoc::Markup::ToHtml.accept_blank_line(blank_line)\nAdds +blank_line+ to the output\n
accept_heading RDoc::Markup::ToHtml.accept_heading(heading)\nAdds +heading+ to the output\n
accept_list_end RDoc::Markup::ToHtml.accept_list_end(list)\nFinishes consumption of +list+\n
accept_list_item_end RDoc::Markup::ToHtml.accept_list_item_end(list_item)\nFinishes consumption of +list_item+\n
accept_list_item_start RDoc::Markup::ToHtml.accept_list_item_start(list_item)\nPrepares the visitor for consuming +list_item+\n
accept_list_start RDoc::Markup::ToHtml.accept_list_start(list)\nPrepares the visitor for consuming +list+\n
accept_paragraph RDoc::Markup::ToHtml.accept_paragraph(paragraph)\nAdds +paragraph+ to the output\n
accept_raw RDoc::Markup::ToHtml.accept_raw(raw)\nAdds +raw+ to the output\n
accept_rule RDoc::Markup::ToHtml.accept_rule(rule)\nAdds +rule+ to the output\n
accept_verbatim RDoc::Markup::ToHtml.accept_verbatim(verbatim)\nAdds +verbatim+ to the output\n
convert_string RDoc::Markup::ToHtml.convert_string(text)\nCGI escapes +text+\n
end_accepting RDoc::Markup::ToHtml.end_accepting()\nReturns the generated output\n
gen_url RDoc::Markup::ToHtml.gen_url(url, text)\nGenerate a link for +url+, labeled with +text+.  Handles the special cases\nfor img: and link: described under handle_special_HYPERLINK\n
handle_special_HYPERLINK RDoc::Markup::ToHtml.handle_special_HYPERLINK(special)\n+special+ is a potential link.  The following schemes are handled:\n\n<tt>mailto:</tt>::\n  Inserted as-is.\n<tt>http:</tt>::\n  Links are checked to see if they reference an image. If so, that image\n  gets inserted using an <tt><img></tt> tag. Otherwise a conventional\n  <tt><a href></tt> is used.\n<tt>link:</tt>::\n  Reference to a local file relative to the output directory.\n
handle_special_TIDYLINK RDoc::Markup::ToHtml.handle_special_TIDYLINK(special)\nThis +special+ is a link where the label is different from the URL\n<tt>label[url]</tt> or <tt>{long label}[url]</tt>\n
html_list_name RDoc::Markup::ToHtml.html_list_name(list_type, open_tag)\nDetermines the HTML list element for +list_type+ and +open_tag+\n
init_tags RDoc::Markup::ToHtml.init_tags()\nMaps attributes to HTML tags\n
list_end_for RDoc::Markup::ToHtml.list_end_for(list_type)\nReturns the HTML end-tag for +list_type+\n
list_item_start RDoc::Markup::ToHtml.list_item_start(list_item, list_type)\nReturns the HTML tag for +list_type+, possible using a label from\n+list_item+\n
start_accepting RDoc::Markup::ToHtml.start_accepting()\nPrepares the visitor for HTML generation\n
to_html RDoc::Markup::ToHtml.to_html(item)\nConverts +item+ to HTML using RDoc::Text#to_html\n
new RDoc::Markup::ToRdoc.new(markup = nil)\nCreates a new formatter that will output (mostly) \RDoc markup\n
accept_blank_line RDoc::Markup::ToRdoc.accept_blank_line(blank_line)\nAdds +blank_line+ to the output\n
accept_heading RDoc::Markup::ToRdoc.accept_heading(heading)\nAdds +heading+ to the output\n
accept_indented_paragraph RDoc::Markup::ToRdoc.accept_indented_paragraph(paragraph)\nAdds +paragraph+ to the output\n
accept_list_end RDoc::Markup::ToRdoc.accept_list_end(list)\nFinishes consumption of +list+\n
accept_list_item_end RDoc::Markup::ToRdoc.accept_list_item_end(list_item)\nFinishes consumption of +list_item+\n
accept_list_item_start RDoc::Markup::ToRdoc.accept_list_item_start(list_item)\nPrepares the visitor for consuming +list_item+\n
accept_list_start RDoc::Markup::ToRdoc.accept_list_start(list)\nPrepares the visitor for consuming +list+\n
accept_paragraph RDoc::Markup::ToRdoc.accept_paragraph(paragraph)\nAdds +paragraph+ to the output\n
accept_raw RDoc::Markup::ToRdoc.accept_raw(raw)\nAdds +raw+ to the output\n
accept_rule RDoc::Markup::ToRdoc.accept_rule(rule)\nAdds +rule+ to the output\n
accept_verbatim RDoc::Markup::ToRdoc.accept_verbatim(verbatim)\nOutputs +verbatim+ indented 2 columns\n
attributes RDoc::Markup::ToRdoc.attributes(text)\nApplies attribute-specific markup to +text+ using RDoc::AttributeManager\n
end_accepting RDoc::Markup::ToRdoc.end_accepting()\nReturns the generated output\n
handle_special_SUPPRESSED_CROSSREF RDoc::Markup::ToRdoc.handle_special_SUPPRESSED_CROSSREF(special)\nRemoves preceding \\ from the suppressed crossref +special+\n
init_tags RDoc::Markup::ToRdoc.init_tags()\nMaps attributes to HTML sequences\n
start_accepting RDoc::Markup::ToRdoc.start_accepting()\nPrepares the visitor for text generation\n
use_prefix RDoc::Markup::ToRdoc.use_prefix()\nAdds the stored #prefix to the output and clears it.  Lists generate a\nprefix for later consumption.\n
wrap RDoc::Markup::ToRdoc.wrap(text)\nWraps +text+ to #width\n
new RDoc::Markup::Raw.new(*parts)\nCreates a new Raw containing +parts+\n
accept RDoc::Markup::Raw.accept(visitor)\nCalls #accept_raw+ on +visitor+\n
merge RDoc::Markup::Raw.merge(other)\nAppends +other+'s parts\n
push RDoc::Markup::Raw.push(*texts)\nAppends +texts+ onto this Paragraph\n
text RDoc::Markup::Raw.text()\nThe raw text\n
new RDoc::Markup::List.new(type = nil, *items)\nCreates a new list of +type+ with +items+\n
accept RDoc::Markup::List.accept(visitor)\nRuns this list and all its #items through +visitor+\n
empty? RDoc::Markup::List.empty?()\nIs the list empty?\n
last RDoc::Markup::List.last()\nReturns the last item in the list\n
push RDoc::Markup::List.push(*items)\nAppends +items+ to the list\n
new RDoc::Markup::ListItem.new(label = nil, *parts)\nCreates a new ListItem with an optional +label+ containing +parts+\n
accept RDoc::Markup::ListItem.accept(visitor)\nRuns this list item and all its #parts through +visitor+\n
empty? RDoc::Markup::ListItem.empty?()\nIs the ListItem empty?\n
length RDoc::Markup::ListItem.length()\nLength of parts in the ListItem\n
push RDoc::Markup::ListItem.push(*parts)\nAdds +parts+ to the ListItem\n
add_text_tests RDoc::Markup::TextFormatterTestCase.add_text_tests()\nAdds test cases to the calling TestCase.\n
test_accept_heading_indent RDoc::Markup::TextFormatterTestCase.test_accept_heading_indent()\nTest case that calls <tt>@to.accept_heading</tt>\n
test_accept_paragraph_indent RDoc::Markup::TextFormatterTestCase.test_accept_paragraph_indent()\nTest case that calls <tt>@to.accept_paragraph</tt> with an indent\n
test_accept_paragraph_wrap RDoc::Markup::TextFormatterTestCase.test_accept_paragraph_wrap()\nTest case that calls <tt>@to.accept_paragraph</tt> with a long line\n
test_accept_rule_indent RDoc::Markup::TextFormatterTestCase.test_accept_rule_indent()\nTest case that calls <tt>@to.accept_rule</tt>\n
test_accept_verbatim_big_indent RDoc::Markup::TextFormatterTestCase.test_accept_verbatim_big_indent()\nTest case that calls <tt>@to.accept_verbatim</tt> with a big indent\n
test_accept_verbatim_indent RDoc::Markup::TextFormatterTestCase.test_accept_verbatim_indent()\nTest case that calls <tt>@to.accept_verbatim</tt>\n
test_attributes RDoc::Markup::TextFormatterTestCase.test_attributes()\nTest case that calls <tt>@to.attributes</tt> with an escaped\ncross-reference.  If this test doesn't pass something may be very\nwrong.\n
new RDoc::Markup::ToHtmlCrossref.new(from_path, context, show_hash, hyperlink_all\n= false, markup = nil)\nCreates a new crossref resolver that generates links relative to +context+\nwhich lives at +from_path+ in the generated files.  '#' characters on\nreferences are removed unless +show_hash+ is true.  Only method names\npreceded by '#' or '::' are linked, unless +hyperlink_all+ is true.\n
cross_reference RDoc::Markup::ToHtmlCrossref.cross_reference(name, text = nil)\nCreates a link to the reference +name+ if the name exists.  If +text+ is\ngiven it is used as the link text, otherwise +name+ is used.\n
gen_url RDoc::Markup::ToHtmlCrossref.gen_url(url, text)\nGenerates links for <tt>rdoc-ref:</tt> scheme URLs and allows\nRDoc::Markup::ToHtml to handle other schemes.\n
handle_special_CROSSREF RDoc::Markup::ToHtmlCrossref.handle_special_CROSSREF(special)\nWe're invoked when any text matches the CROSSREF pattern.  If we find the\ncorresponding reference, generate a link.  If the name we're looking for\ncontains no punctuation, we look for it up the module/class chain.  For\nexample, ToHtml is found, even without the <tt>RDoc::Markup::</tt> prefix,\nbecause we look for it in module Markup first.\n
handle_special_HYPERLINK RDoc::Markup::ToHtmlCrossref.handle_special_HYPERLINK(special)\nHandles <tt>rdoc-ref:</tt> scheme links and allows RDoc::Markup::ToHtml to\nhandle other schemes.\n
link RDoc::Markup::ToHtmlCrossref.link(name, text)\nCreates an HTML link to +name+ with the given +text+.\n
accept RDoc::Markup::Heading.accept(visitor)\nCalls #accept_heading on +visitor+\n
new RDoc::Markup::IndentedParagraph.new(indent, *parts)\nCreates a new IndentedParagraph containing +parts+ indented with +indent+\nspaces\n
accept RDoc::Markup::IndentedParagraph.accept(visitor)\nCalls #accept_indented_paragraph on +visitor+\n
new RDoc::Markup::PreProcess.new(input_file_name, include_path)\nCreates a new pre-processor for +input_file_name+ that will look for\nincluded files in +include_path+\n
register RDoc::Markup::PreProcess.register(directive, &block)\nRegisters +directive+ as one handled by RDoc.  If a block is given the\ndirective will be replaced by the result of the block, otherwise the\ndirective will be removed from the processed text.\n
registered RDoc::Markup::PreProcess.registered()\nRegistered directives\n
find_include_file RDoc::Markup::PreProcess.find_include_file(name)\nLook for the given file in the directory containing the current file,\nand then in each of the directories specified in the RDOC_INCLUDE path\n
handle RDoc::Markup::PreProcess.handle(text, code_object = nil, &block)\nLook for directives in a chunk of +text+.\n\nOptions that we don't handle are yielded.  If the block returns false the\ndirective is restored to the text.  If the block returns nil or no block\nwas given the directive is handled according to the registered directives.\nIf a String was returned the directive is replaced with the string.\n\nIf no matching directive was registered the directive is restored to the\ntext.\n\nIf +code_object+ is given and the param is set as metadata on the\n+code_object+.  See RDoc::CodeObject#metadata\n
handle_directive RDoc::Markup::PreProcess.handle_directive(prefix, directive, param, code_object\n= nil, encoding = nil)\n\n
include_file RDoc::Markup::PreProcess.include_file(name, indent, encoding)\nHandles the <tt>:include: _filename_</tt> directive.\n\nIf the first line of the included file starts with '#', and contains\nan encoding information in the form 'coding:' or 'coding=', it is\nremoved.\n\nIf all lines in the included file start with a '#', this leading '#'\nis removed before inclusion. The included content is indented like\nthe <tt>:include:</tt> directive.\n
new RDoc::Markup::ToTtOnly.new(markup = nil)\nCreates a new tt-only formatter.\n
accept_blank_line RDoc::Markup::ToTtOnly.accept_blank_line(markup_item)\n\n
accept_heading RDoc::Markup::ToTtOnly.accept_heading(markup_item)\n\n
accept_list_end RDoc::Markup::ToTtOnly.accept_list_end(list)\nPops the list type for +list+ from #list_type\n
accept_list_item_end RDoc::Markup::ToTtOnly.accept_list_item_end(markup_item)\n\n
accept_list_item_start RDoc::Markup::ToTtOnly.accept_list_item_start(list_item)\nPrepares the visitor for consuming +list_item+\n
accept_list_start RDoc::Markup::ToTtOnly.accept_list_start(list)\nPushes the list type for +list+ onto #list_type\n
accept_paragraph RDoc::Markup::ToTtOnly.accept_paragraph(paragraph)\nAdds +paragraph+ to the output\n
accept_raw RDoc::Markup::ToTtOnly.accept_raw(markup_item)\n\n
accept_rule RDoc::Markup::ToTtOnly.accept_rule(markup_item)\n\n
accept_verbatim RDoc::Markup::ToTtOnly.accept_verbatim(markup_item)\n\n
do_nothing RDoc::Markup::ToTtOnly.do_nothing(markup_item)\nDoes nothing to +markup_item+ because it doesn't have any user-built\ncontent\n
end_accepting RDoc::Markup::ToTtOnly.end_accepting()\nReturns an Array of items that were wrapped in plus, tt or code.\n
start_accepting RDoc::Markup::ToTtOnly.start_accepting()\nPrepares the visitor for gathering tt sections\n
tt_sections RDoc::Markup::ToTtOnly.tt_sections(text)\nExtracts tt sections from +text+\n
accept RDoc::Markup::Paragraph.accept(visitor)\nCalls #accept_paragraph on +visitor+\n
new RDoc::Markup.new(attribute_manager = nil)\nTake a block of text and use various heuristics to determine its\nstructure (paragraphs, lists, and so on).  Invoke an event handler as we\nidentify significant chunks.\n
add_html RDoc::Markup.add_html(tag, name)\nAdd to the sequences recognized as general markup.\n
add_special RDoc::Markup.add_special(pattern, name)\nAdd to other inline sequences.  For example, we could add WikiWords using\nsomething like:\n\n   parser.add_special(/\b([A-Z][a-z]+[A-Z]\w+)/, :WIKIWORD)\n\nEach wiki word will be presented to the output formatter via the\naccept_special method.\n
add_word_pair RDoc::Markup.add_word_pair(start, stop, name)\nAdd to the sequences used to add formatting to an individual word (such\nas *bold*).  Matching entries will generate attributes that the output\nformatters can recognize by their +name+.\n
convert RDoc::Markup.convert(input, formatter)\nWe take +input+, parse it if necessary, then invoke the output +formatter+\nusing a Visitor to render the result.\n
as_string RDoc::Markup::Attribute.as_string(bitmap)\nReturns a string representation of +bitmap+\n
bitmap_for RDoc::Markup::Attribute.bitmap_for(name)\nReturns a unique bit for +name+\n
each_name_of RDoc::Markup::Attribute.each_name_of(bitmap)\nyields each attribute name in +bitmap+\n
new RDoc::Markup::AttrSpan.new(length)\nCreates a new AttrSpan for +length+ characters\n
set_attrs RDoc::Markup::AttrSpan.set_attrs(start, length, bits)\nToggles +bits+ from +start+ to +length+\n
new RDoc::Markup::Special.new(type, text)\nCreates a new special sequence of +type+ with +text+\n
new RDoc::Markup::AttributeManager.new()\nCreates a new attribute manager that understands bold, emphasized and\nteletype text.\n
add_html RDoc::Markup::AttributeManager.add_html(tag, name)\nAdds a markup class with +name+ for words surrounded by HTML tag +tag+.\nTo process emphasis tags:\n\n  am.add_html 'em', :EM\n
add_special RDoc::Markup::AttributeManager.add_special(pattern, name)\nAdds a special handler for +pattern+ with +name+.  A simple URL handler\nwould be:\n\n  @am.add_special(/((https?:)\S+\w)/, :HYPERLINK)\n
add_word_pair RDoc::Markup::AttributeManager.add_word_pair(start, stop, name)\nAdds a markup class with +name+ for words wrapped in the +start+ and\n+stop+ character.  To make words wrapped with "*" bold:\n\n  am.add_word_pair '*', '*', :BOLD\n
attribute RDoc::Markup::AttributeManager.attribute(turn_on, turn_off)\nReturn an attribute object with the given turn_on and turn_off bits set\n
change_attribute RDoc::Markup::AttributeManager.change_attribute(current, new)\nChanges the current attribute from +current+ to +new+\n
changed_attribute_by_name RDoc::Markup::AttributeManager.changed_attribute_by_name(current_set, new_set)\nUsed by the tests to change attributes by name from +current_set+ to\n+new_set+\n
convert_attrs RDoc::Markup::AttributeManager.convert_attrs(str, attrs)\nMap attributes like <b>text</b>to the sequence\n\001\002<char>\001\003<char>, where <char> is a per-attribute specific\ncharacter\n
convert_html RDoc::Markup::AttributeManager.convert_html(str, attrs)\nConverts HTML tags to RDoc attributes\n
convert_specials RDoc::Markup::AttributeManager.convert_specials(str, attrs)\nConverts special sequences to RDoc attributes\n
copy_string RDoc::Markup::AttributeManager.copy_string(start_pos, end_pos)\nCopies +start_pos+ to +end_pos+ from the current string\n
display_attributes RDoc::Markup::AttributeManager.display_attributes()\nDebug method that prints a string along with its attributes\n
flow RDoc::Markup::AttributeManager.flow(str)\nProcesses +str+ converting attributes, HTML and specials\n
mask_protected_sequences RDoc::Markup::AttributeManager.mask_protected_sequences()\nEscapes special sequences of text to prevent conversion to RDoc\n
split_into_flow RDoc::Markup::AttributeManager.split_into_flow()\nSplits the string into chunks by attribute change\n
unmask_protected_sequences RDoc::Markup::AttributeManager.unmask_protected_sequences()\nUnescapes special sequences of text\n
add_visitor_tests RDoc::Markup::FormatterTestCase.add_visitor_tests()\nCall to add the visitor tests to your test case\n
setup RDoc::Markup::FormatterTestCase.setup()\nCall #setup when inheriting from this test case.\n\nProvides the following instance variables:\n\n+@m+::           RDoc::Markup.new\n+@RM+::          RDoc::Markup # to reduce typing\n+@bullet_list+:: @RM::List.new :BULLET, # ...\n+@label_list+::  @RM::List.new :LABEL, # ...\n+@lalpha_list+:: @RM::List.new :LALPHA, # ...\n+@note_list+::   @RM::List.new :NOTE, # ...\n+@number_list+:: @RM::List.new :NUMBER, # ...\n+@ualpha_list+:: @RM::List.new :UALPHA, # ...\n
test_accept_blank_line RDoc::Markup::FormatterTestCase.test_accept_blank_line()\nCalls accept_blank_line\n
test_accept_document RDoc::Markup::FormatterTestCase.test_accept_document()\nTest case that calls <tt>@to.accept_document</tt>\n
test_accept_heading RDoc::Markup::FormatterTestCase.test_accept_heading()\nCalls accept_heading with a level 5 RDoc::Markup::Heading\n
test_accept_heading_1 RDoc::Markup::FormatterTestCase.test_accept_heading_1()\nCalls accept_heading_1 with a level 1 RDoc::Markup::Heading\n
test_accept_heading_2 RDoc::Markup::FormatterTestCase.test_accept_heading_2()\nCalls accept_heading_2 with a level 2 RDoc::Markup::Heading\n
test_accept_heading_3 RDoc::Markup::FormatterTestCase.test_accept_heading_3()\nCalls accept_heading_3 with a level 3 RDoc::Markup::Heading\n
test_accept_heading_4 RDoc::Markup::FormatterTestCase.test_accept_heading_4()\nCalls accept_heading_4 with a level 4 RDoc::Markup::Heading\n
test_accept_heading_b RDoc::Markup::FormatterTestCase.test_accept_heading_b()\nCalls accept_heading_b with a bold level 1 RDoc::Markup::Heading\n
test_accept_heading_suppressed_crossref RDoc::Markup::FormatterTestCase.test_accept_heading_suppressed_crossref()\nCalls accept_heading_suppressed_crossref with a level 1\nRDoc::Markup::Heading containing a suppressed crossref\n
test_accept_list_end_bullet RDoc::Markup::FormatterTestCase.test_accept_list_end_bullet()\nCalls accept_list_end_bullet\n
test_accept_list_end_label RDoc::Markup::FormatterTestCase.test_accept_list_end_label()\nCalls accept_list_end_label\n
test_accept_list_end_lalpha RDoc::Markup::FormatterTestCase.test_accept_list_end_lalpha()\nCalls accept_list_end_lalpha\n
test_accept_list_end_note RDoc::Markup::FormatterTestCase.test_accept_list_end_note()\nCalls accept_list_end_note\n
test_accept_list_end_number RDoc::Markup::FormatterTestCase.test_accept_list_end_number()\nCalls accept_list_end_number\n
test_accept_list_end_ualpha RDoc::Markup::FormatterTestCase.test_accept_list_end_ualpha()\nCalls accept_list_end_ulpha\n
test_accept_list_item_end_bullet RDoc::Markup::FormatterTestCase.test_accept_list_item_end_bullet()\nCalls accept_list_item_end_bullet\n
test_accept_list_item_end_label RDoc::Markup::FormatterTestCase.test_accept_list_item_end_label()\nCalls accept_list_item_end_label\n
test_accept_list_item_end_lalpha RDoc::Markup::FormatterTestCase.test_accept_list_item_end_lalpha()\nCalls accept_list_item_end_lalpha\n
test_accept_list_item_end_note RDoc::Markup::FormatterTestCase.test_accept_list_item_end_note()\nCalls accept_list_item_end_note\n
test_accept_list_item_end_number RDoc::Markup::FormatterTestCase.test_accept_list_item_end_number()\nCalls accept_list_item_end_number\n
test_accept_list_item_end_ualpha RDoc::Markup::FormatterTestCase.test_accept_list_item_end_ualpha()\nCalls accept_list_item_end_ualpha\n
test_accept_list_item_start_bullet RDoc::Markup::FormatterTestCase.test_accept_list_item_start_bullet()\nCalls accept_list_item_start_bullet\n
test_accept_list_item_start_label RDoc::Markup::FormatterTestCase.test_accept_list_item_start_label()\nCalls accept_list_item_start_label\n
test_accept_list_item_start_lalpha RDoc::Markup::FormatterTestCase.test_accept_list_item_start_lalpha()\nCalls accept_list_item_start_lalpha\n
test_accept_list_item_start_note RDoc::Markup::FormatterTestCase.test_accept_list_item_start_note()\nCalls accept_list_item_start_note\n
test_accept_list_item_start_note_2 RDoc::Markup::FormatterTestCase.test_accept_list_item_start_note_2()\nCalls accept_list_item_start_note_2\n
test_accept_list_item_start_number RDoc::Markup::FormatterTestCase.test_accept_list_item_start_number()\nCalls accept_list_item_start_number\n
test_accept_list_item_start_ualpha RDoc::Markup::FormatterTestCase.test_accept_list_item_start_ualpha()\nCalls accept_list_item_start_ualpha\n
test_accept_list_start_bullet RDoc::Markup::FormatterTestCase.test_accept_list_start_bullet()\nCalls accept_list_start_bullet\n
test_accept_list_start_label RDoc::Markup::FormatterTestCase.test_accept_list_start_label()\nCalls accept_list_start_label\n
test_accept_list_start_lalpha RDoc::Markup::FormatterTestCase.test_accept_list_start_lalpha()\nCalls accept_list_start_lalpha\n
test_accept_list_start_note RDoc::Markup::FormatterTestCase.test_accept_list_start_note()\nCalls accept_list_start_note\n
test_accept_list_start_number RDoc::Markup::FormatterTestCase.test_accept_list_start_number()\nCalls accept_list_start_number\n
test_accept_list_start_ualpha RDoc::Markup::FormatterTestCase.test_accept_list_start_ualpha()\nCalls accept_list_start_ualpha\n
test_accept_paragraph RDoc::Markup::FormatterTestCase.test_accept_paragraph()\nCalls accept_paragraph\n
test_accept_paragraph_b RDoc::Markup::FormatterTestCase.test_accept_paragraph_b()\nCalls accept_paragraph_b with a RDoc::Markup::Paragraph containing\nbold words\n
test_accept_paragraph_i RDoc::Markup::FormatterTestCase.test_accept_paragraph_i()\nCalls accept_paragraph_i with a RDoc::Markup::Paragraph containing\nemphasized words\n
test_accept_paragraph_plus RDoc::Markup::FormatterTestCase.test_accept_paragraph_plus()\nCalls accept_paragraph_plus with a RDoc::Markup::Paragraph containing\nteletype words\n
test_accept_paragraph_star RDoc::Markup::FormatterTestCase.test_accept_paragraph_star()\nCalls accept_paragraph_star with a RDoc::Markup::Paragraph containing\nbold words\n
test_accept_paragraph_underscore RDoc::Markup::FormatterTestCase.test_accept_paragraph_underscore()\nCalls accept_paragraph_underscore with a RDoc::Markup::Paragraph\ncontaining emphasized words\n
test_accept_raw RDoc::Markup::FormatterTestCase.test_accept_raw()\nCalls accept_raw with a RDoc::Markup::Raw\n
test_accept_rule RDoc::Markup::FormatterTestCase.test_accept_rule()\nCalls accept_rule with a RDoc::Markup::Rule\n
test_accept_verbatim RDoc::Markup::FormatterTestCase.test_accept_verbatim()\nCalls accept_verbatim with a RDoc::Markup::Verbatim\n
test_end_accepting RDoc::Markup::FormatterTestCase.test_end_accepting()\nCalls end_accepting on your test case which needs to call\n<tt>@to.end_accepting</tt> and verify document generation\n
test_list_nested RDoc::Markup::FormatterTestCase.test_list_nested()\nCalls list_nested with a two-level list\n
test_list_verbatim RDoc::Markup::FormatterTestCase.test_list_verbatim()\nCalls list_verbatim with a list containing a verbatim block\n
test_start_accepting RDoc::Markup::FormatterTestCase.test_start_accepting()\nCalls start_accepting which needs to verify startup state\n
accept RDoc::Markup::Verbatim.accept(visitor)\nCalls #accept_verbatim on +visitor+\n
normalize RDoc::Markup::Verbatim.normalize()\nCollapses 3+ newlines into two newlines\n
text RDoc::Markup::Verbatim.text()\nThe text of the section\n
new RDoc::Markup::BlankLine.new()\nRDoc::Markup::BlankLine is a singleton\n
accept RDoc::Markup::BlankLine.accept(visitor)\nCalls #accept_blank_line on +visitor+\n
new RDoc::Markup::ToBs.new(markup = nil)\nReturns a new ToBs that is ready for hot backspace action!\n
accept_heading RDoc::Markup::ToBs.accept_heading(heading)\nMakes heading text bold.\n
annotate RDoc::Markup::ToBs.annotate(tag)\nTurns on or off special handling for +convert_string+\n
convert_special RDoc::Markup::ToBs.convert_special(special)\nCalls convert_string on the result of convert_special\n
convert_string RDoc::Markup::ToBs.convert_string(string)\nAdds bold or underline mixed with backspaces\n
init_tags RDoc::Markup::ToBs.init_tags()\nSets a flag that is picked up by #annotate to do the right thing in\nconvert_string\n
new RDoc::Markup::Document.new(*parts)\nCreates a new Document with +parts+\n
accept RDoc::Markup::Document.accept(visitor)\nRuns this document and all its #items through +visitor+\n
empty? RDoc::Markup::Document.empty?()\nDoes this document have no parts?\n
merge RDoc::Markup::Document.merge(other)\nWhen this is a collection of documents (#file is not set and this document\ncontains only other documents as its direct children) #merge replaces\ndocuments in this class with documents from +other+ when the file matches\nand adds documents from +other+ when the files do not.\n\nThe information in +other+ is preferred over the receiver\n
merged? RDoc::Markup::Document.merged?()\nDoes this Document contain other Documents?\n
push RDoc::Markup::Document.push(*parts)\nAppends +parts+ to the document\n
new RDoc::Markup::ToAnsi.new(markup = nil)\nCreates a new ToAnsi visitor that is ready to output vibrant ANSI color!\n
accept_list_item_end RDoc::Markup::ToAnsi.accept_list_item_end(list_item)\nOverrides indent width to ensure output lines up correctly.\n
accept_list_item_start RDoc::Markup::ToAnsi.accept_list_item_start(list_item)\nAdds coloring to note and label list items\n
init_tags RDoc::Markup::ToAnsi.init_tags()\nMaps attributes to ANSI sequences\n
start_accepting RDoc::Markup::ToAnsi.start_accepting()\nStarts accepting with a reset screen\n
new RDoc::Markup::Parser.new()\nCreates a new Parser.  See also ::parse\n
parse RDoc::Markup::Parser.parse(str)\nParses +str+ into a Document\n
tokenize RDoc::Markup::Parser.tokenize(str)\nReturns a token stream for +str+, for testing\n
build_heading RDoc::Markup::Parser.build_heading(level)\nBuilds a Heading of +level+\n
build_list RDoc::Markup::Parser.build_list(margin)\nBuilds a List flush to +margin+\n
build_paragraph RDoc::Markup::Parser.build_paragraph(margin)\nBuilds a Paragraph that is flush to +margin+\n
build_verbatim RDoc::Markup::Parser.build_verbatim(margin)\nBuilds a Verbatim that is indented from +margin+.\n\nThe verbatim block is shifted left (the least indented lines start in\ncolumn 0).  Each part of the verbatim is one line of text, always\nterminated by a newline.  Blank lines always consist of a single newline\ncharacter, and there is never a single newline at the end of the verbatim.\n
get RDoc::Markup::Parser.get()\nPulls the next token from the stream.\n
parse RDoc::Markup::Parser.parse(parent, indent = 0)\nParses the tokens into an array of RDoc::Markup::XXX objects,\nand appends them to the passed +parent+ RDoc::Markup::YYY object.\n\nExits at the end of the token stream, or when it encounters a token\nin a column less than +indent+ (unless it is a NEWLINE).\n\nReturns +parent+.\n
peek_token RDoc::Markup::Parser.peek_token()\nReturns the next token on the stream without modifying the stream\n
skip RDoc::Markup::Parser.skip(token_type, error = true)\nSkips the next token if its type is +token_type+.\n\nOptionally raises an error if the next token is not of the expected type.\n
token_pos RDoc::Markup::Parser.token_pos(offset)\nCalculates the column and line of the current token based on +offset+.\n
tokenize RDoc::Markup::Parser.tokenize(input)\nTurns text +input+ into a stream of tokens\n
unget RDoc::Markup::Parser.unget()\nReturns the current token to the token stream\n
accept RDoc::Markup::Rule.accept(visitor)\nCalls #accept_rule on +visitor+\n
new RDoc::Markup::Formatter.new(markup = nil)\nCreates a new Formatter\n
accept_document RDoc::Markup::Formatter.accept_document(document)\nAdds +document+ to the output\n
add_tag RDoc::Markup::Formatter.add_tag(name, start, stop)\nAdd a new set of tags for an attribute. We allow separate start and end\ntags for flexibility\n
annotate RDoc::Markup::Formatter.annotate(tag)\nAllows +tag+ to be decorated with additional information.\n
convert RDoc::Markup::Formatter.convert(content)\nMarks up +content+\n
convert_flow RDoc::Markup::Formatter.convert_flow(flow)\nConverts flow items +flow+\n
convert_special RDoc::Markup::Formatter.convert_special(special)\nConverts added specials.  See RDoc::Markup#add_special\n
convert_string RDoc::Markup::Formatter.convert_string(string)\nConverts a string to be fancier if desired\n
in_tt? RDoc::Markup::Formatter.in_tt?()\nAre we currently inside tt tags?\n
off_tags RDoc::Markup::Formatter.off_tags(res, item)\nTurns off tags for +item+ on +res+\n
on_tags RDoc::Markup::Formatter.on_tags(res, item)\nTurns on tags for +item+ on +res+\n
tt? RDoc::Markup::Formatter.tt?(tag)\nIs +tag+ a tt tag?\n
add_generator RDoc::RDoc.add_generator(klass)\nAdd +klass+ that can generate output after parsing\n
current RDoc::RDoc.current()\nActive RDoc::RDoc instance\n
current= RDoc::RDoc.current=(rdoc)\nSets the active RDoc::RDoc instance\n
new RDoc::RDoc.new()\nCreates a new RDoc::RDoc instance.  Call #document to parse files and\ngenerate documentation.\n
reset RDoc::RDoc.reset()\nResets all internal state\n
document RDoc::RDoc.document(options)\nGenerates documentation or a coverage report depending upon the settings\nin +options+.\n\n+options+ can be either an RDoc::Options instance or an array of strings\nequivalent to the strings that would be passed on the command line like\n<tt>%w[-q -o doc -t My\ Doc\ Title]</tt>.  #document will automatically\ncall RDoc::Options#finish if an options instance was given.\n\nFor a list of options, see either RDoc::Options or <tt>rdoc --help</tt>.\n\nBy default, output will be stored in a directory called "doc" below the\ncurrent directory, so make sure you're somewhere writable before invoking.\n
error RDoc::RDoc.error(msg)\nReport an error message and exit\n
gather_files RDoc::RDoc.gather_files(files)\nGathers a set of parseable files from the files and directories listed in\n+files+.\n
generate RDoc::RDoc.generate(file_info)\nGenerates documentation for +file_info+ (from #parse_files) into the\noutput dir using the generator selected\nby the RDoc options\n
handle_pipe RDoc::RDoc.handle_pipe()\nTurns RDoc from stdin into HTML\n
install_siginfo_handler RDoc::RDoc.install_siginfo_handler()\nInstalls a siginfo handler that prints the current filename.\n
list_files_in_directory RDoc::RDoc.list_files_in_directory(dir)\nReturn a list of the files to be processed in a directory. We know that\nthis directory doesn't have a .document file, so we're looking for real\nfiles. However we may well contain subdirectories which must be tested\nfor .document files.\n
normalized_file_list RDoc::RDoc.normalized_file_list(relative_files, force_doc = false,\nexclude_pattern = nil)\nGiven a list of files and directories, create a list of all the Ruby\nfiles they contain.\n\nIf +force_doc+ is true we always add the given files, if false, only\nadd files that we guarantee we can parse.  It is true when looking at\nfiles given on the command line, false when recursing through\nsubdirectories.\n\nThe effect of this is that if you want a file with a non-standard\nextension parsed, you must name it explicitly.\n
output_flag_file RDoc::RDoc.output_flag_file(op_dir)\nReturn the path name of the flag file in an output directory.\n
parse_dot_doc_file RDoc::RDoc.parse_dot_doc_file(in_dir, filename)\nThe .document file contains a list of file and directory name patterns,\nrepresenting candidates for documentation. It may also contain comments\n(starting with '#')\n
parse_file RDoc::RDoc.parse_file(filename)\nParses +filename+ and returns an RDoc::TopLevel\n
parse_files RDoc::RDoc.parse_files(files)\nParse each file on the command line, recursively entering directories.\n
remove_siginfo_handler RDoc::RDoc.remove_siginfo_handler()\nRemoves a siginfo handler and replaces the previous\n
remove_unparseable RDoc::RDoc.remove_unparseable(files)\nRemoves file extensions known to be unparseable from +files+\n
setup_output_dir RDoc::RDoc.setup_output_dir(dir, force)\nCreate an output dir if it doesn't exist. If it does exist, but doesn't\ncontain the flag file <tt>created.rid</tt> then we refuse to use it, as\nwe may clobber some manually generated documentation\n
update_output_dir RDoc::RDoc.update_output_dir(op_dir, time, last = {})\nUpdate the flag file in an output directory.\n
generation_hook RDoc::RubygemsHook.generation_hook(installer, specs)\nPost installs hook that generates documentation for each specification in\n+specs+\n
load_rdoc RDoc::RubygemsHook.load_rdoc()\nLoads the RDoc generator\n
new RDoc::RubygemsHook.new(spec, generate_rdoc = true, generate_ri = true)\nCreates a new documentation generator for +spec+.  RDoc and ri data\ngeneration can be disabled through +generate_rdoc+ and +generate_ri+\nrespectively.\n
delete_legacy_args RDoc::RubygemsHook.delete_legacy_args(args)\nRemoves legacy rdoc arguments from +args+\n
document RDoc::RubygemsHook.document(generator, options, destination)\nGenerates documentation using the named +generator+ ("darkfish" or "ri")\nand following the given +options+.\n\nDocumentation will be generated into +destination+\n
generate RDoc::RubygemsHook.generate()\nGenerates RDoc and ri data\n
rdoc_installed? RDoc::RubygemsHook.rdoc_installed?()\nIs rdoc documentation installed?\n
remove RDoc::RubygemsHook.remove()\nRemoves generated RDoc and ri data\n
ri_installed? RDoc::RubygemsHook.ri_installed?()\nIs ri data installed?\n
setup RDoc::RubygemsHook.setup()\nPrepares the spec for documentation generation\n
new RDoc::Stats.new(num_files, verbosity = 1)\nCreates a new Stats that will have +num_files+.  +verbosity+ defaults to 1\nwhich will create an RDoc::Stats::Normal outputter.\n
add_alias RDoc::Stats.add_alias(as)\nRecords the parsing of an alias +as+.\n
add_attribute RDoc::Stats.add_attribute(attribute)\nRecords the parsing of an attribute +attribute+\n
add_class RDoc::Stats.add_class(klass)\nRecords the parsing of a class +klass+\n
add_constant RDoc::Stats.add_constant(constant)\nRecords the parsing of +constant+\n
add_file RDoc::Stats.add_file(file)\nRecords the parsing of +file+\n
add_method RDoc::Stats.add_method(method)\nRecords the parsing of +method+\n
add_module RDoc::Stats.add_module(mod)\nRecords the parsing of a module +mod+\n
begin_adding RDoc::Stats.begin_adding()\nCall this to mark the beginning of parsing for display purposes\n
calculate RDoc::Stats.calculate()\nCalculates documentation totals and percentages for classes, modules,\nconstants, attributes and methods.\n
coverage_level= RDoc::Stats.coverage_level=(level)\nSets coverage report level.  Accepted values are:\n\nfalse or nil:: No report\n0:: Classes, modules, constants, attributes, methods\n1:: Level 0 + method parameters\n
doc_stats RDoc::Stats.doc_stats(collection)\nReturns the length and number of undocumented items in +collection+.\n
done_adding RDoc::Stats.done_adding()\nCall this to mark the end of parsing for display purposes\n
fully_documented? RDoc::Stats.fully_documented?()\nThe documentation status of this project.  +true+ when 100%, +false+ when\nless than 100% and +nil+ when unknown.\n\nSet by calling #calculate\n
great_job RDoc::Stats.great_job()\nA report that says you did a great job!\n
percent_doc RDoc::Stats.percent_doc()\nCalculates the percentage of items documented.\n
report RDoc::Stats.report()\nReturns a report on which items are not documented\n
report_attributes RDoc::Stats.report_attributes(cm)\nReturns a report on undocumented attributes in ClassModule +cm+\n
report_class_module RDoc::Stats.report_class_module(cm)\nReturns a report on undocumented items in ClassModule +cm+\n
report_constants RDoc::Stats.report_constants(cm)\nReturns a report on undocumented constants in ClassModule +cm+\n
report_methods RDoc::Stats.report_methods(cm)\nReturns a report on undocumented methods in ClassModule +cm+\n
summary RDoc::Stats.summary()\nReturns a summary of the collected statistics.\n
undoc_params RDoc::Stats.undoc_params(method)\nDetermines which parameters in +method+ were not documented.  Returns a\ntotal parameter count and an Array of undocumented methods.\n
default_options RDoc::RI::Driver.default_options()\nDefault options for ri\n
dump RDoc::RI::Driver.dump(data_path)\nDump +data_path+ using pp\n
new RDoc::RI::Driver.new(initial_options = {})\nCreates a new driver using +initial_options+ from ::process_args\n
process_args RDoc::RI::Driver.process_args(argv)\nParses +argv+ and returns a Hash of options\n
run RDoc::RI::Driver.run(argv = ARGV)\nRuns the ri command line executable using +argv+\n
add_also_in RDoc::RI::Driver.add_also_in(out, also_in)\nAdds paths for undocumented classes +also_in+ to +out+\n
add_class RDoc::RI::Driver.add_class(out, name, classes)\nAdds a class header to +out+ for class +name+ which is described in\n+classes+.\n
add_from RDoc::RI::Driver.add_from(out, store)\nAdds "(from ...)" to +out+ for +store+\n
add_includes RDoc::RI::Driver.add_includes(out, includes)\nAdds +includes+ to +out+\n
add_method_list RDoc::RI::Driver.add_method_list(out, methods, name)\nAdds a list of +methods+ to +out+ with a heading of +name+\n
ancestors_of RDoc::RI::Driver.ancestors_of(klass)\nReturns ancestor classes of +klass+\n
class_document RDoc::RI::Driver.class_document(name, found, klasses, includes)\nBuilds a RDoc::Markup::Document from +found+, +klasess+ and +includes+\n
classes RDoc::RI::Driver.classes()\nHash mapping a known class or module to the stores it can be loaded from\n
classes_and_includes_for RDoc::RI::Driver.classes_and_includes_for(name)\nReturns the stores wherin +name+ is found along with the classes and\nincludes that match it\n
complete RDoc::RI::Driver.complete(name)\nCompletes +name+ based on the caches.  For Readline\n
display RDoc::RI::Driver.display(document)\nConverts +document+ to text and writes it to the pager\n
display_class RDoc::RI::Driver.display_class(name)\nOutputs formatted RI data for class +name+.  Groups undocumented classes\n
display_method RDoc::RI::Driver.display_method(name)\nOutputs formatted RI data for method +name+\n
display_name RDoc::RI::Driver.display_name(name)\nOutputs formatted RI data for the class or method +name+.\n\nReturns true if +name+ was found, false if it was not an alternative could\nbe guessed, raises an error if +name+ couldn't be guessed.\n
display_names RDoc::RI::Driver.display_names(names)\nDisplays each name in +name+\n
expand_class RDoc::RI::Driver.expand_class(klass)\nExpands abbreviated klass +klass+ into a fully-qualified class.  "Zl::Da"\nwill be expanded to Zlib::DataError.\n
expand_name RDoc::RI::Driver.expand_name(name)\nExpands the class portion of +name+ into a fully-qualified class.  See\nexpand_class.\n
filter_methods RDoc::RI::Driver.filter_methods(found, name)\nFilters the methods in +found+ trying to find a match for +name+.\n
find_methods RDoc::RI::Driver.find_methods(name)\nYields items matching +name+ including the store they were found in, the\nclass being searched for, the class they were found in (an ancestor) the\ntypes of methods to look up (from #method_type), and the method name being\nsearched for\n
formatter RDoc::RI::Driver.formatter(io)\nCreates a new RDoc::Markup::Formatter.  If a formatter is given with -f,\nuse it.  If we're outputting to a pager, use bs, otherwise ansi.\n
in_path? RDoc::RI::Driver.in_path?(file)\nIs +file+ in ENV['PATH']?\n
interactive RDoc::RI::Driver.interactive()\nRuns ri interactively using Readline if it is available.\n
list_known_classes RDoc::RI::Driver.list_known_classes(names = [])\nLists classes known to ri starting with +names+.  If +names+ is empty all\nknown classes are shown.\n
list_methods_matching RDoc::RI::Driver.list_methods_matching(name)\nReturns an Array of methods matching +name+\n
load_method RDoc::RI::Driver.load_method(store, cache, klass, type, name)\nLoads RI data for method +name+ on +klass+ from +store+.  +type+ and\n+cache+ indicate if it is a class or instance method.\n
load_methods_matching RDoc::RI::Driver.load_methods_matching(name)\nReturns an Array of RI data for methods matching +name+\n
method_document RDoc::RI::Driver.method_document(name, filtered)\nBuilds a RDoc::Markup::Document from +found+, +klasess+ and +includes+\n
method_type RDoc::RI::Driver.method_type(selector)\nReturns the type of method (:both, :instance, :class) for +selector+\n
name_regexp RDoc::RI::Driver.name_regexp(name)\nReturns a regular expression for +name+ that will match an\nRDoc::AnyMethod's name.\n
page RDoc::RI::Driver.page()\nPaginates output through a pager program.\n
paging? RDoc::RI::Driver.paging?()\nAre we using a pager?\n
parse_name RDoc::RI::Driver.parse_name(name)\nExtracts the class, selector and method name parts from +name+ like\nFoo::Bar#baz.\n\nNOTE: Given Foo::Bar, Bar is considered a class even though it may be a\n      method\n
run RDoc::RI::Driver.run()\nLooks up and displays ri data according to the options given.\n
setup_pager RDoc::RI::Driver.setup_pager()\nSets up a pager program to pass output through.  Tries the RI_PAGER and\nPAGER environment variables followed by pager, less then more.\n
new RDoc::RI::Store.new(path, type = nil)\nCreates a new Store of +type+ that will load or save to +path+\n
ancestors RDoc::RI::Store.ancestors()\nAncestors cache accessor.  Maps a klass name to an Array of its ancestors\nin this store.  If Foo in this store inherits from Object, Kernel won't be\nlisted (it will be included from ruby's ri store).\n
attributes RDoc::RI::Store.attributes()\nAttributes cache accessor.  Maps a class to an Array of its attributes.\n
cache_path RDoc::RI::Store.cache_path()\nPath to the cache file\n
class_file RDoc::RI::Store.class_file(klass_name)\nPath to the ri data for +klass_name+\n
class_methods RDoc::RI::Store.class_methods()\nClass methods cache accessor.  Maps a class to an Array of its class\nmethods (not full name).\n
class_path RDoc::RI::Store.class_path(klass_name)\nPath where data for +klass_name+ will be stored (methods or class data)\n
friendly_path RDoc::RI::Store.friendly_path()\nFriendly rendition of #path\n
instance_methods RDoc::RI::Store.instance_methods()\nInstance methods cache accessor.  Maps a class to an Array of its\ninstance methods (not full name).\n
load_cache RDoc::RI::Store.load_cache()\nLoads cache file for this store\n
load_class RDoc::RI::Store.load_class(klass_name)\nLoads ri data for +klass_name+\n
load_method RDoc::RI::Store.load_method(klass_name, method_name)\nLoads ri data for +method_name+ in +klass_name+\n
method_file RDoc::RI::Store.method_file(klass_name, method_name)\nPath to the ri data for +method_name+ in +klass_name+\n
modules RDoc::RI::Store.modules()\nModules cache accessor.  An Array of all the modules (and classes) in the\nstore.\n
save_cache RDoc::RI::Store.save_cache()\nWrites the cache file for this store\n
save_class RDoc::RI::Store.save_class(klass)\nWrites the ri data for +klass+\n
save_method RDoc::RI::Store.save_method(klass, method)\nWrites the ri data for +method+ on +klass+\n
alias_extension RDoc::Parser.alias_extension(old_ext, new_ext)\nAlias an extension to another extension. After this call, files ending\n"new_ext" will be parsed using the same parser as "old_ext"\n
binary? RDoc::Parser.binary?(file)\nDetermines if the file is a "binary" file which basically means it has\ncontent that an RDoc parser shouldn't try to consume.\n
can_parse RDoc::Parser.can_parse(file_name)\nReturn a parser that can handle a particular extension\n
for RDoc::Parser.for(top_level, file_name, body, options, stats)\nFind the correct parser for a particular file name. Return a SimpleParser\nfor ones that we don't know\n
new RDoc::Parser.new(top_level, file_name, content, options, stats)\nCreates a new Parser storing +top_level+, +file_name+, +content+,\n+options+ and +stats+ in instance variables.\n\nUsually invoked by +super+\n
parse_files_matching RDoc::Parser.parse_files_matching(regexp)\nRecord which file types this parser can understand.\n\nIt is ok to call this multiple times.\n
process_directive RDoc::Parser.process_directive(code_object, directive, value)\nProcesses common directives for CodeObjects for the C and Ruby parsers.\n\nApplies +directive+'s +value+ to +code_object+, if appropriate\n
zip? RDoc::Parser.zip?(file)\nChecks if +file+ is a zip file in disguise.  Signatures from\nhttp://www.garykessler.net/library/file_sigs.html\n
new RDoc::Parser::Ruby.new(top_level, file_name, content, options, stats)\nCreates a new Ruby parser.\n
collect_first_comment RDoc::Parser::Ruby.collect_first_comment()\nLook for the first comment in a file that isn't a shebang line.\n
error RDoc::Parser::Ruby.error(msg)\nAborts with +msg+\n
extract_call_seq RDoc::Parser::Ruby.extract_call_seq(comment, meth)\nLook for a 'call-seq' in the comment, and override the normal parameter\nstuff\n
get_bool RDoc::Parser::Ruby.get_bool()\nLooks for a true or false token.  Returns false if TkFALSE or TkNIL are\nfound.\n
get_class_or_module RDoc::Parser::Ruby.get_class_or_module(container)\nLook for the name of a class of module (optionally with a leading :: or\nwith :: separated named) and return the ultimate name, the associated\ncontainer, and the given name (with the ::).\n
get_class_specification RDoc::Parser::Ruby.get_class_specification()\nReturn a superclass, which can be either a constant of an expression\n
get_constant RDoc::Parser::Ruby.get_constant()\nParse a constant, which might be qualified by one or more class or module\nnames\n
get_constant_with_optional_parens RDoc::Parser::Ruby.get_constant_with_optional_parens()\nGet a constant that may be surrounded by parens\n
get_symbol_or_name RDoc::Parser::Ruby.get_symbol_or_name()\nExtracts a name or symbol from the token stream.\n
look_for_directives_in RDoc::Parser::Ruby.look_for_directives_in(context, comment)\nLook for directives in a normal comment block:\n :stopdoc:\n Don't display comment from this point forward\n\nThis routine modifies its +comment+ parameter.\n
make_message RDoc::Parser::Ruby.make_message(message)\nAdds useful info about the parser to +message+\n
parse_alias RDoc::Parser::Ruby.parse_alias(context, single, tk, comment)\nParses an +alias+ in +context+ with +comment+\n
parse_attr RDoc::Parser::Ruby.parse_attr(context, single, tk, comment)\nCreates an RDoc::Attr for the name following +tk+, setting the comment to\n+comment+.\n
parse_attr_accessor RDoc::Parser::Ruby.parse_attr_accessor(context, single, tk, comment)\nCreates an RDoc::Attr for each attribute listed after +tk+, setting the\ncomment for each to +comment+.\n
parse_call_parameters RDoc::Parser::Ruby.parse_call_parameters(tk)\nExtracts call parameters from the token stream.\n
parse_class RDoc::Parser::Ruby.parse_class(container, single, tk, comment)\nParses a class in +context+ with +comment+\n
parse_comment RDoc::Parser::Ruby.parse_comment(container, tk, comment)\nGenerates an RDoc::Method or RDoc::Attr from +comment+ by looking for\n:method: or :attr: directives in +comment+.\n
parse_constant RDoc::Parser::Ruby.parse_constant(container, tk, comment)\nParses a constant in +context+ with +comment+\n
parse_include RDoc::Parser::Ruby.parse_include(context, comment)\nParses an +include+ in +context+ with +comment+\n
parse_meta_attr RDoc::Parser::Ruby.parse_meta_attr(context, single, tk, comment)\nParses a meta-programmed attribute and creates an RDoc::Attr.\n\nTo create foo and bar attributes on class C with comment "My attributes":\n\n  class C\n\n :attr:\n\n My attributes\n\n    my_attr :foo, :bar\n\n  end\n\nTo create a foo attribute on class C with comment "My attribute":\n\n  class C\n\n :attr: foo\n\n My attribute\n\n    my_attr :foo, :bar\n\n  end\n
parse_meta_method RDoc::Parser::Ruby.parse_meta_method(container, single, tk, comment)\nParses a meta-programmed method\n
parse_method RDoc::Parser::Ruby.parse_method(container, single, tk, comment)\nParses a normal method defined by +def+\n
parse_method_or_yield_parameters RDoc::Parser::Ruby.parse_method_or_yield_parameters(method = nil, modifiers\n= RDoc::METHOD_MODIFIERS)\nExtracts +yield+ parameters from +method+\n
parse_method_parameters RDoc::Parser::Ruby.parse_method_parameters(method)\nCapture the method's parameters. Along the way, look for a comment\ncontaining:\n yields: ....\n\nand add this as the block_params for the method\n
parse_module RDoc::Parser::Ruby.parse_module(container, single, tk, comment)\nParses an RDoc::NormalModule in +container+ with +comment+\n
parse_require RDoc::Parser::Ruby.parse_require(context, comment)\nParses an RDoc::Require in +context+ containing +comment+\n
parse_statements RDoc::Parser::Ruby.parse_statements(container, single = NORMAL, current_method\n= nil, comment = '')\nThe core of the ruby parser.\n
parse_symbol_arg RDoc::Parser::Ruby.parse_symbol_arg(no = nil)\nParse up to +no+ symbol arguments\n
parse_symbol_in_arg RDoc::Parser::Ruby.parse_symbol_in_arg()\nReturns symbol text from the next token\n
parse_top_level_statements RDoc::Parser::Ruby.parse_top_level_statements(container)\nParses statements in the top-level +container+\n
parse_visibility RDoc::Parser::Ruby.parse_visibility(container, single, tk)\nDetermines the visibility in +container+ from +tk+\n
parse_yield RDoc::Parser::Ruby.parse_yield(context, single, tk, method)\nDetermines the block parameter for +context+\n
read_directive RDoc::Parser::Ruby.read_directive(allowed)\nDirectives are modifier comments that can appear after class, module, or\nmethod names. For example:\n\n  def fred # :yields: a, b\n\nor:\n\n  class MyClass # :nodoc:\n\nWe return the directive name and any parameters as a two element array\n
read_documentation_modifiers RDoc::Parser::Ruby.read_documentation_modifiers(context, allow)\nHandles the directive for +context+ if the directive is listed in +allow+.\nThis method is called for directives following a definition.\n
remove_private_comments RDoc::Parser::Ruby.remove_private_comments(comment)\nRemoves private comments from +comment+\n
scan RDoc::Parser::Ruby.scan()\nScans this ruby file for ruby constructs\n
skip_for_variable RDoc::Parser::Ruby.skip_for_variable()\nskip the var [in] part of a 'for' statement\n
skip_method RDoc::Parser::Ruby.skip_method(container)\nSkips the next method in +container+\n
skip_optional_do_after_expression RDoc::Parser::Ruby.skip_optional_do_after_expression()\nwhile, until, and for have an optional do\n
skip_tkspace_comment RDoc::Parser::Ruby.skip_tkspace_comment(skip_nl = true)\nSkip spaces until a comment is found\n
warn RDoc::Parser::Ruby.warn(msg)\nPrints +msg+ to +$stderr+ unless we're being quiet\n
new RDoc::Parser::Simple.new(top_level, file_name, content, options, stats)\nPrepare to parse a plain file\n
remove_coding_comment RDoc::Parser::Simple.remove_coding_comment(text)\nRemoves the encoding magic comment from +text+\n
remove_private_comments RDoc::Parser::Simple.remove_private_comments(text)\nRemoves comments wrapped in <tt>--/++</tt>\n
scan RDoc::Parser::Simple.scan()\nExtract the file contents and attach them to the TopLevel as a comment\n
new RDoc::Parser::C.new(top_level, file_name, content, options, stats)\nPrepare to parse a C file\n
reset RDoc::Parser::C.reset()\nResets cross-file state.  Call when parsing different projects that need\nseparate documentation.\n
do_aliases RDoc::Parser::C.do_aliases()\nScans #content for rb_define_alias\n
do_attrs RDoc::Parser::C.do_attrs()\nScans #content for rb_attr and rb_define_attr\n
do_classes RDoc::Parser::C.do_classes()\nScans #content for rb_define_module, rb_define_class, boot_defclass,\nrb_define_module_under, rb_define_class_under and rb_singleton_class\n
do_constants RDoc::Parser::C.do_constants()\nScans #content for rb_define_variable, rb_define_readonly_variable,\nrb_define_const and rb_define_global_const\n
do_includes RDoc::Parser::C.do_includes()\nScans #content for rb_include_module\n
do_methods RDoc::Parser::C.do_methods()\nScans #content for rb_define_method, rb_define_singleton_method,\nrb_define_module_function, rb_define_private_method,\nrb_define_global_function and define_filetest_function\n
find_alias_comment RDoc::Parser::C.find_alias_comment(class_name, new_name, old_name)\nFinds the comment for an alias on +class_name+ from +new_name+ to\n+old_name+\n
find_attr_comment RDoc::Parser::C.find_attr_comment(var_name, attr_name, read = nil, write = nil)\nFinds a comment for rb_define_attr, rb_attr or Document-attr.\n\n+var_name+ is the C class variable the attribute is defined on.\n+attr_name+ is the attribute's name.\n\n+read+ and +write+ are the read/write flags ('1' or '0').  Either both or\nneither must be provided.\n
find_body RDoc::Parser::C.find_body(class_name, meth_name, meth_obj, file_content,\nquiet = false)\nFind the C code corresponding to a Ruby method\n
find_class RDoc::Parser::C.find_class(raw_name, name)\nFinds a RDoc::NormalClass or RDoc::NormalModule for +raw_name+\n
find_class_comment RDoc::Parser::C.find_class_comment(class_name, class_mod)\nLook for class or module documentation above Init_+class_name+(void),\nin a Document-class +class_name+ (or module) comment or above an\nrb_define_class (or module).  If a comment is supplied above a matching\nInit_ and a rb_define_class the Init_ comment is used.\n\n  /*\n   * This is a comment for Foo\n   */\n  Init_Foo(void) {\n      VALUE cFoo = rb_define_class("Foo", rb_cObject);\n  }\n\n  /*\n   * Document-class: Foo\n   * This is a comment for Foo\n   */\n  Init_foo(void) {\n      VALUE cFoo = rb_define_class("Foo", rb_cObject);\n  }\n\n  /*\n   * This is a comment for Foo\n   */\n  VALUE cFoo = rb_define_class("Foo", rb_cObject);\n
find_const_comment RDoc::Parser::C.find_const_comment(type, const_name, class_name = nil)\nFinds a comment matching +type+ and +const_name+ either above the\ncomment or in the matching Document- section.\n
find_modifiers RDoc::Parser::C.find_modifiers(comment, meth_obj)\nHandles modifiers in +comment+ and updates +meth_obj+ as appropriate.\n\nIf <tt>:nodoc:</tt> is found, documentation on +meth_obj+ is suppressed.\n\nIf <tt>:yields:</tt> is followed by an argument list it is used for the\nblock_params of +meth_obj+.\n\nIf the comment block contains a <tt>\n  call-seq:\n     ARGF.readlines(sep=$/)     -> array\n     ARGF.readlines(limit)      -> array\n     ARGF.readlines(sep, limit) -> array\n\n     ARGF.to_a(sep=$/)     -> array\n     ARGF.to_a(limit)      -> array\n     ARGF.to_a(sep, limit) -> array\n\nit is used for the parameters of +meth_obj+.\n
find_override_comment RDoc::Parser::C.find_override_comment(class_name, meth_obj)\nFinds a <tt>Document-method</tt> override for +meth_obj+ on +class_name+\n
handle_attr RDoc::Parser::C.handle_attr(var_name, attr_name, read, write)\nCreates a new RDoc::Attr +attr_name+ on class +var_name+ that is either\n+read+, +write+ or both\n
handle_class_module RDoc::Parser::C.handle_class_module(var_name, type, class_name, parent,\nin_module)\nCreates a new RDoc::NormalClass or RDoc::NormalModule based on +type+\nnamed +class_name+ in +parent+ which was assigned to the C +var_name+.\n
handle_constants RDoc::Parser::C.handle_constants(type, var_name, const_name, definition)\nAdds constants.  By providing some_value: at the start of the comment you\ncan override the C value of the comment to give a friendly definition.\n\n  /* 300: The perfect score in bowling */\n  rb_define_const(cFoo, "PERFECT", INT2FIX(300);\n\nWill override <tt>INT2FIX(300)</tt> with the value +300+ in the output\nRDoc.  Values may include quotes and escaped colons (\:).\n
handle_ifdefs_in RDoc::Parser::C.handle_ifdefs_in(body)\nRemoves #ifdefs that would otherwise confuse us\n
handle_method RDoc::Parser::C.handle_method(type, var_name, meth_name, function, param_count,\nsource_file = nil)\nAdds an RDoc::AnyMethod +meth_name+ defined on a class or module assigned\nto +var_name+.  +type+ is the type of method definition function used.\n+singleton_method+ and +module_function+ create a singleton method.\n
handle_singleton RDoc::Parser::C.handle_singleton(sclass_var, class_var)\nRegisters a singleton class +sclass_var+ as a singleton of +class_var+\n
handle_tab_width RDoc::Parser::C.handle_tab_width(body)\nNormalizes tabs in +body+\n
look_for_directives_in RDoc::Parser::C.look_for_directives_in(context, comment)\nLook for directives in a normal comment block:\n\n  /*\n   * :title: My Awesome Project\n   */\n\nThis method modifies the +comment+\n
rb_scan_args RDoc::Parser::C.rb_scan_args(method_body)\nExtracts parameters from the +method_body+ and returns a method\nparameter string.  Follows 1.9.3dev's scan-arg-spec, see README.EXT\n
remove_commented_out_lines RDoc::Parser::C.remove_commented_out_lines()\nRemoves lines that are commented out that might otherwise get picked up\nwhen scanning for classes and methods\n
remove_private_comments RDoc::Parser::C.remove_private_comments(comment)\nRemoves private comments from +comment+\n
scan RDoc::Parser::C.scan()\nExtracts the classes, modules, methods, attributes, constants and aliases\nfrom a C file and returns an RDoc::TopLevel for this file\n
print_file RDoc::Stats::Normal.print_file(files_so_far, filename)\nPrints a file with a progress bar\n
new RDoc::Stats::Quiet.new(num_files)\nCreates a new Quiet that will print nothing\n
begin_adding RDoc::Stats::Quiet.begin_adding(*)\nPrints a message at the beginning of parsing\n
done_adding RDoc::Stats::Quiet.done_adding(*)\nPrints when RDoc is done\n
print_alias RDoc::Stats::Quiet.print_alias(*)\nPrints when an alias is added\n
print_attribute RDoc::Stats::Quiet.print_attribute(*)\nPrints when an attribute is added\n
print_class RDoc::Stats::Quiet.print_class(*)\nPrints when a class is added\n
print_constant RDoc::Stats::Quiet.print_constant(*)\nPrints when a constant is added\n
print_file RDoc::Stats::Quiet.print_file(*)\nPrints when a file is added\n
print_method RDoc::Stats::Quiet.print_method(*)\nPrints when a method is added\n
print_module RDoc::Stats::Quiet.print_module(*)\nPrints when a module is added\n
nodoc RDoc::Stats::Verbose.nodoc(co)\nReturns a marker for RDoc::CodeObject +co+ being undocumented\n
definition RDoc::NormalModule.definition()\nThe definition of this module, <tt>module MyModuleName</tt>\n
module? RDoc::NormalModule.module?()\nThis is a module, returns true\n
superclass RDoc::NormalModule.superclass()\nModules don't have one, raises NoMethodError\n
check_files RDoc::Options.check_files()\nCheck that the files on the command line exist\n
check_generator RDoc::Options.check_generator()\nEnsure only one generator is loaded\n
default_title= RDoc::Options.default_title=(string)\nSet the title, but only if not already set. Used to set the title\nfrom a source file, so that a title set from the command line\nwill have the priority.\n
finish RDoc::Options.finish()\nCompletes any unfinished option setup business such as filtering for\nexistent files, creating a regexp for #exclude and setting a default\ntemplate.\n
generator_descriptions RDoc::Options.generator_descriptions()\nReturns a properly-space list of generators and their descriptions.\n
parse RDoc::Options.parse(argv)\nParses command line options.\n
quiet RDoc::Options.quiet()\nDon't display progress as we process the files\n
quiet= RDoc::Options.quiet=(bool)\nSet quietness to +bool+\n
setup_generator RDoc::Options.setup_generator(generator_name = @generator_name)\nSet up an output generator for the named +generator_name+.\n\nIf the found generator responds to :setup_options it will be called with\nthe options instance.  This allows generators to add custom options or set\ndefault options.\n
template_dir_for RDoc::Options.template_dir_for(template)\nFinds the template dir for +template+\n
ancestors RDoc::SingleClass.ancestors()\nAdds the superclass to the included modules.\n
definition RDoc::SingleClass.definition()\nThe definition of this singleton class, <tt>class << MyClassName</tt>\n
ancestors RDoc::NormalClass.ancestors()\nAppends the superclass, if any, to the included modules.\n
definition RDoc::NormalClass.definition()\nThe definition of this class, <tt>class MyClassName</tt>\n
new RDoc::ERBIO.new(str, safe_level = nil, trim_mode = nil, eoutvar = 'io')\nDefaults +eoutvar+ to 'io', otherwise is identical to ERB's initialize\n
set_eoutvar RDoc::ERBIO.set_eoutvar(compiler, io_variable)\nInstructs +compiler+ how to write to +io_variable+\n
new RDoc::Task.new(name = :rdoc)\nCreate an RDoc task with the given name. See the RDoc::Task class overview\nfor documentation.\n
before_running_rdoc RDoc::Task.before_running_rdoc(&block)\nThe block passed to this method will be called just before running the\nRDoc generator. It is allowed to modify RDoc::Task attributes inside the\nblock.\n
check_names RDoc::Task.check_names(names)\nEnsures that +names+ only includes names for the :rdoc, :clobber_rdoc and\n:rerdoc.  If other names are given an ArgumentError is raised.\n
clobber_task_description RDoc::Task.clobber_task_description()\nTask description for the clobber rdoc task or its renamed equivalent\n
defaults RDoc::Task.defaults()\nSets default task values\n
define RDoc::Task.define()\nCreate the tasks defined by this task lib.\n
option_list RDoc::Task.option_list()\nList of options that will be supplied to RDoc\n
rdoc_task_description RDoc::Task.rdoc_task_description()\nTask description for the rdoc task or its renamed equivalent\n
rerdoc_task_description RDoc::Task.rerdoc_task_description()\nTask description for the rerdoc task or its renamed description\n
new RDoc::Task.new(name = :rdoc)\nCreate an RDoc task with the given name. See the RDoc::Task class overview\nfor documentation.\n
before_running_rdoc RDoc::Task.before_running_rdoc(&block)\nThe block passed to this method will be called just before running the\nRDoc generator. It is allowed to modify RDoc::Task attributes inside the\nblock.\n
check_names RDoc::Task.check_names(names)\nEnsures that +names+ only includes names for the :rdoc, :clobber_rdoc and\n:rerdoc.  If other names are given an ArgumentError is raised.\n
clobber_task_description RDoc::Task.clobber_task_description()\nTask description for the clobber rdoc task or its renamed equivalent\n
defaults RDoc::Task.defaults()\nSets default task values\n
define RDoc::Task.define()\nCreate the tasks defined by this task lib.\n
option_list RDoc::Task.option_list()\nList of options that will be supplied to RDoc\n
rdoc_task_description RDoc::Task.rdoc_task_description()\nTask description for the rdoc task or its renamed equivalent\n
rerdoc_task_description RDoc::Task.rerdoc_task_description()\nTask description for the rerdoc task or its renamed description\n
new RDoc::CrossReference.new(context)\nAllows cross-references to be created based on the given +context+\n(RDoc::Context).\n
resolve RDoc::CrossReference.resolve(name, text)\nReturns a reference to +name+.\n\nIf the reference is found and +name+ is not documented +text+ will be\nreturned.  If +name+ is escaped +name+ is returned.  If +name+ is not\nfound +text+ is returned.\n
each_prime Integer.each_prime(ubound)\nIterates the given block over all prime numbers.\n\nSee +Prime+#each for more details.\n
from_prime_division Integer.from_prime_division(pd)\nRe-composes a prime factorization and returns the product.\n\nSee Prime#int_from_prime_division for more details.\n
ceil Integer.ceil()\nAs <i>int</i> is already an `Integer`, all these\nmethods simply return the receiver.\n
chr Integer.chr(*args)\nReturns a string containing the character represented by the\nreceiver's value according to +encoding+.\n\n   65.chr    #=> "A"\n   230.chr   #=> "\346"\n   255.chr(Encoding::UTF_8)   #=> "\303\277"\n
denominator Integer.denominator()\nReturns 1.\n
downto Integer.downto(p1)\nIterates <em>block</em>, passing decreasing values from <i>int</i>\ndown to and including <i>limit</i>.\n\nIf no block is given, an enumerator is returned instead.\n\n   5.downto(1) { |n| print n, ".. " }\n   print "  Liftoff!\\n"\n\n<em>produces:</em>\n\n   5.. 4.. 3.. 2.. 1..   Liftoff!\n
even? Integer.even?()\nReturns `true` if <i>int</i> is an even number.\n
floor Integer.floor()\nAs <i>int</i> is already an `Integer`, all these\nmethods simply return the receiver.\n
gcd Integer.gcd(p1)\nReturns the greatest common divisor (always positive).  0.gcd(x)\nand x.gcd(0) return abs(x).\n\nFor example:\n\n   2.gcd(2)                    #=> 2\n   3.gcd(-7)                   #=> 1\n   ((1<<31)-1).gcd((1<<61)-1)  #=> 1\n
gcdlcm Integer.gcdlcm(p1)\nReturns an array; [int.gcd(int2), int.lcm(int2)].\n\nFor example:\n\n   2.gcdlcm(2)                    #=> [2, 2]\n   3.gcdlcm(-7)                   #=> [1, 21]\n   ((1<<31)-1).gcdlcm((1<<61)-1)  #=> [1, 4951760154835678088235319297]\n
integer? Integer.integer?()\nAlways returns `true`.\n
lcm Integer.lcm(p1)\nReturns the least common multiple (always positive).  0.lcm(x) and\nx.lcm(0) return zero.\n\nFor example:\n\n   2.lcm(2)                    #=> 2\n   3.lcm(-7)                   #=> 21\n   ((1<<31)-1).lcm((1<<61)-1)  #=> 4951760154835678088235319297\n
next Integer.next()\nReturns the `Integer` equal to <i>int</i> + 1.\n\n   1.next      #=> 2\n   (-1).next   #=> 0\n
numerator Integer.numerator()\nReturns self.\n
odd? Integer.odd?()\nReturns `true` if <i>int</i> is an odd number.\n
ord Integer.ord()\nReturns the int itself.\n\n   ?a.ord    #=> 97\n\nThis method is intended for compatibility to\ncharacter constant in Ruby 1.9.\nFor example, ?a.ord returns 97 both in 1.8 and 1.9.\n
pred Integer.pred()\nReturns the `Integer` equal to <i>int</i> - 1.\n\n   1.pred      #=> 0\n   (-1).pred   #=> -2\n
prime? Integer.prime?()\nReturns true if +self+ is a prime number, false for a composite.\n
prime_division Integer.prime_division(generator = Prime::Generator23.new)\nReturns the factorization of +self+.\n\nSee Prime#prime_division for more details.\n
rationalize Integer.rationalize(p1 = v1)\nReturns the value as a rational.  An optional argument eps is\nalways ignored.\n
round Integer.round(p1)\nRounds <i>flt</i> to a given precision in decimal digits (default 0 digits).\nPrecision may be negative.  Returns a floating point number when +ndigits+\nis positive, +self+ for zero, and round down for negative.\n\n   1.round        #=> 1\n   1.round(2)     #=> 1.0\n   15.round(-1)   #=> 20\n
succ Integer.succ()\nReturns the `Integer` equal to <i>int</i> + 1.\n\n   1.next      #=> 2\n   (-1).next   #=> 0\n
times Integer.times()\nIterates block <i>int</i> times, passing in values from zero to\n<i>int</i> - 1.\n\nIf no block is given, an enumerator is returned instead.\n\n   5.times do |i|\n     print i, " "\n   end\n\n<em>produces:</em>\n\n   0 1 2 3 4\n
to_bn Integer.to_bn()\n\n
to_d Integer.to_d()\nConvert +int+ to a BigDecimal and return it.\n\n    require 'bigdecimal'\n    require 'bigdecimal/util'\n\n    42.to_d\n => #<BigDecimal:1008ef070,'0.42E2',9(36)>\n
to_i Integer.to_i()\nAs <i>int</i> is already an `Integer`, all these\nmethods simply return the receiver.\n
to_int Integer.to_int()\nAs <i>int</i> is already an `Integer`, all these\nmethods simply return the receiver.\n
to_r Integer.to_r()\nReturns the value as a rational.\n\nFor example:\n\n   1.to_r        #=> (1/1)\n   (1<<64).to_r  #=> (18446744073709551616/1)\n
truncate Integer.truncate()\nAs <i>int</i> is already an `Integer`, all these\nmethods simply return the receiver.\n
upto Integer.upto(p1)\nIterates <em>block</em>, passing in integer values from <i>int</i>\nup to and including <i>limit</i>.\n\nIf no block is given, an enumerator is returned instead.\n\n   5.upto(10) { |i| print i, " " }\n\n<em>produces:</em>\n\n   5 6 7 8 9 10\n
from_module RDoc::ClassModule.from_module(class_type, mod)\nReturn a RDoc::ClassModule of class +class_type+ that is a copy\nof module +module+. Used to promote modules to classes.\n
new RDoc::ClassModule.new(name, superclass = nil)\nCreates a new ClassModule with +name+ with optional +superclass+\n\nThis is a constructor for subclasses, and must never be called directly.\n
add_comment RDoc::ClassModule.add_comment(comment, location)\nAdds +comment+ to this ClassModule's list of comments at +location+.  This\nmethod is preferred over #comment= since it allows ri data to be updated\nacross multiple runs.\n
ancestors RDoc::ClassModule.ancestors()\nAncestors list for this ClassModule: the list of included modules\n(classes will add their superclass if any).\n\nReturns the included classes or modules, not the includes\nthemselves. The returned values are either String or\nRDoc::NormalModule instances (see RDoc::Include#module).\n\nThe values are returned in reverse order of their inclusion,\nwhich is the order suitable for searching methods/attributes\nin the ancestors. The superclass, if any, comes last.\n
clear_comment RDoc::ClassModule.clear_comment()\nClears the comment. Used by the ruby parser.\n
comment= RDoc::ClassModule.comment=(comment)\nThis method is deprecated, use #add_comment instead.\n\nAppends +comment+ to the current comment, but separated by a rule.  Works\nmore like <tt>+=</tt>.\n
complete RDoc::ClassModule.complete(min_visibility)\nPrepares this ClassModule for use by a generator.\n\nSee RDoc::TopLevel::complete\n
each_ancestor RDoc::ClassModule.each_ancestor()\nIterates the ancestors of this class or module for which an\nRDoc::ClassModule exists.\n
find_ancestor_local_symbol RDoc::ClassModule.find_ancestor_local_symbol(symbol)\nLooks for a symbol in the #ancestors. See Context#find_local_symbol.\n
find_class_named RDoc::ClassModule.find_class_named(name)\nFinds a class or module with +name+ in this namespace or its descendants\n
full_name RDoc::ClassModule.full_name()\nReturn the fully qualified name of this class or module\n
merge RDoc::ClassModule.merge(class_module)\nMerges +class_module+ into this ClassModule.\n\nThe data in +class_module+ is preferred over the receiver.\n
module? RDoc::ClassModule.module?()\nDoes this object represent a module?\n
name= RDoc::ClassModule.name=(new_name)\nAllows overriding the initial name.\n\nUsed for modules and classes that are constant aliases.\n
name_for_path RDoc::ClassModule.name_for_path()\nName to use to generate the url:\nmodules and classes that are aliases for another\nmodule or class return the name of the latter.\n
non_aliases RDoc::ClassModule.non_aliases()\nReturns the classes and modules that are not constants\naliasing another class or module. For use by formatters\nonly (caches its result).\n
parse RDoc::ClassModule.parse(comment_location)\nParses +comment_location+ into an RDoc::Markup::Document composed of\nmultiple RDoc::Markup::Documents with their file set.\n
path RDoc::ClassModule.path()\nPath to this class or module\n
remove_nodoc_children RDoc::ClassModule.remove_nodoc_children()\nUpdates the child modules or classes of class/module +parent+ by\ndeleting the ones that have been removed from the documentation.\n\n+parent_hash+ is either <tt>parent.modules_hash</tt> or\n<tt>parent.classes_hash</tt> and +all_hash+ is ::all_modules_hash or\n::all_classes_hash.\n
superclass RDoc::ClassModule.superclass()\nGet the superclass of this class.  Attempts to retrieve the superclass\nobject, returns the name if it is not known.\n
superclass= RDoc::ClassModule.superclass=(superclass)\nSet the superclass of this class to +superclass+\n
type RDoc::ClassModule.type()\n'module' or 'class'\n
update_aliases RDoc::ClassModule.update_aliases()\nUpdates the child modules & classes by replacing the ones that are\naliases through a constant.\n\nThe aliased module/class is replaced in the children and in\nRDoc::TopLevel::all_modules_hash or RDoc::TopLevel::all_classes_hash\nby a copy that has <tt>RDoc::ClassModule#is_alias_for</tt> set to\nthe aliased module/class, and this copy is added to <tt>#aliases</tt>\nof the aliased module/class.\n\nFormatters can use the #non_aliases method to retrieve children that\nare not aliases, for instance to list the namespace content, since\nthe aliased modules are included in the constants of the class/module,\nthat are listed separately.\n
update_includes RDoc::ClassModule.update_includes()\nDeletes from #includes those whose module has been removed from the\ndocumentation.\n
new RDoc::MethodAttr.new(text, name)\nCreates a new MethodAttr from token stream +text+ and method or attribute\nname +name+.\n\nUsually this is called by super from a subclass.\n
add_alias RDoc::MethodAttr.add_alias(an_alias, context)\nAbstract method. Contexts in their building phase call this\nto register a new alias for this known method/attribute.\n\n- creates a new AnyMethod/Attribute +newa+ named an_alias.new_name;\n- adds +self+ as +newa.is_alias_for+;\n- adds +newa+ to #aliases\n- adds +newa+ to the methods/attributes of +context+.\n
aref RDoc::MethodAttr.aref()\nHTML fragment reference for this method\n
aref_prefix RDoc::MethodAttr.aref_prefix()\nPrefix for +aref+, defined by subclasses.\n
block_params= RDoc::MethodAttr.block_params=(value)\nAttempts to sanitize the content passed by the ruby parser:\nremove outer parentheses, etc.\n
documented? RDoc::MethodAttr.documented?()\nA method/attribute is documented if any of the following is true:\n- it was marked with :nodoc:;\n- it has a comment;\n- it is an alias for a documented method;\n- it has a +#see+ method that is documented.\n
full_name RDoc::MethodAttr.full_name()\nFull method/attribute name including namespace\n
html_name RDoc::MethodAttr.html_name()\nHTML id-friendly method/attribute name\n
name_prefix RDoc::MethodAttr.name_prefix()\n'::' for a class method/attribute, '#' for an instance method.\n
parent_name RDoc::MethodAttr.parent_name()\nName of our parent with special handling for un-marshaled methods\n
path RDoc::MethodAttr.path()\nPath to this method\n
pretty_name RDoc::MethodAttr.pretty_name()\nMethod/attribute name with class/instance indicator\n
see RDoc::MethodAttr.see()\nA method/attribute to look at,\nin particular if this method/attribute has no documentation.\n\nIt can be a method/attribute of the superclass or of an included module,\nincluding the Kernel module, which is always appended to the included\nmodules.\n\nReturns +nil+ if there is no such method/attribute.\nThe +#is_alias_for+ method/attribute, if any, is not included.\n\nTemplates may generate a "see also ..." if this method/attribute\nhas documentation, and "see ..." if it does not.\n
type RDoc::MethodAttr.type()\nType of method/attribute (class or instance)\n
new RDoc::Require.new(name, comment)\nCreates a new Require that loads +name+ with +comment+\n
top_level RDoc::Require.top_level()\nThe RDoc::TopLevel corresponding to this require, or +nil+ if not found.\n
new IRB::Notifier::AbstractNotifier.new(prefix, base_notifier)\n\n
exec_if IRB::Notifier::AbstractNotifier.exec_if()\n\n
notify? IRB::Notifier::AbstractNotifier.notify?()\n\n
pp IRB::Notifier::AbstractNotifier.pp(*objs)\n\n
ppx IRB::Notifier::AbstractNotifier.ppx(prefix, *objs)\n\n
print IRB::Notifier::AbstractNotifier.print(*opts)\n\n
printf IRB::Notifier::AbstractNotifier.printf(format, *opts)\n\n
printn IRB::Notifier::AbstractNotifier.printn(*opts)\n\n
puts IRB::Notifier::AbstractNotifier.puts(*objs)\n\n
new IRB::Notifier::CompositeNotifier.new(prefix, base_notifier)\n\n
def_notifier IRB::Notifier::CompositeNotifier.def_notifier(level, prefix = "")\n\n
level= IRB::Notifier::CompositeNotifier.level=(value)\n\n
level_notifier= IRB::Notifier::CompositeNotifier.level_notifier=(value)\n\n
new IRB::Notifier::LeveledNotifier.new(base, level, prefix)\n\n
notify? IRB::Notifier::LeveledNotifier.notify?()\n\n
new IRB::Notifier::NoMsgNotifier.new()\n\n
notify? IRB::Notifier::NoMsgNotifier.notify?()\n\n
new RubyToken::Token.new(seek, line_no, char_no)\n\n
new RubyToken::TkNode.new(seek, line_no, char_no)\n\n
new RubyToken::TkId.new(seek, line_no, char_no, name)\n\n
new RubyToken::TkVal.new(seek, line_no, char_no, value = nil)\n\n
new RubyToken::TkOPASGN.new(seek, line_no, char_no, op)\n\n
new RubyToken::TkUnknownChar.new(seek, line_no, char_no, id)\n\n
new IRB::WorkSpace.new(*main)\ncreate new workspace. set self to main if specified, otherwise\ninherit main from TOPLEVEL_BINDING.\n
__evaluate__ IRB::WorkSpace.__evaluate__(context, statements, file = __FILE__, line =\n__LINE__)\n\n
evaluate IRB::WorkSpace.evaluate(context, statements, file = __FILE__, line = __LINE__)\n\n
filter_backtrace IRB::WorkSpace.filter_backtrace(bt)\nerror message manipulator\n
execute IRB::ExtendCommand::Nop.execute(conf, *opts)\n\n
new IRB::ExtendCommand::Nop.new(conf)\n\n
execute IRB::ExtendCommand::Nop.execute(*opts)\n\n
irb IRB::ExtendCommand::Nop.irb()\n\n
execute IRB::ExtendCommand::IrbCommand.execute(*obj)\n\n
execute IRB::ExtendCommand::Jobs.execute()\n\n
execute IRB::ExtendCommand::Foreground.execute(key)\n\n
execute IRB::ExtendCommand::Kill.execute(*keys)\n\n
execute IRB::ExtendCommand::Fork.execute(&block)\n\n
execute IRB::ExtendCommand::Load.execute(file_name, priv = nil)\n\n
execute IRB::ExtendCommand::Require.execute(file_name)\n\n
execute IRB::ExtendCommand::Source.execute(file_name)\n\n
execute IRB::ExtendCommand::Help.execute(*names)\n\n
execute IRB::ExtendCommand::Workspaces.execute(*obj)\n\n
execute IRB::ExtendCommand::PushWorkspace.execute(*obj)\n\n
execute IRB::ExtendCommand::PopWorkspace.execute(*obj)\n\n
execute IRB::ExtendCommand::CurrentWorkingWorkspace.execute(*obj)\n\n
execute IRB::ExtendCommand::ChangeWorkspace.execute(*obj)\n\n
new IRB::Inspector.new(inspect_proc, init_proc = nil)\n\n
init IRB::Inspector.init()\n\n
inspect_value IRB::Inspector.inspect_value(v)\n\n
new IRB::Locale.new(locale = nil)\n\n
String IRB::Locale.String(mes)\n\n
find IRB::Locale.find(file , paths = $:)\n\n
format IRB::Locale.format(*opts)\n\n
gets IRB::Locale.gets(*rs)\n\n
load IRB::Locale.load(file, priv=nil)\n\n
print IRB::Locale.print(*opts)\n\n
printf IRB::Locale.printf(*opts)\n\n
puts IRB::Locale.puts(*opts)\n\n
readline IRB::Locale.readline(*rs)\n\n
require IRB::Locale.require(file, priv = nil)\n\n
toplevel_load IRB::Locale.toplevel_load(file, priv=nil)\n\n
new IRB::Context.new(irb, workspace = nil, input_method = nil, output_method = nil)\nArguments:\n  input_method: nil -- stdin or readline\n                String -- File\n                other -- using this as InputMethod\n
__exit__ IRB::Context.__exit__(ret = 0)\n\n
__inspect__ IRB::Context.__inspect__()\n\n
__to_s__ IRB::Context.__to_s__()\n\n
_set_last_value IRB::Context._set_last_value(value)\n\n
change_workspace IRB::Context.change_workspace(*_main)\n\n
debug? IRB::Context.debug?()\n\n
debug_level= IRB::Context.debug_level=(value)\n\n
eval_history= IRB::Context.eval_history=(no)\n\n
evaluate IRB::Context.evaluate(line, line_no)\n\n
exit IRB::Context.exit(ret = 0)\n\n
file_input? IRB::Context.file_input?()\n\n
history_file IRB::Context.history_file()\n\n
history_file= IRB::Context.history_file=(hist)\n\n
home_workspace IRB::Context.home_workspace()\n\n
init_save_history IRB::Context.init_save_history()\n\n
inspect IRB::Context.inspect()\n\n
inspect? IRB::Context.inspect?()\n\n
inspect_last_value IRB::Context.inspect_last_value()\n\n
inspect_mode= IRB::Context.inspect_mode=(opt)\n\n
irb_level IRB::Context.irb_level()\n\n
main IRB::Context.main()\n\n
math_mode= IRB::Context.math_mode=(opt)\n\n
pop_workspace IRB::Context.pop_workspace()\n\n
prompt_mode= IRB::Context.prompt_mode=(mode)\n\n
prompting? IRB::Context.prompting?()\n\n
push_workspace IRB::Context.push_workspace(*_main)\n\n
save_history IRB::Context.save_history()\n\n
save_history= IRB::Context.save_history=(val)\n\n
set_last_value IRB::Context.set_last_value(value)\n\n
to_s IRB::Context.to_s()\n\n
use_loader IRB::Context.use_loader()\n\n
use_loader= IRB::Context.use_loader=(opt)\n\n
use_loader? IRB::Context.use_loader?()\n\n
use_readline= IRB::Context.use_readline=(opt)\n\n
use_tracer= IRB::Context.use_tracer=(opt)\n\n
verbose? IRB::Context.verbose?()\n\n
workspaces IRB::Context.workspaces()\n\n
debug? RubyLex.debug?()\n\n
new RubyLex.new()\n\n
each_top_level_statement RubyLex.each_top_level_statement()\n\n
eof? RubyLex.eof?()\n\n
get_readed RubyLex.get_readed()\n\n
getc RubyLex.getc()\n\n
getc_of_rests RubyLex.getc_of_rests()\n\n
gets RubyLex.gets()\n\n
identify_comment RubyLex.identify_comment()\n\n
identify_gvar RubyLex.identify_gvar()\n\n
identify_here_document RubyLex.identify_here_document()\n\n
identify_identifier RubyLex.identify_identifier()\n\n
identify_number RubyLex.identify_number()\n\n
identify_quotation RubyLex.identify_quotation()\n\n
identify_string RubyLex.identify_string(ltype, quoted = ltype)\n\n
identify_string_dvar RubyLex.identify_string_dvar()\n\n
initialize_input RubyLex.initialize_input()\n\n
lex RubyLex.lex()\n\n
lex_init RubyLex.lex_init()\n\n
lex_int2 RubyLex.lex_int2()\n\n
peek RubyLex.peek(i = 0)\n\n
peek_equal? RubyLex.peek_equal?(str)\n\n
peek_match? RubyLex.peek_match?(regexp)\n\n
prompt RubyLex.prompt()\n\n
read_escape RubyLex.read_escape()\n\n
set_input RubyLex.set_input(io, p = nil, &block)\nio functions\n
set_prompt RubyLex.set_prompt(p = nil, &block)\n\n
token RubyLex.token()\n\n
ungetc RubyLex.ungetc(c = nil)\n\n
new IRB::JobManager.new()\n\n
delete IRB::JobManager.delete(key)\n\n
insert IRB::JobManager.insert(irb)\n\n
inspect IRB::JobManager.inspect()\n\n
irb IRB::JobManager.irb(key)\n\n
kill IRB::JobManager.kill(*keys)\n\n
main_irb IRB::JobManager.main_irb()\n\n
main_thread IRB::JobManager.main_thread()\n\n
n_jobs IRB::JobManager.n_jobs()\n\n
search IRB::JobManager.search(key)\n\n
switch IRB::JobManager.switch(key)\n\n
thread IRB::JobManager.thread(key)\n\n
new IRB::Irb.new(workspace = nil, input_method = nil, output_method = nil)\n\n
eval_input IRB::Irb.eval_input()\n\n
inspect IRB::Irb.inspect()\n\n
output_value IRB::Irb.output_value()\n\n
prompt IRB::Irb.prompt(prompt, ltype, indent, line_no)\n\n
signal_handle IRB::Irb.signal_handle()\n\n
signal_status IRB::Irb.signal_status(status)\n\n
suspend_context IRB::Irb.suspend_context(context)\n\n
suspend_input_method IRB::Irb.suspend_input_method(input_method)\n\n
suspend_name IRB::Irb.suspend_name(path = nil, name = nil)\n\n
suspend_workspace IRB::Irb.suspend_workspace(workspace)\n\n
new IRB::History.new(size = 16)\n\n
inspect IRB::History.inspect()\n\n
push IRB::History.push(no, val)\n\n
real_inspect IRB::History.real_inspect()\n\n
size IRB::History.size(size)\n\n
new XMP.new(bind = nil)\n\n
puts XMP.puts(exps)\n\n
new XMP::StringInputMethod.new()\n\n
eof? XMP::StringInputMethod.eof?()\n\n
gets XMP::StringInputMethod.gets()\n\n
puts XMP::StringInputMethod.puts(exps)\n\n
new IRB::InputMethod.new(file = STDIN_FILE_NAME)\n\n
gets IRB::InputMethod.gets()\n\n
readable_atfer_eof? IRB::InputMethod.readable_atfer_eof?()\n\n
new IRB::StdioInputMethod.new()\n\n
encoding IRB::StdioInputMethod.encoding()\n\n
eof? IRB::StdioInputMethod.eof?()\n\n
gets IRB::StdioInputMethod.gets()\n\n
line IRB::StdioInputMethod.line(line_no)\n\n
readable_atfer_eof? IRB::StdioInputMethod.readable_atfer_eof?()\n\n
new IRB::FileInputMethod.new(file)\n\n
encoding IRB::FileInputMethod.encoding()\n\n
eof? IRB::FileInputMethod.eof?()\n\n
gets IRB::FileInputMethod.gets()\n\n
new IRB::ReadlineInputMethod.new()\n\n
encoding IRB::ReadlineInputMethod.encoding()\n\n
eof? IRB::ReadlineInputMethod.eof?()\n\n
gets IRB::ReadlineInputMethod.gets()\n\n
line IRB::ReadlineInputMethod.line(line_no)\n\n
readable_atfer_eof? IRB::ReadlineInputMethod.readable_atfer_eof?()\n\n
parse_printf_format IRB::OutputMethod.parse_printf_format(format, opts)\n%\n<flag>  [#0- +]\n<minimum field width> (\*|\*[1-9][0-9]*\$|[1-9][0-9]*)\n<precision>.(\*|\*[1-9][0-9]*\$|[1-9][0-9]*|)?\n<length modifier>(hh|h|l|ll|L|q|j|z|t)\n<conversion specifier>[diouxXeEfgGcsb%]\n
pp IRB::OutputMethod.pp(*objs)\n\n
ppx IRB::OutputMethod.ppx(prefix, *objs)\n\n
print IRB::OutputMethod.print(*opts)\n\n
printf IRB::OutputMethod.printf(format, *opts)\nextend printf\n
printn IRB::OutputMethod.printn(*opts)\n\n
puts IRB::OutputMethod.puts(*objs)\n\n
print IRB::StdioOutputMethod.print(*opts)\n\n
bottom IRB::Frame.bottom(n = 0)\nsingleton functions\n
new IRB::Frame.new()\n\n
sender IRB::Frame.sender()\n\n
top IRB::Frame.top(n = 0)\n\n
bottom IRB::Frame.bottom(n = 0)\n\n
top IRB::Frame.top(n = 0)\n\n
trace_func IRB::Frame.trace_func(event, file, line, id, binding)\n\n
new IRB::SLex.new()\n\n
create IRB::SLex.create(token, preproc = nil, postproc = nil)\n\n
def_rule IRB::SLex.def_rule(token, preproc = nil, postproc = nil, &block)\n\n
def_rules IRB::SLex.def_rules(*tokens, &block)\n\n
inspect IRB::SLex.inspect()\n\n
match IRB::SLex.match(token)\n\n
postproc IRB::SLex.postproc(token)\n$BMW%A%'%C%/(B?\n
preproc IRB::SLex.preproc(token, proc)\n\n
search IRB::SLex.search(token)\n\n
new IRB::SLex::Node.new(preproc = nil, postproc = nil)\nif postproc is nil, this node is an abstract node.\nif postproc is non-nil, this node is a real node.\n
create_subnode IRB::SLex::Node.create_subnode(chrs, preproc = nil, postproc = nil)\n\n
match IRB::SLex::Node.match(chrs, op = "")\nchrs: String\n      character array\n      io must have getc()/ungetc(); and ungetc() must be\n      able to be called arbitrary number of times.\n
match_io IRB::SLex::Node.match_io(io, op = "")\n\n
search IRB::SLex::Node.search(chrs, opt = nil)\n\n
all_waits ThreadsWait.all_waits(*threads)\nWaits until all specified threads have terminated.  If a block is provided,\nit is executed for each thread as they terminate.\n
new ThreadsWait.new(*threads)\nCreates a ThreadsWait object, specifying the threads to wait on.\nNon-blocking.\n
all_waits ThreadsWait.all_waits()\nWaits until all of the specified threads are terminated.  If a block is\nsupplied for the method, it is executed for each thread termination.\n\nRaises exceptions in the same manner as +next_wait+.\n
empty? ThreadsWait.empty?()\nReturns +true+ if there are no threads in the pool still running.\n
finished? ThreadsWait.finished?()\nReturns +true+ if any thread has terminated and is ready to be collected.\n
join ThreadsWait.join(*threads)\nWaits for specified threads to terminate, and returns when one of\nthe threads terminated.\n
join_nowait ThreadsWait.join_nowait(*threads)\nSpecifies the threads that this object will wait for, but does not actually\nwait.\n
next_wait ThreadsWait.next_wait(nonblock = nil)\nWaits until any of the specified threads has terminated, and returns the one\nthat does.\n\nIf there is no thread to wait, raises +ErrNoWaitingThread+.  If +nonblock+\nis true, and there is no terminated thread, raises +ErrNoFinishedThread+.\n
all_waits ThreadsWait.all_waits(*threads)\nWaits until all specified threads have terminated.  If a block is provided,\nit is executed for each thread as they terminate.\n
new ThreadsWait.new(*threads)\nCreates a ThreadsWait object, specifying the threads to wait on.\nNon-blocking.\n
all_waits ThreadsWait.all_waits()\nWaits until all of the specified threads are terminated.  If a block is\nsupplied for the method, it is executed for each thread termination.\n\nRaises exceptions in the same manner as +next_wait+.\n
empty? ThreadsWait.empty?()\nReturns +true+ if there are no threads in the pool still running.\n
finished? ThreadsWait.finished?()\nReturns +true+ if any thread has terminated and is ready to be collected.\n
join ThreadsWait.join(*threads)\nWaits for specified threads to terminate, and returns when one of\nthe threads terminated.\n
join_nowait ThreadsWait.join_nowait(*threads)\nSpecifies the threads that this object will wait for, but does not actually\nwait.\n
next_wait ThreadsWait.next_wait(nonblock = nil)\nWaits until any of the specified threads has terminated, and returns the one\nthat does.\n\nIf there is no thread to wait, raises +ErrNoWaitingThread+.  If +nonblock+\nis true, and there is no terminated thread, raises +ErrNoFinishedThread+.\n
racc_runtime_type Racc::Parser.racc_runtime_type()\n\n
_load DRb::DRbObject._load(s)\nUnmarshall a marshalled DRbObject.\n\nIf the referenced object is located within the local server, then\nthe object itself is returned.  Otherwise, a new DRbObject is\ncreated to act as a stub for the remote referenced object.\n
new DRb::DRbObject.new(obj, uri=nil)\nCreate a new remote object stub.\n\n+obj+ is the (local) object we want to create a stub for.  Normally\nthis is +nil+.  +uri+ is the URI of the remote object that this\nwill be a stub for.\n
new_with DRb::DRbObject.new_with(uri, ref)\n\n
new_with_uri DRb::DRbObject.new_with_uri(uri)\nCreate a new DRbObject from a URI alone.\n
prepare_backtrace DRb::DRbObject.prepare_backtrace(uri, result)\n\n
with_friend DRb::DRbObject.with_friend(uri)\n\n
__drbref DRb::DRbObject.__drbref()\nGet the reference of the object, if local.\n
__drburi DRb::DRbObject.__drburi()\nGet the URI of the remote object.\n
_dump DRb::DRbObject._dump(lv)\nMarshall this object.\n\nThe URI and ref of the object are marshalled.\n
eql? DRb::DRbObject.eql?(other)\n\n
hash DRb::DRbObject.hash()\n\n
method_missing DRb::DRbObject.method_missing(msg_id, *a, &b)\nRoutes method calls to the referenced object.\n
respond_to? DRb::DRbObject.respond_to?(msg_id, priv=false)\n\n
command DRb::ExtServManager.command()\n\n
command= DRb::ExtServManager.command=(cmd)\n\n
new DRb::ExtServManager.new()\n\n
regist DRb::ExtServManager.regist(name, ro)\n\n
service DRb::ExtServManager.service(name)\n\n
unregist DRb::ExtServManager.unregist(name)\n\n
new DRb::DRbUNIXSocket.new(uri, soc, config={}, server_mode = false)\n\n
open DRb::DRbUNIXSocket.open(uri, config)\n\n
open_server DRb::DRbUNIXSocket.open_server(uri, config)\n\n
parse_uri DRb::DRbUNIXSocket.parse_uri(uri)\n\n
uri_option DRb::DRbUNIXSocket.uri_option(uri, config)\n\n
accept DRb::DRbUNIXSocket.accept()\n\n
close DRb::DRbUNIXSocket.close()\n\n
set_sockopt DRb::DRbUNIXSocket.set_sockopt(soc)\n\n
new ACL.new(list=nil, order = DENY_ALLOW)\nCreates a new ACL from +list+ with an evaluation +order+ of DENY_ALLOW or\nALLOW_DENY.\n\nAn ACL +list+ is an Array of "allow" or "deny" and an address or address\nmask or "all" or "*" to match any address:\n\n  %w[\n    deny all\n    allow 192.0.2.2\n    allow 192.0.2.128/26\n  ]\n
allow_addr? ACL.allow_addr?(addr)\nAllow connections from addrinfo +addr+?  It must be formatted like\nSocket#peeraddr:\n\n  ["AF_INET", 10, "lc630", "192.0.2.1"]\n
allow_socket? ACL.allow_socket?(soc)\nAllow connections from Socket +soc+?\n
install_list ACL.install_list(list)\nAdds +list+ of ACL entries to this ACL.\n
new ACL::ACLEntry.new(str)\nCreates a new entry using +str+.\n\n+str+ may be "*" or "all" to match any address, an IP address string\nto match a specific address, an IP address mask per IPAddr, or one\ncontaining "*" to match part of an IPv4 address.\n
match ACL::ACLEntry.match(addr)\nMatches +addr+ against this entry.\n
new ACL::ACLList.new()\nCreates an empty ACLList\n
add ACL::ACLList.add(str)\nAdds +str+ as an ACLEntry in this list\n
match ACL::ACLList.match(addr)\nMatches +addr+ against each ACLEntry in this list.\n
new DRb::DRbSSLSocket.new(uri, soc, config, is_established)\n\n
open DRb::DRbSSLSocket.open(uri, config)\n\n
open_server DRb::DRbSSLSocket.open_server(uri, config)\n\n
parse_uri DRb::DRbSSLSocket.parse_uri(uri)\n\n
uri_option DRb::DRbSSLSocket.uri_option(uri, config)\n\n
accept DRb::DRbSSLSocket.accept()\n\n
close DRb::DRbSSLSocket.close()\n\n
stream DRb::DRbSSLSocket.stream()\n\n
new DRb::DRbSSLSocket::SSLConfig.new(config)\n\n
accept DRb::DRbSSLSocket::SSLConfig.accept(tcp)\n\n
connect DRb::DRbSSLSocket::SSLConfig.connect(tcp)\n\n
setup_certificate DRb::DRbSSLSocket::SSLConfig.setup_certificate()\n\n
setup_ssl_context DRb::DRbSSLSocket::SSLConfig.setup_ssl_context()\n\n
to_id DRb::DRbIdConv.to_id(obj)\nConvert an object into a reference id.\n\nThis implementation returns the object's __id__ in the local\nobject space.\n
to_obj DRb::DRbIdConv.to_obj(ref)\nConvert an object reference id to an object.\n\nThis implementation looks up the reference id in the local object\nspace and returns the object it refers to.\n
new DRb::DRbUnknownError.new(unknown)\nCreate a new DRbUnknownError for the DRb::DRbUnknown object +unknown+\n
new DRb::DRbRemoteError.new(error)\n\n
new DRb::DRbUnknown.new(err, buf)\nCreate a new DRbUnknown object.\n\n+buf+ is a string containing a marshalled object that could not\nbe unmarshalled.  +err+ is the error message that was raised\nwhen the unmarshalling failed.  It is used to determine the\nname of the unmarshalled object.\n
exception DRb::DRbUnknown.exception()\nCreate a DRbUnknownError exception containing this object.\n
reload DRb::DRbUnknown.reload()\nAttempt to load the wrapped marshalled object again.\n\nIf the class of the object is now known locally, the object\nwill be unmarshalled and returned.  Otherwise, a new\nbut identical DRbUnknown object will be returned.\n
_load DRb::DRbArray._load(s)\n\n
new DRb::DRbArray.new(ary)\n\n
_dump DRb::DRbArray._dump(lv)\n\n
getservername DRb::DRbTCPSocket.getservername()\n\n
new DRb::DRbTCPSocket.new(uri, soc, config={})\nCreate a new DRbTCPSocket instance.\n\n+uri+ is the URI we are connected to.\n+soc+ is the tcp socket we are bound to.  +config+ is our\nconfiguration.\n
open DRb::DRbTCPSocket.open(uri, config)\nOpen a client connection to +uri+ using configuration +config+.\n
open_server DRb::DRbTCPSocket.open_server(uri, config)\nOpen a server listening for connections at +uri+ using\nconfiguration +config+.\n
open_server_inaddr_any DRb::DRbTCPSocket.open_server_inaddr_any(host, port)\n\n
uri_option DRb::DRbTCPSocket.uri_option(uri, config)\nParse +uri+ into a [uri, option] pair.\n
accept DRb::DRbTCPSocket.accept()\nOn the server side, for an instance returned by #open_server,\naccept a client connection and return a new instance to handle\nthe server's side of this client-server session.\n
alive? DRb::DRbTCPSocket.alive?()\nCheck to see if this connection is alive.\n
close DRb::DRbTCPSocket.close()\nClose the connection.\n\nIf this is an instance returned by #open_server, then this stops\nlistening for new connections altogether.  If this is an instance\nreturned by #open or by #accept, then it closes this particular\nclient-server session.\n
peeraddr DRb::DRbTCPSocket.peeraddr()\nGet the address of our TCP peer (the other end of the socket\nwe are bound to.\n
recv_reply DRb::DRbTCPSocket.recv_reply()\nOn the client side, receive a reply from the server.\n
recv_request DRb::DRbTCPSocket.recv_request()\nOn the server side, receive a request from the client.\n
send_reply DRb::DRbTCPSocket.send_reply(succ, result)\nOn the server side, send a reply to the client.\n
send_request DRb::DRbTCPSocket.send_request(ref, msg_id, arg, b)\nOn the client side, send a request to the server.\n
stream DRb::DRbTCPSocket.stream()\nGet the socket.\n
default_acl DRb::DRbServer.default_acl(acl)\nSet the default value for the :acl option.\n\nSee #new().  The initial default value is nil.\n
default_argc_limit DRb::DRbServer.default_argc_limit(argc)\nSet the default value for the :argc_limit option.\n\nSee #new().  The initial default value is 256.\n
default_id_conv DRb::DRbServer.default_id_conv(idconv)\nSet the default value for the :id_conv option.\n\nSee #new().  The initial default value is a DRbIdConv instance.\n
default_load_limit DRb::DRbServer.default_load_limit(sz)\nSet the default value for the :load_limit option.\n\nSee #new().  The initial default value is 25 MB.\n
default_safe_level DRb::DRbServer.default_safe_level(level)\n\n
new DRb::DRbServer.new(uri=nil, front=nil, config_or_acl=nil)\nCreate a new DRbServer instance.\n\n+uri+ is the URI to bind to.  This is normally of the form\n'druby://<hostname>:<port>' where <hostname> is a hostname of\nthe local machine.  If nil, then the system's default hostname\nwill be bound to, on a port selected by the system; these value\ncan be retrieved from the +uri+ attribute.  'druby:' specifies\nthe default dRuby transport protocol: another protocol, such\nas 'drbunix:', can be specified instead.\n\n+front+ is the front object for the server, that is, the object\nto which remote method calls on the server will be passed.  If\nnil, then the server will not accept remote method calls.\n\nIf +config_or_acl+ is a hash, it is the configuration to\nuse for this server.  The following options are recognised:\n\n:idconv :: an id-to-object conversion object.  This defaults\n           to an instance of the class DRb::DRbIdConv.\n:verbose :: if true, all unsuccessful remote calls on objects\n            in the server will be logged to $stdout. false\n            by default.\n:tcp_acl :: the access control list for this server.  See\n            the ACL class from the main dRuby distribution.\n:load_limit :: the maximum message size in bytes accepted by\n               the server.  Defaults to 25 MB (26214400).\n:argc_limit :: the maximum number of arguments to a remote\n               method accepted by the server.  Defaults to\n               256.\n\nThe default values of these options can be modified on\na class-wide basis by the class methods #default_argc_limit,\ndefault_load_limit, #default_acl, #default_id_conv,\nand #verbose=\n\nIf +config_or_acl+ is not a hash, but is not nil, it is\nassumed to be the access control list for this server.\nSee the :tcp_acl option for more details.\n\nIf no other server is currently set as the primary server,\nthis will become the primary server.\n\nThe server will immediately start running in its own thread.\n
verbose DRb::DRbServer.verbose()\nGet the default value of the :verbose option.\n
verbose= DRb::DRbServer.verbose=(on)\nSet the default value of the :verbose option.\n\nSee #new().  The initial default value is false.\n
alive? DRb::DRbServer.alive?()\nIs this server alive?\n
check_insecure_method DRb::DRbServer.check_insecure_method(obj, msg_id)\nCheck that a method is callable via dRuby.\n\n+obj+ is the object we want to invoke the method on. +msg_id+ is the\nmethod name, as a Symbol.\n\nIf the method is an insecure method (see #insecure_method?) a\nSecurityError is thrown.  If the method is private or undefined,\na NameError is thrown.\n
here? DRb::DRbServer.here?(uri)\n\n
stop_service DRb::DRbServer.stop_service()\nStop this server.\n
to_id DRb::DRbServer.to_id(obj)\nConvert a local object to a dRuby reference.\n
to_obj DRb::DRbServer.to_obj(ref)\nConvert a dRuby reference to the local object it refers to.\n
verbose DRb::DRbServer.verbose()\nGet whether the server is in verbose mode.\n\nIn verbose mode, failed calls are logged to stdout.\n
verbose= DRb::DRbServer.verbose=(v)\nSet whether to operate in verbose mode.\n\nIn verbose mode, failed calls are logged to stdout.\n
_load DRb::DRbObject._load(s)\nUnmarshall a marshalled DRbObject.\n\nIf the referenced object is located within the local server, then\nthe object itself is returned.  Otherwise, a new DRbObject is\ncreated to act as a stub for the remote referenced object.\n
new DRb::DRbObject.new(obj, uri=nil)\nCreate a new remote object stub.\n\n+obj+ is the (local) object we want to create a stub for.  Normally\nthis is +nil+.  +uri+ is the URI of the remote object that this\nwill be a stub for.\n
new_with DRb::DRbObject.new_with(uri, ref)\n\n
new_with_uri DRb::DRbObject.new_with_uri(uri)\nCreate a new DRbObject from a URI alone.\n
prepare_backtrace DRb::DRbObject.prepare_backtrace(uri, result)\n\n
with_friend DRb::DRbObject.with_friend(uri)\n\n
__drbref DRb::DRbObject.__drbref()\nGet the reference of the object, if local.\n
__drburi DRb::DRbObject.__drburi()\nGet the URI of the remote object.\n
_dump DRb::DRbObject._dump(lv)\nMarshall this object.\n\nThe URI and ref of the object are marshalled.\n
eql? DRb::DRbObject.eql?(other)\n\n
hash DRb::DRbObject.hash()\n\n
method_missing DRb::DRbObject.method_missing(msg_id, *a, &b)\nRoutes method calls to the referenced object.\n
respond_to? DRb::DRbObject.respond_to?(msg_id, priv=false)\n\n
to_id DRb::DRbIdConv.to_id(obj)\nConvert an object into a reference id.\n\nThis implementation returns the object's __id__ in the local\nobject space.\n
to_obj DRb::DRbIdConv.to_obj(ref)\nConvert an object reference id to an object.\n\nThis implementation looks up the reference id in the local object\nspace and returns the object it refers to.\n
new DRb::TimerIdConv.new(timeout=600)\n\n
to_id DRb::TimerIdConv.to_id(obj)\n\n
to_obj DRb::TimerIdConv.to_obj(ref)\n\n
new DRb::TimerIdConv::TimerHolder2.new(timeout=600)\n\n
add DRb::TimerIdConv::TimerHolder2.add(obj)\n\n
fetch DRb::TimerIdConv::TimerHolder2.fetch(key, dv=@sentinel)\n\n
include? DRb::TimerIdConv::TimerHolder2.include?(key)\n\n
peek DRb::TimerIdConv::TimerHolder2.peek(key)\n\n
new DRb::ExtServ.new(there, name, server=nil)\n\n
alive? DRb::ExtServ.alive?()\n\n
front DRb::ExtServ.front()\n\n
stop_service DRb::ExtServ.stop_service()\n\n
new Foo.new(str)\n\n
hello Foo.hello(it)\n\n
to_s Foo.to_s()\n\n
to_obj DRb::GWIdConv.to_obj(ref)\n\n
new DRb::GW.new()\n\n
new XMLRPC::Service::BasicInterface.new(prefix)\n\n
add_method XMLRPC::Service::BasicInterface.add_method(sig, help=nil, meth_name=nil)\n\n
new XMLRPC::Service::Interface.new(prefix, &p)\n\n
get_methods XMLRPC::Service::Interface.get_methods(obj, delim=".")\n\n
new XMLRPC::Service::PublicInstanceMethodsInterface.new(prefix)\n\n
get_methods XMLRPC::Service::PublicInstanceMethodsInterface.get_methods(obj, delim=".")\n\n
new XMLRPC::DateTime.new(year, month, day, hour, min, sec)\n\n
day= XMLRPC::DateTime.day=(value)\n\n
hour= XMLRPC::DateTime.hour=(value)\n\n
min= XMLRPC::DateTime.min=(value)\n\n
mon= XMLRPC::DateTime.mon=(value)\n\n
month= XMLRPC::DateTime.month=(value)\n\n
sec= XMLRPC::DateTime.sec=(value)\n\n
to_a XMLRPC::DateTime.to_a()\n\n
to_date XMLRPC::DateTime.to_date()\n\n
to_time XMLRPC::DateTime.to_time()\n\n
year= XMLRPC::DateTime.year=(value)\n\n
decode XMLRPC::Base64.decode(str)\n\n
encode XMLRPC::Base64.encode(str)\n\n
new XMLRPC::Base64.new(str, state = :dec)\n\n
decoded XMLRPC::Base64.decoded()\n\n
encoded XMLRPC::Base64.encoded()\n\n
dump XMLRPC::Marshal.dump( param )\n\n
dump_call XMLRPC::Marshal.dump_call( methodName, *params )\n\n
dump_response XMLRPC::Marshal.dump_response( param )\n\n
load XMLRPC::Marshal.load( stringOrReadable )\n\n
load_call XMLRPC::Marshal.load_call( stringOrReadable )\n\n
load_response XMLRPC::Marshal.load_response( stringOrReadable )\n\n
new XMLRPC::Marshal.new( parser = nil, writer = nil )\ninstance methods ----------------------------\n
dump_call XMLRPC::Marshal.dump_call( methodName, *params )\n\n
dump_response XMLRPC::Marshal.dump_response( param )\n\n
load_call XMLRPC::Marshal.load_call( stringOrReadable )\nreturns [ methodname, params ]\n
load_response XMLRPC::Marshal.load_response( stringOrReadable )\nreturns paramOrFault\n
new XMLRPC::Client.new(host=nil, path=nil, port=nil, proxy_host=nil,\nproxy_port=nil, user=nil, password=nil, use_ssl=nil, timeout=nil)\nConstructors\n-------------------------------------------------------------------\n
new2 XMLRPC::Client.new2(uri, proxy=nil, timeout=nil)\n\n
new3 XMLRPC::Client.new3(hash={})\n\n
new_from_hash XMLRPC::Client.new_from_hash(hash={})\n\n
new_from_uri XMLRPC::Client.new_from_uri(uri, proxy=nil, timeout=nil)\n\n
call XMLRPC::Client.call(method, *args)\nCall methods --------------------------------------------------------------\n
call2 XMLRPC::Client.call2(method, *args)\n\n
call2_async XMLRPC::Client.call2_async(method, *args)\n\n
call_async XMLRPC::Client.call_async(method, *args)\n\n
multicall XMLRPC::Client.multicall(*methods)\nMulticall methods\n--------------------------------------------------------------\n
multicall2 XMLRPC::Client.multicall2(*methods)\n\n
multicall2_async XMLRPC::Client.multicall2_async(*methods)\n\n
multicall_async XMLRPC::Client.multicall_async(*methods)\n\n
password= XMLRPC::Client.password=(new_password)\n\n
proxy XMLRPC::Client.proxy(prefix=nil, *args)\nProxy generating methods ------------------------------------------\n
proxy2 XMLRPC::Client.proxy2(prefix=nil, *args)\n\n
proxy2_async XMLRPC::Client.proxy2_async(prefix=nil, *args)\n\n
proxy_async XMLRPC::Client.proxy_async(prefix=nil, *args)\n\n
timeout= XMLRPC::Client.timeout=(new_timeout)\n\n
user= XMLRPC::Client.user=(new_user)\n\n
new XMLRPC::Client::Proxy.new(server, prefix, args=[], meth=:call, delim=".")\n\n
method_missing XMLRPC::Client::Proxy.method_missing(mid, *args)\n\n
ele XMLRPC::XMLWriter::Abstract.ele(name, *children)\n\n
tag XMLRPC::XMLWriter::Abstract.tag(name, txt)\n\n
document XMLRPC::XMLWriter::Simple.document(*params)\n\n
document_to_str XMLRPC::XMLWriter::Simple.document_to_str(doc)\n\n
element XMLRPC::XMLWriter::Simple.element(name, attrs, *children)\n\n
pi XMLRPC::XMLWriter::Simple.pi(name, *params)\n\n
text XMLRPC::XMLWriter::Simple.text(txt)\n\n
new XMLRPC::XMLWriter::XMLParser.new()\n\n
document XMLRPC::XMLWriter::XMLParser.document(*params)\n\n
document_to_str XMLRPC::XMLWriter::XMLParser.document_to_str(doc)\n\n
element XMLRPC::XMLWriter::XMLParser.element(name, attrs, *children)\n\n
pi XMLRPC::XMLWriter::XMLParser.pi(name, *params)\n\n
text XMLRPC::XMLWriter::XMLParser.text(txt)\n\n
new XMLRPC::Create.new(xml_writer = nil)\n\n
methodCall XMLRPC::Create.methodCall(name, *params)\n\n
methodResponse XMLRPC::Create.methodResponse(is_ret, *params)\ngenerates a XML-RPC methodResponse document\n\nif is_ret == false then the params array must\ncontain only one element, which is a structure\nof a fault return-value.\n\nif is_ret == true then a normal\nreturn-value of all the given params is created.\n
new HttpServer.new(handle_obj, port = 8080, host = DEFAULT_HOST, maxConnections =\n4, stdlog = $stdout, audit = true, debug = true)\nhandle_obj specifies the object, that receives calls to request_handler\nand ip_auth_handler\n
new HttpServer::Request.new(data, method=nil, path=nil, proto=nil)\n\n
content_length HttpServer::Request.content_length()\n\n
new HttpServer::Response.new(status=200)\n\n
new HttpServer::Table.new(hash={})\n\n
each HttpServer::Table.each()\n\n
update HttpServer::Table.update(hash)\n\n
writeTo HttpServer::Table.writeTo(port)\n\n
childNodes NQXML::Node.childNodes()\n\n
hasChildNodes NQXML::Node.hasChildNodes()\n\n
nodeName NQXML::Node.nodeName()\n\n
nodeType NQXML::Node.nodeType()\n\n
nodeValue NQXML::Node.nodeValue()\n\n
removeChild NQXML::Node.removeChild(node)\n\n
new XMLRPC::FaultException.new(faultCode, faultString)\n\n
to_h XMLRPC::FaultException.to_h()\nreturns a hash\n
parseMethodCall XMLRPC::XMLParser::AbstractTreeParser.parseMethodCall(str)\n\n
parseMethodResponse XMLRPC::XMLParser::AbstractTreeParser.parseMethodResponse(str)\n\n
parseMethodCall XMLRPC::XMLParser::AbstractStreamParser.parseMethodCall(str)\n\n
parseMethodResponse XMLRPC::XMLParser::AbstractStreamParser.parseMethodResponse(str)\n\n
new XMLRPC::XMLParser::XMLStreamParser.new()\n\n
new XMLRPC::XMLParser::NQXMLStreamParser.new()\n\n
parse XMLRPC::XMLParser::NQXMLStreamParser::XMLRPCParser.parse(str)\n\n
new XMLRPC::XMLParser::XMLTreeParser.new()\n\n
new XMLRPC::XMLParser::NQXMLTreeParser.new()\n\n
new XMLRPC::XMLParser::REXMLStreamParser.new()\n\n
method_missing XMLRPC::XMLParser::REXMLStreamParser::StreamListener.method_missing(*a)\n\n
parse XMLRPC::XMLParser::REXMLStreamParser::StreamListener.parse(str)\n\n
new XMLRPC::XMLParser::XMLScanStreamParser.new()\n\n
method_missing XMLRPC::XMLParser::XMLScanStreamParser::XMLScanParser.method_missing(*a)\n\n
on_cdata XMLRPC::XMLParser::XMLScanStreamParser::XMLScanParser.on_cdata(str)\n\n
on_chardata XMLRPC::XMLParser::XMLScanStreamParser::XMLScanParser.on_chardata(str)\n\n
on_charref XMLRPC::XMLParser::XMLScanStreamParser::XMLScanParser.on_charref(code)\n\n
on_charref_hex XMLRPC::XMLParser::XMLScanStreamParser::XMLScanParser.on_charref_hex(code)\n\n
on_entityref XMLRPC::XMLParser::XMLScanStreamParser::XMLScanParser.on_entityref(ent)\n\n
on_stag_end XMLRPC::XMLParser::XMLScanStreamParser::XMLScanParser.on_stag_end(name)\n\n
on_stag_end_empty XMLRPC::XMLParser::XMLScanStreamParser::XMLScanParser.on_stag_end_empty(name)\n\n
parse XMLRPC::XMLParser::XMLScanStreamParser::XMLScanParser.parse(str)\n\n
new XMLRPC::XMLParser::XMLParser.new()\n\n
new XMLRPC::XMLParser::NQXMLParser.new()\n\n
new XMLRPC::BasicServer.new(class_delim=".")\n\n
add_handler XMLRPC::BasicServer.add_handler(prefix, obj_or_signature=nil, help=nil, &block)\n\n
add_introspection XMLRPC::BasicServer.add_introspection()\n\n
add_multicall XMLRPC::BasicServer.add_multicall()\n\n
get_default_handler XMLRPC::BasicServer.get_default_handler()\n\n
get_service_hook XMLRPC::BasicServer.get_service_hook()\n\n
process XMLRPC::BasicServer.process(data)\n\n
set_default_handler XMLRPC::BasicServer.set_default_handler(&handler)\n\n
set_service_hook XMLRPC::BasicServer.set_service_hook(&handler)\n\n
new XMLRPC::CGIServer.new(*a)\n\n
new XMLRPC::CGIServer.new(*a)\n\n
serve XMLRPC::CGIServer.serve()\n\n
new XMLRPC::ModRubyServer.new(*a)\n\n
serve XMLRPC::ModRubyServer.serve()\n\n
new XMLRPC::WEBrickServlet.new(*a)\n\n
get_instance XMLRPC::WEBrickServlet.get_instance(config, *options)\n\n
get_valid_ip XMLRPC::WEBrickServlet.get_valid_ip()\n\n
require_path_info? XMLRPC::WEBrickServlet.require_path_info?()\ndeprecated from WEBrick/1.2.2.\nbut does not break anything.\n
service XMLRPC::WEBrickServlet.service(request, response)\n\n
set_valid_ip XMLRPC::WEBrickServlet.set_valid_ip(*ip_addr)\n\n
new XMLRPC::Server.new(port=8080, host="127.0.0.1", maxConnections=4,\nstdlog=$stdout, audit=true, debug=true, *a)\n\n
serve XMLRPC::Server.serve()\n\n
shutdown XMLRPC::Server.shutdown()\n\n
new Rinda::Tuple.new(ary_or_hash)\nCreates a new Tuple from +ary_or_hash+ which must be an Array or Hash.\n
each Rinda::Tuple.each()\nIterate through the tuple, yielding the index or key, and the\nvalue, thus ensuring arrays are iterated similarly to hashes.\n
fetch Rinda::Tuple.fetch(k)\nFetches item +k+ from the tuple.\n
size Rinda::Tuple.size()\nThe number of elements in the tuple.\n
value Rinda::Tuple.value()\nReturn the tuple itself\n
match Rinda::Template.match(tuple)\nMatches this template against +tuple+.  The +tuple+ must be the same\nsize as the template.  An element with a +nil+ value in a template acts\nas a wildcard, matching any value in the corresponding position in the\ntuple.  Elements of the template match the +tuple+ if the are #== or\n===.\n\n  Template.new([:foo, 5]).match   Tuple.new([:foo, 5]) # => true\n  Template.new([:foo, nil]).match Tuple.new([:foo, 5]) # => true\n  Template.new([String]).match    Tuple.new(['hello']) # => true\n\n  Template.new([:foo]).match      Tuple.new([:foo, 5]) # => false\n  Template.new([:foo, 6]).match   Tuple.new([:foo, 5]) # => false\n  Template.new([:foo, nil]).match Tuple.new([:foo])    # => false\n  Template.new([:foo, 6]).match   Tuple.new([:foo])    # => false\n
new Rinda::DRbObjectTemplate.new(uri=nil, ref=nil)\nCreates a new DRbObjectTemplate that will match against +uri+ and +ref+.\n
new Rinda::TupleSpaceProxy.new(ts)\nCreates a new TupleSpaceProxy to wrap +ts+.\n
notify Rinda::TupleSpaceProxy.notify(ev, tuple, sec=nil)\nRegisters for notifications of event +ev+ on the proxied TupleSpace.\nSee TupleSpace#notify\n
read Rinda::TupleSpaceProxy.read(tuple, sec=nil, &block)\nReads +tuple+ from the proxied TupleSpace.  See TupleSpace#read.\n
read_all Rinda::TupleSpaceProxy.read_all(tuple)\nReads all tuples matching +tuple+ from the proxied TupleSpace.  See\nTupleSpace#read_all.\n
take Rinda::TupleSpaceProxy.take(tuple, sec=nil, &block)\nTakes +tuple+ from the proxied TupleSpace.  See TupleSpace#take.\n
write Rinda::TupleSpaceProxy.write(tuple, sec=nil)\nAdds +tuple+ to the proxied TupleSpace.  See TupleSpace#write.\n
new Rinda::SimpleRenewer.new(sec=180)\nCreates a new SimpleRenewer that keeps an object alive for another +sec+\nseconds.\n
renew Rinda::SimpleRenewer.renew()\nCalled by the TupleSpace to check if the object is still alive.\n
new Rinda::RingServer.new(ts, port=Ring_PORT)\nAdvertises +ts+ on the UDP broadcast address at +port+.\n
do_reply Rinda::RingServer.do_reply()\nPulls lookup tuples out of the TupleSpace and sends their DRb object the\naddress of the local TupleSpace.\n
do_write Rinda::RingServer.do_write(msg)\nExtracts the response URI from +msg+ and adds it to TupleSpace where it\nwill be picked up by +reply_service+ for notification.\n
reply_service Rinda::RingServer.reply_service()\nCreates a thread that notifies waiting clients from the TupleSpace.\n
write_service Rinda::RingServer.write_service()\nCreates a thread that picks up UDP packets and passes them to do_write\nfor decoding.\n
finger Rinda::RingFinger.finger()\nCreates a singleton RingFinger and looks for a RingServer.  Returns the\ncreated RingFinger.\n
new Rinda::RingFinger.new(broadcast_list=@@broadcast_list, port=Ring_PORT)\nCreates a new RingFinger that will look for RingServers at +port+ on\nthe addresses in +broadcast_list+.\n
primary Rinda::RingFinger.primary()\nReturns the first advertised TupleSpace.\n
to_a Rinda::RingFinger.to_a()\nContains all discovered TupleSpaces except for the primary.\n
each Rinda::RingFinger.each()\nIterates over all discovered TupleSpaces starting with the primary.\n
lookup_ring Rinda::RingFinger.lookup_ring(timeout=5, &block)\nLooks up RingServers waiting +timeout+ seconds.  RingServers will be\ngiven +block+ as a callback, which will be called with the remote\nTupleSpace.\n
lookup_ring_any Rinda::RingFinger.lookup_ring_any(timeout=5)\nReturns the first found remote TupleSpace.  Any further recovered\nTupleSpaces can be found by calling +to_a+.\n
to_a Rinda::RingFinger.to_a()\nContains all discovered TupleSpaces except for the primary.\n
new Rinda::RingProvider.new(klass, front, desc, renewer = nil)\nCreates a RingProvider that will provide a +klass+ service running on\n+front+, with a +description+.  +renewer+ is optional.\n
provide Rinda::RingProvider.provide()\nAdvertises this service on the primary remote TupleSpace.\n
new Rinda::TupleEntry.new(ary, sec=nil)\nCreates a TupleEntry based on +ary+ with an optional renewer or expiry\ntime +sec+.\n\nA renewer must implement the +renew+ method which returns a Numeric,\nnil, or true to indicate when the tuple has expired.\n
alive? Rinda::TupleEntry.alive?()\nA TupleEntry is dead when it is canceled or expired.\n
cancel Rinda::TupleEntry.cancel()\nMarks this TupleEntry as canceled.\n
canceled? Rinda::TupleEntry.canceled?()\nReturns the canceled status.\n
expired? Rinda::TupleEntry.expired?()\nHas this tuple expired? (true/false).\n\nA tuple has expired when its expiry timer based on the +sec+ argument to\ninitialize runs out.\n
fetch Rinda::TupleEntry.fetch(key)\nFetches +key+ from the tuple.\n
make_expires Rinda::TupleEntry.make_expires(sec=nil)\nReturns an expiry Time based on +sec+ which can be one of:\nNumeric:: +sec+ seconds into the future\n+true+::  the expiry time is the start of 1970 (i.e. expired)\n+nil+::   it is  Tue Jan 19 03:14:07 GMT Standard Time 2038 (i.e. when\n          UNIX clocks will die)\n
make_tuple Rinda::TupleEntry.make_tuple(ary)\nCreates a Rinda::Tuple for +ary+.\n
renew Rinda::TupleEntry.renew(sec_or_renewer)\nReset the expiry time according to +sec_or_renewer+.\n\n+nil+::    it is set to expire in the far future.\n+false+::  it has expired.\nNumeric::  it will expire in that many seconds.\n\nOtherwise the argument refers to some kind of renewer object\nwhich will reset its expiry time.\n
size Rinda::TupleEntry.size()\nThe size of the tuple.\n
value Rinda::TupleEntry.value()\nReturn the object which makes up the tuple itself: the Array\nor Hash.\n
match Rinda::TemplateEntry.match(tuple)\nMatches this TemplateEntry against +tuple+.  See Template#match for\ndetails on how a Template matches a Tuple.\n
new Rinda::WaitTemplateEntry.new(place, ary, expires=nil)\n\n
cancel Rinda::WaitTemplateEntry.cancel()\n\n
read Rinda::WaitTemplateEntry.read(tuple)\n\n
signal Rinda::WaitTemplateEntry.signal()\n\n
wait Rinda::WaitTemplateEntry.wait()\n\n
new Rinda::NotifyTemplateEntry.new(place, event, tuple, expires=nil)\nCreates a new NotifyTemplateEntry that watches +place+ for +event+s that\nmatch +tuple+.\n
each Rinda::NotifyTemplateEntry.each()\nYields event/tuple pairs until this NotifyTemplateEntry expires.\n
notify Rinda::NotifyTemplateEntry.notify(ev)\nCalled by TupleSpace to notify this NotifyTemplateEntry of a new event.\n
pop Rinda::NotifyTemplateEntry.pop()\nRetrieves a notification.  Raises RequestExpiredError when this\nNotifyTemplateEntry expires.\n
delete Rinda::TupleBag.delete(tuple)\nRemoves +tuple+ from the TupleBag.\n
delete_unless_alive Rinda::TupleBag.delete_unless_alive()\nDelete tuples which dead tuples from the TupleBag, returning the deleted\ntuples.\n
find Rinda::TupleBag.find(template)\nFinds a live tuple that matches +template+.\n
find_all Rinda::TupleBag.find_all(template)\nFinds all live tuples that match +template+.\n
find_all_template Rinda::TupleBag.find_all_template(tuple)\nFinds all tuples in the TupleBag which when treated as templates, match\n+tuple+ and are alive.\n
has_expires? Rinda::TupleBag.has_expires?()\n+true+ if the TupleBag to see if it has any expired entries.\n
push Rinda::TupleBag.push(tuple)\nAdd +tuple+ to the TupleBag.\n
new Rinda::TupleBag::TupleBin.new()\n\n
add Rinda::TupleBag::TupleBin.add(tuple)\n\n
delete Rinda::TupleBag::TupleBin.delete(tuple)\n\n
find Rinda::TupleBag::TupleBin.find(&blk)\n\n
new Rinda::TupleSpace.new(period=60)\nCreates a new TupleSpace.  +period+ is used to control how often to look\nfor dead tuples after modifications to the TupleSpace.\n\nIf no dead tuples are found +period+ seconds after the last\nmodification, the TupleSpace will stop looking for dead tuples.\n
move Rinda::TupleSpace.move(port, tuple, sec=nil)\nMoves +tuple+ to +port+.\n
notify Rinda::TupleSpace.notify(event, tuple, sec=nil)\nRegisters for notifications of +event+.  Returns a NotifyTemplateEntry.\nSee NotifyTemplateEntry for examples of how to listen for notifications.\n\n+event+ can be:\n'write'::  A tuple was added\n'take'::   A tuple was taken or moved\n'delete':: A tuple was lost after being overwritten or expiring\n\nThe TupleSpace will also notify you of the 'close' event when the\nNotifyTemplateEntry has expired.\n
read Rinda::TupleSpace.read(tuple, sec=nil)\nReads +tuple+, but does not remove it.\n
read_all Rinda::TupleSpace.read_all(tuple)\nReturns all tuples matching +tuple+.  Does not remove the found tuples.\n
take Rinda::TupleSpace.take(tuple, sec=nil, &block)\nRemoves +tuple+\n
write Rinda::TupleSpace.write(tuple, sec=nil)\nAdds +tuple+\n
instance Prime.instance()\nReturns the default instance of Prime.\n
new Prime.new()\nobsolete. Use +Prime+::+instance+ or class methods of +Prime+.\n
each Prime.each(ubound = nil, generator = EratosthenesGenerator.new, &block)\nIterates the given block over all prime numbers.\n\n== Parameters\n\n+ubound+::\n  Optional. An arbitrary positive number.\n  The upper bound of enumeration. The method enumerates\n  prime numbers infinitely if +ubound+ is nil.\n+generator+::\n  Optional. An implementation of pseudo-prime generator.\n\n== Return value\n\nAn evaluated value of the given block at the last time.\nOr an enumerator which is compatible to an +Enumerator+\nif no block given.\n\n== Description\n\nCalls +block+ once for each prime number, passing the prime as\na parameter.\n\n+ubound+::\n  Upper bound of prime numbers. The iterator stops after\n  yields all prime numbers p <= +ubound+.\n\n== Note\n\n+Prime+.+new+ returns a object extended by +Prime+::+OldCompatibility+\nin order to compatibility to Ruby 1.8, and +Prime+#each is overwritten\nby +Prime+::+OldCompatibility+#+each+.\n\n+Prime+.+new+ is now obsolete. Use +Prime+.+instance+.+each+ or simply\n+Prime+.+each+.\n
int_from_prime_division Prime.int_from_prime_division(pd)\nRe-composes a prime factorization and returns the product.\n\n== Parameters\n+pd+:: Array of pairs of integers. The each internal\n       pair consists of a prime number -- a prime factor --\n       and a natural number -- an exponent.\n\n== Example\nFor <tt>[[p_1, e_1], [p_2, e_2], ...., [p_n, e_n]]</tt>, it returns:\n\n  p_1**e_1 * p_2**e_2 * .... * p_n**e_n.\n\n  Prime.int_from_prime_division([[2,2], [3,1]])  #=> 12\n
prime? Prime.prime?(value, generator = Prime::Generator23.new)\nReturns true if +value+ is prime, false for a composite.\n\n== Parameters\n\n+value+:: an arbitrary integer to be checked.\n+generator+:: optional. A pseudo-prime generator.\n
prime_division Prime.prime_division(value, generator= Prime::Generator23.new)\nReturns the factorization of +value+.\n\n== Parameters\n+value+:: An arbitrary integer.\n+generator+:: Optional. A pseudo-prime generator.\n              +generator+.succ must return the next\n              pseudo-prime number in the ascendent\n              order. It must generate all prime numbers,\n              but may generate non prime numbers.\n\n=== Exceptions\n+ZeroDivisionError+:: when +value+ is zero.\n\n== Example\nFor an arbitrary integer:\n\n  n = p_1**e_1 * p_2**e_2 * .... * p_n**e_n,\n\nprime_division(n) returns:\n\n  [[p_1, e_1], [p_2, e_2], ...., [p_n, e_n]].\n\n  Prime.prime_division(12) #=> [[2,2], [3,1]]\n
new Prime::PseudoPrimeGenerator.new(ubound = nil)\n\n
each Prime::PseudoPrimeGenerator.each(&block)\nIterates the given block for each prime numbers.\n
next Prime::PseudoPrimeGenerator.next()\nalias of +succ+.\n
rewind Prime::PseudoPrimeGenerator.rewind()\nRewinds the internal position for enumeration.\n\nSee +Enumerator+#rewind.\n
succ Prime::PseudoPrimeGenerator.succ()\nreturns the next pseudo-prime number, and move the internal\nposition forward.\n\n+PseudoPrimeGenerator+#succ raises +NotImplementedError+.\n
upper_bound Prime::PseudoPrimeGenerator.upper_bound()\n\n
upper_bound= Prime::PseudoPrimeGenerator.upper_bound=(ubound)\n\n
with_object Prime::PseudoPrimeGenerator.with_object(obj)\nsee +Enumerator+#with_object.\n
new Prime::EratosthenesGenerator.new()\n\n
next Prime::EratosthenesGenerator.next()\n\n
rewind Prime::EratosthenesGenerator.rewind()\n\n
succ Prime::EratosthenesGenerator.succ()\n\n
new Prime::TrialDivisionGenerator.new()\n\n
next Prime::TrialDivisionGenerator.next()\n\n
rewind Prime::TrialDivisionGenerator.rewind()\n\n
succ Prime::TrialDivisionGenerator.succ()\n\n
new Prime::Generator23.new()\n\n
next Prime::Generator23.next()\n\n
rewind Prime::Generator23.rewind()\n\n
succ Prime::Generator23.succ()\n\n
cache Prime::TrialDivision.cache()\nReturns the cached prime numbers.\n
primes Prime::TrialDivision.primes()\n\n
primes_so_far Prime::TrialDivision.primes_so_far()\n\n
next_to Prime::EratosthenesSieve.next_to(n)\nreturns the least odd prime number which is greater than +n+.\n
new Set.new(enum = nil)\nCreates a new set containing the elements of the given enumerable\nobject.\n\nIf a block is given, the elements of enum are preprocessed by the\ngiven block.\n
add Set.add(o)\nAdds the given object to the set and returns self.  Use +merge+ to\nadd many elements at once.\n
add? Set.add?(o)\nAdds the given object to the set and returns self.  If the\nobject is already in the set, returns nil.\n
classify Set.classify()\nClassifies the set by the return value of the given block and\nreturns a hash of {value => set of elements} pairs.  The block is\ncalled once for each element of the set, passing the element as\nparameter.\n\ne.g.:\n\n  require 'set'\n  files = Set.new(Dir.glob("*.rb"))\n  hash = files.classify { |f| File.mtime(f).year }\n  p hash    # => {2000=>#<Set: {"a.rb", "b.rb"}>,\n     2001=>#<Set: {"c.rb", "d.rb", "e.rb"}>,\n     2002=>#<Set: {"f.rb"}>}\n
clear Set.clear()\nRemoves all elements and returns self.\n
collect! Set.collect!()\nReplaces the elements with ones returned by collect().\n
delete Set.delete(o)\nDeletes the given object from the set and returns self.  Use +subtract+ to\ndelete many items at once.\n
delete? Set.delete?(o)\nDeletes the given object from the set and returns self.  If the\nobject is not in the set, returns nil.\n
delete_if Set.delete_if()\nDeletes every element of the set for which block evaluates to\ntrue, and returns self.\n
difference Set.difference(enum)\n\n
divide Set.divide(&func)\nDivides the set into a set of subsets according to the commonality\ndefined by the given block.\n\nIf the arity of the block is 2, elements o1 and o2 are in common\nif block.call(o1, o2) is true.  Otherwise, elements o1 and o2 are\nin common if block.call(o1) == block.call(o2).\n\ne.g.:\n\n  require 'set'\n  numbers = Set[1, 3, 4, 6, 9, 10, 11]\n  set = numbers.divide { |i,j| (i - j).abs == 1 }\n  p set     # => #<Set: {#<Set: {1}>,\n            #<Set: {11, 9, 10}>,\n            #<Set: {3, 4}>,\n            #<Set: {6}>}>\n
each Set.each()\nCalls the given block once for each element in the set, passing\nthe element as parameter.  Returns an enumerator if no block is\ngiven.\n
empty? Set.empty?()\nReturns true if the set contains no elements.\n
flatten Set.flatten()\nReturns a new set that is a copy of the set, flattening each\ncontaining set recursively.\n
flatten! Set.flatten!()\nEquivalent to Set#flatten, but replaces the receiver with the\nresult in place.  Returns nil if no modifications were made.\n
include? Set.include?(o)\nReturns true if the set contains the given object.\n
initialize_copy Set.initialize_copy(orig)\nCopy internal hash.\n
inspect Set.inspect()\nReturns a string containing a human-readable representation of the\nset. ("#<Set: {element1, element2, ...}>")\n
intersection Set.intersection(enum)\n\n
keep_if Set.keep_if()\nDeletes every element of the set for which block evaluates to\nfalse, and returns self.\n
length Set.length()\n\n
map! Set.map!()\n\n
member? Set.member?(o)\n\n
merge Set.merge(enum)\nMerges the elements of the given enumerable object to the set and\nreturns self.\n
proper_subset? Set.proper_subset?(set)\nReturns true if the set is a proper subset of the given set.\n
proper_superset? Set.proper_superset?(set)\nReturns true if the set is a proper superset of the given set.\n
reject! Set.reject!()\nEquivalent to Set#delete_if, but returns nil if no changes were\nmade.\n
replace Set.replace(enum)\nReplaces the contents of the set with the contents of the given\nenumerable object and returns self.\n
select! Set.select!()\nEquivalent to Set#keep_if, but returns nil if no changes were\nmade.\n
size Set.size()\nReturns the number of elements.\n
subset? Set.subset?(set)\nReturns true if the set is a subset of the given set.\n
subtract Set.subtract(enum)\nDeletes every element that appears in the given enumerable object\nand returns self.\n
superset? Set.superset?(set)\nReturns true if the set is a superset of the given set.\n
to_a Set.to_a()\nConverts the set to an array.  The order of elements is uncertain.\n
union Set.union(enum)\n\n
new Tempfile.new(basename, *rest)\nCreates a temporary file with permissions 0600 (= only readable and\nwritable by the owner) and opens it with mode "w+".\n\nThe +basename+ parameter is used to determine the name of the\ntemporary file. You can either pass a String or an Array with\n2 String elements. In the former form, the temporary file's base\nname will begin with the given string. In the latter form,\nthe temporary file's base name will begin with the array's first\nelement, and end with the second element. For example:\n\n  file = Tempfile.new('hello')\n  file.path  # => something like: "/tmp/hello2843-8392-92849382--0"\n Use the Array form to enforce an extension in the filename:\n  file = Tempfile.new(['hello', '.jpg'])\n  file.path  # => something like: "/tmp/hello2843-8392-92849382--0.jpg"\n\nThe temporary file will be placed in the directory as specified\nby the +tmpdir+ parameter. By default, this is +Dir.tmpdir+.\nWhen $SAFE > 0 and the given +tmpdir+ is tainted, it uses\n'/tmp' as the temporary directory. Please note that ENV values\nare tainted by default, and +Dir.tmpdir+'s return value might\ncome from environment variables (e.g. <tt>$TMPDIR</tt>).\n\n  file = Tempfile.new('hello', '/home/aisaka')\n  file.path  # => something like: "/home/aisaka/hello2843-8392-92849382--0"\n\nYou can also pass an options hash. Under the hood, Tempfile creates\nthe temporary file using +File.open+. These options will be passed to\n+File.open+. This is mostly useful for specifying encoding\noptions, e.g.:\n\n  Tempfile.new('hello', '/home/aisaka', :encoding => 'ascii-8bit')\n You can also omit the 'tmpdir' parameter:\n  Tempfile.new('hello', :encoding => 'ascii-8bit')\n\n=== Exceptions\n\nIf Tempfile.new cannot find a unique filename within a limited\nnumber of tries, then it will raise an exception.\n
open Tempfile.open(*args)\nCreates a new Tempfile.\n\nIf no block is given, this is a synonym for Tempfile.new.\n\nIf a block is given, then a Tempfile object will be constructed,\nand the block is run with said object as argument. The Tempfile\noject will be automatically closed after the block terminates.\nThe call returns the value of the block.\n\nIn any case, all arguments (+*args+) will be passed to Tempfile.new.\n\n  Tempfile.open('foo', '/home/temp') do |f|\n     ... do something with f ...\n  end\n Equivalent:\n  f = Tempfile.open('foo', '/home/temp')\n  begin\n     ... do something with f ...\n  ensure\n     f.close\n  end\n
close Tempfile.close(unlink_now=false)\nCloses the file. If +unlink_now+ is true, then the file will be unlinked\n(deleted) after closing. Of course, you can choose to later call #unlink\nif you do not unlink it now.\n\nIf you don't explicitly unlink the temporary file, the removal\nwill be delayed until the object is finalized.\n
close! Tempfile.close!()\nCloses and unlinks (deletes) the file. Has the same effect as called\n<tt>close(true)</tt>.\n
delete Tempfile.delete()\n\n
length Tempfile.length()\n\n
open Tempfile.open()\nOpens or reopens the file with mode "r+".\n
path Tempfile.path()\nReturns the full path name of the temporary file.\nThis will be nil if #unlink has been called.\n
size Tempfile.size()\nReturns the size of the temporary file.  As a side effect, the IO\nbuffer is flushed before determining the size.\n
unlink Tempfile.unlink()\nUnlinks (deletes) the file from the filesystem. One should always unlink\nthe file after using it, as is explained in the "Explicit close" good\npractice section in the Tempfile overview:\n\n  file = Tempfile.new('foo')\n  begin\n     ...do something with file...\n  ensure\n     file.close\n     file.unlink   # deletes the temp file\n  end\n\n=== Unlink-before-close\n\nOn POSIX systems it's possible to unlink a file before closing it. This\npractice is explained in detail in the Tempfile overview (section\n"Unlink after creation"); please refer there for more information.\n\nHowever, unlink-before-close may not be supported on non-POSIX operating\nsystems. Microsoft Windows is the most notable case: unlinking a non-closed\nfile will result in an error, which this method will silently ignore. If\nyou want to practice unlink-before-close whenever possible, then you should\nwrite code like this:\n\n  file = Tempfile.new('foo')\n  file.unlink   # On Windows this silently fails.\n  begin\n     ... do something with file ...\n  ensure\n     file.close!   # Closes the file handle. If the file wasn't unlinked\n because #unlink failed, then this method will attempt\n to do so again.\n  end\n
new PStore.new(file, thread_safe = false)\nTo construct a PStore object, pass in the _file_ path where you would like\nthe data to be stored.\n\nPStore objects are always reentrant. But if _thread_safe_ is set to true,\nthen it will become thread-safe at the cost of a minor performance hit.\n
abort PStore.abort()\nEnds the current PStore#transaction, discarding any changes to the data\nstore.\n\n== Example:\n\n require "pstore"\n\n store = PStore.new("data_file.pstore")\n store.transaction do  # begin transaction\n   store[:one] = 1     # this change is not applied, see below...\n   store[:two] = 2     # this change is not applied, see below...\n\n   store.abort         # end transaction here, discard all changes\n\n   store[:three] = 3   # this change is never reached\n end\n\n*WARNING*:  This method is only valid in a PStore#transaction.  It will\nraise PStore::Error if called at any other time.\n
commit PStore.commit()\nEnds the current PStore#transaction, committing any changes to the data\nstore immediately.\n\n== Example:\n\n require "pstore"\n\n store = PStore.new("data_file.pstore")\n store.transaction do  # begin transaction\n load some data into the store...\n   store[:one] = 1\n   store[:two] = 2\n\n   store.commit        # end transaction here, committing changes\n\n   store[:three] = 3   # this change is never reached\n end\n\n*WARNING*:  This method is only valid in a PStore#transaction.  It will\nraise PStore::Error if called at any other time.\n
delete PStore.delete(name)\nRemoves an object hierarchy from the data store, by _name_.\n\n*WARNING*:  This method is only valid in a PStore#transaction and it cannot\nbe read-only.  It will raise PStore::Error if called at any other time.\n
fetch PStore.fetch(name, default=PStore::Error)\nThis method is just like PStore#[], save that you may also provide a\n_default_ value for the object.  In the event the specified _name_ is not\nfound in the data store, your _default_ will be returned instead.  If you do\nnot specify a default, PStore::Error will be raised if the object is not\nfound.\n\n*WARNING*:  This method is only valid in a PStore#transaction.  It will\nraise PStore::Error if called at any other time.\n
path PStore.path()\nReturns the path to the data store file.\n
root? PStore.root?(name)\nReturns true if the supplied _name_ is currently in the data store.\n\n*WARNING*:  This method is only valid in a PStore#transaction.  It will\nraise PStore::Error if called at any other time.\n
roots PStore.roots()\nReturns the names of all object hierarchies currently in the store.\n\n*WARNING*:  This method is only valid in a PStore#transaction.  It will\nraise PStore::Error if called at any other time.\n
transaction PStore.transaction(read_only = false)\nOpens a new transaction for the data store.  Code executed inside a block\npassed to this method may read and write data to and from the data store\nfile.\n\nAt the end of the block, changes are committed to the data store\nautomatically.  You may exit the transaction early with a call to either\nPStore#commit or PStore#abort.  See those methods for details about how\nchanges are handled.  Raising an uncaught Exception in the block is\nequivalent to calling PStore#abort.\n\nIf _read_only_ is set to +true+, you will only be allowed to read from the\ndata store during the transaction and any attempts to change the data will\nraise a PStore::Error.\n\nNote that PStore does not support nested transactions.\n
add_filter Tracer.add_filter(p = proc)\nUsed to filter unwanted trace output\n\nExample which only outputs lines of code executed within the Kernel class:\n\n  Tracer.add_filter do |event, file, line, id, binding, klass, *rest|\n    "Kernel" == klass.to_s\n  end\n
off Tracer.off()\nDisable tracing\n
on Tracer.on()\nStart tracing\n\n=== Example\n\n  Tracer.on\n code to trace here\n  Tracer.off\n\nYou can also pass a block:\n\n  Tracer.on {\n trace everything in this block\n  }\n
set_get_line_procs Tracer.set_get_line_procs(file_name, p = proc)\nRegister an event handler `p` which is called everytime a line\nin +file_name+ is executed.\n\nExample:\n\n  Tracer.set_get_line_procs("example.rb", lambda { |line|\n    puts "line number executed is #{line}"\n  })\n
trace_func Tracer.trace_func(*vars)\n\n
break_points DEBUGGER__.break_points()\n\n
context DEBUGGER__.context(thread=Thread.current)\n\n
debug_thread_info DEBUGGER__.debug_thread_info(input, binding)\n\n
display DEBUGGER__.display()\n\n
get_thread DEBUGGER__.get_thread(num)\n\n
interrupt DEBUGGER__.interrupt()\n\n
make_thread_list DEBUGGER__.make_thread_list()\n\n
resume DEBUGGER__.resume()\n\n
set_last_thread DEBUGGER__.set_last_thread(th)\n\n
set_trace DEBUGGER__.set_trace( arg )\n\n
stdout DEBUGGER__.stdout()\n\n
stdout= DEBUGGER__.stdout=(s)\n\n
suspend DEBUGGER__.suspend()\n\n
thread_list DEBUGGER__.thread_list(num)\n\n
thread_list_all DEBUGGER__.thread_list_all()\n\n
waiting DEBUGGER__.waiting()\n\n
break_points DEBUGGER__.break_points()\n\n
check_break_points DEBUGGER__.check_break_points(file, klass, pos, binding, id)\n\n
context DEBUGGER__.context(th)\n\n
debug_command DEBUGGER__.debug_command(file, line, id, binding)\n\n
debug_eval DEBUGGER__.debug_eval(str, binding)\n\n
debug_funcname DEBUGGER__.debug_funcname(id)\n\n
debug_method_info DEBUGGER__.debug_method_info(input, binding)\n\n
debug_print_help DEBUGGER__.debug_print_help()\n\n
debug_silent_eval DEBUGGER__.debug_silent_eval(str, binding)\n\n
debug_variable_info DEBUGGER__.debug_variable_info(input, binding)\n\n
display DEBUGGER__.display()\n\n
display_expression DEBUGGER__.display_expression(exp, binding)\n\n
display_expressions DEBUGGER__.display_expressions(binding)\n\n
display_frames DEBUGGER__.display_frames(pos)\n\n
display_list DEBUGGER__.display_list(b, e, file, line)\n\n
excn_handle DEBUGGER__.excn_handle(file, line, id, binding)\n\n
format_frame DEBUGGER__.format_frame(pos)\n\n
frame_set_pos DEBUGGER__.frame_set_pos(file, line)\n\n
line_at DEBUGGER__.line_at(file, line)\n\n
set_last_thread DEBUGGER__.set_last_thread(th)\n\n
set_trace DEBUGGER__.set_trace(arg)\n\n
set_trace_all DEBUGGER__.set_trace_all(arg)\n\n
stdout DEBUGGER__.stdout()\n\n
thnum DEBUGGER__.thnum()\n\n
trace? DEBUGGER__.trace?()\n\n
trace_func DEBUGGER__.trace_func(event, file, line, id, binding, klass)\n\n
var_list DEBUGGER__.var_list(ary, binding)\n\n
new DEBUGGER__::Context.new()\n\n
check_suspend DEBUGGER__::Context.check_suspend()\n\n
clear_suspend DEBUGGER__::Context.clear_suspend()\n\n
readline DEBUGGER__::Context.readline(prompt, hist)\n\n
resume_all DEBUGGER__::Context.resume_all()\n\n
set_suspend DEBUGGER__::Context.set_suspend()\n\n
stop_next DEBUGGER__::Context.stop_next(n=1)\n\n
suspend_all DEBUGGER__::Context.suspend_all()\n\n
new RSS::XML::Element.new(name, prefix=nil, uri=nil, attributes={}, children=[])\n\n
each RSS::XML::Element.each(&block)\n\n
full_name RSS::XML::Element.full_name()\n\n
to_s RSS::XML::Element.to_s()\n\n
new RSS::RDF.new(version=nil, encoding=nil, standalone=nil)\n\n
required_uri RSS::RDF.required_uri()\n\n
full_name RSS::RDF.full_name()\n\n
new RSS::RDF::Item.new(*args)\n\n
required_uri RSS::RDF::Item.required_uri()\n\n
new RSS::RDF::Channel.new(*args)\n\n
required_uri RSS::RDF::Channel.required_uri()\n\n
new RSS::RDF::Image.new(*args)\n\n
required_uri RSS::RDF::Image.required_uri()\n\n
new RSS::RDF::Textinput.new(*args)\n\n
required_uri RSS::RDF::Textinput.required_uri()\n\n
new RSS::Atom::Feed.new(version=nil, encoding=nil, standalone=nil)\n\n
have_author? RSS::Atom::Feed.have_author?()\n\n
have_author? RSS::Atom::Feed::Entry.have_author?(check_parent=true)\n\n
new RSS::Atom::Entry.new(version=nil, encoding=nil, standalone=nil)\n\n
have_author? RSS::Atom::Entry.have_author?()\n\n
items RSS::Atom::Entry.items()\n\n
setup_maker RSS::Atom::Entry.setup_maker(maker)\n\n
new RSS::Rss.new(feed_version, version=nil, encoding=nil, standalone=nil)\n\n
image RSS::Rss.image()\n\n
items RSS::Rss.items()\n\n
setup_maker_elements RSS::Rss.setup_maker_elements(maker)\n\n
textinput RSS::Rss.textinput()\n\n
new RSS::XMLStyleSheet.new(*attrs)\n\n
alternate= RSS::XMLStyleSheet.alternate=(value)\n\n
href= RSS::XMLStyleSheet.href=(value)\n\n
setup_maker RSS::XMLStyleSheet.setup_maker(maker)\n\n
to_s RSS::XMLStyleSheet.to_s()\n\n
new RSS::RDF::Li.new(*args)\n\n
required_uri RSS::RDF::Li.required_uri()\n\n
full_name RSS::RDF::Li.full_name()\n\n
new RSS::RDF::Seq.new(*args)\n\n
required_uri RSS::RDF::Seq.required_uri()\n\n
full_name RSS::RDF::Seq.full_name()\n\n
setup_maker RSS::RDF::Seq.setup_maker(target)\n\n
new RSS::RDF::Seq::Li.new(*args)\n\n
required_uri RSS::RDF::Seq::Li.required_uri()\n\n
full_name RSS::RDF::Seq::Li.full_name()\n\n
new RSS::RDF::Bag.new(*args)\n\n
required_uri RSS::RDF::Bag.required_uri()\n\n
full_name RSS::RDF::Bag.full_name()\n\n
setup_maker RSS::RDF::Bag.setup_maker(target)\n\n
new RSS::RDF::Bag::Li.new(*args)\n\n
required_uri RSS::RDF::Bag::Li.required_uri()\n\n
full_name RSS::RDF::Bag::Li.full_name()\n\n
new RSS::RDF::Channel::Image.new(*args)\n\n
required_uri RSS::RDF::Channel::Image.required_uri()\n\n
new RSS::RDF::Channel::Textinput.new(*args)\n\n
required_uri RSS::RDF::Channel::Textinput.required_uri()\n\n
new RSS::RDF::Channel::Items.new(*args)\n\n
required_uri RSS::RDF::Channel::Items.required_uri()\n\n
resources RSS::RDF::Channel::Items.resources()\n\n
new RSS::RDF::Channel::Items::Seq.new(*args)\n\n
required_uri RSS::RDF::Channel::Items::Seq.required_uri()\n\n
full_name RSS::RDF::Channel::Items::Seq.full_name()\n\n
setup_maker RSS::RDF::Channel::Items::Seq.setup_maker(target)\n\n
new RSS::Maker::ItemsBase.new(maker)\n\n
normalize RSS::Maker::ItemsBase.normalize()\n\n
date= RSS::Maker::ItemsBase::ItemBase.date=(_date)\n\n
pubDate RSS::Maker::ItemsBase::ItemBase.pubDate()\n\n
pubDate= RSS::Maker::ItemsBase::ItemBase.pubDate=(date)\n\n
updated RSS::Maker::ItemsBase::ItemBase.updated()\n\n
updated= RSS::Maker::ItemsBase::ItemBase.updated=(date)\n\n
date= RSS::Maker::ChannelBase.date=(_date)\n\n
icon RSS::Maker::ChannelBase.icon()\n\n
icon= RSS::Maker::ChannelBase.icon=(url)\n\n
lastBuildDate= RSS::Maker::ChannelBase.lastBuildDate=(_date)\n\n
logo RSS::Maker::ChannelBase.logo()\n\n
logo= RSS::Maker::ChannelBase.logo=(url)\n\n
pubDate RSS::Maker::ChannelBase.pubDate()\n\n
pubDate= RSS::Maker::ChannelBase.pubDate=(date)\n\n
updated RSS::Maker::ChannelBase.updated()\n\n
updated= RSS::Maker::ChannelBase.updated=(date)\n\n
new RSS::Maker::Atom::Feed.new(feed_version="1.0")\n\n
have_required_values? RSS::Maker::Atom::Feed::Channel.have_required_values?()\n\n
to_feed RSS::Maker::Atom::Feed::Channel.to_feed(feed)\n\n
to_feed RSS::Maker::Atom::Feed::Channel::SkipDays.to_feed(*args)\n\n
to_feed RSS::Maker::Atom::Feed::Channel::SkipHours.to_feed(*args)\n\n
to_feed RSS::Maker::Atom::Feed::Channel::Cloud.to_feed(*args)\n\n
not_set_name RSS::Maker::Atom::Feed::Channel::Categories::Category.not_set_name()\n\n
not_set_name RSS::Maker::Atom::Feed::Channel::Links::Link.not_set_name()\n\n
not_set_name RSS::Maker::Atom::Feed::Channel::Generator.not_set_name()\n\n
to_feed RSS::Maker::Atom::Feed::Image.to_feed(feed)\n\n
to_feed RSS::Maker::Atom::Feed::Items.to_feed(feed)\n\n
have_required_values? RSS::Maker::Atom::Feed::Items::Item.have_required_values?()\n\n
to_feed RSS::Maker::Atom::Feed::Items::Item.to_feed(feed)\n\n
to_feed RSS::Maker::Atom::Feed::Items::Item::Guid.to_feed(feed, current)\n\n
to_feed RSS::Maker::Atom::Feed::Items::Item::Enclosure.to_feed(feed, current)\n\n
to_feed RSS::Maker::Atom::Feed::Items::Item::Source.to_feed(feed, current)\n\n
not_set_name RSS::Maker::Atom::Feed::Items::Item::Source::Categories::Category.not_set_name()\n\n
not_set_name RSS::Maker::Atom::Feed::Items::Item::Source::Generator.not_set_name()\n\n
to_feed RSS::Maker::Atom::Feed::Items::Item::Source::Icon.to_feed(feed, current)\n\n
not_set_name RSS::Maker::Atom::Feed::Items::Item::Source::Links::Link.not_set_name()\n\n
not_set_name RSS::Maker::Atom::Feed::Items::Item::Source::Logo.not_set_name()\n\n
not_set_name RSS::Maker::Atom::Feed::Items::Item::Categories::Category.not_set_name()\n\n
not_set_name RSS::Maker::Atom::Feed::Items::Item::Links::Link.not_set_name()\n\n
to_feed RSS::Maker::Atom::Feed::Items::Item::Content.to_feed(feed, current)\n\n
new RSS::Maker::Atom::Entry.new(feed_version="1.0")\n\n
not_set_name RSS::Maker::Atom::Entry::Channel::Generator.not_set_name()\n\n
to_feed RSS::Maker::Atom::Entry::Items.to_feed(entry)\n\n
to_feed RSS::Maker::Atom::Entry::Items::Item.to_feed(entry)\n\n
new RSS::Maker::RSS10.new(feed_version="1.0")\n\n
to_feed RSS::Maker::RSS10::Channel.to_feed(rss)\n\n
to_feed RSS::Maker::RSS10::Channel::SkipDays.to_feed(*args)\n\n
to_feed RSS::Maker::RSS10::Channel::SkipHours.to_feed(*args)\n\n
to_feed RSS::Maker::RSS10::Channel::Cloud.to_feed(*args)\n\n
to_feed RSS::Maker::RSS10::Channel::Categories.to_feed(*args)\n\n
to_feed RSS::Maker::RSS10::Channel::Links.to_feed(rss, channel)\n\n
to_feed RSS::Maker::RSS10::Channel::Links::Link.to_feed(rss, channel)\n\n
to_feed RSS::Maker::RSS10::Channel::Authors.to_feed(rss, channel)\n\n
to_feed RSS::Maker::RSS10::Channel::Authors::Author.to_feed(rss, channel)\n\n
to_feed RSS::Maker::RSS10::Channel::Contributors.to_feed(rss, channel)\n\n
to_feed RSS::Maker::RSS10::Channel::Generator.to_feed(rss, channel)\n\n
to_feed RSS::Maker::RSS10::Channel::Copyright.to_feed(rss, channel)\n\n
to_feed RSS::Maker::RSS10::Channel::Description.to_feed(rss, channel)\n\n
to_feed RSS::Maker::RSS10::Channel::Title.to_feed(rss, channel)\n\n
have_required_values? RSS::Maker::RSS10::Image.have_required_values?()\n\n
to_feed RSS::Maker::RSS10::Image.to_feed(rss)\n\n
to_feed RSS::Maker::RSS10::Items.to_feed(rss)\n\n
to_feed RSS::Maker::RSS10::Items::Item.to_feed(rss)\n\n
to_feed RSS::Maker::RSS10::Items::Item::Guid.to_feed(*args)\n\n
to_feed RSS::Maker::RSS10::Items::Item::Enclosure.to_feed(*args)\n\n
to_feed RSS::Maker::RSS10::Items::Item::Source.to_feed(*args)\n\n
to_feed RSS::Maker::RSS10::Items::Item::Source::Authors.to_feed(*args)\n\n
to_feed RSS::Maker::RSS10::Items::Item::Source::Categories.to_feed(*args)\n\n
to_feed RSS::Maker::RSS10::Items::Item::Source::Contributors.to_feed(*args)\n\n
to_feed RSS::Maker::RSS10::Items::Item::Source::Generator.to_feed(*args)\n\n
to_feed RSS::Maker::RSS10::Items::Item::Source::Icon.to_feed(*args)\n\n
to_feed RSS::Maker::RSS10::Items::Item::Source::Links.to_feed(*args)\n\n
to_feed RSS::Maker::RSS10::Items::Item::Source::Logo.to_feed(*args)\n\n
to_feed RSS::Maker::RSS10::Items::Item::Source::Rights.to_feed(*args)\n\n
to_feed RSS::Maker::RSS10::Items::Item::Source::Subtitle.to_feed(*args)\n\n
to_feed RSS::Maker::RSS10::Items::Item::Source::Title.to_feed(*args)\n\n
to_feed RSS::Maker::RSS10::Items::Item::Categories.to_feed(*args)\n\n
to_feed RSS::Maker::RSS10::Items::Item::Authors.to_feed(*args)\n\n
to_feed RSS::Maker::RSS10::Items::Item::Links.to_feed(*args)\n\n
to_feed RSS::Maker::RSS10::Items::Item::Contributors.to_feed(rss, item)\n\n
to_feed RSS::Maker::RSS10::Items::Item::Rights.to_feed(rss, item)\n\n
to_feed RSS::Maker::RSS10::Items::Item::Description.to_feed(rss, item)\n\n
to_feed RSS::Maker::RSS10::Items::Item::Content.to_feed(rss, item)\n\n
to_feed RSS::Maker::RSS10::Items::Item::Title.to_feed(rss, item)\n\n
have_required_values? RSS::Maker::RSS10::Textinput.have_required_values?()\n\n
to_feed RSS::Maker::RSS10::Textinput.to_feed(rss)\n\n
add_need_initialize_variable RSS::Maker::Base.add_need_initialize_variable(variable_name, init_value=nil,\n&init_block)\n\n
add_other_element RSS::Maker::Base.add_other_element(variable_name)\n\n
def_array_element RSS::Maker::Base.def_array_element(name, plural=nil, klass_name=nil)\n\n
def_classed_element RSS::Maker::Base.def_classed_element(name, class_name=nil, attribute_name=nil)\n\n
def_classed_element_without_accessor RSS::Maker::Base.def_classed_element_without_accessor(name, class_name=nil)\n\n
def_classed_elements RSS::Maker::Base.def_classed_elements(name, attribute, plural_class_name=nil,\nplural_name=nil, new_name=nil)\n\n
def_csv_element RSS::Maker::Base.def_csv_element(name, type=nil)\n\n
def_other_element RSS::Maker::Base.def_other_element(name)\n\n
def_other_element_without_accessor RSS::Maker::Base.def_other_element_without_accessor(name)\n\n
inherited RSS::Maker::Base.inherited(subclass)\n\n
inherited_base RSS::Maker::Base.inherited_base()\n\n
need_initialize_variables RSS::Maker::Base.need_initialize_variables()\n\n
new RSS::Maker::Base.new(maker)\n\n
other_elements RSS::Maker::Base.other_elements()\n\n
have_required_values? RSS::Maker::Base.have_required_values?()\n\n
variable_is_set? RSS::Maker::Base.variable_is_set?()\n\n
make RSS::Maker::RSSBase.make(*args, &block)\n\n
new RSS::Maker::RSSBase.new(feed_version)\n\n
make RSS::Maker::RSSBase.make()\n\n
to_feed RSS::Maker::RSSBase.to_feed()\n\n
to_feed RSS::Maker::XMLStyleSheets::XMLStyleSheet.to_feed(feed)\n\n
link RSS::Maker::ImageBase.link()\n\n
permanent_link= RSS::Maker::ItemsBase::ItemBase::GuidBase.permanent_link=(bool)\n\n
permanent_link? RSS::Maker::ItemsBase::ItemBase::GuidBase.permanent_link?()\n\n
date= RSS::Maker::ItemsBase::ItemBase::SourceBase.date=(_date)\n\n
updated RSS::Maker::ItemsBase::ItemBase::SourceBase.updated()\n\n
updated= RSS::Maker::ItemsBase::ItemBase::SourceBase.updated=(date)\n\n
inline_html? RSS::Maker::ItemsBase::ItemBase::ContentBase.inline_html?()\n\n
inline_other? RSS::Maker::ItemsBase::ItemBase::ContentBase.inline_other?()\n\n
inline_other_base64? RSS::Maker::ItemsBase::ItemBase::ContentBase.inline_other_base64?()\n\n
inline_other_text? RSS::Maker::ItemsBase::ItemBase::ContentBase.inline_other_text?()\n\n
inline_other_xml? RSS::Maker::ItemsBase::ItemBase::ContentBase.inline_other_xml?()\n\n
inline_text? RSS::Maker::ItemsBase::ItemBase::ContentBase.inline_text?()\n\n
inline_xhtml? RSS::Maker::ItemsBase::ItemBase::ContentBase.inline_xhtml?()\n\n
out_of_line? RSS::Maker::ItemsBase::ItemBase::ContentBase.out_of_line?()\n\n
xml= RSS::Maker::ItemsBase::ItemBase::ContentBase.xml=(content)\n\n
xml_content= RSS::Maker::ItemsBase::ItemBase::ContentBase.xml_content=(content)\n\n
new RSS::Maker::RSS09.new(feed_version)\n\n
to_feed RSS::Maker::RSS09::Channel.to_feed(rss)\n\n
to_feed RSS::Maker::RSS09::Channel::SkipDays.to_feed(rss, channel)\n\n
to_feed RSS::Maker::RSS09::Channel::SkipDays::Day.to_feed(rss, days)\n\n
to_feed RSS::Maker::RSS09::Channel::SkipHours.to_feed(rss, channel)\n\n
to_feed RSS::Maker::RSS09::Channel::SkipHours::Hour.to_feed(rss, hours)\n\n
to_feed RSS::Maker::RSS09::Channel::Cloud.to_feed(*args)\n\n
to_feed RSS::Maker::RSS09::Channel::Categories.to_feed(*args)\n\n
to_feed RSS::Maker::RSS09::Channel::Links.to_feed(rss, channel)\n\n
to_feed RSS::Maker::RSS09::Channel::Links::Link.to_feed(rss, channel)\n\n
to_feed RSS::Maker::RSS09::Channel::Authors.to_feed(rss, channel)\n\n
to_feed RSS::Maker::RSS09::Channel::Authors::Author.to_feed(rss, channel)\n\n
to_feed RSS::Maker::RSS09::Channel::Contributors.to_feed(rss, channel)\n\n
to_feed RSS::Maker::RSS09::Channel::Generator.to_feed(rss, channel)\n\n
to_feed RSS::Maker::RSS09::Channel::Copyright.to_feed(rss, channel)\n\n
to_feed RSS::Maker::RSS09::Channel::Description.to_feed(rss, channel)\n\n
to_feed RSS::Maker::RSS09::Channel::Title.to_feed(rss, channel)\n\n
to_feed RSS::Maker::RSS09::Image.to_feed(rss)\n\n
to_feed RSS::Maker::RSS09::Items.to_feed(rss)\n\n
to_feed RSS::Maker::RSS09::Items::Item.to_feed(rss)\n\n
to_feed RSS::Maker::RSS09::Items::Item::Guid.to_feed(*args)\n\n
to_feed RSS::Maker::RSS09::Items::Item::Enclosure.to_feed(*args)\n\n
to_feed RSS::Maker::RSS09::Items::Item::Source.to_feed(*args)\n\n
to_feed RSS::Maker::RSS09::Items::Item::Source::Authors.to_feed(*args)\n\n
to_feed RSS::Maker::RSS09::Items::Item::Source::Categories.to_feed(*args)\n\n
to_feed RSS::Maker::RSS09::Items::Item::Source::Contributors.to_feed(*args)\n\n
to_feed RSS::Maker::RSS09::Items::Item::Source::Generator.to_feed(*args)\n\n
to_feed RSS::Maker::RSS09::Items::Item::Source::Icon.to_feed(*args)\n\n
to_feed RSS::Maker::RSS09::Items::Item::Source::Links.to_feed(*args)\n\n
to_feed RSS::Maker::RSS09::Items::Item::Source::Logo.to_feed(*args)\n\n
to_feed RSS::Maker::RSS09::Items::Item::Source::Rights.to_feed(*args)\n\n
to_feed RSS::Maker::RSS09::Items::Item::Source::Subtitle.to_feed(*args)\n\n
to_feed RSS::Maker::RSS09::Items::Item::Source::Title.to_feed(*args)\n\n
to_feed RSS::Maker::RSS09::Items::Item::Categories.to_feed(*args)\n\n
to_feed RSS::Maker::RSS09::Items::Item::Authors.to_feed(*args)\n\n
to_feed RSS::Maker::RSS09::Items::Item::Links.to_feed(rss, item)\n\n
to_feed RSS::Maker::RSS09::Items::Item::Links::Link.to_feed(rss, item)\n\n
to_feed RSS::Maker::RSS09::Items::Item::Contributors.to_feed(rss, item)\n\n
to_feed RSS::Maker::RSS09::Items::Item::Rights.to_feed(rss, item)\n\n
to_feed RSS::Maker::RSS09::Items::Item::Description.to_feed(rss, item)\n\n
to_feed RSS::Maker::RSS09::Items::Item::Content.to_feed(rss, item)\n\n
to_feed RSS::Maker::RSS09::Items::Item::Title.to_feed(rss, item)\n\n
to_feed RSS::Maker::RSS09::Textinput.to_feed(rss)\n\n
new RSS::Maker::RSS091.new(feed_version="0.91")\n\n
new RSS::Maker::RSS092.new(feed_version="0.92")\n\n
have_required_values? RSS::Maker::TrackBackModel::TrackBackAboutsBase::TrackBackAboutBase.have_required_values?()\n\n
to_feed RSS::Maker::TrackBackModel::TrackBackAboutsBase::TrackBackAboutBase.to_feed(feed,\ncurrent)\n\n
new RSS::Maker::RSS20.new(feed_version="2.0")\n\n
to_feed RSS::Maker::RSS20::Channel::Cloud.to_feed(rss, channel)\n\n
to_feed RSS::Maker::RSS20::Channel::Categories.to_feed(rss, channel)\n\n
to_feed RSS::Maker::RSS20::Channel::Categories::Category.to_feed(rss, channel)\n\n
to_feed RSS::Maker::RSS20::Channel::Generator.to_feed(rss, channel)\n\n
to_feed RSS::Maker::RSS20::Items::Item::Guid.to_feed(rss, item)\n\n
to_feed RSS::Maker::RSS20::Items::Item::Enclosure.to_feed(rss, item)\n\n
to_feed RSS::Maker::RSS20::Items::Item::Source.to_feed(rss, item)\n\n
to_feed RSS::Maker::RSS20::Items::Item::Source::Links.to_feed(rss, source)\n\n
to_feed RSS::Maker::RSS20::Items::Item::Source::Links::Link.to_feed(rss, source)\n\n
to_feed RSS::Maker::RSS20::Items::Item::Categories.to_feed(rss, item)\n\n
to_feed RSS::Maker::RSS20::Items::Item::Categories::Category.to_feed(rss, item)\n\n
to_feed RSS::Maker::RSS20::Items::Item::Authors.to_feed(rss, item)\n\n
to_feed RSS::Maker::RSS20::Items::Item::Authors::Author.to_feed(rss, item)\n\n
have_required_values? RSS::Maker::ITunesChannelModel::ITunesCategoriesBase::ITunesCategoryBase.have_required_values?()\n\n
to_feed RSS::Maker::ITunesChannelModel::ITunesCategoriesBase::ITunesCategoryBase.to_feed(feed,\ncurrent)\n\n
to_feed_for_categories RSS::Maker::ITunesChannelModel::ITunesCategoriesBase::ITunesCategoryBase.to_feed_for_categories(feed,\ncurrent)\n\n
to_feed RSS::Maker::ITunesChannelModel::ITunesImageBase.to_feed(feed, current)\n\n
to_feed RSS::Maker::ITunesChannelModel::ITunesOwnerBase.to_feed(feed, current)\n\n
content= RSS::Maker::ITunesItemModel::ITunesDurationBase.content=(content)\n\n
hour= RSS::Maker::ITunesItemModel::ITunesDurationBase.hour=(hour)\n\n
minute= RSS::Maker::ITunesItemModel::ITunesDurationBase.minute=(minute)\n\n
second= RSS::Maker::ITunesItemModel::ITunesDurationBase.second=(second)\n\n
to_feed RSS::Maker::ITunesItemModel::ITunesDurationBase.to_feed(feed, current)\n\n
have_required_values? RSS::Maker::ImageItemModel::ImageItemBase.have_required_values?()\n\n
to_feed RSS::Maker::ImageItemModel::ImageItemBase.to_feed(feed, current)\n\n
have_required_values? RSS::Maker::ImageFaviconModel::ImageFaviconBase.have_required_values?()\n\n
to_feed RSS::Maker::ImageFaviconModel::ImageFaviconBase.to_feed(feed, current)\n\n
have_required_values? RSS::Maker::TaxonomyTopicModel::TaxonomyTopicsBase::TaxonomyTopicBase.have_required_values?()\n\n
new RSS::OverlappedPrefixError.new(prefix)\n\n
new RSS::MissingTagError.new(tag, parent)\n\n
new RSS::TooMuchTagError.new(tag, parent)\n\n
new RSS::MissingAttributeError.new(tag, attribute)\n\n
new RSS::UnknownTagError.new(tag, uri)\n\n
new RSS::NotExpectedTagError.new(tag, uri, parent)\n\n
new RSS::NotExceptedTagError.new(tag, uri, parent)\n\n
new RSS::NotAvailableValueError.new(tag, value, attribute=nil)\n\n
new RSS::UnknownConversionMethodError.new(to, from)\n\n
new RSS::UnknownConvertMethod.new(to, from)\n\n
new RSS::ConversionError.new(string, to, from)\n\n
new RSS::NotSetError.new(name, variables)\n\n
new RSS::UnsupportedMakerVersionError.new(version)\n\n
add_have_children_element RSS::Element.add_have_children_element(variable_name, plural_name)\n\n
add_need_initialize_variable RSS::Element.add_need_initialize_variable(variable_name)\n\n
add_plural_form RSS::Element.add_plural_form(singular, plural)\n\n
add_to_element_method RSS::Element.add_to_element_method(method_name)\n\n
content_setup RSS::Element.content_setup(type=nil, disp_name=nil)\n\n
def_corresponded_attr_reader RSS::Element.def_corresponded_attr_reader(name, type=nil)\n\n
def_corresponded_attr_writer RSS::Element.def_corresponded_attr_writer(name, type=nil, disp_name=nil)\n\n
get_attributes RSS::Element.get_attributes()\n\n
have_children_elements RSS::Element.have_children_elements()\n\n
have_content? RSS::Element.have_content?()\n\n
inherited RSS::Element.inherited(klass)\n\n
inherited_base RSS::Element.inherited_base()\n\n
install_get_attribute RSS::Element.install_get_attribute(name, uri, required=true, type=nil,\ndisp_name=nil, element_name=nil)\n\n
install_model RSS::Element.install_model(tag, uri, occurs=nil, getter=nil, plural=false)\n\n
install_must_call_validator RSS::Element.install_must_call_validator(prefix, uri)\n\n
install_ns RSS::Element.install_ns(prefix, uri)\n\n
models RSS::Element.models()\n\n
must_call_validators RSS::Element.must_call_validators()\n\n
need_initialize_variables RSS::Element.need_initialize_variables()\n\n
need_parent? RSS::Element.need_parent?()\n\n
new RSS::Element.new(do_validate=true, attrs=nil)\n\n
plural_forms RSS::Element.plural_forms()\n\n
required_prefix RSS::Element.required_prefix()\n\n
required_uri RSS::Element.required_uri()\n\n
tag_name RSS::Element.tag_name()\n\n
to_element_methods RSS::Element.to_element_methods()\n\n
convert RSS::Element.convert(value)\n\n
converter= RSS::Element.converter=(converter)\n\n
full_name RSS::Element.full_name()\n\n
have_required_elements? RSS::Element.have_required_elements?()\n\n
have_xml_content? RSS::Element.have_xml_content?()\n\n
need_base64_encode? RSS::Element.need_base64_encode?()\n\n
set_next_element RSS::Element.set_next_element(tag_name, next_element)\n\n
tag_name RSS::Element.tag_name()\n\n
to_s RSS::Element.to_s(need_convert=true, indent='')\n\n
valid? RSS::Element.valid?(ignore_unknown_element=true)\n\n
validate RSS::Element.validate(ignore_unknown_element=true)\n\n
validate_for_stream RSS::Element.validate_for_stream(tags, ignore_unknown_element=true)\n\n
new RSS::Rss::Channel::SkipDays::Day.new(*args)\n\n
new RSS::Rss::Channel::SkipHours::Hour.new(*args)\n\n
new RSS::Rss::Channel::Image.new(*args)\n\n
new RSS::Rss::Channel::Cloud.new(*args)\n\n
new RSS::Rss::Channel::Item::Source.new(*args)\n\n
new RSS::Rss::Channel::Item::Enclosure.new(*args)\n\n
new RSS::Rss::Channel::Item::Category.new(*args)\n\n
new RSS::Rss::Channel::TextInput.new(*args)\n\n
listener RSS::REXMLParser.listener()\n\n
raise_for_undefined_entity? RSS::REXMLListener.raise_for_undefined_entity?()\n\n
xmldecl RSS::REXMLListener.xmldecl(version, encoding, standalone)\n\n
new RSS::TrackBackModel10::TrackBackPing.new(*args)\n\n
required_prefix RSS::TrackBackModel10::TrackBackPing.required_prefix()\n\n
required_uri RSS::TrackBackModel10::TrackBackPing.required_uri()\n\n
full_name RSS::TrackBackModel10::TrackBackPing.full_name()\n\n
new RSS::TrackBackModel10::TrackBackAbout.new(*args)\n\n
required_prefix RSS::TrackBackModel10::TrackBackAbout.required_prefix()\n\n
required_uri RSS::TrackBackModel10::TrackBackAbout.required_uri()\n\n
full_name RSS::TrackBackModel10::TrackBackAbout.full_name()\n\n
new RSS::TrackBackModel20::TrackBackPing.new(*args)\n\n
required_prefix RSS::TrackBackModel20::TrackBackPing.required_prefix()\n\n
required_uri RSS::TrackBackModel20::TrackBackPing.required_uri()\n\n
full_name RSS::TrackBackModel20::TrackBackPing.full_name()\n\n
new RSS::TrackBackModel20::TrackBackAbout.new(*args)\n\n
required_prefix RSS::TrackBackModel20::TrackBackAbout.required_prefix()\n\n
required_uri RSS::TrackBackModel20::TrackBackAbout.required_uri()\n\n
full_name RSS::TrackBackModel20::TrackBackAbout.full_name()\n\n
new RSS::Converter.new(to_enc, from_enc=nil)\n\n
convert RSS::Converter.convert(value)\n\n
def_convert RSS::Converter.def_convert(depth=0)\n\n
def_else_enc RSS::Converter.def_else_enc(to_enc, from_enc)\n\n
def_iconv_convert RSS::Converter.def_iconv_convert(to_enc, from_enc, depth=0)\n\n
def_same_enc RSS::Converter.def_same_enc()\n\n
def_to_euc_jp_from_iso_2022_jp RSS::Converter.def_to_euc_jp_from_iso_2022_jp()\n\n
def_to_euc_jp_from_shift_jis RSS::Converter.def_to_euc_jp_from_shift_jis()\n\n
def_to_euc_jp_from_utf_8 RSS::Converter.def_to_euc_jp_from_utf_8()\n\n
def_to_iso_2022_jp_from_euc_jp RSS::Converter.def_to_iso_2022_jp_from_euc_jp()\n\n
def_to_iso_8859_1_from_utf_8 RSS::Converter.def_to_iso_8859_1_from_utf_8()\n\n
def_to_shift_jis_from_euc_jp RSS::Converter.def_to_shift_jis_from_euc_jp()\n\n
def_to_shift_jis_from_utf_8 RSS::Converter.def_to_shift_jis_from_utf_8()\n\n
def_to_utf_8_from_euc_jp RSS::Converter.def_to_utf_8_from_euc_jp()\n\n
def_to_utf_8_from_iso_8859_1 RSS::Converter.def_to_utf_8_from_iso_8859_1()\n\n
def_to_utf_8_from_shift_jis RSS::Converter.def_to_utf_8_from_shift_jis()\n\n
def_uconv_convert_if_can RSS::Converter.def_uconv_convert_if_can(meth, to_enc, from_enc, nkf_arg)\n\n
maker_target RSS::Atom::Feed::Logo.maker_target(target)\n\n
xml_getter RSS::Atom::Feed::Entry::Content.xml_getter()\n\n
xml_setter RSS::Atom::Feed::Entry::Content.xml_setter()\n\n
atom_validate RSS::Atom::Feed::Entry::Content.atom_validate(ignore_unknown_element,\ntags, uri)\n\n
have_xml_content? RSS::Atom::Feed::Entry::Content.have_xml_content?()\n\n
inline_html? RSS::Atom::Feed::Entry::Content.inline_html?()\n\n
inline_other? RSS::Atom::Feed::Entry::Content.inline_other?()\n\n
inline_other_base64? RSS::Atom::Feed::Entry::Content.inline_other_base64?()\n\n
inline_other_text? RSS::Atom::Feed::Entry::Content.inline_other_text?()\n\n
inline_other_xml? RSS::Atom::Feed::Entry::Content.inline_other_xml?()\n\n
inline_text? RSS::Atom::Feed::Entry::Content.inline_text?()\n\n
inline_xhtml? RSS::Atom::Feed::Entry::Content.inline_xhtml?()\n\n
mime_split RSS::Atom::Feed::Entry::Content.mime_split()\n\n
need_base64_encode? RSS::Atom::Feed::Entry::Content.need_base64_encode?()\n\n
out_of_line? RSS::Atom::Feed::Entry::Content.out_of_line?()\n\n
xhtml RSS::Atom::Feed::Entry::Content.xhtml()\n\n
xml RSS::Atom::Feed::Entry::Content.xml()\n\n
have_author? RSS::Atom::Feed::Entry::Source.have_author?()\n\n
new RSS::Rss::Channel::Item::Guid.new(*args)\n\n
PermaLink? RSS::Rss::Channel::Item::Guid.PermaLink?()\n\n
_PermaLink? RSS::Rss::Channel::Item::Guid._PermaLink?()\n\n
new RSS::ITunesChannelModel::ITunesCategory.new(*args)\n\n
required_prefix RSS::ITunesChannelModel::ITunesCategory.required_prefix()\n\n
required_uri RSS::ITunesChannelModel::ITunesCategory.required_uri()\n\n
full_name RSS::ITunesChannelModel::ITunesCategory.full_name()\n\n
new RSS::ITunesChannelModel::ITunesImage.new(*args)\n\n
required_prefix RSS::ITunesChannelModel::ITunesImage.required_prefix()\n\n
required_uri RSS::ITunesChannelModel::ITunesImage.required_uri()\n\n
full_name RSS::ITunesChannelModel::ITunesImage.full_name()\n\n
new RSS::ITunesChannelModel::ITunesOwner.new(*args)\n\n
required_prefix RSS::ITunesChannelModel::ITunesOwner.required_prefix()\n\n
required_uri RSS::ITunesChannelModel::ITunesOwner.required_uri()\n\n
full_name RSS::ITunesChannelModel::ITunesOwner.full_name()\n\n
construct RSS::ITunesItemModel::ITunesDuration.construct(hour, minute, second)\n\n
new RSS::ITunesItemModel::ITunesDuration.new(*args)\n\n
parse RSS::ITunesItemModel::ITunesDuration.parse(duration, do_validate=true)\n\n
required_prefix RSS::ITunesItemModel::ITunesDuration.required_prefix()\n\n
required_uri RSS::ITunesItemModel::ITunesDuration.required_uri()\n\n
content= RSS::ITunesItemModel::ITunesDuration.content=(value)\n\n
full_name RSS::ITunesItemModel::ITunesDuration.full_name()\n\n
hour= RSS::ITunesItemModel::ITunesDuration.hour=(hour)\n\n
minute= RSS::ITunesItemModel::ITunesDuration.minute=(minute)\n\n
second= RSS::ITunesItemModel::ITunesDuration.second=(second)\n\n
value= RSS::ITunesItemModel::ITunesDuration.value=(value)\n\n
character RSS::REXMLLikeXMLParser.character(data)\n\n
endElement RSS::REXMLLikeXMLParser.endElement(name)\n\n
listener= RSS::REXMLLikeXMLParser.listener=(listener)\n\n
processingInstruction RSS::REXMLLikeXMLParser.processingInstruction(target, content)\n\n
startElement RSS::REXMLLikeXMLParser.startElement(name, attrs)\n\n
xmlDecl RSS::REXMLLikeXMLParser.xmlDecl(version, encoding, standalone)\n\n
listener RSS::XMLParserParser.listener()\n\n
xmldecl RSS::XMLParserListener.xmldecl(version, encoding, standalone)\n\n
new RSS::ImageItemModel::ImageItem.new(*args)\n\n
required_prefix RSS::ImageItemModel::ImageItem.required_prefix()\n\n
required_uri RSS::ImageItemModel::ImageItem.required_uri()\n\n
full_name RSS::ImageItemModel::ImageItem.full_name()\n\n
new RSS::ImageFaviconModel::ImageFavicon.new(*args)\n\n
required_prefix RSS::ImageFaviconModel::ImageFavicon.required_prefix()\n\n
required_uri RSS::ImageFaviconModel::ImageFavicon.required_uri()\n\n
full_name RSS::ImageFaviconModel::ImageFavicon.full_name()\n\n
image_size= RSS::ImageFaviconModel::ImageFavicon.image_size=(new_value)\n\n
set_size RSS::ImageFaviconModel::ImageFavicon.set_size(new_value)\n\n
size= RSS::ImageFaviconModel::ImageFavicon.size=(new_value)\n\n
listener RSS::XMLScanParser.listener()\n\n
on_attr_charref RSS::XMLScanListener.on_attr_charref(code)\n\n
on_attr_charref_hex RSS::XMLScanListener.on_attr_charref_hex(code)\n\n
on_attr_entityref RSS::XMLScanListener.on_attr_entityref(ref)\n\n
on_attr_value RSS::XMLScanListener.on_attr_value(str)\n\n
on_attribute RSS::XMLScanListener.on_attribute(name)\n\n
on_charref RSS::XMLScanListener.on_charref(code)\n\n
on_charref_hex RSS::XMLScanListener.on_charref_hex(code)\n\n
on_entityref RSS::XMLScanListener.on_entityref(ref)\n\n
on_etag RSS::XMLScanListener.on_etag(name)\n\n
on_stag RSS::XMLScanListener.on_stag(name)\n\n
on_stag_end RSS::XMLScanListener.on_stag_end(name)\n\n
on_stag_end_empty RSS::XMLScanListener.on_stag_end_empty(name)\n\n
on_xmldecl_encoding RSS::XMLScanListener.on_xmldecl_encoding(str)\n\n
on_xmldecl_end RSS::XMLScanListener.on_xmldecl_end()\n\n
on_xmldecl_standalone RSS::XMLScanListener.on_xmldecl_standalone(str)\n\n
on_xmldecl_version RSS::XMLScanListener.on_xmldecl_version(str)\n\n
new RSS::TaxonomyTopicsModel::TaxonomyTopics.new(*args)\n\n
required_prefix RSS::TaxonomyTopicsModel::TaxonomyTopics.required_prefix()\n\n
required_uri RSS::TaxonomyTopicsModel::TaxonomyTopics.required_uri()\n\n
full_name RSS::TaxonomyTopicsModel::TaxonomyTopics.full_name()\n\n
maker_target RSS::TaxonomyTopicsModel::TaxonomyTopics.maker_target(target)\n\n
resources RSS::TaxonomyTopicsModel::TaxonomyTopics.resources()\n\n
new RSS::TaxonomyTopicsModel::TaxonomyTopics::Bag.new(*args)\n\n
required_uri RSS::TaxonomyTopicsModel::TaxonomyTopics::Bag.required_uri()\n\n
full_name RSS::TaxonomyTopicsModel::TaxonomyTopics::Bag.full_name()\n\n
setup_maker RSS::TaxonomyTopicsModel::TaxonomyTopics::Bag.setup_maker(target)\n\n
new RSS::TaxonomyTopicModel::TaxonomyTopic.new(*args)\n\n
required_prefix RSS::TaxonomyTopicModel::TaxonomyTopic.required_prefix()\n\n
required_uri RSS::TaxonomyTopicModel::TaxonomyTopic.required_uri()\n\n
full_name RSS::TaxonomyTopicModel::TaxonomyTopic.full_name()\n\n
maker_target RSS::TaxonomyTopicModel::TaxonomyTopic.maker_target(target)\n\n
new RSS::NotWellFormedError.new(line=nil, element=nil)\nCreate a new NotWellFormedError for an error at +line+\nin +element+.  If a block is given the return value of\nthe block ends up in the error message.\n
new RSS::XMLParserNotFound.new()\n\n
new RSS::NotValidXMLParser.new(parser)\n\n
new RSS::NSError.new(tag, prefix, require_uri)\n\n
default_parser RSS::Parser.default_parser()\n\n
default_parser= RSS::Parser.default_parser=(new_value)\nSet @@default_parser to new_value if it is one of the\navailable parsers. Else raise NotValidXMLParser error.\n
new RSS::Parser.new(rss, parser_class=self.class.default_parser)\n\n
parse RSS::Parser.parse(rss, do_validate=true, ignore_unknown_element=true,\nparser_class=default_parser)\n\n
new RSS::BaseParser.new(rss)\n\n
raise_for_undefined_entity? RSS::BaseParser.raise_for_undefined_entity?()\n\n
do_validate RSS::BaseParser.do_validate()\n\n
do_validate= RSS::BaseParser.do_validate=(new_value)\n\n
ignore_unknown_element RSS::BaseParser.ignore_unknown_element()\n\n
ignore_unknown_element= RSS::BaseParser.ignore_unknown_element=(new_value)\n\n
parse RSS::BaseParser.parse()\n\n
rss RSS::BaseParser.rss()\n\n
available_tags RSS::BaseListener.available_tags(uri)\nreturn the tag_names for setters associated with uri\n
class_name RSS::BaseListener.class_name(uri, tag_name)\nretrieve class_name for the supplied uri and tag_name\nIf it doesn't exist, capitalize the tag_name\n
getter RSS::BaseListener.getter(uri, tag_name)\n\n
install_class_name RSS::BaseListener.install_class_name(uri, tag_name, class_name)\nrecord class_name for the supplied uri and tag_name\n
install_get_text_element RSS::BaseListener.install_get_text_element(uri, name, accessor_base)\n\n
raise_for_undefined_entity? RSS::BaseListener.raise_for_undefined_entity?()\n\n
register_uri RSS::BaseListener.register_uri(uri, name)\nregister uri against this name.\n
setter RSS::BaseListener.setter(uri, tag_name)\nreturn the setter for the uri, tag_name pair, or nil.\n
uri_registered? RSS::BaseListener.uri_registered?(uri, name)\ntest if this uri is registered against this name\n
in_service? GServer.in_service?(port, host = DEFAULT_HOST)\nCheck if a server is running on the given port and host\n\n+port+:: port, as a FixNum, of the server to check\n+host+:: host on which to find the server to check\n\nReturns true if a server is running on that port and host.\n
new GServer.new(port, host = DEFAULT_HOST, maxConnections = 4, stdlog = $stderr,\naudit = false, debug = false)\nCreate a new server\n\n+port+:: the port, as a FixNum, on which to listen.\n+host+:: the host to bind to\n+maxConnections+:: The maximum number of simultaneous connections to\n                   accept\n+stdlog+:: IO device on which to log messages\n+audit+:: if true, lifecycle callbacks will be called.  See #audit\n+debug+:: if true, error messages are logged.  See #debug\n
stop GServer.stop(port, host = DEFAULT_HOST)\nStop the server running on the given port, bound to the given host\n\n+port+:: port, as a FixNum, of the server to stop\n+host+:: host on which to find the server to stop\n
connecting GServer.connecting(client)\nCalled when a client connects, if auditing is enabled.\n\n+client+:: a TCPSocket instances representing the client that connected\n\nReturn true to allow this client to connect, false to prevent it.\n
connections GServer.connections()\nReturn the current number of connected clients\n
disconnecting GServer.disconnecting(clientPort)\nCalled when a client disconnects, if audition is enabled.\n\n+clientPort+:: the port of the client that is connecting\n
error GServer.error(detail)\nCalled if #debug is true whenever an unhandled exception is raised.\nThis implementation simply logs the backtrace.\n\n+detail+:: The Exception that was caught\n
join GServer.join()\nJoin with the server thread\n
log GServer.log(msg)\nLog a message to #stdlog, if it's defined.  This implementation\noutputs the timestamp and message to the log.\n\n+msg+:: the message to log\n
serve GServer.serve(io)\n\n
shutdown GServer.shutdown()\nSchedule a shutdown for the server\n
start GServer.start(maxConnections = -1)\nStart the server if it isn't already running\n\n+maxConnections+::\n  override +maxConnections+ given to the constructor.  A negative\n  value indicates that the value from the constructor should be used.\n
starting GServer.starting()\nCalled when the server is starting up, if auditing is enabled.\n
stop GServer.stop()\nStop the server\n
stopped? GServer.stopped?()\nReturns true if the server has stopped.\n
stopping GServer.stopping()\nCalled when the server is shutting down, if auditing is enabled.\n
Fail Sync_m::Err.Fail(*opt)\n\n
Fail Sync_m::Err::UnknownLocker.Fail(th)\n\n
Fail Sync_m::Err::LockModeFailer.Fail(mode)\n\n
getaddress IPSocket.getaddress(s)\nReturns a +String+ based representation of a valid DNS hostname,\nIPv4 or IPv6 address.\n\n  IPSocket.getaddress 'localhost'         #=> "::1"\n  IPSocket.getaddress 'broadcasthost'     #=> "255.255.255.255"\n  IPSocket.getaddress 'www.ruby-lang.org' #=> "221.186.184.68"\n  IPSocket.getaddress 'www.ccc.de'        #=> "2a00:1328:e102:ccc0::122"\n
getaddress_orig IPSocket.getaddress_orig(s)\n\n
addr IPSocket.addr(*args)\nReturns the local address as an array which contains\naddress_family, port, hostname and numeric_address.\n\nIf +reverse_lookup+ is +true+ or +:hostname+,\nhostname is obtained from numeric_address using reverse lookup.\nOr if it is +false+, or +:numeric+,\nhostname is same as numeric_address.\nOr if it is +nil+ or ommitted, obeys to +ipsocket.do_not_reverse_lookup+.\nSee +Socket.getaddrinfo+ also.\n\n  TCPSocket.open("www.ruby-lang.org", 80) {|sock|\n    p sock.addr #=> ["AF_INET", 49429, "hal", "192.168.0.128"]\n    p sock.addr(true)  #=> ["AF_INET", 49429, "hal", "192.168.0.128"]\n    p sock.addr(false) #=> ["AF_INET", 49429, "192.168.0.128", "192.168.0.128"]\n    p sock.addr(:hostname)  #=> ["AF_INET", 49429, "hal", "192.168.0.128"]\n    p sock.addr(:numeric)   #=> ["AF_INET", 49429, "192.168.0.128",\n    "192.168.0.128"]\n  }\n
peeraddr IPSocket.peeraddr(*args)\nReturns the remote address as an array which contains\naddress_family, port, hostname and numeric_address.\nIt is defined for connection oriented socket such as TCPSocket.\n\nIf +reverse_lookup+ is +true+ or +:hostname+,\nhostname is obtained from numeric_address using reverse lookup.\nOr if it is +false+, or +:numeric+,\nhostname is same as numeric_address.\nOr if it is +nil+ or ommitted, obeys to +ipsocket.do_not_reverse_lookup+.\nSee +Socket.getaddrinfo+ also.\n\n  TCPSocket.open("www.ruby-lang.org", 80) {|sock|\n    p sock.peeraddr #=> ["AF_INET", 80, "carbon.ruby-lang.org",\n    "221.186.184.68"]\n    p sock.peeraddr(true)  #=> ["AF_INET", 80, "221.186.184.68",\n    "221.186.184.68"]\n    p sock.peeraddr(false) #=> ["AF_INET", 80, "221.186.184.68",\n    "221.186.184.68"]\n    p sock.peeraddr(:hostname) #=> ["AF_INET", 80, "carbon.ruby-lang.org",\n    "221.186.184.68"]\n    p sock.peeraddr(:numeric)  #=> ["AF_INET", 80, "221.186.184.68",\n    "221.186.184.68"]\n  }\n
recvfrom IPSocket.recvfrom(*args)\nReceives a message and return the message as a string and\nan address which the message come from.\n\n_maxlen_ is the maximum number of bytes to receive.\n\n_flags_ should be a bitwise OR of Socket::MSG_* constants.\n\nipaddr is same as IPSocket#{peeraddr,addr}.\n\n  u1 = UDPSocket.new\n  u1.bind("127.0.0.1", 4913)\n  u2 = UDPSocket.new\n  u2.send "uuuu", 0, "127.0.0.1", 4913\n  p u1.recvfrom(10) #=> ["uuuu", ["AF_INET", 33230, "localhost", "127.0.0.1"]]\n
gethostbyname TCPSocket.gethostbyname(p1)\nLookups host information by _hostname_.\n\n  TCPSocket.gethostbyname("localhost")\n=> ["localhost", ["hal"], 2, "127.0.0.1"]\n
new TCPSocket.new(host, serv, *rest)\n\n
new TCPSocket.new(p1, p2, p3 = v3, p4 = v4)\nOpens a TCP connection to +remote_host+ on +remote_port+.  If +local_host+\nand +local_port+ are specified, then those parameters are used on the local\nend to establish the connection.\n
new UDPSocket.new(p1 = v1)\nCreates a new UDPSocket object.\n\n_address_family_ should be an integer, a string or a symbol:\nSocket::AF_INET, "AF_INET", :INET, etc.\n\n  UDPSocket.new                   #=> #<UDPSocket:fd 3>\n  UDPSocket.new(Socket::AF_INET6) #=> #<UDPSocket:fd 4>\n
bind UDPSocket.bind(host, port)\nBinds _udpsocket_ to _host_:_port_.\n\n  u1 = UDPSocket.new\n  u1.bind("127.0.0.1", 4913)\n  u1.send "message-to-self", 0, "127.0.0.1", 4913\n  p u1.recvfrom(10) #=> ["message-to", ["AF_INET", 4913, "localhost",\n  "127.0.0.1"]]\n
connect UDPSocket.connect(host, port)\nConnects _udpsocket_ to _host_:_port_.\n\nThis makes possible to send without destination address.\n\n  u1 = UDPSocket.new\n  u1.bind("127.0.0.1", 4913)\n  u2 = UDPSocket.new\n  u2.connect("127.0.0.1", 4913)\n  u2.send "uuuu", 0\n  p u1.recvfrom(10) #=> ["uuuu", ["AF_INET", 33230, "localhost", "127.0.0.1"]]\n
recvfrom_nonblock UDPSocket.recvfrom_nonblock(*args)\nReceives up to _maxlen_ bytes from +udpsocket+ using recvfrom(2) after\nO_NONBLOCK is set for the underlying file descriptor.\nIf _maxlen_ is omitted, its default value is 65536.\n_flags_ is zero or more of the +MSG_+ options.\nThe first element of the results, _mesg_, is the data received.\nThe second element, _sender_inet_addr_, is an array to represent the sender\naddress.\n\nWhen recvfrom(2) returns 0,\nSocket#recvfrom_nonblock returns an empty string as data.\nIt means an empty packet.\n\n=== Parameters\n* +maxlen+ - the number of bytes to receive from the socket\n* +flags+ - zero or more of the +MSG_+ options\n\n=== Example\n     require 'socket'\n     s1 = UDPSocket.new\n     s1.bind("127.0.0.1", 0)\n     s2 = UDPSocket.new\n     s2.bind("127.0.0.1", 0)\n     s2.connect(*s1.addr.values_at(3,1))\n     s1.connect(*s2.addr.values_at(3,1))\n     s1.send "aaa", 0\n     begin # emulate blocking recvfrom\n       p s2.recvfrom_nonblock(10)  #=> ["aaa", ["AF_INET", 33302,\n       "localhost.localdomain", "127.0.0.1"]]\n     rescue IO::WaitReadable\n       IO.select([s2])\n       retry\n     end\n\nRefer to Socket#recvfrom for the exceptions that may be thrown if the call\nto _recvfrom_nonblock_ fails.\n\nUDPSocket#recvfrom_nonblock may raise any error corresponding to recvfrom(2)\nfailure,\nincluding Errno::EWOULDBLOCK.\n\nIf the exception is Errno::EWOULDBLOCK or Errno::AGAIN,\nit is extended by IO::WaitReadable.\nSo IO::WaitReadable can be used to rescue the exceptions for retrying\nrecvfrom_nonblock.\n\n=== See\n* Socket#recvfrom\n
send UDPSocket.send(mesg, flags, *rest)\nSends _mesg_ via _udpsocket_.\n\n_flags_ should be a bitwise OR of Socket::MSG_* constants.\n\n  u1 = UDPSocket.new\n  u1.bind("127.0.0.1", 4913)\n\n  u2 = UDPSocket.new\n  u2.send "hi", 0, "127.0.0.1", 4913\n\n  mesg, addr = u1.recvfrom(10)\n  u1.send mesg, 0, addr[3], addr[1]\n\n  p u2.recv(100) #=> "hi"\n
new SOCKSSocket.new(host, serv)\n\n
new SOCKSSocket.new(p1, p2)\nOpens a SOCKS connection to +host+ via the SOCKS server +serv+.\n
close SOCKSSocket.close()\nCloses the SOCKS connection.\n
new OpenURI::HTTPError.new(message, io)\n\n
new OpenURI::HTTPRedirect.new(message, io, uri)\n\n
build URI::Generic.build(args)\n== Synopsis\n\nSee #new\n\n== Description\n\nCreates a new URI::Generic instance from components of URI::Generic\nwith check.  Components are: scheme, userinfo, host, port, registry, path,\nopaque, query and fragment. You can provide arguments either by an Array or\na Hash.\nSee #new for hash keys to use or for order of array items.\n
build2 URI::Generic.build2(args)\n== Synopsis\n\nSee #new\n\n== Description\n\nAt first, tries to create a new URI::Generic instance using\nURI::Generic::build. But, if exception URI::InvalidComponentError is raised,\nthen it URI::Escape.escape all URI components and tries again.\n
component URI::Generic.component()\nComponents of the URI in the order.\n
default_port URI::Generic.default_port()\nReturns default port\n
new URI::Generic.new(scheme, userinfo, host, port, registry, path, opaque, query,\nfragment, parser = DEFAULT_PARSER, arg_check = false)\n== Args\n\n+scheme+::\n  Protocol scheme, i.e. 'http','ftp','mailto' and so on.\n+userinfo+::\n  User name and password, i.e. 'sdmitry:bla'\n+host+::\n  Server host name\n+port+::\n  Server port\n+registry+::\n  Registry of naming authorities.\n+path+::\n  Path on server\n+opaque+::\n  Opaque part\n+query+::\n  Query data\n+fragment+::\n  A part of URI after '#' sign\n+parser+::\n  Parser for internal use [URI::DEFAULT_PARSER by default]\n+arg_check+::\n  Check arguments [false by default]\n\n== Description\n\nCreates a new URI::Generic instance from ``generic'' components without check.\n
use_registry URI::Generic.use_registry()\nReturns whether a registry of naming\nauthorities are being used.\n
absolute URI::Generic.absolute()\n\n
absolute? URI::Generic.absolute?()\nChecks if URI is an absolute one\n
coerce URI::Generic.coerce(oth)\n== Args\n\n+v+::\n   URI or String\n\n== Description\n\n attempt to parse other URI +oth+\n return [parsed_oth, self]\n\n== Usage\n\n  require 'uri'\n\n  uri = URI.parse("http://my.example.com")\n  uri.coerce("http://foo.com")\n=> [#<URI::HTTP:0x00000000bcb028 URL:http://foo.com/>,\n#<URI::HTTP:0x00000000d92178 URL:http://my.example.com>]\n
component URI::Generic.component()\nComponents of the URI in the order.\n
component_ary URI::Generic.component_ary()\nreturns an Array of the components defined from the COMPONENT Array\n
default_port URI::Generic.default_port()\nReturns default port\n
eql? URI::Generic.eql?(oth)\n\n
find_proxy URI::Generic.find_proxy()\nreturns a proxy URI.\nThe proxy URI is obtained from environment variables such as http_proxy,\nftp_proxy, no_proxy, etc.\nIf there is no proper proxy, nil is returned.\n\nNote that capitalized variables (HTTP_PROXY, FTP_PROXY, NO_PROXY, etc.)\nare examined too.\n\nBut http_proxy and HTTP_PROXY is treated specially under CGI environment.\nIt's because HTTP_PROXY may be set by Proxy: header.\nSo HTTP_PROXY is not used.\nhttp_proxy is not used too if the variable is case insensitive.\nCGI_HTTP_PROXY can be used instead.\n
fragment= URI::Generic.fragment=(v)\n== Args\n\n+v+::\n   String\n\n== Description\n\npublic setter for the fragment component +v+.\n(with validation)\n\nsee also URI::Generic.check_fragment\n\n== Usage\n\n  require 'uri'\n\n  uri = URI.parse("http://my.example.com/?id=25#time=1305212049")\n  uri.fragment = "time=1305212086"\n =>  "time=1305212086"\n  uri\n=> #<URI::HTTP:0x000000007a81f8\nURL:http://my.example.com/?id=25#time=1305212086>\n
hash URI::Generic.hash()\n\n
hierarchical? URI::Generic.hierarchical?()\nChecks if URI has a path\n
host= URI::Generic.host=(v)\n== Args\n\n+v+::\n   String\n\n== Description\n\npublic setter for the host component +v+.\n(with validation)\n\nsee also URI::Generic.check_host\n\n== Usage\n\n  require 'uri'\n\n  uri = URI.parse("http://my.example.com")\n  uri.host = "foo.com"\n =>  "foo.com"\n  uri\n=> #<URI::HTTP:0x000000008e89e8 URL:http://foo.com>\n
hostname URI::Generic.hostname()\nextract the host part of the URI and unwrap brackets for IPv6 addresses.\n\nThis method is same as URI::Generic#host except\nbrackets for IPv6 (andn future IP) addresses are removed.\n\nu = URI("http://[::1]/bar")\np u.hostname      #=> "::1"\np u.host          #=> "[::1]"\n
hostname= URI::Generic.hostname=(v)\nset the host part of the URI as the argument with brackets for IPv6 addresses.\n\nThis method is same as URI::Generic#host= except\nthe argument can be bare IPv6 address.\n\nu = URI("http://foo/bar")\np u.to_s                  #=> "http://foo/bar"\nu.hostname = "::1"\np u.to_s                  #=> "http://[::1]/bar"\n\nIf the arugument seems IPv6 address,\nit is wrapped by brackets.\n
inspect URI::Generic.inspect()\n\n
merge URI::Generic.merge(oth)\n== Args\n\n+oth+::\n   URI or String\n\n== Description\n\nMerges two URI's.\n\n== Usage\n\n  require 'uri'\n\n  uri = URI.parse("http://my.example.com")\n  p uri.merge("/main.rbx?page=1")\n =>  #<URI::HTTP:0x2021f3b0 URL:http://my.example.com/main.rbx?page=1>\n
merge! URI::Generic.merge!(oth)\n== Args\n\n+oth+::\n   URI or String\n\n== Description\n\nDestructive form of #merge\n\n== Usage\n\n  require 'uri'\n\n  uri = URI.parse("http://my.example.com")\n  uri.merge!("/main.rbx?page=1")\n  p uri\n =>  #<URI::HTTP:0x2021f3b0 URL:http://my.example.com/main.rbx?page=1>\n
normalize URI::Generic.normalize()\nReturns normalized URI\n
normalize! URI::Generic.normalize!()\nDestructive version of #normalize\n
opaque= URI::Generic.opaque=(v)\n== Args\n\n+v+::\n   String\n\n== Description\n\npublic setter for the opaque component +v+.\n(with validation)\n\nsee also URI::Generic.check_opaque\n
parser URI::Generic.parser()\nreturns the parser to be used.\n\nUnless a URI::Parser is defined, then DEFAULT_PARSER is used.\n
password URI::Generic.password()\nreturns the password component\n
password= URI::Generic.password=(password)\n== Args\n\n+v+::\n   String\n\n== Description\n\npublic setter for the +password+ component.\n(with validation)\n\nsee also URI::Generic.check_password\n\n== Usage\n\n  require 'uri'\n\n  uri = URI.parse("http://john:S3nsit1ve@my.example.com")\n  uri.password = "V3ry_S3nsit1ve"\n =>  "V3ry_S3nsit1ve"\n  uri\n=> #<URI::HTTP:0x00000000881d90 URL:http://john:V3ry_S3nsit1ve@my.example.com>\n
path= URI::Generic.path=(v)\n== Args\n\n+v+::\n   String\n\n== Description\n\npublic setter for the path component +v+.\n(with validation)\n\nsee also URI::Generic.check_path\n\n== Usage\n\n  require 'uri'\n\n  uri = URI.parse("http://my.example.com/pub/files")\n  uri.path = "/faq/"\n =>  "/faq/"\n  uri\n=> #<URI::HTTP:0x000000008e89e8 URL:http://my.example.com/faq/>\n
port= URI::Generic.port=(v)\n== Args\n\n+v+::\n   String\n\n== Description\n\npublic setter for the port component +v+.\n(with validation)\n\nsee also URI::Generic.check_port\n\n== Usage\n\n  require 'uri'\n\n  uri = URI.parse("http://my.example.com")\n  uri.port = 8080\n =>  8080\n  uri\n=> #<URI::HTTP:0x000000008e89e8 URL:http://my.example.com:8080>\n
query= URI::Generic.query=(v)\n== Args\n\n+v+::\n   String\n\n== Description\n\npublic setter for the query component +v+.\n(with validation)\n\nsee also URI::Generic.check_query\n\n== Usage\n\n  require 'uri'\n\n  uri = URI.parse("http://my.example.com/?id=25")\n  uri.query = "id=1"\n =>  "id=1"\n  uri\n=> #<URI::HTTP:0x000000008e89e8 URL:http://my.example.com/?id=1>\n
registry= URI::Generic.registry=(v)\n== Args\n\n+v+::\n   String\n\n== Description\n\npublic setter for the registry component +v+.\n(with validation)\n\nsee also URI::Generic.check_registry\n
relative? URI::Generic.relative?()\nChecks if URI is relative\n
route_from URI::Generic.route_from(oth)\n== Args\n\n+oth+::\n   URI or String\n\n== Description\n\nCalculates relative path from oth to self\n\n== Usage\n\n  require 'uri'\n\n  uri = URI.parse('http://my.example.com/main.rbx?page=1')\n  p uri.route_from('http://my.example.com')\n=> #<URI::Generic:0x20218858 URL:/main.rbx?page=1>\n
route_to URI::Generic.route_to(oth)\n== Args\n\n+oth+::\n   URI or String\n\n== Description\n\nCalculates relative path to oth from self\n\n== Usage\n\n  require 'uri'\n\n  uri = URI.parse('http://my.example.com')\n  p uri.route_to('http://my.example.com/main.rbx?page=1')\n=> #<URI::Generic:0x2020c2f6 URL:/main.rbx?page=1>\n
scheme= URI::Generic.scheme=(v)\n== Args\n\n+v+::\n   String\n\n== Description\n\npublic setter for the scheme component +v+.\n(with validation)\n\nsee also URI::Generic.check_scheme\n\n== Usage\n\n  require 'uri'\n\n  uri = URI.parse("http://my.example.com")\n  uri.scheme = "https"\n =>  "https"\n  uri\n=> #<URI::HTTP:0x000000008e89e8 URL:https://my.example.com>\n
select URI::Generic.select(*components)\n== Args\n\n+components+::\n   Multiple Symbol arguments defined in URI::HTTP\n\n== Description\n\nSelects specified components from URI\n\n== Usage\n\n  require 'uri'\n\n  uri = URI.parse('http://myuser:mypass@my.example.com/test.rbx')\n  p uri.select(:userinfo, :host, :path)\n => ["myuser:mypass", "my.example.com", "/test.rbx"]\n
set_fragment URI::Generic.set_fragment(v)\nprotected setter for the fragment component +v+\n\nsee also URI::Generic.fragment=\n
set_host URI::Generic.set_host(v)\nprotected setter for the host component +v+\n\nsee also URI::Generic.host=\n
set_opaque URI::Generic.set_opaque(v)\nprotected setter for the opaque component +v+\n\nsee also URI::Generic.opaque=\n
set_password URI::Generic.set_password(v)\nprotected setter for the password component +v+\n\nsee also URI::Generic.password=\n
set_path URI::Generic.set_path(v)\nprotected setter for the path component +v+\n\nsee also URI::Generic.path=\n
set_port URI::Generic.set_port(v)\nprotected setter for the port component +v+\n\nsee also URI::Generic.port=\n
set_query URI::Generic.set_query(v)\nprotected setter for the query component +v+\n\nsee also URI::Generic.query=\n
set_registry URI::Generic.set_registry(v)\nprotected setter for the registry component +v+\n\nsee also URI::Generic.registry=\n
set_scheme URI::Generic.set_scheme(v)\nprotected setter for the scheme component +v+\n\nsee also URI::Generic.scheme=\n
set_user URI::Generic.set_user(v)\nprotected setter for the user component +v+\n\nsee also URI::Generic.user=\n
set_userinfo URI::Generic.set_userinfo(user, password = nil)\nprotect setter for the +user+ component, and +password+ if available.\n(with validation)\n\nsee also URI::Generic.userinfo=\n
to_s URI::Generic.to_s()\nConstructs String from URI\n
user URI::Generic.user()\nreturns the user component\n
user= URI::Generic.user=(user)\n== Args\n\n+v+::\n   String\n\n== Description\n\npublic setter for the +user+ component.\n(with validation)\n\nsee also URI::Generic.check_user\n\n== Usage\n\n  require 'uri'\n\n  uri = URI.parse("http://john:S3nsit1ve@my.example.com")\n  uri.user = "sam"\n =>  "sam"\n  uri\n=> #<URI::HTTP:0x00000000881d90 URL:http://sam:V3ry_S3nsit1ve@my.example.com>\n
userinfo URI::Generic.userinfo()\nreturns the userinfo, either as 'user' or 'user:password'\n
userinfo= URI::Generic.userinfo=(userinfo)\nSets userinfo, argument is string like 'name:pass'\n
build URI::HTTP.build(args)\n== Description\n\nCreate a new URI::HTTP object from components, with syntax checking.\n\nThe components accepted are userinfo, host, port, path, query and\nfragment.\n\nThe components should be provided either as an Array, or as a Hash\nwith keys formed by preceding the component names with a colon.\n\nIf an Array is used, the components must be passed in the order\n[userinfo, host, port, path, query, fragment].\n\nExample:\n\n    newuri = URI::HTTP.build({:host => 'www.example.com',\n      :path> => '/foo/bar'})\n\n    newuri = URI::HTTP.build([nil, "www.example.com", nil, "/path",\n      "query", 'fragment'])\n\nCurrently, if passed userinfo components this method generates\ninvalid HTTP URIs as per RFC 1738.\n
new URI::HTTP.new(*arg)\n== Description\n\nCreate a new URI::HTTP object from generic URI components as per\nRFC 2396. No HTTP-specific syntax checking (as per RFC 1738) is\nperformed.\n\nArguments are +scheme+, +userinfo+, +host+, +port+, +registry+, +path+,\n+opaque+, +query+ and +fragment+, in that order.\n\nExample:\n\n    uri = URI::HTTP.new('http', nil, "www.example.com", nil, "/path",\n      "query", 'fragment')\n\nSee also URI::Generic.new\n
request_uri URI::HTTP.request_uri()\n== Description\n\nReturns the full path for an HTTP request, as required by Net::HTTP::Get.\n\nIf the URI contains a query, the full path is URI#path + '?' + URI#query.\nOtherwise, the path is simply URI#path.\n
build URI::FTP.build(args)\n== Description\n\nCreates a new URI::FTP object from components, with syntax checking.\n\nThe components accepted are +userinfo+, +host+, +port+, +path+ and\n+typecode+.\n\nThe components should be provided either as an Array, or as a Hash\nwith keys formed by preceding the component names with a colon.\n\nIf an Array is used, the components must be passed in the order\n[userinfo, host, port, path, typecode]\n\nIf the path supplied is absolute, it will be escaped in order to\nmake it absolute in the URI. Examples:\n\n    require 'uri'\n\n    uri = URI::FTP.build(['user:password', 'ftp.example.com', nil,\n      '/path/file.> zip', 'i'])\n    puts uri.to_s  ->\n    ftp://user:password@ftp.example.com/%2Fpath/file.zip;type=a\n\n    uri2 = URI::FTP.build({:host => 'ftp.example.com',\n      :path => 'ruby/src'})\n    puts uri2.to_s  ->  ftp://ftp.example.com/ruby/src\n
new URI::FTP.new(*arg)\n== Description\n\nCreates a new URI::FTP object from generic URL components with no\nsyntax checking.\n\nUnlike build(), this method does not escape the path component as\nrequired by RFC1738; instead it is treated as per RFC2396.\n\nArguments are +scheme+, +userinfo+, +host+, +port+, +registry+, +path+,\n+opaque+, +query+ and +fragment+, in that order.\n
new2 URI::FTP.new2(user, password, host, port, path, typecode = nil, arg_check\n= true)\nalternate initialization\nCreates a new URI::FTP object.\n\nUnlike build(), this method does not escape the path component as\nrequired by RFC1738; instead it is treated as per RFC2396.\n\nArguments are user, password, host, port, path, typecode,\nand arg_check, in that order.\n
path URI::FTP.path()\nReturns the path from an FTP URI.\n\nRFC 1738 specifically states that the path for an FTP URI does not\ninclude the / which separates the URI path from the URI host. Example:\n\n    ftp://ftp.example.com/pub/ruby\n\nThe above URI indicates that the client should connect to\nftp.example.com then cd pub/ruby from the initial login directory.\n\nIf you want to cd to an absolute directory, you must include an\nescaped / (%2F) in the path. Example:\n\n    ftp://ftp.example.com/%2Fpub/ruby\n\nThis method will then return "/pub/ruby"\n
set_path URI::FTP.set_path(v)\n\n
set_typecode URI::FTP.set_typecode(v)\nprivate setter for the typecode +v+\n\nsee also URI::FTP.typecode=\n
to_s URI::FTP.to_s()\n\n
typecode= URI::FTP.typecode=(typecode)\n== Args\n\n+v+::\n   String\n\n== Description\n\npublic setter for the typecode +v+.\n(with validation)\n\nsee also URI::FTP.check_typecode\n\n== Usage\n\n  require 'uri'\n\n  uri = URI.parse("ftp://john@ftp.example.com/my_file.img")\n=> #<URI::FTP:0x00000000923650 URL:ftp://john@ftp.example.com/my_file.img>\n  uri.typecode = "i"\n =>  "i"\n  uri\n=> #<URI::FTP:0x00000000923650\nURL:ftp://john@ftp.example.com/my_file.img;type=i>\n
each_address Resolv.each_address(name, &block)\nIterates over all IP addresses for +name+.\n
each_name Resolv.each_name(address, &proc)\nIterates over all hostnames for +address+.\n
getaddress Resolv.getaddress(name)\nLooks up the first IP address for +name+.\n
getaddresses Resolv.getaddresses(name)\nLooks up all IP address for +name+.\n
getname Resolv.getname(address)\nLooks up the hostname of +address+.\n
getnames Resolv.getnames(address)\nLooks up all hostnames for +address+.\n
new Resolv.new(resolvers=[Hosts.new, DNS.new])\nCreates a new Resolv using +resolvers+.\n
each_address Resolv.each_address(name)\nIterates over all IP addresses for +name+.\n
each_name Resolv.each_name(address)\nIterates over all hostnames for +address+.\n
getaddress Resolv.getaddress(name)\nLooks up the first IP address for +name+.\n
getaddresses Resolv.getaddresses(name)\nLooks up all IP address for +name+.\n
getname Resolv.getname(address)\nLooks up the hostname of +address+.\n
getnames Resolv.getnames(address)\nLooks up all hostnames for +address+.\n
new Resolv::Hosts.new(filename = DefaultFileName)\nCreates a new Resolv::Hosts, using +filename+ for its data source.\n
each_address Resolv::Hosts.each_address(name, &proc)\nIterates over all IP addresses for +name+ retrieved from the hosts file.\n
each_name Resolv::Hosts.each_name(address, &proc)\nIterates over all hostnames for +address+ retrieved from the hosts file.\n
getaddress Resolv::Hosts.getaddress(name)\nGets the IP address of +name+ from the hosts file.\n
getaddresses Resolv::Hosts.getaddresses(name)\nGets all IP addresses for +name+ from the hosts file.\n
getname Resolv::Hosts.getname(address)\nGets the hostname of +address+ from the hosts file.\n
getnames Resolv::Hosts.getnames(address)\nGets all hostnames for +address+ from the hosts file.\n
new Resolv::DNS.new(config_info=nil)\nCreates a new DNS resolver.\n\n+config_info+ can be:\n\nnil:: Uses /etc/resolv.conf.\nString:: Path to a file using /etc/resolv.conf's format.\nHash:: Must contain :nameserver, :search and :ndots keys.\n:nameserver_port can be used to specify port number of nameserver address.\n\nThe value of :nameserver should be an address string or\nan array of address strings.\n- :nameserver => '8.8.8.8'\n- :nameserver => ['8.8.8.8', '8.8.4.4']\n\nThe value of :nameserver_port should be an array of\npair of nameserver address and port number.\n- :nameserver_port => [['8.8.8.8', 53], ['8.8.4.4', 53]]\n\nExample:\n\n  Resolv::DNS.new(:nameserver => ['210.251.121.21'],\n                  :search => ['ruby-lang.org'],\n                  :ndots => 1)\n
open Resolv::DNS.open(*args)\nCreates a new DNS resolver.  See Resolv::DNS.new for argument details.\n\nYields the created DNS resolver to the block, if given, otherwise\nreturns it.\n
close Resolv::DNS.close()\nCloses the DNS resolver.\n
each_address Resolv::DNS.each_address(name)\nIterates over all IP addresses for +name+ retrieved from the DNS\nresolver.\n\n+name+ can be a Resolv::DNS::Name or a String.  Retrieved addresses will\nbe a Resolv::IPv4 or Resolv::IPv6\n
each_name Resolv::DNS.each_name(address)\nIterates over all hostnames for +address+ retrieved from the DNS\nresolver.\n\n+address+ must be a Resolv::IPv4, Resolv::IPv6 or a String.  Retrieved\nnames will be Resolv::DNS::Name instances.\n
each_resource Resolv::DNS.each_resource(name, typeclass, &proc)\nIterates over all +typeclass+ DNS resources for +name+.  See\ngetresource for argument details.\n
getaddress Resolv::DNS.getaddress(name)\nGets the IP address of +name+ from the DNS resolver.\n\n+name+ can be a Resolv::DNS::Name or a String.  Retrieved address will\nbe a Resolv::IPv4 or Resolv::IPv6\n
getaddresses Resolv::DNS.getaddresses(name)\nGets all IP addresses for +name+ from the DNS resolver.\n\n+name+ can be a Resolv::DNS::Name or a String.  Retrieved addresses will\nbe a Resolv::IPv4 or Resolv::IPv6\n
getname Resolv::DNS.getname(address)\nGets the hostname for +address+ from the DNS resolver.\n\n+address+ must be a Resolv::IPv4, Resolv::IPv6 or a String.  Retrieved\nname will be a Resolv::DNS::Name.\n
getnames Resolv::DNS.getnames(address)\nGets all hostnames for +address+ from the DNS resolver.\n\n+address+ must be a Resolv::IPv4, Resolv::IPv6 or a String.  Retrieved\nnames will be Resolv::DNS::Name instances.\n
getresource Resolv::DNS.getresource(name, typeclass)\nLook up the +typeclass+ DNS resource of +name+.\n\n+name+ must be a Resolv::DNS::Name or a String.\n\n+typeclass+ should be one of the following:\n\n* Resolv::DNS::Resource::IN::A\n* Resolv::DNS::Resource::IN::AAAA\n* Resolv::DNS::Resource::IN::ANY\n* Resolv::DNS::Resource::IN::CNAME\n* Resolv::DNS::Resource::IN::HINFO\n* Resolv::DNS::Resource::IN::MINFO\n* Resolv::DNS::Resource::IN::MX\n* Resolv::DNS::Resource::IN::NS\n* Resolv::DNS::Resource::IN::PTR\n* Resolv::DNS::Resource::IN::SOA\n* Resolv::DNS::Resource::IN::TXT\n* Resolv::DNS::Resource::IN::WKS\n\nReturned resource is represented as a Resolv::DNS::Resource instance,\ni.e. Resolv::DNS::Resource::IN::A.\n
getresources Resolv::DNS.getresources(name, typeclass)\nLooks up all +typeclass+ DNS resources for +name+.  See #getresource for\nargument details.\n
create Resolv::DNS::Name.create(arg)\nCreates a new DNS name from +arg+.  +arg+ can be:\n\nName:: returns +arg+.\nString:: Creates a new Name.\n
absolute? Resolv::DNS::Name.absolute?()\nTrue if this name is absolute.\n
subdomain_of? Resolv::DNS::Name.subdomain_of?(other)\nReturns true if +other+ is a subdomain.\n\nExample:\n\n  domain = Resolv::DNS::Name.create("y.z")\n  p Resolv::DNS::Name.create("w.x.y.z").subdomain_of?(domain) #=> true\n  p Resolv::DNS::Name.create("x.y.z").subdomain_of?(domain) #=> true\n  p Resolv::DNS::Name.create("y.z").subdomain_of?(domain) #=> false\n  p Resolv::DNS::Name.create("z").subdomain_of?(domain) #=> false\n  p Resolv::DNS::Name.create("x.y.z.").subdomain_of?(domain) #=> false\n  p Resolv::DNS::Name.create("w.z").subdomain_of?(domain) #=> false\n
to_s Resolv::DNS::Name.to_s()\nreturns the domain name as a string.\n\nThe domain name doesn't have a trailing dot even if the name object is\nabsolute.\n\nExample:\n\n  p Resolv::DNS::Name.create("x.y.z.").to_s #=> "x.y.z"\n  p Resolv::DNS::Name.create("x.y.z").to_s #=> "x.y.z"\n
new Resolv::DNS::Resource::Generic.new(data)\nCreates a new generic resource.\n
new Resolv::DNS::Resource::DomainName.new(name)\nCreates a new DomainName from +name+.\n
new Resolv::DNS::Resource::SOA.new(mname, rname, serial, refresh, retry_,\nexpire, minimum)\nCreates a new SOA record.  See the attr documentation for the\ndetails of each argument.\n
new Resolv::DNS::Resource::HINFO.new(cpu, os)\nCreates a new HINFO running +os+ on +cpu+.\n
new Resolv::DNS::Resource::MINFO.new(rmailbx, emailbx)\n\n
new Resolv::DNS::Resource::MX.new(preference, exchange)\nCreates a new MX record with +preference+, accepting mail at\n+exchange+.\n
new Resolv::DNS::Resource::TXT.new(first_string, *rest_strings)\n\n
data Resolv::DNS::Resource::TXT.data()\nReturns the concatenated string from +strings+.\n
new Resolv::DNS::Resource::IN::A.new(address)\nCreates a new A for +address+.\n
new Resolv::DNS::Resource::IN::WKS.new(address, protocol, bitmap)\n\n
new Resolv::DNS::Resource::IN::AAAA.new(address)\nCreates a new AAAA for +address+.\n
new Resolv::DNS::Resource::IN::SRV.new(priority, weight, port, target)\nCreate a SRV resource record.\n\nSee the documentation for #priority, #weight, #port and #target\nfor +priority+, +weight+, +port and +target+ respectively.\n
create Resolv::IPv4.create(arg)\n\n
to_name Resolv::IPv4.to_name()\nTurns this IPv4 address into a Resolv::DNS::Name.\n
create Resolv::IPv6.create(arg)\nCreates a new IPv6 address from +arg+ which may be:\n\nIPv6:: returns +arg+.\nString:: +arg+ must match one of the IPv6::Regex* constants\n
to_name Resolv::IPv6.to_name()\nTurns this IPv6 address into a Resolv::DNS::Name.\n
accept OptionParser.accept(*args, &blk)\nSee #accept.\n
each_const OptionParser.each_const(path, base = ::Object)\n\n
getopts OptionParser.getopts(*args)\nSee #getopts.\n
inc OptionParser.inc(arg, default = nil)\nReturns an incremented value of +default+ according to +arg+.\n
new OptionParser.new(banner = nil, width = 32, indent = ' ' * 4)\nInitializes the instance and yields itself if called with a block.\n\n+banner+:: Banner message.\n+width+::  Summary width.\n+indent+:: Summary indent.\n
reject OptionParser.reject(*args, &blk)\nSee #reject.\n
search_const OptionParser.search_const(klass, name)\n\n
show_version OptionParser.show_version(*pkgs)\n\n
terminate OptionParser.terminate(arg = nil)\n\n
top OptionParser.top()\n\n
with OptionParser.with(*args, &block)\nInitializes a new instance and evaluates the optional block in context\nof the instance. Arguments +args+ are passed to #new, see there for\ndescription of parameters.\n\nThis method is *deprecated*, its behavior corresponds to the older #new\nmethod.\n
abort OptionParser.abort(mesg = $!)\n\n
accept OptionParser.accept(*args, &blk)\nDirects to accept specified class +t+. The argument string is passed to\nthe block in which it should be converted to the desired class.\n\n+t+::   Argument class specifier, any object including Class.\n+pat+:: Pattern for argument, defaults to +t+ if it responds to match.\n\n  accept(t, pat, &block)\n
banner OptionParser.banner()\nHeading banner preceding summary.\n
base OptionParser.base()\nSubject of #on_tail.\n
candidate OptionParser.candidate(word)\n\n
def_head_option OptionParser.def_head_option(*opts, &block)\n\n
def_option OptionParser.def_option(*opts, &block)\n\n
def_tail_option OptionParser.def_tail_option(*opts, &block)\n\n
define OptionParser.define(*opts, &block)\n\n
define_head OptionParser.define_head(*opts, &block)\n\n
define_tail OptionParser.define_tail(*opts, &block)\n\n
environment OptionParser.environment(env = File.basename($0, '.*'))\nParses environment variable +env+ or its uppercase with splitting like a\nshell.\n\n+env+ defaults to the basename of the program.\n
getopts OptionParser.getopts(*args)\nWrapper method for getopts.rb.\n\n  params = ARGV.getopts("ab:", "foo", "bar:")\n params[:a] = true   # -a\n params[:b] = "1"    # -b1\n params[:foo] = "1"  # --foo\n params[:bar] = "x"  # --bar x\n
help OptionParser.help()\nReturns option summary string.\n
inc OptionParser.inc(*args)\n\n
load OptionParser.load(filename = nil)\nLoads options from file names as +filename+. Does nothing when the file\nis not present. Returns whether successfully loaded.\n\n+filename+ defaults to basename of the program without suffix in a\ndirectory ~/.options.\n
make_switch OptionParser.make_switch(opts, block = nil)\nCreates an OptionParser::Switch from the parameters. The parsed argument\nvalue is passed to the given block, where it can be processed.\n\nSee at the beginning of OptionParser for some full examples.\n\n+opts+ can include the following elements:\n\n[Argument style:]\n  One of the following:\n    :NONE, :REQUIRED, :OPTIONAL\n\n[Argument pattern:]\n  Acceptable option argument format, must be pre-defined with\n  OptionParser.accept or OptionParser#accept, or Regexp. This can appear\n  once or assigned as String if not present, otherwise causes an\n  ArgumentError. Examples:\n    Float, Time, Array\n\n[Possible argument values:]\n  Hash or Array.\n    [:text, :binary, :auto]\n    %w[iso-2022-jp shift_jis euc-jp utf8 binary]\n    { "jis" => "iso-2022-jp", "sjis" => "shift_jis" }\n\n[Long style switch:]\n  Specifies a long style switch which takes a mandatory, optional or no\n  argument. It's a string of the following form:\n    "--switch=MANDATORY" or "--switch MANDATORY"\n    "--switch[=OPTIONAL]"\n    "--switch"\n\n[Short style switch:]\n  Specifies short style switch which takes a mandatory, optional or no\n  argument. It's a string of the following form:\n    "-xMANDATORY"\n    "-x[OPTIONAL]"\n    "-x"\n  There is also a special form which matches character range (not full\n  set of regular expression):\n    "-[a-z]MANDATORY"\n    "-[a-z][OPTIONAL]"\n    "-[a-z]"\n\n[Argument style and description:]\n  Instead of specifying mandatory or optional arguments directly in the\n  switch parameter, this separate parameter can be used.\n    "=MANDATORY"\n    "=[OPTIONAL]"\n\n[Description:]\n  Description string for the option.\n    "Run verbosely"\n\n[Handler:]\n  Handler for the parsed argument value. Either give a block or pass a\n  Proc or Method as an argument.\n
new OptionParser.new()\nPushes a new List.\n
on OptionParser.on(*opts, &block)\nAdd option switch and handler. See #make_switch for an explanation of\nparameters.\n
on_head OptionParser.on_head(*opts, &block)\nAdd option switch like with #on, but at head of summary.\n
on_tail OptionParser.on_tail(*opts, &block)\nAdd option switch like with #on, but at tail of summary.\n
order OptionParser.order(*argv, &block)\nParses command line arguments +argv+ in order. When a block is given,\neach non-option argument is yielded.\n\nReturns the rest of +argv+ left unparsed.\n
order! OptionParser.order!(argv = default_argv, &nonopt)\nSame as #order, but removes switches destructively.\n
parse OptionParser.parse(*argv)\nParses command line arguments +argv+ in order when environment variable\nPOSIXLY_CORRECT is set, and in permutation mode otherwise.\n
parse! OptionParser.parse!(argv = default_argv)\nSame as #parse, but removes switches destructively.\n
permute OptionParser.permute(*argv)\nParses command line arguments +argv+ in permutation mode and returns\nlist of non-option arguments.\n
permute! OptionParser.permute!(argv = default_argv)\nSame as #permute, but removes switches destructively.\n
program_name OptionParser.program_name()\nProgram name to be emitted in error message and default banner, defaults\nto $0.\n
reject OptionParser.reject(*args, &blk)\nDirects to reject specified class argument.\n\n+t+:: Argument class specifier, any object including Class.\n\n  reject(t)\n
release OptionParser.release()\nRelease code\n
remove OptionParser.remove()\nRemoves the last List.\n
separator OptionParser.separator(string)\nAdd separator in summary.\n
summarize OptionParser.summarize(to = [], width = @summary_width, max = width - 1,\nindent = @summary_indent, &blk)\nPuts option summary into +to+ and returns +to+. Yields each line if\na block is given.\n\n+to+:: Output destination, which must have method <<. Defaults to [].\n+width+:: Width of left side, defaults to @summary_width.\n+max+:: Maximum length allowed for left side, defaults to +width+ - 1.\n+indent+:: Indentation, defaults to @summary_indent.\n
terminate OptionParser.terminate(arg = nil)\nTerminates option parsing. Optional parameter +arg+ is a string pushed\nback to be the first non-option argument.\n
to_a OptionParser.to_a()\nReturns option summary list.\n
to_s OptionParser.to_s()\n\n
top OptionParser.top()\nSubject of #on / #on_head, #accept / #reject\n
ver OptionParser.ver()\nReturns version string from program_name, version and release.\n
version OptionParser.version()\nVersion\n
warn OptionParser.warn(mesg = $!)\n\n
guess OptionParser::Switch.guess(arg)\nGuesses argument style from +arg+.  Returns corresponding\nOptionParser::Switch class (OptionalArgument, etc.).\n
incompatible_argument_styles OptionParser::Switch.incompatible_argument_styles(arg, t)\n\n
new OptionParser::Switch.new(pattern = nil, conv = nil, short = nil, long = nil,\narg = nil, desc = ([] if short or long), block = Proc.new)\n\n
pattern OptionParser::Switch.pattern()\n\n
summarize OptionParser::Switch.summarize(sdone = [], ldone = [], width = 1, max =\nwidth - 1, indent = "")\nProduces the summary text. Each line of the summary is yielded to the\nblock (without newline).\n\n+sdone+::  Already summarized short style options keyed hash.\n+ldone+::  Already summarized long style options keyed hash.\n+width+::  Width of left side (option part). In other words, the right\n           side (description part) starts after +width+ columns.\n+max+::    Maximum width of left side -> the options are filled within\n           +max+ columns.\n+indent+:: Prefix string indents all summarized lines.\n
switch_name OptionParser::Switch.switch_name()\nMain name of the switch.\n
incompatible_argument_styles OptionParser::Switch::NoArgument.incompatible_argument_styles(*)\n\n
pattern OptionParser::Switch::NoArgument.pattern()\n\n
parse OptionParser::Switch::NoArgument.parse(arg, argv)\nRaises an exception if any arguments given.\n
parse OptionParser::Switch::RequiredArgument.parse(arg, argv)\nRaises an exception if argument is not present.\n
parse OptionParser::Switch::OptionalArgument.parse(arg, argv, &error)\nParses argument if given, or uses default value.\n
parse OptionParser::Switch::PlacedArgument.parse(arg, argv, &error)\nReturns nil if argument is not present or begins with '-'.\n
new OptionParser::List.new()\nJust initializes all instance variables.\n
accept OptionParser::List.accept(t, pat = /.*/m, &block)\nSee OptionParser.accept.\n
append OptionParser::List.append(*args)\nAppends +switch+ at the tail of the list, and associates short, long\nand negated long options. Arguments are:\n\n+switch+::      OptionParser::Switch instance to be inserted.\n+short_opts+::  List of short style options.\n+long_opts+::   List of long style options.\n+nolong_opts+:: List of long style options with "no-" prefix.\n\n  append(switch, short_opts, long_opts, nolong_opts)\n
complete OptionParser::List.complete(id, opt, icase = false, *pat, &block)\nSearches list +id+ for +opt+ and the optional patterns for completion\n+pat+. If +icase+ is true, the search is case insensitive. The result\nis returned or yielded if a block is given. If it isn't found, nil is\nreturned.\n
each_option OptionParser::List.each_option(&block)\nIterates over each option, passing the option to the +block+.\n
prepend OptionParser::List.prepend(*args)\nInserts +switch+ at the head of the list, and associates short, long\nand negated long options. Arguments are:\n\n+switch+::      OptionParser::Switch instance to be inserted.\n+short_opts+::  List of short style options.\n+long_opts+::   List of long style options.\n+nolong_opts+:: List of long style options with "no-" prefix.\n\n  prepend(switch, short_opts, long_opts, nolong_opts)\n
reject OptionParser::List.reject(t)\nSee OptionParser.reject.\n
search OptionParser::List.search(id, key)\nSearches +key+ in +id+ list. The result is returned or yielded if a\nblock is given. If it isn't found, nil is returned.\n
summarize OptionParser::List.summarize(*args, &block)\nCreates the summary table, passing each line to the +block+ (without\nnewline). The arguments +args+ are passed along to the summarize\nmethod which is called on every option.\n
match OptionParser::CompletingHash.match(key)\nCompletion for hash key.\n
filter_backtrace OptionParser::ParseError.filter_backtrace(array)\n\n
new OptionParser::ParseError.new(*args)\n\n
inspect OptionParser::ParseError.inspect()\n\n
message OptionParser::ParseError.message()\nDefault stringizing method to emit standard error message.\n
reason OptionParser::ParseError.reason()\nReturns error reason. Override this for I18N.\n
recover OptionParser::ParseError.recover(argv)\nPushes back erred argument(s) to +argv+.\n
set_backtrace OptionParser::ParseError.set_backtrace(array)\n\n
set_option OptionParser::ParseError.set_option(opt, eq)\n\n
to_s OptionParser::ParseError.to_s()\n\n
new GetoptLong.new(*arguments)\nSet up option processing.\n\nThe options to support are passed to new() as an array of arrays.\nEach sub-array contains any number of String option names which carry\nthe same meaning, and one of the following flags:\n\nGetoptLong::NO_ARGUMENT :: Option does not take an argument.\n\nGetoptLong::REQUIRED_ARGUMENT :: Option always takes an argument.\n\nGetoptLong::OPTIONAL_ARGUMENT :: Option may or may not take an argument.\n\nThe first option name is considered to be the preferred (canonical) name.\nOther than that, the elements of each sub-array can be in any order.\n
each GetoptLong.each()\nIterator version of `get'.\n\nThe block is called repeatedly with two arguments:\nThe first is the option name.\nThe second is the argument which followed it (if any).\nExample: ('--opt', 'value')\n\nThe option name is always converted to the first (preferred)\nname given in the original options to GetoptLong.new.\n
each_option GetoptLong.each_option()\n`each_option' is an alias of `each'.\n
error_message GetoptLong.error_message()\nReturn the appropriate error message in POSIX-defined format.\nIf no error has occurred, returns nil.\n
get GetoptLong.get()\nGet next option name and its argument, as an Array of two elements.\n\nThe option name is always converted to the first (preferred)\nname given in the original options to GetoptLong.new.\n\nExample: ['--option', 'value']\n\nReturns nil if the processing is complete (as determined by\nSTATUS_TERMINATED).\n
get_option GetoptLong.get_option()\n`get_option' is an alias of `get'.\n
ordering= GetoptLong.ordering=(ordering)\nSet the handling of the ordering of options and arguments.\nA RuntimeError is raised if option processing has already started.\n\nThe supplied value must be a member of GetoptLong::ORDERINGS. It alters\nthe processing of options as follows:\n\n<b>REQUIRE_ORDER</b> :\n\nOptions are required to occur before non-options.\n\nProcessing of options ends as soon as a word is encountered that has not\nbeen preceded by an appropriate option flag.\n\nFor example, if -a and -b are options which do not take arguments,\nparsing command line arguments of '-a one -b two' would result in\n'one', '-b', 'two' being left in ARGV, and only ('-a', '') being\nprocessed as an option/arg pair.\n\nThis is the default ordering, if the environment variable\nPOSIXLY_CORRECT is set. (This is for compatibility with GNU getopt_long.)\n\n<b>PERMUTE</b> :\n\nOptions can occur anywhere in the command line parsed. This is the\ndefault behavior.\n\nEvery sequence of words which can be interpreted as an option (with or\nwithout argument) is treated as an option; non-option words are skipped.\n\nFor example, if -a does not require an argument and -b optionally takes\nan argument, parsing '-a one -b two three' would result in ('-a','') and\n('-b', 'two') being processed as option/arg pairs, and 'one','three'\nbeing left in ARGV.\n\nIf the ordering is set to PERMUTE but the environment variable\nPOSIXLY_CORRECT is set, REQUIRE_ORDER is used instead. This is for\ncompatibility with GNU getopt_long.\n\n<b>RETURN_IN_ORDER</b> :\n\nAll words on the command line are processed as options. Words not\npreceded by a short or long option flag are passed as arguments\nwith an option of '' (empty string).\n\nFor example, if -a requires an argument but -b does not, a command line\nof '-a one -b two three' would result in option/arg pairs of ('-a', 'one')\n('-b', ''), ('', 'two'), ('', 'three') being processed.\n
set_error GetoptLong.set_error(type, message)\nSet an error (a protected method).\n
set_options GetoptLong.set_options(*arguments)\nSet options. Takes the same argument as GetoptLong.new.\n\nRaises a RuntimeError if option processing has already started.\n
terminate GetoptLong.terminate()\nExplicitly terminate option processing.\n
terminated? GetoptLong.terminated?()\nReturns true if option processing has terminated, false otherwise.\n
configured_args Gem::DocManager.configured_args()\n\n
configured_args= Gem::DocManager.configured_args=(args)\n\n
load_rdoc Gem::DocManager.load_rdoc()\nLoad RDoc from a gem if it is available, otherwise from Ruby's stdlib\n
new Gem::DocManager.new(spec, rdoc_args="")\nCreate a document manager for +spec+. +rdoc_args+ contains arguments for\nRDoc (template etc.) as a String.\n
rdoc_version Gem::DocManager.rdoc_version()\n\n
update_ri_cache Gem::DocManager.update_ri_cache()\nUpdates the RI cache for RDoc 2 if it is installed\n
generate_rdoc Gem::DocManager.generate_rdoc()\nGenerate the RDoc documents for this gem spec.\n\nNote that if both RI and RDoc documents are generated from the same\nprocess, the RI docs should be done first (a likely bug in RDoc will cause\nRI docs generation to fail if run after RDoc).\n
generate_ri Gem::DocManager.generate_ri()\nGenerate the RI documents for this gem spec.\n\nNote that if both RI and RDoc documents are generated from the same\nprocess, the RI docs should be done first (a likely bug in RDoc will cause\nRI docs generation to fail if run after RDoc).\n
install_rdoc Gem::DocManager.install_rdoc()\nGenerate and install RDoc into the documentation directory\n
install_ri Gem::DocManager.install_ri()\nGenerate and install RI into the documentation directory\n
rdoc_installed? Gem::DocManager.rdoc_installed?()\nIs the RDoc documentation installed?\n
ri_installed? Gem::DocManager.ri_installed?()\nIs the RI documentation installed?\n
run_rdoc Gem::DocManager.run_rdoc(*args)\nRun RDoc with +args+, which is an ARGV style argument list\n
setup_rdoc Gem::DocManager.setup_rdoc()\n\n
uninstall_doc Gem::DocManager.uninstall_doc()\nRemove RDoc and RI documentation\n
new Gem::ConfigFile.new(arg_list)\nCreate the config file object.  +args+ is the list of arguments\nfrom the command line.\n\nThe following command line options are handled early here rather\nthan later at the time most command options are processed.\n\n<tt>--config-file</tt>, <tt>--config-file==NAME</tt>::\n  Obviously these need to be handled by the ConfigFile object to ensure we\n  get the right config file.\n\n<tt>--backtrace</tt>::\n  Backtrace needs to be turned on early so that errors before normal\n  option parsing can be properly handled.\n\n<tt>--debug</tt>::\n  Enable Ruby level debug messages.  Handled early for the same reason as\n  --backtrace.\n
backtrace Gem::ConfigFile.backtrace()\nTrue if the backtrace option has been specified, or debug is on.\n
config_file_name Gem::ConfigFile.config_file_name()\nThe name of the configuration file.\n
credentials_path Gem::ConfigFile.credentials_path()\nLocation of RubyGems.org credentials\n
each Gem::ConfigFile.each(&block)\nDelegates to @hash\n
handle_arguments Gem::ConfigFile.handle_arguments(arg_list)\nHandle the command arguments.\n
load_api_keys Gem::ConfigFile.load_api_keys()\n\n
load_file Gem::ConfigFile.load_file(filename)\n\n
really_verbose Gem::ConfigFile.really_verbose()\nReally verbose mode gives you extra output.\n
rubygems_api_key= Gem::ConfigFile.rubygems_api_key=(api_key)\n\n
write Gem::ConfigFile.write()\nWrites out this config file, replacing its source.\n
fetcher Gem::RemoteFetcher.fetcher()\nCached RemoteFetcher instance.\n
fetcher= Gem::RemoteFetcher.fetcher=(fetcher)\n\n
new Gem::RemoteFetcher.new(proxy = nil)\nInitialize a remote fetcher using the source URI and possible proxy\ninformation.\n\n+proxy+\n* [String]: explicit specification of proxy; overrides any environment\n            variable setting\n* nil: respect environment variables (HTTP_PROXY, HTTP_PROXY_USER,\n       HTTP_PROXY_PASS)\n* <tt>:no_proxy</tt>: ignore environment variables and _don't_ use a proxy\n
add_rubygems_trusted_certs Gem::RemoteFetcher.add_rubygems_trusted_certs(store)\n\n
configure_connection_for_https Gem::RemoteFetcher.configure_connection_for_https(connection)\n\n
connection_for Gem::RemoteFetcher.connection_for(uri)\nCreates or an HTTP connection based on +uri+, or retrieves an existing\nconnection, using a proxy if needed.\n
correct_for_windows_path Gem::RemoteFetcher.correct_for_windows_path(path)\n\n
download Gem::RemoteFetcher.download(spec, source_uri, install_dir = Gem.dir)\nMoves the gem +spec+ from +source_uri+ to the cache dir unless it is\nalready there.  If the source_uri is local the gem cache dir copy is\nalways replaced.\n
download_to_cache Gem::RemoteFetcher.download_to_cache(dependency)\nGiven a name and requirement, downloads this gem into cache and returns the\nfilename. Returns nil if the gem cannot be located.\n
escape Gem::RemoteFetcher.escape(str)\n\n
fetch_file Gem::RemoteFetcher.fetch_file(uri, *_)\nFile Fetcher. Dispatched by +fetch_path+. Use it instead.\n
fetch_http Gem::RemoteFetcher.fetch_http(uri, last_modified = nil, head = false, depth\n= 0)\nHTTP Fetcher. Dispatched by +fetch_path+. Use it instead.\n
fetch_https Gem::RemoteFetcher.fetch_https(uri, last_modified = nil, head = false,\ndepth = 0)\n\n
fetch_path Gem::RemoteFetcher.fetch_path(uri, mtime = nil, head = false)\nDownloads +uri+ and returns it as a String.\n
fetch_size Gem::RemoteFetcher.fetch_size(uri)\nReturns the size of +uri+ in bytes.\n
get_proxy_from_env Gem::RemoteFetcher.get_proxy_from_env()\nReturns an HTTP proxy URI if one is set in the environment variables.\n
https? Gem::RemoteFetcher.https?(uri)\n\n
normalize_uri Gem::RemoteFetcher.normalize_uri(uri)\nNormalize the URI by adding "http://" if it is missing.\n
open_uri_or_path Gem::RemoteFetcher.open_uri_or_path(uri, last_modified = nil, head = false,\ndepth = 0)\nRead the data from the (source based) URI, but if it is a file:// URI,\nread from the filesystem instead.\n
request Gem::RemoteFetcher.request(uri, request_class, last_modified = nil)\nPerforms a Net::HTTP request of type +request_class+ on +uri+ returning\na Net::HTTP response object.  request maintains a table of persistent\nconnections to reduce connect overhead.\n
reset Gem::RemoteFetcher.reset(connection)\nResets HTTP connection +connection+.\n
unescape Gem::RemoteFetcher.unescape(str)\n\n
uri_escaper Gem::RemoteFetcher.uri_escaper()\n\n
user_agent Gem::RemoteFetcher.user_agent()\n\n
new Gem::RemoteFetcher::FetchError.new(message, uri)\n\n
new Gem::FilePermissionError.new(path)\n\n
new Gem::GemNotFoundException.new(msg, name=nil, version=nil, errors=nil)\n\n
new Gem::SystemExitException.new(exit_code)\n\n
local Gem::Platform.local()\n\n
match Gem::Platform.match(platform)\n\n
new Gem::Platform.new(arch)\n\n
empty? Gem::Platform.empty?()\n\n
eql? Gem::Platform.eql?(other)\n\n
inspect Gem::Platform.inspect()\n\n
to_a Gem::Platform.to_a()\n\n
to_s Gem::Platform.to_s()\n\n
from_gems_in Gem::SourceIndex.from_gems_in(*spec_dirs)\nCreates a new SourceIndex from the ruby format gem specifications in\n+spec_dirs+.\n
from_installed_gems Gem::SourceIndex.from_installed_gems(*deprecated)\nFactory method to construct a source index instance for a given\npath.\n\ndeprecated::\n  If supplied, from_installed_gems will act just like\n  +from_gems_in+.  This argument is deprecated and is provided\n  just for backwards compatibility, and should not generally\n  be used.\n\nreturn::\n  SourceIndex instance\n
installed_spec_directories Gem::SourceIndex.installed_spec_directories()\nReturns a list of directories from Gem.path that contain specifications.\n
load_specification Gem::SourceIndex.load_specification(file_name)\nLoads a ruby-format specification from +file_name+ and returns the\nloaded spec.\n
new Gem::SourceIndex.new(specs_or_dirs = [])\nConstructs a source index instance from the provided specifications, which\nis a Hash of gem full names and Gem::Specifications.\n
add_spec Gem::SourceIndex.add_spec(gem_spec, name = gem_spec.full_name)\nAdd a gem specification to the source index.\n
add_specs Gem::SourceIndex.add_specs(*gem_specs)\nAdd gem specifications to the source index.\n
all_gems Gem::SourceIndex.all_gems()\n\n
dump Gem::SourceIndex.dump()\n\n
each Gem::SourceIndex.each()\nIterate over the specifications in the source index.\n
find_name Gem::SourceIndex.find_name(gem_name, requirement = Gem::Requirement.default)\nFind a gem by an exact match on the short name.\n
gem_signature Gem::SourceIndex.gem_signature(gem_full_name)\nThe signature for the given gem specification.\n
index_signature Gem::SourceIndex.index_signature()\nThe signature for the source index.  Changes in the signature indicate a\nchange in the index.\n
latest_specs Gem::SourceIndex.latest_specs(include_prerelease=false)\nReturns an Array specifications for the latest released versions\nof each gem in this index.\n
length Gem::SourceIndex.length()\n\n
load_gems_in Gem::SourceIndex.load_gems_in(*spec_dirs)\nReconstruct the source index from the specifications in +spec_dirs+.\n
outdated Gem::SourceIndex.outdated()\nReturns an Array of Gem::Specifications that are not up to date.\n
prerelease_gems Gem::SourceIndex.prerelease_gems()\n\n
prerelease_specs Gem::SourceIndex.prerelease_specs()\nAn array including only the prerelease gemspecs\n
refresh! Gem::SourceIndex.refresh!()\nReplaces the gems in the source index from specifications in the\ndirectories this source index was created from.  Raises an exception if\nthis source index wasn't created from a directory (via from_gems_in or\nfrom_installed_gems, or having spec_dirs set).\n
released_gems Gem::SourceIndex.released_gems()\n\n
released_specs Gem::SourceIndex.released_specs()\nAn array including only the released gemspecs\n
remove_spec Gem::SourceIndex.remove_spec(full_name)\nRemove a gem specification named +full_name+.\n
search Gem::SourceIndex.search(gem_pattern, platform_or_requirement = false)\nSearch for a gem by Gem::Dependency +gem_pattern+.  If +only_platform+\nis true, only gems matching Gem::Platform.local will be returned.  An\nArray of matching Gem::Specification objects is returned.\n\nFor backwards compatibility, a String or Regexp pattern may be passed as\n+gem_pattern+, and a Gem::Requirement for +platform_only+.  This\nbehavior is deprecated and will be removed.\n
size Gem::SourceIndex.size()\n\n
specification Gem::SourceIndex.specification(full_name)\nThe gem specification given a full gem spec name.\n
new Gem::PathSupport.new(env=ENV)\nConstructor. Takes a single argument which is to be treated like a\nhashtable, or defaults to ENV, the system environment.\n
create Gem::Requirement.create(input)\nFactory method to create a Gem::Requirement object.  Input may be\na Version, a String, or nil.  Intended to simplify client code.\n\nIf the input is "weird", the default version requirement is\nreturned.\n
default Gem::Requirement.default()\nA default "version requirement" can surely _only_ be '>= 0'.\n
new Gem::Requirement.new(*requirements)\nConstructs a requirement from +requirements+. Requirements can be\nStrings, Gem::Versions, or Arrays of those. +nil+ and duplicate\nrequirements are ignored. An empty set of +requirements+ is the\nsame as <tt>">= 0"</tt>.\n
parse Gem::Requirement.parse(obj)\nParse +obj+, returning an <tt>[op, version]</tt> pair. +obj+ can\nbe a String or a Gem::Version.\n\nIf +obj+ is a String, it can be either a full requirement\nspecification, like <tt>">= 1.2"</tt>, or a simple version number,\nlike <tt>"1.2"</tt>.\n\n    parse("> 1.0")                 # => [">", "1.0"]\n    parse("1.0")                   # => ["=", "1.0"]\n    parse(Gem::Version.new("1.0")) # => ["=,  "1.0"]\n
none? Gem::Requirement.none?()\n\n
prerelease? Gem::Requirement.prerelease?()\n\n
satisfied_by? Gem::Requirement.satisfied_by?(version)\nTrue if +version+ satisfies this Requirement.\n
specific? Gem::Requirement.specific?()\nTrue if the requirement will not always match the latest version.\n
create Gem::Requirement.create(input)\nFactory method to create a Gem::Requirement object.  Input may be\na Version, a String, or nil.  Intended to simplify client code.\n\nIf the input is "weird", the default version requirement is\nreturned.\n
default Gem::Requirement.default()\nA default "version requirement" can surely _only_ be '>= 0'.\n
new Gem::Requirement.new(*requirements)\nConstructs a requirement from +requirements+. Requirements can be\nStrings, Gem::Versions, or Arrays of those. +nil+ and duplicate\nrequirements are ignored. An empty set of +requirements+ is the\nsame as <tt>">= 0"</tt>.\n
parse Gem::Requirement.parse(obj)\nParse +obj+, returning an <tt>[op, version]</tt> pair. +obj+ can\nbe a String or a Gem::Version.\n\nIf +obj+ is a String, it can be either a full requirement\nspecification, like <tt>">= 1.2"</tt>, or a simple version number,\nlike <tt>"1.2"</tt>.\n\n    parse("> 1.0")                 # => [">", "1.0"]\n    parse("1.0")                   # => ["=", "1.0"]\n    parse(Gem::Version.new("1.0")) # => ["=,  "1.0"]\n
none? Gem::Requirement.none?()\n\n
prerelease? Gem::Requirement.prerelease?()\n\n
satisfied_by? Gem::Requirement.satisfied_by?(version)\nTrue if +version+ satisfies this Requirement.\n
specific? Gem::Requirement.specific?()\nTrue if the requirement will not always match the latest version.\n
_httpdate Date._httpdate(p1)\nReturns a hash of parsed elements.\n
_iso8601 Date._iso8601(p1)\nReturns a hash of parsed elements.\n
_jisx0301 Date._jisx0301(p1)\nReturns a hash of parsed elements.\n
_parse Date._parse(*args)\nParses the given representation of date and time, and returns a\nhash of parsed elements.\n\nIf the optional second argument is true and the detected year is in\nthe range "00" to "99", considers the year a 2-digit form and makes\nit full.\n\nFor example:\n\n   Date._parse('2001-02-03') #=> {:year=>2001, :mon=>2, :mday=>3}\n
_rfc2822 Date._rfc2822(p1)\nReturns a hash of parsed elements.\n
_rfc3339 Date._rfc3339(p1)\nReturns a hash of parsed elements.\n
_rfc822 Date._rfc822(p1)\nReturns a hash of parsed elements.\n
_strptime Date._strptime(*args)\nParses the given representation of date and time with the given\ntemplate, and returns a hash of parsed elements.\n\nFor example:\n\n   Date._strptime('2001-02-03', '%Y-%m-%d')\n=> {:year=>2001, :mon=>2, :mday=>3}\n\n See also strptime(3) and strftime.\n
_xmlschema Date._xmlschema(p1)\nReturns a hash of parsed elements.\n
civil Date.civil(p1 = v1, p2 = v2, p3 = v3, p4 = v4)\nCreates a date object denoting the given calendar date.\n\nIn this class, BCE years are counted astronomically.  Thus, the\nyear before the year 1 is the year zero, and the year preceding the\nyear zero is the year -1.  The month and the day of month should be\na negative or a positive number (as a relative month/day from the\nend of year/month when negative).  They should not be zero.\n\nThe last argument should be a Julian day number which denotes the\nday of calendar reform.  Date::ITALY (2299161=1582-10-15),\nDate::ENGLAND (2361222=1752-09-14), Date::GREGORIAN (the proleptic\nGregorian calendar) and Date::JULIAN (the proleptic Julian\ncalendar) can be specified as a day of calendar reform.\n\nFor example:\n\n   Date.new(2001)            #=> #<Date: 2001-01-01 ...>\n   Date.new(2001,2,3)        #=> #<Date: 2001-02-03 ...>\n   Date.new(2001,2,-1)       #=> #<Date: 2001-02-28 ...>\n\nSee also jd.\n
commercial Date.commercial(p1 = v1, p2 = v2, p3 = v3, p4 = v4)\nCreates a date object denoting the given week date.\n\nThe week and the day of week should be a negative or a positive\nnumber (as a relative week/day from the end of year/week when\nnegative).  They should not be zero.\n\nFor example:\n\n   Date.commercial(2001)     #=> #<Date: 2001-01-01 ...>\n   Date.commercial(2002)     #=> #<Date: 2001-12-31 ...>\n   Date.commercial(2001,5,6) #=> #<Date: 2001-02-03 ...>\n\nSee also jd and new.\n
gregorian_leap? Date.gregorian_leap?(p1)\nReturns true if the given year is a leap year of the proleptic\nGregorian calendar.\n\nFor example:\n\n   Date.gregorian_leap?(1900)        #=> false\n   Date.gregorian_leap?(2000)        #=> true\n
httpdate Date.httpdate(p1 = v1, p2 = v2)\nCreates a new Date object by parsing from a string according to\nsome RFC 2616 format.\n\nFor example:\n\n   Date.httpdate('Sat, 03 Feb 2001 00:00:00 GMT')\n=> #<Date: 2001-02-03 ...>\n
iso8601 Date.iso8601(p1 = v1, p2 = v2)\nCreates a new Date object by parsing from a string according to\nsome typical ISO 8601 formats.\n\nFor example:\n\n   Date.iso8601('2001-02-03')        #=> #<Date: 2001-02-03 ...>\n   Date.iso8601('20010203')          #=> #<Date: 2001-02-03 ...>\n   Date.iso8601('2001-W05-6')        #=> #<Date: 2001-02-03 ...>\n
jd Date.jd(p1 = v1, p2 = v2)\nCreates a date object denoting the given chronological Julian day\nnumber.\n\nFor example:\n\n   Date.jd(2451944)          #=> #<Date: 2001-02-03 ...>\n   Date.jd(2451945)          #=> #<Date: 2001-02-04 ...>\n   Date.jd(0)                #=> #<Date: -4712-01-01 ...>\n\nSee also new.\n
jisx0301 Date.jisx0301(p1 = v1, p2 = v2)\nCreates a new Date object by parsing from a string according to\nsome typical JIS X 0301 formats.\n\nFor example:\n\n   Date.jisx0301('H13.02.03')                #=> #<Date: 2001-02-03 ...>\n
json_create Date.json_create(object)\nDeserializes JSON string by converting Julian year <tt>y</tt>, month\n<tt>m</tt>, day <tt>d</tt> and Day of Calendar Reform <tt>sg</tt> to Date.\n
julian_leap? Date.julian_leap?(p1)\nReturns true if the given year is a leap year of the proleptic\nJulian calendar.\n\nFor example:\n\n   Date.julian_leap?(1900)           #=> true\n   Date.julian_leap?(1901)           #=> false\n
leap? Date.leap?(p1)\nReturns true if the given year is a leap year of the proleptic\nGregorian calendar.\n\nFor example:\n\n   Date.gregorian_leap?(1900)        #=> false\n   Date.gregorian_leap?(2000)        #=> true\n
new Date.new(p1 = v1, p2 = v2, p3 = v3, p4 = v4)\nCreates a date object denoting the given calendar date.\n\nIn this class, BCE years are counted astronomically.  Thus, the\nyear before the year 1 is the year zero, and the year preceding the\nyear zero is the year -1.  The month and the day of month should be\na negative or a positive number (as a relative month/day from the\nend of year/month when negative).  They should not be zero.\n\nThe last argument should be a Julian day number which denotes the\nday of calendar reform.  Date::ITALY (2299161=1582-10-15),\nDate::ENGLAND (2361222=1752-09-14), Date::GREGORIAN (the proleptic\nGregorian calendar) and Date::JULIAN (the proleptic Julian\ncalendar) can be specified as a day of calendar reform.\n\nFor example:\n\n   Date.new(2001)            #=> #<Date: 2001-01-01 ...>\n   Date.new(2001,2,3)        #=> #<Date: 2001-02-03 ...>\n   Date.new(2001,2,-1)       #=> #<Date: 2001-02-28 ...>\n\nSee also jd.\n
ordinal Date.ordinal(p1 = v1, p2 = v2, p3 = v3)\nCreates a date object denoting the given ordinal date.\n\nThe day of year should be a negative or a positive number (as a\nrelative day from the end of year when negative).  It should not be\nzero.\n\nFor example:\n\n   Date.ordinal(2001)        #=> #<Date: 2001-01-01 ...>\n   Date.ordinal(2001,34)     #=> #<Date: 2001-02-03 ...>\n   Date.ordinal(2001,-1)     #=> #<Date: 2001-12-31 ...>\n\nSee also jd and new.\n
parse Date.parse(p1 = v1, p2 = v2, p3 = v3)\nParses the given representation of date and time, and creates a\ndate object.\n\nIf the optional second argument is true and the detected year is in\nthe range "00" to "99", considers the year a 2-digit form and makes\nit full.\n\nFor example:\n\n   Date.parse('2001-02-03')          #=> #<Date: 2001-02-03 ...>\n   Date.parse('20010203')            #=> #<Date: 2001-02-03 ...>\n   Date.parse('3rd Feb 2001')        #=> #<Date: 2001-02-03 ...>\n
rfc2822 Date.rfc2822(p1 = v1, p2 = v2)\nCreates a new Date object by parsing from a string according to\nsome typical RFC 2822 formats.\n\nFor example:\n\n   Date.rfc2822('Sat, 3 Feb 2001 00:00:00 +0000')\n=> #<Date: 2001-02-03 ...>\n
rfc3339 Date.rfc3339(p1 = v1, p2 = v2)\nCreates a new Date object by parsing from a string according to\nsome typical RFC 3339 formats.\n\nFor example:\n\n   Date.rfc3339('2001-02-03T04:05:06+07:00') #=> #<Date: 2001-02-03 ...>\n
rfc822 Date.rfc822(p1 = v1, p2 = v2)\nCreates a new Date object by parsing from a string according to\nsome typical RFC 2822 formats.\n\nFor example:\n\n   Date.rfc2822('Sat, 3 Feb 2001 00:00:00 +0000')\n=> #<Date: 2001-02-03 ...>\n
strptime Date.strptime(p1 = v1, p2 = v2, p3 = v3)\nParses the given representation of date and time with the given\ntemplate, and creates a date object.\n\nFor example:\n\n   Date.strptime('2001-02-03', '%Y-%m-%d')   #=> #<Date: 2001-02-03 ...>\n   Date.strptime('03-02-2001', '%d-%m-%Y')   #=> #<Date: 2001-02-03 ...>\n   Date.strptime('2001-034', '%Y-%j')        #=> #<Date: 2001-02-03 ...>\n   Date.strptime('2001-W05-6', '%G-W%V-%u')  #=> #<Date: 2001-02-03 ...>\n   Date.strptime('2001 04 6', '%Y %U %w')    #=> #<Date: 2001-02-03 ...>\n   Date.strptime('2001 05 6', '%Y %W %u')    #=> #<Date: 2001-02-03 ...>\n   Date.strptime('sat3feb01', '%a%d%b%y')    #=> #<Date: 2001-02-03 ...>\n\nSee also strptime(3) and strftime.\n
today Date.today(p1 = v1)\nFor example:\n\n   Date.today                #=> #<Date: 2011-06-11 ..>\n\nCreates a date object denoting the present day.\n
valid_civil? Date.valid_civil?(p1, p2, p3, p4 = v4)\nReturns true if the given calendar date is valid, and false if not.\n\nFor example:\n\n   Date.valid_date?(2001,2,3)        #=> true\n   Date.valid_date?(2001,2,29)       #=> false\n\nSee also jd and civil.\n
valid_commercial? Date.valid_commercial?(p1, p2, p3, p4 = v4)\nReturns true if the given week date is valid, and false if not.\n\nFor example:\n\n   Date.valid_commercial?(2001,5,6)  #=> true\n   Date.valid_commercial?(2001,5,8)  #=> false\n\nSee also jd and commercial.\n
valid_date? Date.valid_date?(p1, p2, p3, p4 = v4)\nReturns true if the given calendar date is valid, and false if not.\n\nFor example:\n\n   Date.valid_date?(2001,2,3)        #=> true\n   Date.valid_date?(2001,2,29)       #=> false\n\nSee also jd and civil.\n
valid_jd? Date.valid_jd?(p1, p2 = v2)\nJust returns true.  It's nonsense, but is for symmetry.\n\nFor example:\n\n   Date.valid_jd?(2451944)           #=> true\n\nSee also jd.\n
valid_ordinal? Date.valid_ordinal?(p1, p2, p3 = v3)\nReturns true if the given ordinal date is valid, and false if not.\n\nFor example:\n\n   Date.valid_ordinal?(2001,34)      #=> true\n   Date.valid_ordinal?(2001,366)     #=> false\n\nSee also jd and ordinal.\n
xmlschema Date.xmlschema(p1 = v1, p2 = v2)\nCreates a new Date object by parsing from a string according to\nsome typical XML Schema formats.\n\nFor example:\n\n   Date.xmlschema('2001-02-03')      #=> #<Date: 2001-02-03 ...>\n
ajd Date.ajd()\nReturns the astronomical Julian day number.  This is a fractional\nnumber, which is not adjusted by the offset.\n\nFor example:\n\n   DateTime.new(2001,2,3,4,5,6,'+7').ajd     #=> (11769328217/4800)\n   DateTime.new(2001,2,2,14,5,6,'-7').ajd    #=> (11769328217/4800)\n
amjd Date.amjd()\nReturns the astronomical modified Julian day number.  This is\na fractional number, which is not adjusted by the offset.\n\nFor example:\n\n   DateTime.new(2001,2,3,4,5,6,'+7').amjd    #=> (249325817/4800)\n   DateTime.new(2001,2,2,14,5,6,'-7').amjd   #=> (249325817/4800)\n
as_json Date.as_json(*)\nReturns a hash, that will be turned into a JSON object and represent this\nobject.\n
asctime Date.asctime()\nReturns a string in asctime(3) format (but without "\\n\0" at the\nend).  This method is equivalent to strftime('%c').\n\nSee also asctime(3) or ctime(3).\n
ctime Date.ctime()\nReturns a string in asctime(3) format (but without "\\n\0" at the\nend).  This method is equivalent to strftime('%c').\n\nSee also asctime(3) or ctime(3).\n
cwday Date.cwday()\nReturns the day of calendar week (1-7, Monday is 1).\n\nFor example:\n\n   Date.new(2001,2,3).cwday          #=> 6\n
cweek Date.cweek()\nReturns the calendar week number (1-53).\n\nFor example:\n\n   Date.new(2001,2,3).cweek          #=> 5\n
cwyear Date.cwyear()\nReturns the calendar week based year.\n\nFor example:\n\n   Date.new(2001,2,3).cwyear         #=> 2001\n   Date.new(2000,1,1).cwyear         #=> 1999\n
day Date.day()\nReturns the day of the month (1-31).\n\nFor example:\n\n   Date.new(2001,2,3).mday           #=> 3\n
day_fraction Date.day_fraction()\nReturns the fractional part of the day.\n\nFor example:\n\n   DateTime.new(2001,2,3,12).day_fraction    #=> (1/2)\n
downto Date.downto(p1)\nThis method is equivalent to step(min, -1){|date| ...}.\n
england Date.england()\nThis method is equivalent to new_start(Date::ENGLAND).\n
friday? Date.friday?()\nReturns true if the date is Friday.\n
gregorian Date.gregorian()\nThis method is equivalent to new_start(Date::GREGORIAN).\n
gregorian? Date.gregorian?()\nRetunrs true if the date is on or after the day of calendar reform.\n\nFor example:\n\n    Date.new(1582,10,15).gregorian?          #=> true\n    (Date.new(1582,10,15) - 1).gregorian?    #=> false\n
httpdate Date.httpdate()\nThis method is equivalent to strftime('%a, %d %b %Y %T GMT').\nSee also RFC 2616.\n
inspect Date.inspect()\nReturns the value as a string for inspection.\n\nFor example:\n\n   Date.new(2001,2,3).inspect\n=> "#<Date: 2001-02-03 ((2451944j,0s,0n),+0s,2299161j)>"\n   DateTime.new(2001,2,3,4,5,6,'-7').inspect\n=> "#<DateTime: 2001-02-03T04:05:06-07:00\n((2451944j,39906s,0n),-25200s,2299161j)>"\n
iso8601 Date.iso8601()\nThis method is equivalent to strftime('%F').\n
italy Date.italy()\nThis method is equivalent to new_start(Date::ITALY).\n
jd Date.jd()\nReturns the Julian day number.  This is a whole number, which is\nadjusted by the offset as the local time.\n\nFor example:\n\n   DateTime.new(2001,2,3,4,5,6,'+7').jd      #=> 2451944\n   DateTime.new(2001,2,3,4,5,6,'-7').jd      #=> 2451944\n
jisx0301 Date.jisx0301()\nReturns a string in a JIS X 0301 format.\n\nFor example:\n\n   Date.new(2001,2,3).jisx0301       #=> "H13.02.03"\n
julian Date.julian()\nThis method is equivalent to new_start(Date::JULIAN).\n
julian? Date.julian?()\nRetruns true if the date is before the day of calendar reform.\n\nFor example:\n\n    Date.new(1582,10,15).julian?             #=> false\n    (Date.new(1582,10,15) - 1).julian?       #=> true\n
ld Date.ld()\nReturns the Lilian day number.  This is a whole number, which is\nadjusted by the offset as the local time.\n\nFor example:\n\n    Date.new(2001,2,3).ld            #=> 152784\n
leap? Date.leap?()\nReturns true if the year is a leap year.\n\nFor example:\n\n   Date.new(2000).leap?      #=> true\n   Date.new(2001).leap?      #=> false\n
mday Date.mday()\nReturns the day of the month (1-31).\n\nFor example:\n\n   Date.new(2001,2,3).mday           #=> 3\n
mjd Date.mjd()\nReturns the modified Julian day number.  This is a whole number,\nwhich is adjusted by the offset as the local time.\n\nFor example:\n\n   DateTime.new(2001,2,3,4,5,6,'+7').mjd     #=> 51943\n   DateTime.new(2001,2,3,4,5,6,'-7').mjd     #=> 51943\n
mon Date.mon()\nReturns the month (1-12).\n\nFor example:\n\n   Date.new(2001,2,3).mon            #=> 2\n
monday? Date.monday?()\nReturns true if the date is Monday.\n
month Date.month()\nReturns the month (1-12).\n\nFor example:\n\n   Date.new(2001,2,3).mon            #=> 2\n
new_start Date.new_start(p1 = v1)\nDuplicates self and resets its the day of calendar reform.\n\nFor example:\n\n   d = Date.new(1582,10,15)\n   d.new_start(Date::JULIAN)         #=> #<Date: 1582-10-05 ...>\n
next Date.next()\nReturns a date object denoting the following day.\n
next_day Date.next_day(p1 = v1)\nThis method is equivalent to d + n.\n
next_month Date.next_month(p1 = v1)\nThis method is equivalent to d >> n\n
next_year Date.next_year(p1 = v1)\nThis method is equivalent to d >> (n * 12)\n
prev_day Date.prev_day(p1 = v1)\nThis method is equivalent to d - n.\n
prev_month Date.prev_month(p1 = v1)\nThis method is equivalent to d << n\n
prev_year Date.prev_year(p1 = v1)\nThis method is equivalent to d << (n * 12)\n
rfc2822 Date.rfc2822()\nThis method is equivalent to strftime('%a, %-d %b %Y %T %z').\n
rfc3339 Date.rfc3339()\nThis method is equivalent to strftime('%FT%T%:z').\n
rfc822 Date.rfc822()\nThis method is equivalent to strftime('%a, %-d %b %Y %T %z').\n
saturday? Date.saturday?()\nReturns true if the date is Saturday.\n
start Date.start()\nReturns the Julian day number denoting the day of calendar reform.\n\nFor example:\n\n   Date.new(2001,2,3).start                  #=> 2299161.0\n   Date.new(2001,2,3,Date::GREGORIAN).start  #=> -Infinity\n
step Date.step(p1, p2 = v2)\nIterates evaluation of the given block, which takes a date object.\nThe limit should be a date object.\n\nFor example:\n\n   Date.new(2001).step(Date.new(2001,-1,-1)).select{|d| d.sunday?}.size\n=> 52\n
strftime Date.strftime(*args)\n Formats date according to the directives in the given format\n string.\n The directives begins with a percent (%) character.\n Any text not listed as a directive will be passed through to the\n output string.\n\n The directive consists of a percent (%) character,\n zero or more flags, optional minimum field width,\n optional modifier and a conversion specifier\n as follows.\n\n   %<flags><width><modifier><conversion>\n\n Flags:\n   -  don't pad a numerical output.\n   _  use spaces for padding.\n   0  use zeros for padding.\n   ^  upcase the result string.\n  change case.\n   :  use colons for %z.\n\n The minimum field width specifies the minimum width.\n\n The modifier is "E" and "O".\n They are ignored.\n\n Format directives:\n\n   Date (Year, Month, Day):\n     %Y - Year with century (can be negative, 4 digits at least)\n             -0001, 0000, 1995, 2009, 14292, etc.\n     %C - year / 100 (round down.  20 in 2009)\n     %y - year % 100 (00..99)\n\n     %m - Month of the year, zero-padded (01..12)\n             %_m  blank-padded ( 1..12)\n             %-m  no-padded (1..12)\n     %B - The full month name (``January'')\n             %^B  uppercased (``JANUARY'')\n     %b - The abbreviated month name (``Jan'')\n             %^b  uppercased (``JAN'')\n     %h - Equivalent to %b\n\n     %d - Day of the month, zero-padded (01..31)\n             %-d  no-padded (1..31)\n     %e - Day of the month, blank-padded ( 1..31)\n\n     %j - Day of the year (001..366)\n\n   Time (Hour, Minute, Second, Subsecond):\n     %H - Hour of the day, 24-hour clock, zero-padded (00..23)\n     %k - Hour of the day, 24-hour clock, blank-padded ( 0..23)\n     %I - Hour of the day, 12-hour clock, zero-padded (01..12)\n     %l - Hour of the day, 12-hour clock, blank-padded ( 1..12)\n     %P - Meridian indicator, lowercase (``am'' or ``pm'')\n     %p - Meridian indicator, uppercase (``AM'' or ``PM'')\n\n     %M - Minute of the hour (00..59)\n\n     %S - Second of the minute (00..59)\n\n     %L - Millisecond of the second (000..999)\n     %N - Fractional seconds digits, default is 9 digits (nanosecond)\n             %3N  millisecond (3 digits)\n             %6N  microsecond (6 digits)\n             %9N  nanosecond (9 digits)\n             %12N picosecond (12 digits)\n\n   Time zone:\n     %z - Time zone as hour and minute offset from UTC (e.g. +0900)\n             %:z - hour and minute offset from UTC with a colon (e.g. +09:00)\n             %::z - hour, minute and second offset from UTC (e.g. +09:00:00)\n             %:::z - hour, minute and second offset from UTC\n                                               (e.g. +09, +09:30, +09:30:30)\n     %Z - Time zone abbreviation name\n\n   Weekday:\n     %A - The full weekday name (``Sunday'')\n             %^A  uppercased (``SUNDAY'')\n     %a - The abbreviated name (``Sun'')\n             %^a  uppercased (``SUN'')\n     %u - Day of the week (Monday is 1, 1..7)\n     %w - Day of the week (Sunday is 0, 0..6)\n\n   ISO 8601 week-based year and week number:\n   The week 1 of YYYY starts with a Monday and includes YYYY-01-04.\n   The days in the year before the first week are in the last week of\n   the previous year.\n     %G - The week-based year\n     %g - The last 2 digits of the week-based year (00..99)\n     %V - Week number of the week-based year (01..53)\n\n   Week number:\n   The week 1 of YYYY starts with a Sunday or Monday (according to %U\n   or %W).  The days in the year before the first week are in week 0.\n     %U - Week number of the year.  The week starts with Sunday.  (00..53)\n     %W - Week number of the year.  The week starts with Monday.  (00..53)\n\n   Seconds since the Unix Epoch:\n     %s - Number of seconds since 1970-01-01 00:00:00 UTC.\n     %Q - Number of milliseconds since 1970-01-01 00:00:00 UTC.\n\n   Literal string:\n     %n - Newline character (\\n)\n     %t - Tab character (\t)\n     %% - Literal ``%'' character\n\n   Combination:\n     %c - date and time (%a %b %e %T %Y)\n     %D - Date (%m/%d/%y)\n     %F - The ISO 8601 date format (%Y-%m-%d)\n     %v - VMS date (%e-%b-%Y)\n     %x - Same as %D\n     %X - Same as %T\n     %r - 12-hour time (%I:%M:%S %p)\n     %R - 24-hour time (%H:%M)\n     %T - 24-hour time (%H:%M:%S)\n     %+ - date(1) (%a %b %e %H:%M:%S %Z %Y)\n\n This method is similar to strftime() function defined in ISO C and POSIX.\n Several directives (%a, %A, %b, %B, %c, %p, %r, %x, %X, %E*, %O* and %Z)\n are locale dependent in the function.\n However this method is locale independent.\n So, the result may differ even if a same format string is used in other\n systems such as C.\n It is good practice to avoid %x and %X because there are corresponding\n locale independent representations, %D and %T.\n\n Examples:\n\n   d = DateTime.new(2007,11,19,8,37,48,"-06:00")\n=> #<DateTime: 2007-11-19T08:37:48-0600 ...>\n   d.strftime("Printed on %m/%d/%Y")   #=> "Printed on 11/19/2007"\n   d.strftime("at %I:%M%p")            #=> "at 08:37AM"\n\n Various ISO 8601 formats:\n   %Y%m%d           => 20071119                  Calendar date (basic)\n   %F               => 2007-11-19                Calendar date (extended)\n   %Y-%m            => 2007-11                   Calendar date, reduced\n   accuracy, specific month\n   %Y               => 2007                      Calendar date, reduced\n   accuracy, specific year\n   %C               => 20                        Calendar date, reduced\n   accuracy, specific century\n   %Y%j             => 2007323                   Ordinal date (basic)\n   %Y-%j            => 2007-323                  Ordinal date (extended)\n   %GW%V%u          => 2007W471                  Week date (basic)\n   %G-W%V-%u        => 2007-W47-1                Week date (extended)\n   %GW%V            => 2007W47                   Week date, reduced accuracy,\n   specific week (basic)\n   %G-W%V           => 2007-W47                  Week date, reduced accuracy,\n   specific week (extended)\n   %H%M%S           => 083748                    Local time (basic)\n   %T               => 08:37:48                  Local time (extended)\n   %H%M             => 0837                      Local time, reduced accuracy,\n   specific minute (basic)\n   %H:%M            => 08:37                     Local time, reduced accuracy,\n   specific minute (extended)\n   %H               => 08                        Local time, reduced accuracy,\n   specific hour\n   %H%M%S,%L        => 083748,000                Local time with decimal\n   fraction, comma as decimal sign (basic)\n   %T,%L            => 08:37:48,000              Local time with decimal\n   fraction, comma as decimal sign (extended)\n   %H%M%S.%L        => 083748.000                Local time with decimal\n   fraction, full stop as decimal sign (basic)\n   %T.%L            => 08:37:48.000              Local time with decimal\n   fraction, full stop as decimal sign (extended)\n   %H%M%S%z         => 083748-0600               Local time and the difference\n   from UTC (basic)\n   %T%:z            => 08:37:48-06:00            Local time and the difference\n   from UTC (extended)\n   %Y%m%dT%H%M%S%z  => 20071119T083748-0600      Date and time of day for\n   calendar date (basic)\n   %FT%T%:z         => 2007-11-19T08:37:48-06:00 Date and time of day for\n   calendar date (extended)\n   %Y%jT%H%M%S%z    => 2007323T083748-0600       Date and time of day for\n   ordinal date (basic)\n   %Y-%jT%T%:z      => 2007-323T08:37:48-06:00   Date and time of day for\n   ordinal date (extended)\n   %GW%V%uT%H%M%S%z => 2007W471T083748-0600      Date and time of day for\n   week date (basic)\n   %G-W%V-%uT%T%:z  => 2007-W47-1T08:37:48-06:00 Date and time of day for\n   week date (extended)\n   %Y%m%dT%H%M      => 20071119T0837             Calendar date and local time\n   (basic)\n   %FT%R            => 2007-11-19T08:37          Calendar date and local time\n   (extended)\n   %Y%jT%H%MZ       => 2007323T0837Z             Ordinal date and UTC of day\n   (basic)\n   %Y-%jT%RZ        => 2007-323T08:37Z           Ordinal date and UTC of day\n   (extended)\n   %GW%V%uT%H%M%z   => 2007W471T0837-0600        Week date and local time\n   and difference from UTC (basic)\n   %G-W%V-%uT%R%:z  => 2007-W47-1T08:37-06:00    Week date and local time\n   and difference from UTC (extended)\n\nSee also strftime(3) and strptime.\n
succ Date.succ()\nReturns a date object denoting the following day.\n
sunday? Date.sunday?()\nReturns true if the date is Sunday.\n
thursday? Date.thursday?()\nReturns true if the date is Thursday.\n
to_date Date.to_date()\nReturns self;\n
to_datetime Date.to_datetime()\nReturns a DateTime object which denotes self.\n
to_json Date.to_json(*args)\nStores class name (Date) with Julian year <tt>y</tt>, month <tt>m</tt>, day\n<tt>d</tt> and Day of Calendar Reform <tt>sg</tt> as JSON string\n
to_s Date.to_s()\nReturns a string in an ISO 8601 format (This method doesn't use the\nexpanded representations).\n\nFor example:\n\n    Date.new(2001,2,3).to_s  #=> "2001-02-03"\n
to_time Date.to_time()\nReturns a Time object which denotes self.\n
tuesday? Date.tuesday?()\nReturns true if the date is Tuesday.\n
upto Date.upto(p1)\nThis method is equivalent to step(max, 1){|date| ...}.\n
wday Date.wday()\nReturns the day of week (0-6, Sunday is zero).\n\nFor example:\n\n   Date.new(2001,2,3).wday           #=> 6\n
wednesday? Date.wednesday?()\nReturns true if the date is Wednesday.\n
xmlschema Date.xmlschema()\nThis method is equivalent to strftime('%F').\n
yday Date.yday()\nReturns the day of the year (1-366).\n\nFor example:\n\n   Date.new(2001,2,3).yday           #=> 34\n
year Date.year()\nReturns the year.\n\nFor example:\n\n   Date.new(2001,2,3).year           #=> 2001\n   (Date.new(1,1,1) - 1).year        #=> 0\n
_load Gem::Specification._load(str)\nLoad custom marshal format, re-initializing defaults as needed\n
add_spec Gem::Specification.add_spec(spec)\nAdds +spec+ to the known specifications, keeping the collection\nproperly sorted.\n
add_specs Gem::Specification.add_specs(*specs)\nAdds multiple specs to the known specifications.\n
all Gem::Specification.all()\nReturns all specifications. This method is discouraged from use.\nYou probably want to use one of the Enumerable methods instead.\n
all= Gem::Specification.all=(specs)\nSets the known specs to +specs+. Not guaranteed to work for you in\nthe future. Use at your own risk. Caveat emptor. Doomy doom doom.\nEtc etc.\n
all_names Gem::Specification.all_names()\nReturn full names of all specs in sorted order.\n
array_attributes Gem::Specification.array_attributes()\nReturn the list of all array-oriented instance variables.\n
attribute_names Gem::Specification.attribute_names()\nReturn the list of all instance variables.\n
dirs Gem::Specification.dirs()\nReturn the directories that Specification uses to find specs.\n
dirs= Gem::Specification.dirs=(dirs)\nSet the directories that Specification uses to find specs. Setting\nthis resets the list of known specs.\n
each Gem::Specification.each()\nEnumerate every known spec.  See ::dirs= and ::add_spec to set the list of\nspecs.\n
find_all_by_name Gem::Specification.find_all_by_name(name, *requirements)\nReturns every spec that matches +name+ and optional +requirements+.\n
find_by_name Gem::Specification.find_by_name(name, *requirements)\nFind the best specification matching a +name+ and +requirements+. Raises\nif the dependency doesn't resolve to a valid specification.\n
find_by_path Gem::Specification.find_by_path(path)\nReturn the best specification that contains the file matching +path+.\n
find_in_unresolved Gem::Specification.find_in_unresolved(path)\nReturn currently unresolved specs that contain the file matching +path+.\n
find_in_unresolved_tree Gem::Specification.find_in_unresolved_tree(path)\nSearch through all unresolved deps and sub-dependencies and return\nspecs that contain the file matching +path+.\n
from_yaml Gem::Specification.from_yaml(input)\nSpecial loader for YAML files.  When a Specification object is loaded\nfrom a YAML file, it bypasses the normal Ruby object initialization\nroutine (#initialize).  This method makes up for that and deals with\ngems of different ages.\n\n+input+ can be anything that YAML.load() accepts: String or IO.\n
latest_specs Gem::Specification.latest_specs(prerelease = false)\nReturn the latest specs, optionally including prerelease specs if\n+prerelease+ is true.\n
load Gem::Specification.load(file)\nLoads Ruby format gemspec from +file+.\n
new Gem::Specification.new(name = nil, version = nil)\nSpecification constructor. Assigns the default values to the attributes\nand yields itself for further initialization.  Optionally takes +name+ and\n+version+.\n
non_nil_attributes Gem::Specification.non_nil_attributes()\nSpecification attributes that must be non-nil\n
normalize_yaml_input Gem::Specification.normalize_yaml_input(input)\nMake sure the YAML specification is properly formatted with dashes\n
outdated Gem::Specification.outdated()\nReturn a list of all outdated specifications. This method is HEAVY\nas it must go fetch specifications from the server.\n
remove_spec Gem::Specification.remove_spec(spec)\nRemoves +spec+ from the known specs.\n
required_attribute? Gem::Specification.required_attribute?(name)\nIs +name+ a required attribute?\n
required_attributes Gem::Specification.required_attributes()\nRequired specification attributes\n
reset Gem::Specification.reset()\nReset the list of known specs, running pre and post reset hooks\nregistered in Gem.\n
_dump Gem::Specification._dump(limit)\nDump only crucial instance variables.\n
activate Gem::Specification.activate()\nActivate this spec, registering it as a loaded spec and adding\nit's lib paths to $LOAD_PATH. Returns true if the spec was\nactivated, false if it was previously activated. Freaks out if\nthere are conflicts upon activation.\n
activate_dependencies Gem::Specification.activate_dependencies()\nActivate all unambiguously resolved runtime dependencies of this\nspec. Add any ambigous dependencies to the unresolved list to be\nresolved later, as needed.\n
add_bindir Gem::Specification.add_bindir(executables)\nReturns an array with bindir attached to each executable in the\n+executables+ list\n
add_dependency Gem::Specification.add_dependency(gem, *requirements)\n\n
add_development_dependency Gem::Specification.add_development_dependency(gem, *requirements)\nAdds a development dependency named +gem+ with +requirements+ to this\nGem.  For example:\n\n  spec.add_development_dependency 'example', '~> 1.1', '>= 1.1.4'\n\nDevelopment dependencies aren't installed by default and aren't\nactivated when a gem is required.\n
add_runtime_dependency Gem::Specification.add_runtime_dependency(gem, *requirements)\nAdds a runtime dependency named +gem+ with +requirements+ to this Gem.\nFor example:\n\n  spec.add_runtime_dependency 'example', '~> 1.1', '>= 1.1.4'\n
add_self_to_load_path Gem::Specification.add_self_to_load_path()\nAdds this spec's require paths to LOAD_PATH, in the proper location.\n
author Gem::Specification.author()\nSingular reader for #authors\n
author= Gem::Specification.author=(o)\nSingular writer for #authors\n
authors Gem::Specification.authors()\nThe list of author names who wrote this gem.\n\nIf you are providing multiple authors and multiple emails they should be\nin the same order such that:\n\n  Hash[*spec.authors.zip(spec.emails).flatten]\n\nGives a hash of author name to email address.\n
authors= Gem::Specification.authors=(value)\nSets the list of authors, ensuring it is an array.\n
base_dir Gem::Specification.base_dir()\nReturns the full path to the base gem directory.\n\neg: /usr/local/lib/ruby/gems/1.8\n
bin_dir Gem::Specification.bin_dir()\nReturns the full path to installed gem's bin directory.\n\nNOTE: do not confuse this with +bindir+, which is just 'bin', not\na full path.\n
bin_file Gem::Specification.bin_file(name)\nReturns the full path to an executable named +name+ in this gem.\n
cache_dir Gem::Specification.cache_dir()\nReturns the full path to the cache directory containing this\nspec's cached gem.\n
cache_file Gem::Specification.cache_file()\nReturns the full path to the cached gem for this spec.\n
cache_gem Gem::Specification.cache_gem()\n\n
conflicts Gem::Specification.conflicts()\nReturn any possible conflicts against the currently loaded specs.\n
contains_requirable_file? Gem::Specification.contains_requirable_file?(file)\nReturn true if this spec can require +file+.\n
date Gem::Specification.date()\nThe date this gem was created. Lazily defaults to TODAY.\n
date= Gem::Specification.date=(date)\nThe date this gem was created\n\nDo not set this, it is set automatically when the gem is packaged.\n
default_executable Gem::Specification.default_executable()\nThe default executable for this gem.\n\nDeprecated: The name of the gem is assumed to be the name of the\nexecutable now.  See Gem.bin_path.\n
default_value Gem::Specification.default_value(name)\nThe default value for specification attribute +name+\n
dependencies Gem::Specification.dependencies()\nA list of Gem::Dependency objects this gem depends on.\n\nUse #add_dependency or #add_development_dependency to add dependencies to\na gem.\n
dependent_gems Gem::Specification.dependent_gems()\nReturn a list of all gems that have a dependency on this gemspec.  The\nlist is structured with entries that conform to:\n\n  [depending_gem, dependency, [list_of_gems_that_satisfy_dependency]]\n
dependent_specs Gem::Specification.dependent_specs()\nReturns all specs that matches this spec's runtime dependencies.\n
description= Gem::Specification.description=(str)\nA long description of this gem\n
development_dependencies Gem::Specification.development_dependencies()\nList of dependencies that are used for development\n
doc_dir Gem::Specification.doc_dir()\nReturns the full path to this spec's documentation directory.\n
executable Gem::Specification.executable()\nSingular accessor for #executables\n
executable= Gem::Specification.executable=(o)\nSingular accessor for #executables\n
executables Gem::Specification.executables()\nExecutables included in the gem.\n
executables= Gem::Specification.executables=(value)\nSets executables to +value+, ensuring it is an array. Don't\nuse this, push onto the array instead.\n
extensions Gem::Specification.extensions()\nExtensions to build when installing the gem.  See\nGem::Installer#build_extensions for valid values.\n
extensions= Gem::Specification.extensions=(extensions)\nSets extensions to +extensions+, ensuring it is an array. Don't\nuse this, push onto the array instead.\n
extra_rdoc_files Gem::Specification.extra_rdoc_files()\nExtra files to add to RDoc such as README or doc/examples.txt\n
extra_rdoc_files= Gem::Specification.extra_rdoc_files=(files)\nSets extra_rdoc_files to +files+, ensuring it is an array. Don't\nuse this, push onto the array instead.\n
file_name Gem::Specification.file_name()\nThe default (generated) file name of the gem.  See also #spec_name.\n\n  spec.file_name # => "example-1.0.gem"\n
files Gem::Specification.files()\nFiles included in this gem.  You cannot append to this accessor, you must\nassign to it.\n\nOnly add files you can require to this list, not directories, etc.\n\nDirectories are automatically stripped from this list when building a gem,\nother non-files cause an error.\n
files= Gem::Specification.files=(files)\nSets files to +files+, ensuring it is an array.\n
for_cache Gem::Specification.for_cache()\nCreates a duplicate spec without large blobs that aren't used at runtime.\n
full_gem_path Gem::Specification.full_gem_path()\nThe full path to the gem (install path + full name).\n
full_name Gem::Specification.full_name()\nReturns the full name (name-version) of this Gem.  Platform information\nis included (name-version-platform) if it is specified and not the\ndefault Ruby platform.\n
gem_dir Gem::Specification.gem_dir()\nReturns the full path to this spec's gem directory.\neg: /usr/local/lib/ruby/1.8/gems/mygem-1.0\n
gems_dir Gem::Specification.gems_dir()\nReturns the full path to the gems directory containing this spec's\ngem directory. eg: /usr/local/lib/ruby/1.8/gems\n
has_rdoc Gem::Specification.has_rdoc()\nDeprecated and ignored, defaults to true.\n\nFormerly used to indicate this gem was RDoc-capable.\n
has_rdoc= Gem::Specification.has_rdoc=(ignored)\nDeprecated and ignored.\n\nFormerly used to indicate this gem was RDoc-capable.\n
has_rdoc? Gem::Specification.has_rdoc?()\n\n
has_unit_tests? Gem::Specification.has_unit_tests?()\nTrue if this gem has files in test_files\n
initialize_copy Gem::Specification.initialize_copy(other_spec)\nDuplicates array_attributes from +other_spec+ so state isn't shared.\n
installation_path Gem::Specification.installation_path()\nThe directory that this gem was installed into.\nTODO: rename - horrible. this is the base_dir for a gem path\n
lib_dirs_glob Gem::Specification.lib_dirs_glob()\nReturns a string usable in Dir.glob to match all requirable paths\nfor this spec.\n
lib_files Gem::Specification.lib_files()\nFiles in the Gem under one of the require_paths\n
license Gem::Specification.license()\nSingular accessor for #licenses\n
license= Gem::Specification.license=(o)\nSingular accessor for #licenses\n
licenses Gem::Specification.licenses()\nThe license(s) for the library.  Each license must be a short name, no\nmore than 64 characters.\n
licenses= Gem::Specification.licenses=(licenses)\nSet licenses to +licenses+, ensuring it is an array.\n
loaded_from= Gem::Specification.loaded_from=(path)\nSet the location a Specification was loaded from. +obj+ is converted\nto a String.\n
mark_version Gem::Specification.mark_version()\nSets the rubygems_version to the current RubyGems version.\n
matches_for_glob Gem::Specification.matches_for_glob(glob)\nReturn all files in this gem that match for +glob+.\n
normalize Gem::Specification.normalize()\nNormalize the list of files so that:\n* All file lists have redundancies removed.\n* Files referenced in the extra_rdoc_files are included in the package\n  file list.\n
platform Gem::Specification.platform()\nThe platform this gem runs on.  See Gem::Platform for details.\n
platform= Gem::Specification.platform=(platform)\nThe platform this gem runs on.  See Gem::Platform for details.\n\nSetting this to any value other than Gem::Platform::RUBY or\nGem::Platform::CURRENT is probably wrong.\n
raise_if_conflicts Gem::Specification.raise_if_conflicts()\nCheck the spec for possible conflicts and freak out if there are any.\n
rdoc_options Gem::Specification.rdoc_options()\nAn ARGV style array of options to RDoc\n
rdoc_options= Gem::Specification.rdoc_options=(options)\nSets rdoc_options to +value+, ensuring it is an array. Don't\nuse this, push onto the array instead.\n
require_path Gem::Specification.require_path()\nSingular accessor for #require_paths\n
require_path= Gem::Specification.require_path=(path)\nSingular accessor for #require_paths\n
required_ruby_version= Gem::Specification.required_ruby_version=(req)\nThe version of ruby required by this gem\n
required_rubygems_version= Gem::Specification.required_rubygems_version=(req)\nThe RubyGems version required by this gem\n
requirements Gem::Specification.requirements()\nAn array or things required by this gem.  Not used by anything\npresently.\n
requirements= Gem::Specification.requirements=(req)\nSet requirements to +req+, ensuring it is an array. Don't\nuse this, push onto the array instead.\n
ri_dir Gem::Specification.ri_dir()\nReturns the full path to this spec's ri directory.\n
runtime_dependencies Gem::Specification.runtime_dependencies()\nList of dependencies that will automatically be activated at runtime.\n
satisfies_requirement? Gem::Specification.satisfies_requirement?(dependency)\nChecks if this specification meets the requirement of +dependency+.\n
sort_obj Gem::Specification.sort_obj()\nReturns an object you can use to sort specifications in #sort_by.\n
spec_dir Gem::Specification.spec_dir()\nReturns the full path to the directory containing this spec's\ngemspec file. eg: /usr/local/lib/ruby/gems/1.8/specifications\n
spec_file Gem::Specification.spec_file()\nReturns the full path to this spec's gemspec file.\neg: /usr/local/lib/ruby/gems/1.8/specifications/mygem-1.0.gemspec\n
spec_name Gem::Specification.spec_name()\nThe default name of the gemspec.  See also #file_name\n\n  spec.spec_name # => "example-1.0.gemspec"\n
summary= Gem::Specification.summary=(str)\nA short summary of this gem's description.\n
test_file Gem::Specification.test_file()\nSingular accessor for #test_files\n
test_file= Gem::Specification.test_file=(file)\nSingular accessor for #test_files\n
test_files Gem::Specification.test_files()\nTest files included in this gem.  You cannot append to this accessor, you\nmust assign to it.\n
test_files= Gem::Specification.test_files=(files)\nSet test_files to +files+, ensuring it is an array.\n
to_ruby Gem::Specification.to_ruby()\nReturns a Ruby code representation of this specification, such that it can\nbe eval'ed and reconstruct the same specification later.  Attributes that\nstill have their default values are omitted.\n
to_ruby_for_cache Gem::Specification.to_ruby_for_cache()\nReturns a Ruby lighter-weight code representation of this specification,\nused for indexing only.\n\nSee #to_ruby.\n
traverse Gem::Specification.traverse(trail = [], &block)\nRecursively walk dependencies of this spec, executing the +block+ for each\nhop.\n
validate Gem::Specification.validate(packaging = true)\nChecks that the specification contains all required fields, and does a\nvery basic sanity check.\n\nRaises InvalidSpecificationException if the spec does not pass the\nchecks..\n
version= Gem::Specification.version=(version)\nSet the version to +version+, potentially also setting\nrequired_rubygems_version if +version+ indicates it is a\nprerelease.\n
exec_format Gem::Installer.exec_format()\nDefaults to use Ruby's program prefix and suffix.\n
new Gem::Installer.new(gem, options={})\nConstructs an Installer instance that will install the gem located at\n+gem+.  +options+ is a Hash with the following keys:\n\n:env_shebang:: Use /usr/bin/env in bin wrappers.\n:force:: Overrides all version checks and security policy checks, except\n         for a signed-gems-only policy.\n:ignore_dependencies:: Don't raise if a dependency is missing.\n:install_dir:: The directory to install the gem into.\n:format_executable:: Format the executable the same as the ruby executable.\n                     If your ruby is ruby18, foo_exec will be installed as\n                     foo_exec18.\n:security_policy:: Use the specified security policy.  See Gem::Security\n:wrappers:: Install wrappers if true, symlinks if false.\n
app_script_text Gem::Installer.app_script_text(bin_file_name)\nReturn the text for an application file.\n
build_extensions Gem::Installer.build_extensions()\nBuilds extensions.  Valid types of extensions are extconf.rb files,\nconfigure scripts and rakefiles or mkrf_conf files.\n
check_that_user_bin_dir_is_in_path Gem::Installer.check_that_user_bin_dir_is_in_path()\n\n
dir Gem::Installer.dir()\nReturn the target directory where the gem is to be installed. This\ndirectory is not guaranteed to be populated.\n
ensure_dependencies_met Gem::Installer.ensure_dependencies_met()\n\n
ensure_dependency Gem::Installer.ensure_dependency(spec, dependency)\nEnsure that the dependency is satisfied by the current installation of\ngem.  If it is not an exception is raised.\n\nspec       :: Gem::Specification\ndependency :: Gem::Dependency\n
ensure_required_ruby_version_met Gem::Installer.ensure_required_ruby_version_met()\n\n
ensure_required_rubygems_version_met Gem::Installer.ensure_required_rubygems_version_met()\n\n
extract_files Gem::Installer.extract_files()\nReads the file index and extracts each file into the gem directory.\n\nEnsures that files can't be installed outside the gem directory.\n
format Gem::Installer.format()\nLazy accessor for the installer's Gem::Format instance.\n
formatted_program_filename Gem::Installer.formatted_program_filename(filename)\nPrefix and suffix the program filename the same as ruby.\n
gem_dir Gem::Installer.gem_dir()\nLazy accessor for the spec's gem directory.\n
generate_bin Gem::Installer.generate_bin()\n\n
generate_bin_script Gem::Installer.generate_bin_script(filename, bindir)\nCreates the scripts to run the applications in the gem.\n
generate_bin_symlink Gem::Installer.generate_bin_symlink(filename, bindir)\nCreates the symlinks to run the applications in the gem.  Moves\nthe symlink if the gem being installed has a newer version.\n
generate_windows_script Gem::Installer.generate_windows_script(filename, bindir)\nCreates windows .bat files for easy running of commands\n
install Gem::Installer.install()\nInstalls the gem and returns a loaded Gem::Specification for the installed\ngem.\n\nThe gem will be installed with the following structure:\n\n  @gem_home/\n    cache/<gem-version>.gem #=> a cached copy of the installed gem\n    gems/<gem-version>/... #=> extracted files\n    specifications/<gem-version>.gemspec #=> the Gem::Specification\n
installation_satisfies_dependency? Gem::Installer.installation_satisfies_dependency?(dependency)\nTrue if the gems in the source_index satisfy +dependency+.\n
process_options Gem::Installer.process_options()\n\n
shebang Gem::Installer.shebang(bin_file_name)\nGenerates a #! line for +bin_file_name+'s wrapper copying arguments if\nnecessary.\n
spec Gem::Installer.spec()\nLazy accessor for the installer's spec.\n
unpack Gem::Installer.unpack(directory)\nUnpacks the gem into the given directory.\n
verify_gem_home Gem::Installer.verify_gem_home(unpack = false)\n\n
windows_stub_script Gem::Installer.windows_stub_script(bindir, bin_file_name)\nreturn the stub script text used to launch the true ruby script\n
write_spec Gem::Installer.write_spec()\nWrites the .gemspec specification (in Ruby) to the gem home's\nspecifications directory.\n
setup Gem::InstallerTestCase.setup()\n\n
util_gem_bindir Gem::InstallerTestCase.util_gem_bindir(spec = @spec)\n\n
util_gem_dir Gem::InstallerTestCase.util_gem_dir(spec = @spec)\n\n
util_inst_bindir Gem::InstallerTestCase.util_inst_bindir()\n\n
util_installer Gem::InstallerTestCase.util_installer(spec, gem_home, user=false)\n\n
util_make_exec Gem::InstallerTestCase.util_make_exec(spec = @spec, shebang =\n"#!/usr/bin/ruby")\n\n
util_setup_gem Gem::InstallerTestCase.util_setup_gem(ui = @ui)\n\n
new Gem::StreamUI.new(in_stream, out_stream, err_stream=STDERR, usetty=true)\n\n
alert Gem::StreamUI.alert(statement, question=nil)\nDisplay an informational alert.  Will ask +question+ if it is not nil.\n
alert_error Gem::StreamUI.alert_error(statement, question=nil)\nDisplay an error message in a location expected to get error messages.\nWill ask +question+ if it is not nil.\n
alert_warning Gem::StreamUI.alert_warning(statement, question=nil)\nDisplay a warning in a location expected to get error messages.  Will\nask +question+ if it is not nil.\n
ask Gem::StreamUI.ask(question)\nAsk a question.  Returns an answer if connected to a tty, nil otherwise.\n
ask_for_password Gem::StreamUI.ask_for_password(question)\nAsk for a password. Does not echo response to terminal.\n
ask_for_password_on_unix Gem::StreamUI.ask_for_password_on_unix()\nAsks for a password that works on unix\n
ask_for_password_on_windows Gem::StreamUI.ask_for_password_on_windows()\nAsks for a password that works on windows. Ripped from the Heroku gem.\n
ask_yes_no Gem::StreamUI.ask_yes_no(question, default=nil)\nAsk a question.  Returns a true for yes, false for no.  If not connected\nto a tty, raises an exception if default is nil, otherwise returns\ndefault.\n
choose_from_list Gem::StreamUI.choose_from_list(question, list)\nChoose from a list of options.  +question+ is a prompt displayed above\nthe list.  +list+ is a list of option strings.  Returns the pair\n[option_name, option_index].\n
debug Gem::StreamUI.debug(statement)\nDisplay a debug message on the same location as error messages.\n
download_reporter Gem::StreamUI.download_reporter(*args)\nReturn a download reporter object chosen from the current verbosity\n
progress_reporter Gem::StreamUI.progress_reporter(*args)\nReturn a progress reporter object chosen from the current verbosity.\n
say Gem::StreamUI.say(statement="")\nDisplay a statement.\n
terminate_interaction Gem::StreamUI.terminate_interaction(status = 0)\nTerminate the application with exit code +status+, running any exit\nhandlers that might have been defined.\n
tty? Gem::StreamUI.tty?()\n\n
new Gem::StreamUI::SilentProgressReporter.new(out_stream, size, initial_message,\nterminal_message = nil)\n\n
done Gem::StreamUI::SilentProgressReporter.done()\n\n
updated Gem::StreamUI::SilentProgressReporter.updated(message)\n\n
new Gem::StreamUI::SimpleProgressReporter.new(out_stream, size, initial_message,\nterminal_message = "complete")\n\n
done Gem::StreamUI::SimpleProgressReporter.done()\nPrints out the terminal message.\n
updated Gem::StreamUI::SimpleProgressReporter.updated(message)\nPrints out a dot and ignores +message+.\n
new Gem::StreamUI::VerboseProgressReporter.new(out_stream, size, initial_message,\nterminal_message = 'complete')\n\n
done Gem::StreamUI::VerboseProgressReporter.done()\nPrints out the terminal message.\n
updated Gem::StreamUI::VerboseProgressReporter.updated(message)\nPrints out the position relative to the total and the +message+.\n
new Gem::StreamUI::SilentDownloadReporter.new(out_stream, *args)\n\n
done Gem::StreamUI::SilentDownloadReporter.done()\n\n
fetch Gem::StreamUI::SilentDownloadReporter.fetch(filename, filesize)\n\n
update Gem::StreamUI::SilentDownloadReporter.update(current)\n\n
new Gem::StreamUI::VerboseDownloadReporter.new(out_stream, *args)\n\n
done Gem::StreamUI::VerboseDownloadReporter.done()\n\n
fetch Gem::StreamUI::VerboseDownloadReporter.fetch(file_name, total_bytes)\n\n
update Gem::StreamUI::VerboseDownloadReporter.update(bytes)\n\n
new Gem::ConsoleUI.new()\n\n
new Gem::SilentUI.new()\n\n
download_reporter Gem::SilentUI.download_reporter(*args)\n\n
progress_reporter Gem::SilentUI.progress_reporter(*args)\n\n
new Gem::GemRunner.new(options={})\n\n
run Gem::GemRunner.run(args)\nRun the gem command with the following arguments.\n
register Gem::NoAliasYAMLTree.register(target, obj)\nNoop this out so there are no anchors\n
visit_String Gem::NoAliasYAMLTree.visit_String(str)\n\n
new Gem::Validator.new()\n\n
alien Gem::Validator.alien(gems=[])\nChecks the gem directory for the following potential\ninconsistencies/problems:\n\n* Checksum gem itself\n* For each file in each gem, check consistency of installed versions\n* Check for files that aren't part of the gem but are in the gems directory\n* 1 cache - 1 spec - 1 directory.\n\nreturns a hash of ErrorData objects, keyed on the problem gem's name.\n
remove_leading_dot_dir Gem::Validator.remove_leading_dot_dir(path)\n\n
verify_gem Gem::Validator.verify_gem(gem_data)\nGiven a gem file's contents, validates against its own MD5 checksum\ngem_data:: [String] Contents of the gem file\n
verify_gem_file Gem::Validator.verify_gem_file(gem_path)\nGiven the path to a gem file, validates against its own MD5 checksum\n\ngem_path:: [String] Path to gem file\n
new Gem::Indexer.new(directory, options = {})\nCreate an indexer that will index the gems in +directory+.\n
abbreviate Gem::Indexer.abbreviate(spec)\nAbbreviate the spec for downloading.  Abbreviated specs are only used for\nsearching, downloading and related activities and do not need deployment\nspecific information (e.g. list of files).  So we abbreviate the spec,\nmaking it much smaller for quicker downloads.\n
build_indicies Gem::Indexer.build_indicies()\nBuild various indicies\n
build_legacy_indicies Gem::Indexer.build_legacy_indicies()\nBuilds indicies for RubyGems older than 1.2.x\n
build_marshal_gemspecs Gem::Indexer.build_marshal_gemspecs()\nBuilds Marshal quick index gemspecs.\n
build_modern_index Gem::Indexer.build_modern_index(index, file, name)\nBuild a single index for RubyGems 1.2 and newer\n
build_modern_indicies Gem::Indexer.build_modern_indicies()\nBuilds indicies for RubyGems 1.2 and newer. Handles full, latest, prerelease\n
build_rss Gem::Indexer.build_rss()\nBuilds an RSS feed for past two days gem releases according to the gem's\ndate.\n
collect_specs Gem::Indexer.collect_specs(gems = gem_file_list)\nCollect specifications from .gem files from the gem directory.\n
compact_specs Gem::Indexer.compact_specs(specs)\nCompacts Marshal output for the specs index data source by using identical\nobjects as much as possible.\n
compress Gem::Indexer.compress(filename, extension)\nCompress +filename+ with +extension+.\n
compress_indicies Gem::Indexer.compress_indicies()\nCompresses indicies on disk\n
gem_file_list Gem::Indexer.gem_file_list()\nList of gem file names to index.\n
generate_index Gem::Indexer.generate_index()\nBuilds and installs indicies.\n
gzip Gem::Indexer.gzip(filename)\nZlib::GzipWriter wrapper that gzips +filename+ on disk.\n
install_indicies Gem::Indexer.install_indicies()\nInstall generated indicies into the destination directory.\n
make_temp_directories Gem::Indexer.make_temp_directories()\nMake directories for index generation\n
map_gems_to_specs Gem::Indexer.map_gems_to_specs(gems)\n\n
paranoid Gem::Indexer.paranoid(path, extension)\nEnsure +path+ and path with +extension+ are identical.\n
sanitize Gem::Indexer.sanitize(spec)\nSanitize the descriptive fields in the spec.  Sometimes non-ASCII\ncharacters will garble the site index.  Non-ASCII characters will\nbe replaced by their XML entity equivalent.\n
sanitize_string Gem::Indexer.sanitize_string(string)\nSanitize a single string.\n
update_index Gem::Indexer.update_index()\nPerform an in-place update of the repository from newly added gems.  Only\nworks for modern indicies, and sets #build_legacy to false when run.\n
update_specs_index Gem::Indexer.update_specs_index(index, source, dest)\nCombines specs in +index+ and +source+ then writes out a new copy to\n+dest+.  For a latest index, does not ensure the new file is minimal.\n
new Gem::Builder.new(spec)\nConstructs a builder instance for the provided specification\n\nspec:: [Gem::Specification] The specification instance\n
build Gem::Builder.build(skip_validation=false)\nBuilds the gem from the specification.  Returns the name of the file\nwritten.\n
success Gem::Builder.success()\n\n
build Gem::Ext::ConfigureBuilder.build(extension, directory, dest_path, results)\n\n
build Gem::Ext::ExtConfBuilder.build(extension, directory, dest_path, results)\n\n
class_name Gem::Ext::Builder.class_name()\n\n
make Gem::Ext::Builder.make(dest_path, results)\n\n
redirector Gem::Ext::Builder.redirector()\n\n
run Gem::Ext::Builder.run(command, results)\n\n
build Gem::Ext::RakeBuilder.build(extension, directory, dest_path, results)\n\n
new Gem::PackageTask.new(gem_spec)\nCreate a Gem Package task library.  Automatically define the gem if a\nblock is given.  If no block is supplied, then #define needs to be called\nto define the task.\n
define Gem::PackageTask.define()\nCreate the Rake tasks and actions specified by this Gem::PackageTask.\n(+define+ is automatically called if a block is given to +new+).\n
init Gem::PackageTask.init(gem)\nInitialization tasks without the "yield self" or define operations.\n
make_command Gem::TestCase.make_command()\nReturns the make command for the current platform. For versions of Ruby\nbuilt on MS Windows with VC++ or Borland it will return 'nmake'. On all\nother platforms, including Cygwin, it will return 'make'.\n
process_based_port Gem::TestCase.process_based_port()\nAllows tests to use a random (but controlled) port number instead of\na hardcoded one. This helps CI tools when running parallels builds on\nthe same builder slave.\n
rubybin Gem::TestCase.rubybin()\nFinds the path to the ruby executable\n
vc_windows? Gem::TestCase.vc_windows?()\nReturns whether or not we're on a version of Ruby built with VC++ (or\nBorland) versus Cygwin, Mingw, etc.\n
win_platform? Gem::TestCase.win_platform?()\nIs this test being run on a Windows platform?\n
all_spec_names Gem::TestCase.all_spec_names()\n\n
assert_path_exists Gem::TestCase.assert_path_exists(path, msg = nil)\nTODO: move to minitest\n
build_rake_in Gem::TestCase.build_rake_in()\nAllows the proper version of +rake+ to be used for the test.\n
create_tmpdir Gem::TestCase.create_tmpdir()\ncreates a temporary directory with hax\n
dep Gem::TestCase.dep(name, *requirements)\nConstruct a new Gem::Dependency.\n
install_gem Gem::TestCase.install_gem(spec, options = {})\nBuilds and installs the Gem::Specification +spec+\n
install_gem_user Gem::TestCase.install_gem_user(spec)\nBuilds and installs the Gem::Specification +spec+ into the user dir\n
install_specs Gem::TestCase.install_specs(*specs)\nInstall the provided specs\n
make_command Gem::TestCase.make_command()\nReturns the make command for the current platform. For versions of Ruby\nbuilt on MS Windows with VC++ or Borland it will return 'nmake'. On all\nother platforms, including Cygwin, it will return 'make'.\n
mu_pp Gem::TestCase.mu_pp(obj)\nEnables pretty-print for all tests\n
new_spec Gem::TestCase.new_spec(name, version, deps = nil, *files)\nCreate a new spec (or gem if passed an array of files) and set it\nup properly. Use this instead of util_spec and util_gem.\n
nmake_found? Gem::TestCase.nmake_found?()\nReturns whether or not the nmake command could be found.\n
process_based_port Gem::TestCase.process_based_port()\nSee ::process_based_port\n
quick_gem Gem::TestCase.quick_gem(name, version='2')\nCreates a Gem::Specification with a minimum of extra work.  +name+ and\n+version+ are the gem's name and version,  platform, author, email,\nhomepage, summary and description are defaulted.  The specification is\nyielded for customization.\n\nThe gem is added to the installed gems in +@gemhome+ and to the current\nsource_index.\n\nUse this with #write_file to build an installed gem.\n
quick_spec Gem::TestCase.quick_spec(name, version = '2')\n\n
read_binary Gem::TestCase.read_binary(path)\nReads a binary file at +path+\n
read_cache Gem::TestCase.read_cache(path)\nReads a Marshal file at +path+\n
refute_path_exists Gem::TestCase.refute_path_exists(path, msg = nil)\nTODO: move to minitest\n
req Gem::TestCase.req(*requirements)\nConstructs a new Gem::Requirement.\n
setup Gem::TestCase.setup()\nsetup prepares a sandboxed location to install gems.  All installs are\ndirected to a temporary directory.  All install plugins are removed.\n\nIf the +RUBY+ environment variable is set the given path is used for\nGem::ruby.  The local platform is set to <tt>i386-mswin32</tt> for Windows\nor <tt>i686-darwin8.10.1</tt> otherwise.\n\nIf the +KEEP_FILES+ environment variable is set the files will not be\nremoved from <tt>/tmp/test_rubygems_#{$$}.#{Time.now.to_i}</tt>.\n
spec Gem::TestCase.spec(name, version, &block)\nConstructs a new Gem::Specification.\n
teardown Gem::TestCase.teardown()\nteardown restores the process to its original state and removes the\ntempdir unless the +KEEP_FILES+ environment variable was set.\n
uninstall_gem Gem::TestCase.uninstall_gem(spec)\nUninstalls the Gem::Specification +spec+\n
util_build_gem Gem::TestCase.util_build_gem(spec)\nBuilds a gem from +spec+ and places it in <tt>File.join @gemhome,\n'cache'</tt>.  Automatically creates files based on +spec.files+\n
util_clear_gems Gem::TestCase.util_clear_gems()\nRemoves all installed gems from +@gemhome+.\n
util_gem Gem::TestCase.util_gem(name, version, deps = nil, &block)\nCreates a gem with +name+, +version+ and +deps+.  The specification will\nbe yielded before gem creation for customization.  The gem will be placed\nin <tt>File.join @tempdir, 'gems'</tt>.  The specification and .gem file\nlocation are returned.\n
util_gzip Gem::TestCase.util_gzip(data)\nGzips +data+.\n
util_make_gems Gem::TestCase.util_make_gems(prerelease = false)\nCreates several default gems which all have a lib/code.rb file.  The gems\nare not installed but are available in the cache dir.\n\n+@a1+:: gem a version 1, this is the best-described gem.\n+@a2+:: gem a version 2\n+@a3a:: gem a version 3.a\n+@a_evil9+:: gem a_evil version 9, use this to ensure similarly-named gems\n             don't collide with a.\n+@b2+:: gem b version 2\n+@c1_2+:: gem c version 1.2\n+@pl1+:: gem pl version 1, this gem has a legacy platform of i386-linux.\n\nAdditional +prerelease+ gems may also be created:\n\n+@a2_pre+:: gem a version 2.a\nTODO: nuke this and fix tests. this should speed up a lot\n
util_set_arch Gem::TestCase.util_set_arch(arch)\nSet the platform to +arch+\n
util_setup_fake_fetcher Gem::TestCase.util_setup_fake_fetcher(prerelease = false)\nSets up a fake fetcher using the gems from #util_make_gems.  Optionally\nadditional +prerelease+ gems may be included.\n\nGems created by this method may be fetched using Gem::RemoteFetcher.\n
util_setup_spec_fetcher Gem::TestCase.util_setup_spec_fetcher(*specs)\nSets up Gem::SpecFetcher to return information from the gems in +specs+.\nBest used with +@all_gems+ from #util_setup_fake_fetcher.\n
util_spec Gem::TestCase.util_spec(name, version, deps = nil, &block)\nCreates a spec with +name+, +version+ and +deps+.\n
util_zip Gem::TestCase.util_zip(data)\nDeflates +data+\n
v Gem::TestCase.v(string)\nConstruct a new Gem::Version.\n
vc_windows? Gem::TestCase.vc_windows?()\nReturns whether or not we're on a version of Ruby built with VC++ (or\nBorland) versus Cygwin, Mingw, etc.\n
win_platform? Gem::TestCase.win_platform?()\nIs this test being run on a Windows platform?\n
write_file Gem::TestCase.write_file(path)\nWrites a binary file to +path+ which is relative to +@gemhome+\n
new Gem::Package::FormatError.new(message, path = nil)\n\n
correct? Gem::Version.correct?(version)\nTrue if the +version+ string matches RubyGems' requirements.\n
create Gem::Version.create(input)\nFactory method to create a Version object. Input may be a Version\nor a String. Intended to simplify client code.\n\n  ver1 = Version.create('1.3.17')   # -> (Version object)\n  ver2 = Version.create(ver1)       # -> (ver1)\n  ver3 = Version.create(nil)        # -> nil\n
new Gem::Version.new(version)\nConstructs a Version from the +version+ string.  A version string is a\nseries of digits or ASCII letters separated by dots.\n
bump Gem::Version.bump()\nReturn a new version object where the next to the last revision\nnumber is one greater (e.g., 5.3.1 => 5.4).\n\nPre-release (alpha) parts, e.g, 5.3.1.b.2 => 5.4, are ignored.\n
eql? Gem::Version.eql?(other)\nA Version is only eql? to another version if it's specified to the\nsame precision. Version "1.0" is not the same as version "1".\n
marshal_dump Gem::Version.marshal_dump()\nDump only the raw version string, not the complete object. It's a\nstring for backwards (RubyGems 1.3.5 and earlier) compatibility.\n
marshal_load Gem::Version.marshal_load(array)\nLoad custom marshal format. It's a string for backwards (RubyGems\n1.3.5 and earlier) compatibility.\n
prerelease? Gem::Version.prerelease?()\nA version is considered a prerelease if it contains a letter.\n
release Gem::Version.release()\nThe release for this version (e.g. 1.2.0.a -> 1.2.0).\nNon-prerelease versions return themselves.\n
spermy_recommendation Gem::Version.spermy_recommendation()\nA recommended version for use with a ~> Requirement.\n
yaml_initialize Gem::Version.yaml_initialize(tag, map)\n\n
new Gem::Dependency.new(name, *requirements)\nConstructs a dependency with +name+ and +requirements+. The last\nargument can optionally be the dependency type, which defaults to\n<tt>:runtime</tt>.\n
match? Gem::Dependency.match?(name, version)\n\n
matches_spec? Gem::Dependency.matches_spec?(spec)\n\n
matching_specs Gem::Dependency.matching_specs(platform_only = false)\n\n
merge Gem::Dependency.merge(other)\nMerges the requirements of +other+ into this dependency\n
prerelease? Gem::Dependency.prerelease?()\nDoes this dependency require a prerelease?\n
requirement Gem::Dependency.requirement()\nWhat does this dependency require?\n
requirements_list Gem::Dependency.requirements_list()\n\n
specific? Gem::Dependency.specific?()\nTrue if the dependency will not always match the latest version.\n
to_spec Gem::Dependency.to_spec()\n\n
to_specs Gem::Dependency.to_specs()\n\n
type Gem::Dependency.type()\nDependency type.\n
fetcher Gem::SpecFetcher.fetcher()\n\n
new Gem::SpecFetcher.new()\n\n
cache_dir Gem::SpecFetcher.cache_dir(uri)\nReturns the local directory to write +uri+ to.\n
fetch Gem::SpecFetcher.fetch(*args)\n\n
fetch_spec Gem::SpecFetcher.fetch_spec(spec, source_uri)\n\n
fetch_with_errors Gem::SpecFetcher.fetch_with_errors(dependency, all = false, matching_platform\n= true, prerelease = false)\nFetch specs matching +dependency+.  If +all+ is true, all matching\n(released) versions are returned.  If +matching_platform+ is\nfalse, all platforms are returned. If +prerelease+ is true,\nprerelease versions are included.\n
find_matching Gem::SpecFetcher.find_matching(*args)\n\n
find_matching_with_errors Gem::SpecFetcher.find_matching_with_errors(dependency, all = false,\nmatching_platform = true, prerelease = false)\nFind spec names that match +dependency+.  If +all+ is true, all\nmatching released versions are returned.  If +matching_platform+\nis false, gems for all platforms are returned.\n
list Gem::SpecFetcher.list(all = false, prerelease = false)\nReturns a list of gems available for each source in Gem::sources.  If\n+all+ is true, all released versions are returned instead of only latest\nversions. If +prerelease+ is true, include prerelease versions.\n
load_specs Gem::SpecFetcher.load_specs(source_uri, file)\nLoads specs in +file+, fetching from +source_uri+ if the on-disk cache is\nout of date.\n
suggest_gems_from_name Gem::SpecFetcher.suggest_gems_from_name(gem_name)\nSuggests a gem based on the supplied +gem_name+. Returns a string\nof the gem name if an approximate match can be found or nil\notherwise. NOTE: for performance reasons only gems which exactly\nmatch the first character of +gem_name+ are considered.\n
new Gem::FakeFetcher.new()\n\n
download Gem::FakeFetcher.download(spec, source_uri, install_dir = Gem.dir)\n\n
download_to_cache Gem::FakeFetcher.download_to_cache(dependency)\n\n
fetch_path Gem::FakeFetcher.fetch_path(path, mtime = nil)\n\n
fetch_size Gem::FakeFetcher.fetch_size(path)\n\n
find_data Gem::FakeFetcher.find_data(path)\n\n
open_uri_or_path Gem::FakeFetcher.open_uri_or_path(path)\nThanks, FakeWeb!\n
request Gem::FakeFetcher.request(uri, request_class, last_modified = nil)\n\n
new TempIO.new(string = '')\n\n
string TempIO.string()\n\n
from_file_by_path Gem::Format.from_file_by_path(file_path, security_policy = nil)\nReads the gem +file_path+ using +security_policy+ and returns a Format\nrepresenting the data in the gem\n
from_io Gem::Format.from_io(io, gem_path="(io)", security_policy = nil)\nReads a gem from +io+ at +gem_path+ using +security_policy+ and returns a\nFormat representing the data from the gem\n
new Gem::Format.new(gem_path)\nConstructs a Format representing the gem's data which came from +gem_path+\n
from Gem::Package::TarHeader.from(stream)\nCreates a tar header from IO +stream+\n
new Gem::Package::TarHeader.new(vals)\nCreates a new TarHeader using +vals+\n
empty? Gem::Package::TarHeader.empty?()\nIs the tar entry empty?\n
update_checksum Gem::Package::TarHeader.update_checksum()\nUpdates the TarHeader's checksum\n
new Gem::Package::TarWriter.new(io)\nCreates a new TarWriter, yielding it if a block is given\n
new Gem::Package::TarWriter.new(io)\nCreates a new TarWriter that will write to +io+\n
add_file Gem::Package::TarWriter.add_file(name, mode)\nAdds file +name+ with permissions +mode+, and yields an IO for writing the\nfile to\n
add_file_simple Gem::Package::TarWriter.add_file_simple(name, mode, size)\nAdd file +name+ with permissions +mode+ +size+ bytes long.  Yields an IO\nto write the file to.\n
check_closed Gem::Package::TarWriter.check_closed()\nRaises IOError if the TarWriter is closed\n
close Gem::Package::TarWriter.close()\nCloses the TarWriter\n
closed? Gem::Package::TarWriter.closed?()\nIs the TarWriter closed?\n
flush Gem::Package::TarWriter.flush()\nFlushes the TarWriter's IO\n
mkdir Gem::Package::TarWriter.mkdir(name, mode)\nCreates a new directory in the tar file +name+ with +mode+\n
new Gem::Package::TarWriter::BoundedStream.new(io, limit)\nWraps +io+ and allows up to +limit+ bytes to be written\n
write Gem::Package::TarWriter::BoundedStream.write(data)\nWrites +data+ onto the IO, raising a FileOverflow exception if the\nnumber of bytes will be more than #limit\n
new Gem::Package::TarWriter::RestrictedStream.new(io)\nCreates a new RestrictedStream wrapping +io+\n
write Gem::Package::TarWriter::RestrictedStream.write(data)\nWrites +data+ onto the IO\n
ASCIIZ Gem::Package::TarTestCase.ASCIIZ(str, length)\n\n
SP Gem::Package::TarTestCase.SP(s)\n\n
SP_Z Gem::Package::TarTestCase.SP_Z(s)\n\n
Z Gem::Package::TarTestCase.Z(s)\n\n
assert_headers_equal Gem::Package::TarTestCase.assert_headers_equal(expected, actual)\n\n
calc_checksum Gem::Package::TarTestCase.calc_checksum(header)\n\n
header Gem::Package::TarTestCase.header(type, fname, dname, length, mode, checksum\n= nil)\n\n
tar_dir_header Gem::Package::TarTestCase.tar_dir_header(name, prefix, mode)\n\n
tar_file_header Gem::Package::TarTestCase.tar_file_header(fname, dname, mode, length)\n\n
to_oct Gem::Package::TarTestCase.to_oct(n, pad_size)\n\n
util_dir_entry Gem::Package::TarTestCase.util_dir_entry()\n\n
util_entry Gem::Package::TarTestCase.util_entry(tar)\n\n
new Gem::Package::TarReader.new(io)\nCreates a new TarReader on +io+ and yields it to the block, if given.\n
new Gem::Package::TarReader.new(io)\nCreates a new tar file reader on +io+ which needs to respond to #pos,\neof?, #read, #getc and #pos=\n
close Gem::Package::TarReader.close()\nClose the tar file\n
each Gem::Package::TarReader.each()\nIterates over files in the tarball yielding each entry\n
each_entry Gem::Package::TarReader.each_entry()\n\n
rewind Gem::Package::TarReader.rewind()\nNOTE: Do not call #rewind during #each\n
new Gem::Package::TarReader::Entry.new(header, io)\nCreates a new tar entry for +header+ that will be read from +io+\n
bytes_read Gem::Package::TarReader::Entry.bytes_read()\nNumber of bytes read out of the tar entry\n
close Gem::Package::TarReader::Entry.close()\nCloses the tar entry\n
closed? Gem::Package::TarReader::Entry.closed?()\nIs the tar entry closed?\n
directory? Gem::Package::TarReader::Entry.directory?()\nIs this tar entry a directory?\n
eof? Gem::Package::TarReader::Entry.eof?()\nAre we at the end of the tar entry?\n
file? Gem::Package::TarReader::Entry.file?()\nIs this tar entry a file?\n
full_name Gem::Package::TarReader::Entry.full_name()\nFull name of the tar entry\n
getc Gem::Package::TarReader::Entry.getc()\nRead one byte from the tar entry\n
pos Gem::Package::TarReader::Entry.pos()\nThe position in the tar entry\n
read Gem::Package::TarReader::Entry.read(len = nil)\nReads +len+ bytes from the tar file entry, or the rest of the entry if\nnil\n
rewind Gem::Package::TarReader::Entry.rewind()\nRewinds to the beginning of the tar file entry\n
new Gem::Package::TarOutput.new(io, signer)\nCreates a new TarOutput that will write a gem-format tar file to +io+.  If\n+signer+ is given, the data.tar.gz and metadata.gz will be signed and\nthe signatures will be added to the tar file.\n
open Gem::Package::TarOutput.open(io, signer = nil)\nCreates a new TarOutput which will yield a TarWriter object for the\ndata.tar.gz portion of a gem-format tar file.\n\nSee #initialize for details on +io+ and +signer+.\n\nSee #add_gem_contents for details on adding metadata to the tar file.\n
add_gem_contents Gem::Package::TarOutput.add_gem_contents()\nYields a TarWriter for the data.tar.gz inside a gem-format tar file.\nThe yielded TarWriter has been extended with a #metadata= method for\nattaching a YAML format Gem::Specification which will be written by\nadd_metadata.\n
add_metadata Gem::Package::TarOutput.add_metadata()\nAdds metadata.gz to the gem-format tar file which was saved from a\nprevious #add_gem_contents call.\n
add_signatures Gem::Package::TarOutput.add_signatures()\nAdds data.tar.gz.sig and metadata.gz.sig to the gem-format tar files if\na Gem::Security::Signer was sent to initialize.\n
close Gem::Package::TarOutput.close()\nCloses the TarOutput.\n
new Gem::Uninstaller.new(gem, options = {})\nConstructs an uninstaller that will uninstall +gem+\n
ask_if_ok Gem::Uninstaller.ask_if_ok(spec)\n\n
dependencies_ok? Gem::Uninstaller.dependencies_ok?(spec)\n\n
formatted_program_filename Gem::Uninstaller.formatted_program_filename(filename)\n\n
path_ok? Gem::Uninstaller.path_ok?(gem_dir, spec)\nIs +spec+ in +gem_dir+?\n
remove Gem::Uninstaller.remove(spec)\nspec:: the spec of the gem to be uninstalled\nlist:: the list of all such gems\n\nWarning: this method modifies the +list+ parameter.  Once it has\nuninstalled a gem, it is removed from that list.\n
remove_all Gem::Uninstaller.remove_all(list)\nRemoves all gems in +list+.\n\nNOTE: removes uninstalled gems from +list+.\n
remove_executables Gem::Uninstaller.remove_executables(spec)\nRemoves installed executables and batch files (windows only) for\n+gemspec+.\n
uninstall Gem::Uninstaller.uninstall()\nPerforms the uninstall of the gem.  This removes the spec, the Gem\ndirectory, and the cached .gem file.\n
uninstall_gem Gem::Uninstaller.uninstall_gem(spec)\nUninstalls gem +spec+\n
new Gem::Commands::WhichCommand.new()\n\n
execute Gem::Commands::WhichCommand.execute()\n\n
find_paths Gem::Commands::WhichCommand.find_paths(package_name, dirs)\n\n
gem_paths Gem::Commands::WhichCommand.gem_paths(spec)\n\n
new Gem::Commands::PristineCommand.new()\n\n
execute Gem::Commands::PristineCommand.execute()\n\n
new Gem::Commands::SpecificationCommand.new()\n\n
execute Gem::Commands::SpecificationCommand.execute()\n\n
new Gem::Commands::CertCommand.new()\n\n
execute Gem::Commands::CertCommand.execute()\n\n
new Gem::Commands::SearchCommand.new()\n\n
execute Gem::Commands::SearchCommand.execute()\n\n
new Gem::Commands::HelpCommand.new()\n\n
execute Gem::Commands::HelpCommand.execute()\n\n
new Gem::Commands::SourcesCommand.new()\n\n
defaults_str Gem::Commands::SourcesCommand.defaults_str()\n\n
execute Gem::Commands::SourcesCommand.execute()\n\n
new Gem::Commands::LockCommand.new()\n\n
complain Gem::Commands::LockCommand.complain(message)\n\n
execute Gem::Commands::LockCommand.execute()\n\n
spec_path Gem::Commands::LockCommand.spec_path(gem_full_name)\n\n
new Gem::Commands::DependencyCommand.new()\n\n
execute Gem::Commands::DependencyCommand.execute()\n\n
find_reverse_dependencies Gem::Commands::DependencyCommand.find_reverse_dependencies(spec)\nReturns an Array of [specification, dep] that are satisfied by +spec+.\n
print_dependencies Gem::Commands::DependencyCommand.print_dependencies(spec, level = 0)\n\n
new Gem::Commands::EnvironmentCommand.new()\n\n
execute Gem::Commands::EnvironmentCommand.execute()\n\n
new Gem::Commands::ContentsCommand.new()\n\n
execute Gem::Commands::ContentsCommand.execute()\n\n
new Gem::Commands::OwnerCommand.new()\n\n
add_owners Gem::Commands::OwnerCommand.add_owners(name, owners)\n\n
execute Gem::Commands::OwnerCommand.execute()\n\n
manage_owners Gem::Commands::OwnerCommand.manage_owners(method, name, owners)\n\n
remove_owners Gem::Commands::OwnerCommand.remove_owners(name, owners)\n\n
show_owners Gem::Commands::OwnerCommand.show_owners(name)\n\n
new Gem::Commands::ListCommand.new()\n\n
execute Gem::Commands::ListCommand.execute()\n\n
new Gem::Commands::GenerateIndexCommand.new()\n\n
execute Gem::Commands::GenerateIndexCommand.execute()\n\n
new Gem::Commands::UpdateCommand.new()\n\n
execute Gem::Commands::UpdateCommand.execute()\n\n
update_gem Gem::Commands::UpdateCommand.update_gem(name, version =\nGem::Requirement.default)\n\n
update_gems Gem::Commands::UpdateCommand.update_gems(gems_to_update)\n\n
update_rubygems Gem::Commands::UpdateCommand.update_rubygems()\nUpdate RubyGems software to the latest version.\n
which_to_update Gem::Commands::UpdateCommand.which_to_update(highest_installed_gems, gem_names,\nsystem = false)\n\n
new Gem::Commands::CleanupCommand.new()\n\n
execute Gem::Commands::CleanupCommand.execute()\n\n
new Gem::Commands::CheckCommand.new()\n\n
execute Gem::Commands::CheckCommand.execute()\n\n
new Gem::Commands::BuildCommand.new()\n\n
execute Gem::Commands::BuildCommand.execute()\n\n
load_gemspec Gem::Commands::BuildCommand.load_gemspec(filename)\n\n
yaml? Gem::Commands::BuildCommand.yaml?(filename)\n\n
new Gem::Commands::UninstallCommand.new()\n\n
execute Gem::Commands::UninstallCommand.execute()\n\n
new Gem::Commands::StaleCommand.new()\n\n
execute Gem::Commands::StaleCommand.execute()\n\n
new Gem::Commands::ServerCommand.new()\n\n
execute Gem::Commands::ServerCommand.execute()\n\n
new Gem::Commands::UnpackCommand.new()\n\n
execute Gem::Commands::UnpackCommand.execute()\n\n
find_in_cache Gem::Commands::UnpackCommand.find_in_cache(filename)\nFind cached filename in Gem.path. Returns nil if the file cannot be found.\n
get_metadata Gem::Commands::UnpackCommand.get_metadata(path)\nExtracts the Gem::Specification and raw metadata from the .gem file at\n+path+.\n
get_path Gem::Commands::UnpackCommand.get_path(dependency)\nReturn the full path to the cached gem file matching the given\nname and version requirement.  Returns 'nil' if no match.\n\nExample:\n\n  get_path 'rake', '> 0.4' # "/usr/lib/ruby/gems/1.8/cache/rake-0.4.2.gem"\n  get_path 'rake', '< 0.1' # nil\n  get_path 'rak'           # nil (exact name required)\n
new Gem::Commands::InstallCommand.new()\n\n
execute Gem::Commands::InstallCommand.execute()\n\n
new Gem::Commands::RdocCommand.new()\n\n
execute Gem::Commands::RdocCommand.execute()\n\n
new Gem::Commands::OutdatedCommand.new()\n\n
execute Gem::Commands::OutdatedCommand.execute()\n\n
new Gem::Commands::FetchCommand.new()\n\n
execute Gem::Commands::FetchCommand.execute()\n\n
new Gem::Commands::PushCommand.new()\n\n
execute Gem::Commands::PushCommand.execute()\n\n
send_gem Gem::Commands::PushCommand.send_gem(name)\n\n
new Gem::Commands::QueryCommand.new(name = 'query', summary = 'Query gem\ninformation in local or remote repositories')\n\n
execute Gem::Commands::QueryCommand.execute()\n\n
new Gem::Commands::SetupCommand.new()\n\n
check_ruby_version Gem::Commands::SetupCommand.check_ruby_version()\n\n
execute Gem::Commands::SetupCommand.execute()\n\n
generate_default_dirs Gem::Commands::SetupCommand.generate_default_dirs(install_destdir)\n\n
install_executables Gem::Commands::SetupCommand.install_executables(bin_dir)\n\n
install_lib Gem::Commands::SetupCommand.install_lib(lib_dir)\n\n
install_rdoc Gem::Commands::SetupCommand.install_rdoc()\n\n
make_destination_dirs Gem::Commands::SetupCommand.make_destination_dirs(install_destdir)\n\n
remove_old_bin_files Gem::Commands::SetupCommand.remove_old_bin_files(bin_dir)\n\n
run_rdoc Gem::Commands::SetupCommand.run_rdoc(*args)\n\n
uninstall_old_gemcutter Gem::Commands::SetupCommand.uninstall_old_gemcutter()\n\n
new Gem::GemPathSearcher.new()\nInitialise the data we need to make searches later.\n
find Gem::GemPathSearcher.find(glob)\nLook in all the installed gems until a matching +glob+ is found.\nReturn the _gemspec_ of the gem where it was found.  If no match\nis found, return nil.\n\nThe gems are searched in alphabetical order, and in reverse\nversion order.\n\nFor example:\n\n  find('log4r')              # -> (log4r-1.1 spec)\n  find('log4r.rb')           # -> (log4r-1.1 spec)\n  find('rake/rdoctask')      # -> (rake-0.4.12 spec)\n  find('foobarbaz')          # -> nil\n\nMatching paths can have various suffixes ('.rb', '.so', and\nothers), which may or may not already be attached to _file_.\nThis method doesn't care about the full filename that matches;\nonly that there is a match.\n
find_active Gem::GemPathSearcher.find_active(glob)\n\n
find_all Gem::GemPathSearcher.find_all(glob)\nWorks like #find, but finds all gemspecs matching +glob+.\n
find_in_unresolved Gem::GemPathSearcher.find_in_unresolved(glob)\n\n
find_in_unresolved_tree Gem::GemPathSearcher.find_in_unresolved_tree(glob)\n\n
find_spec_for_file Gem::GemPathSearcher.find_spec_for_file(file)\nLooks through the available gemspecs and finds the first\none that contains +file+ as a requirable file.\n
init_gemspecs Gem::GemPathSearcher.init_gemspecs()\nReturn a list of all installed gemspecs, sorted by alphabetical order and\nin reverse version order.  (bar-2, bar-1, foo-2)\n
lib_dirs_for Gem::GemPathSearcher.lib_dirs_for(spec)\nReturns library directories glob for a gemspec.  For example,\n  '/usr/local/lib/ruby/gems/1.8/gems/foobar-1.0/{lib,ext}'\n
matching_file? Gem::GemPathSearcher.matching_file?(spec, path)\nAttempts to find a matching path using the require_paths of the given\n+spec+.\n
matching_files Gem::GemPathSearcher.matching_files(spec, path)\nReturns files matching +path+ in +spec+.\n
matching_paths Gem::GemPathSearcher.matching_paths(spec, path)\n\n
from_source_index Gem::DependencyList.from_source_index(ignored=nil)\nCreates a DependencyList from a Gem::SourceIndex +source_index+\n
from_specs Gem::DependencyList.from_specs()\nCreates a DependencyList from the current specs.\n
new Gem::DependencyList.new(development = false)\nCreates a new DependencyList.  If +development+ is true, development\ndependencies will be included.\n
add Gem::DependencyList.add(*gemspecs)\nAdds +gemspecs+ to the dependency list.\n
clear Gem::DependencyList.clear()\n\n
dependency_order Gem::DependencyList.dependency_order()\nReturn a list of the gem specifications in the dependency list, sorted in\norder so that no gemspec in the list depends on a gemspec earlier in the\nlist.\n\nThis is useful when removing gems from a set of installed gems.  By\nremoving them in the returned order, you don't get into as many dependency\nissues.\n\nIf there are circular dependencies (yuck!), then gems will be returned in\norder until only the circular dependents and anything they reference are\nleft.  Then arbitrary gemspecs will be returned until the circular\ndependency is broken, after which gems will be returned in dependency\norder again.\n
each Gem::DependencyList.each(&block)\nIterator over dependency_order\n
find_name Gem::DependencyList.find_name(full_name)\n\n
ok? Gem::DependencyList.ok?()\nAre all the dependencies in the list satisfied?\n
ok_to_remove? Gem::DependencyList.ok_to_remove?(full_name)\nIs is ok to remove a gemspec from the dependency list?\n\nIf removing the gemspec creates breaks a currently ok dependency, then it\nis NOT ok to remove the gemspec.\n
remove_by_name Gem::DependencyList.remove_by_name(full_name)\nRemoves the gemspec matching +full_name+ from the dependency list\n
remove_specs_unsatisfied_by Gem::DependencyList.remove_specs_unsatisfied_by(dependencies)\nRemove everything in the DependencyList that matches but doesn't\nsatisfy items in +dependencies+ (a hash of gem names to arrays of\ndependencies).\n
spec_predecessors Gem::DependencyList.spec_predecessors()\nReturn a hash of predecessors.  <tt>result[spec]</tt> is an Array of\ngemspecs that have a dependency satisfied by the named gemspec.\n
tsort_each_child Gem::DependencyList.tsort_each_child(node, &block)\n\n
tsort_each_node Gem::DependencyList.tsort_each_node(&block)\n\n
why_not_ok? Gem::DependencyList.why_not_ok?(quick = false)\n\n
instance Gem::CommandManager.instance()\nReturn the authoritative instance of the command manager.\n
new Gem::CommandManager.new()\nRegister all the subcommands supported by the gem command.\n
reset Gem::CommandManager.reset()\nReset the authoritative instance of the command manager.\n
command_names Gem::CommandManager.command_names()\nReturn a sorted list of all command names (as strings).\n
find_command Gem::CommandManager.find_command(cmd_name)\n\n
find_command_possibilities Gem::CommandManager.find_command_possibilities(cmd_name)\n\n
process_args Gem::CommandManager.process_args(args)\n\n
register_command Gem::CommandManager.register_command(command)\nRegister the Symbol +command+ as a gem command.\n
run Gem::CommandManager.run(args)\nRun the config specified by +args+.\n
unregister_command Gem::CommandManager.unregister_command(command)\nUnregister the Symbol +command+ as a gem command.\n
add_common_option Gem::Command.add_common_option(*args, &handler)\n\n
add_specific_extra_args Gem::Command.add_specific_extra_args(cmd,args)\nAdd a list of extra arguments for the given command.  +args+ may be an\narray or a string to be split on white space.\n
build_args Gem::Command.build_args()\nArguments used when building gems\n
build_args= Gem::Command.build_args=(value)\n\n
common_options Gem::Command.common_options()\n\n
extra_args Gem::Command.extra_args()\n\n
extra_args= Gem::Command.extra_args=(value)\n\n
new Gem::Command.new(command, summary=nil, defaults={})\nInitializes a generic gem command named +command+.  +summary+ is a short\ndescription displayed in `gem help commands`.  +defaults+ are the default\noptions.  Defaults should be mirrored in #defaults_str, unless there are\nnone.\n\nWhen defining a new command subclass, use add_option to add command-line\nswitches.\n\nUnhandled arguments (gem names, files, etc.) are left in\n<tt>options[:args]</tt>.\n
specific_extra_args Gem::Command.specific_extra_args(cmd)\nReturn an array of extra arguments for the command.  The extra arguments\ncome from the gem configuration file read at program startup.\n
specific_extra_args_hash Gem::Command.specific_extra_args_hash()\nAccessor for the specific extra args hash (self initializing).\n
add_extra_args Gem::Command.add_extra_args(args)\nAdds extra args from ~/.gemrc\n
add_option Gem::Command.add_option(*opts)\nAdd a command-line option and handler to the command.\n\nSee OptionParser#make_switch for an explanation of +opts+.\n\n+handler+ will be called with two values, the value of the argument and\nthe options hash.\n\nIf the first argument of add_option is a Symbol, it's used to group\noptions in output.  See `gem help list` for an example.\n
arguments Gem::Command.arguments()\nOverride to provide details of the arguments a command takes.  It should\nreturn a left-justified string, one argument per line.\n\nFor example:\n\n  def usage\n    "#{program_name} FILE [FILE ...]"\n  end\n\n  def arguments\n    "FILE          name of file to find"\n  end\n
begins? Gem::Command.begins?(long, short)\nTrue if +long+ begins with the characters from +short+.\n
defaults_str Gem::Command.defaults_str()\nOverride to display the default values of the command options. (similar to\n+arguments+, but displays the default values).\n\nFor example:\n\n  def defaults_str\n    --no-gems-first --no-all\n  end\n
description Gem::Command.description()\nOverride to display a longer description of what this command does.\n
execute Gem::Command.execute()\nOverride to provide command handling.\noptions will be filled in with your parsed options, unparsed options will\nbe left in <tt>options[:args]</tt>.\n\nSee also: #get_all_gem_names, #get_one_gem_name,\nget_one_optional_argument\n
get_all_gem_names Gem::Command.get_all_gem_names()\nGet all gem names from the command line.\n
get_one_gem_name Gem::Command.get_one_gem_name()\nGet a single gem name from the command line.  Fail if there is no gem name\nor if there is more than one gem name given.\n
get_one_optional_argument Gem::Command.get_one_optional_argument()\nGet a single optional argument from the command line.  If more than one\nargument is given, return only the first. Return nil if none are given.\n
handle_options Gem::Command.handle_options(args)\nHandle the given list of arguments by parsing them and recording the\nresults.\n
handles? Gem::Command.handles?(args)\nTrue if the command handles the given argument list.\n
invoke Gem::Command.invoke(*args)\nInvoke the command with the given list of arguments.\n
merge_options Gem::Command.merge_options(new_options)\nMerge a set of command options with the set of default options (without\nmodifying the default option hash).\n
remove_option Gem::Command.remove_option(name)\nRemove previously defined command-line argument +name+.\n
show_help Gem::Command.show_help()\nDisplay the help message for the command.\n
show_lookup_failure Gem::Command.show_lookup_failure(gem_name, version, errors, domain)\nDisplay to the user that a gem couldn't be found and reasons why\n
usage Gem::Command.usage()\nOverride to display the usage for an individual gem command.\n\nThe text "[options]" is automatically appended to the usage text.\n
when_invoked Gem::Command.when_invoked(&block)\nCall the given block when invoked.\n\nNormal command invocations just executes the +execute+ method of the\ncommand.  Specifying an invocation block allows the test methods to\noverride the normal action of a command to determine that it has been\ninvoked correctly.\n
wrap Gem::Command.wrap(text, width)\nWraps +text+ to +width+\n
new Gem::MockGemUi.new(input = "")\n\n
error Gem::MockGemUi.error()\n\n
input Gem::MockGemUi.input()\n\n
output Gem::MockGemUi.output()\n\n
terminate_interaction Gem::MockGemUi.terminate_interaction(status=0)\n\n
terminated? Gem::MockGemUi.terminated?()\n\n
new Gem::MockGemUi::TermError.new(exit_code)\n\n
from_file_by_path Gem::OldFormat.from_file_by_path(file_path)\nReads the named gem file and returns a Format object, representing the\ndata from the gem file\n\nfile_path:: [String] Path to the gem file\n
from_io Gem::OldFormat.from_io(io, gem_path="(io)")\nReads a gem from an io stream and returns a Format object, representing\nthe data from the gem file\n\nio:: [IO] Stream from which to read the gem\n
new Gem::OldFormat.new(gem_path)\nConstructs an instance of a Format object, representing the gem's data\nstructure.\n\ngem:: [String] The file name of the gem\n
new OpenSSL::X509::Certificate.new(p1 = v1)\n\n
add_extension OpenSSL::X509::Certificate.add_extension(p1)\n\n
check_private_key OpenSSL::X509::Certificate.check_private_key(p1)\nChecks if 'key' is PRIV key for this cert\n
check_validity OpenSSL::X509::Certificate.check_validity(issuer_cert = nil, time = Time.now)\nCheck the validity of this certificate.\n
extensions OpenSSL::X509::Certificate.extensions()\n\n
extensions= OpenSSL::X509::Certificate.extensions=(p1)\n\n
inspect OpenSSL::X509::Certificate.inspect()\n\n
issuer OpenSSL::X509::Certificate.issuer()\n\n
issuer= OpenSSL::X509::Certificate.issuer=(p1)\n\n
not_after OpenSSL::X509::Certificate.not_after()\n\n
not_after= OpenSSL::X509::Certificate.not_after=(p1)\n\n
not_before OpenSSL::X509::Certificate.not_before()\n\n
not_before= OpenSSL::X509::Certificate.not_before=(p1)\n\n
public_key OpenSSL::X509::Certificate.public_key()\n\n
public_key= OpenSSL::X509::Certificate.public_key=(p1)\n\n
serial OpenSSL::X509::Certificate.serial()\n\n
serial= OpenSSL::X509::Certificate.serial=(p1)\n\n
sign OpenSSL::X509::Certificate.sign(p1, p2)\n\n
signature_algorithm OpenSSL::X509::Certificate.signature_algorithm()\n\n
subject OpenSSL::X509::Certificate.subject()\n\n
subject= OpenSSL::X509::Certificate.subject=(p1)\n\n
to_der OpenSSL::X509::Certificate.to_der()\n\n
to_pem OpenSSL::X509::Certificate.to_pem()\n\n
to_s OpenSSL::X509::Certificate.to_s()\n\n
to_text OpenSSL::X509::Certificate.to_text()\n\n
verify OpenSSL::X509::Certificate.verify(p1)\nChecks that cert signature is made with PRIVversion of this PUBLIC 'key'\n
version OpenSSL::X509::Certificate.version()\n\n
version= OpenSSL::X509::Certificate.version=(p1)\n\n
new Gem::PlatformMismatch.new(name, version)\n\n
add_platform Gem::PlatformMismatch.add_platform(platform)\n\n
wordy Gem::PlatformMismatch.wordy()\n\n
new Gem::Security::Policy.new(policy = {}, opt = {})\nCreate a new Gem::Security::Policy object with the given mode and\noptions.\n
trusted_cert_path Gem::Security::Policy.trusted_cert_path(cert, opt = {})\nGet the path to the file for this cert.\n
verify_gem Gem::Security::Policy.verify_gem(signature, data, chain, time = Time.now)\nVerify that the gem data with the given signature and signing chain\nmatched this security policy at the specified time.\n
new Gem::Security::Signer.new(key, cert_chain)\n\n
sign Gem::Security::Signer.sign(data)\nSign data with given digest algorithm\n
new Gem::DependencyInstaller.new(options = {})\nCreates a new installer instance.\n\nOptions are:\n:cache_dir:: Alternate repository path to store .gem files in.\n:domain:: :local, :remote, or :both.  :local only searches gems in the\n          current directory.  :remote searches only gems in Gem::sources.\n          :both searches both.\n:env_shebang:: See Gem::Installer::new.\n:force:: See Gem::Installer#install.\n:format_executable:: See Gem::Installer#initialize.\n:ignore_dependencies:: Don't install any dependencies.\n:install_dir:: See Gem::Installer#install.\n:prerelease:: Allow prerelease versions.  See #install.\n:security_policy:: See Gem::Installer::new and Gem::Security.\n:user_install:: See Gem::Installer.new\n:wrappers:: See Gem::Installer::new\n
add_found_dependencies Gem::DependencyInstaller.add_found_dependencies(to_do, dependency_list)\n\n
find_gems_with_sources Gem::DependencyInstaller.find_gems_with_sources(dep)\nReturns a list of pairs of gemspecs and source_uris that match\nGem::Dependency +dep+ from both local (Dir.pwd) and remote (Gem.sources)\nsources.  Gems are sorted with newer gems preferred over older gems, and\nlocal gems preferred over remote gems.\n
find_spec_by_name_and_version Gem::DependencyInstaller.find_spec_by_name_and_version(gem_name, version =\nGem::Requirement.default, prerelease = false)\nFinds a spec and the source_uri it came from for gem +gem_name+ and\n+version+.  Returns an Array of specs and sources required for\ninstallation of the gem.\n
gather_dependencies Gem::DependencyInstaller.gather_dependencies()\nGathers all dependencies necessary for the installation from local and\nremote sources unless the ignore_dependencies was given.\n
install Gem::DependencyInstaller.install(dep_or_name, version =\nGem::Requirement.default)\nInstalls the gem +dep_or_name+ and all its dependencies.  Returns an Array\nof installed gem specifications.\n\nIf the +:prerelease+ option is set and there is a prerelease for\n+dep_or_name+ the prerelease version will be installed.\n\nUnless explicitly specified as a prerelease dependency, prerelease gems\nthat +dep_or_name+ depend on will not be installed.\n\nIf c-1.a depends on b-1 and a-1.a and there is a gem b-1.a available then\nc-1.a, b-1 and a-1.a will be installed.  b-1.a will need to be installed\nseparately.\n
new Gem::Server.new(gem_dirs, port, daemon, launch = nil, addresses = nil)\nOnly the first directory in gem_dirs is used for serving gems\n
run Gem::Server.run(options)\n\n
Marshal Gem::Server.Marshal(req, res)\n\n
add_date Gem::Server.add_date(res)\n\n
latest_specs Gem::Server.latest_specs(req, res)\n\n
launch Gem::Server.launch()\n\n
listen Gem::Server.listen(addresses = @addresses)\nCreates server sockets based on the addresses option.  If no addresses\nwere given a server socket for all interfaces is created.\n
quick Gem::Server.quick(req, res)\n\n
rdoc Gem::Server.rdoc(req, res)\nCan be used for quick navigation to the rdoc documentation.  You can then\ndefine a search shortcut for your browser.  E.g. in Firefox connect\n'shortcut:rdoc' to http://localhost:8808/rdoc?q=%s template. Then you can\ndirectly open the ActionPack documentation by typing 'rdoc actionp'. If\nthere are multiple hits for the search term, they are presented as a list\nwith links.\n\nSearch algorithm aims for an intuitive search:\n1. first try to find the gems and documentation folders which name\n   starts with the search term\n2. search for entries, that *contain* the search term\n3. show all the gems\n\nIf there is only one search hit, user is immediately redirected to the\ndocumentation for the particular gem, otherwise a list with results is\nshown.\n\n=== Additional trick - install documentation for ruby core\n\nNote: please adjust paths accordingly use for example 'locate yaml.rb' and\n'gem environment' to identify directories, that are specific for your\nlocal installation\n\n1. install ruby sources\n     cd /usr/src\n     sudo apt-get source ruby\n\n2. generate documentation\n     rdoc -o /usr/lib/ruby/gems/1.8/doc/core/rdoc \\n       /usr/lib/ruby/1.8 ruby1.8-1.8.7.72\n\nBy typing 'rdoc core' you can now access the core documentation\n
root Gem::Server.root(req, res)\n\n
run Gem::Server.run()\n\n
show_rdoc_for_pattern Gem::Server.show_rdoc_for_pattern(pattern, res)\nReturns true and prepares http response, if rdoc for the requested gem\nname pattern was found.\n\nThe search is based on the file system content, not on the gems metadata.\nThis allows additional documentation folders like 'core' for the ruby core\ndocumentation - just put it underneath the main doc folder.\n
specs Gem::Server.specs(req, res)\n\n
new MonitorMixin::ConditionVariable.new(monitor)\n\n
broadcast MonitorMixin::ConditionVariable.broadcast()\nWakes up all threads waiting for this lock.\n
signal MonitorMixin::ConditionVariable.signal()\nWakes up the first thread in line waiting for this lock.\n
wait MonitorMixin::ConditionVariable.wait(timeout = nil)\nReleases the lock held in the associated monitor and waits; reacquires the\nlock on wakeup.\n\nIf +timeout+ is given, this method returns after +timeout+ seconds passed,\neven if no other thread doesn't signal.\n
wait_until MonitorMixin::ConditionVariable.wait_until()\nCalls wait repeatedly until the given block yields a truthy value.\n
wait_while MonitorMixin::ConditionVariable.wait_while()\nCalls wait repeatedly while the given block yields a truthy value.\n
new ConditionVariable.new()\nCreates a new ConditionVariable\n
broadcast ConditionVariable.broadcast()\nWakes up all threads waiting for this lock.\n
signal ConditionVariable.signal()\nWakes up the first thread in line waiting for this lock.\n
wait ConditionVariable.wait(mutex, timeout=nil)\nReleases the lock held in +mutex+ and waits; reacquires the lock on wakeup.\n\nIf +timeout+ is given, this method returns after +timeout+ seconds passed,\neven if no other thread doesn't signal.\n
new Queue.new()\nCreates a new queue.\n
clear Queue.clear()\nRemoves all objects from the queue.\n
deq Queue.deq(non_block=false)\nAlias of pop\n
empty? Queue.empty?()\nReturns +true+ if the queue is empty.\n
enq Queue.enq(obj)\nAlias of push\n
length Queue.length()\nReturns the length of the queue.\n
num_waiting Queue.num_waiting()\nReturns the number of threads waiting on the queue.\n
pop Queue.pop(non_block=false)\nRetrieves data from the queue.  If the queue is empty, the calling thread is\nsuspended until data is pushed onto the queue.  If +non_block+ is true, the\nthread isn't suspended, and an exception is raised.\n
push Queue.push(obj)\nPushes +obj+ to the queue.\n
shift Queue.shift(non_block=false)\nAlias of pop\n
size Queue.size()\nAlias of length.\n
new SizedQueue.new(max)\nCreates a fixed-length queue with a maximum size of +max+.\n
clear SizedQueue.clear()\nRemoves all objects from the queue and wakes waiting threads, if any.\n
deq SizedQueue.deq(*args)\nAlias of pop\n
enq SizedQueue.enq(obj)\nAlias of push\n
max SizedQueue.max()\nReturns the maximum size of the queue.\n
max= SizedQueue.max=(max)\nSets the maximum size of the queue.\n
num_waiting SizedQueue.num_waiting()\nReturns the number of threads waiting on the queue.\n
pop SizedQueue.pop(*args)\nRetrieves data from the queue and runs a waiting thread, if any.\n
push SizedQueue.push(obj)\nPushes +obj+ to the queue.  If there is no space left in the queue, waits\nuntil space becomes available.\n
shift SizedQueue.shift(*args)\nAlias of pop\n
autorun Test::Unit::Runner.autorun()\n\n
_run_parallel Test::Unit::Runner._run_parallel(suites, type, result)\n\n
_run_suites Test::Unit::Runner._run_suites(suites, type)\n\n
after_worker_down Test::Unit::Runner.after_worker_down(worker, e=nil, c=false)\n\n
after_worker_quit Test::Unit::Runner.after_worker_quit(worker)\n\n
del_jobs_status Test::Unit::Runner.del_jobs_status()\n\n
jobs_status Test::Unit::Runner.jobs_status()\n\n
puke Test::Unit::Runner.puke(klass, meth, e)\nOverriding of MiniTest::Unit#puke\n
status Test::Unit::Runner.status(*args)\n\n
launch Test::Unit::Runner::Worker.launch(ruby,args=[])\n\n
new Test::Unit::Runner::Worker.new(io, pid, status)\n\n
close Test::Unit::Runner::Worker.close()\n\n
died Test::Unit::Runner::Worker.died(*additional)\n\n
hook Test::Unit::Runner::Worker.hook(id,&block)\n\n
puts Test::Unit::Runner::Worker.puts(*args)\n\n
read Test::Unit::Runner::Worker.read()\n\n
run Test::Unit::Runner::Worker.run(task,type)\n\n
to_s Test::Unit::Runner::Worker.to_s()\n\n
new Test::Unit::AutoRunner.new(force_standalone = false, default_dir = nil,\nargv = ARGV)\n\n
run Test::Unit::AutoRunner.run(*args)\n\n
process_args Test::Unit::AutoRunner.process_args(*args)\n\n
run Test::Unit::AutoRunner.run()\n\n
test_order Test::Unit::TestCase.test_order()\n\n
on_parallel_worker? Test::Unit::TestCase.on_parallel_worker?()\n\n
run Test::Unit::TestCase.run(runner)\n\n
_run_suite Test::Unit::Worker._run_suite(suite, type)\n\n
_run_suites Test::Unit::Worker._run_suites(suites, type)\n\n
increment_io Test::Unit::Worker.increment_io(orig)\n\n
orig_run_suite Test::Unit::Worker.orig_run_suite(suite, type)\n\n
run Test::Unit::Worker.run(args = [])\n\n
new Rake::TaskArguments.new(names, values, parent=nil)\nCreate a TaskArgument object with a list of named arguments\n(given by :names) and a set of associated values (given by\n:values).  :parent is the parent argument object.\n
each Rake::TaskArguments.each(&block)\n\n
inspect Rake::TaskArguments.inspect()\n\n
lookup Rake::TaskArguments.lookup(name)\n\n
method_missing Rake::TaskArguments.method_missing(sym, *args, &block)\n\n
new_scope Rake::TaskArguments.new_scope(names)\nCreate a new argument scope using the prerequisite argument\nnames.\n
to_hash Rake::TaskArguments.to_hash()\n\n
to_s Rake::TaskArguments.to_s()\n\n
values_at Rake::TaskArguments.values_at(*keys)\n\n
with_defaults Rake::TaskArguments.with_defaults(defaults)\nSpecify a hash of default values for task arguments. Use the\ndefaults only if there is no specific value for the given\nargument.\n
date Rake::FtpFile.date()\n\n
new Rake::FtpFile.new(path, entry)\n\n
time Rake::FtpFile.time()\n\n
directory? Rake::FtpFile.directory?()\n\n
mode Rake::FtpFile.mode()\n\n
path Rake::FtpFile.path()\n\n
symlink? Rake::FtpFile.symlink?()\n\n
connect Rake::FtpUploader.connect(path, host, account, password)\nCreate an uploader and pass it to the given block as +up+.\nWhen the block is complete, close the uploader.\n
new Rake::FtpUploader.new(path, host, account, password)\nCreate an FTP uploader targeting the directory +path+ on +host+\nusing the given account and password.  +path+ will be the root\npath of the uploader.\n
close Rake::FtpUploader.close()\nClose the uploader.\n
makedirs Rake::FtpUploader.makedirs(path)\nCreate the directory +path+ in the uploader root path.\n
upload_files Rake::FtpUploader.upload_files(wildcard)\nUpload all files matching +wildcard+ to the uploader's root\npath.\n
new Rake::SshDirPublisher.new(host, remote_dir, local_dir)\n\n
upload Rake::SshDirPublisher.upload()\n\n
upload Rake::SshFreshDirPublisher.upload()\n\n
new Rake::SshFilePublisher.new(host, remote_dir, local_dir, *files)\nCreate a publisher using the give host information.\n
upload Rake::SshFilePublisher.upload()\nUpload the local directory to the remote directory.\n
new Rake::CompositePublisher.new()\n\n
add Rake::CompositePublisher.add(pub)\nAdd a publisher to the composite.\n
upload Rake::CompositePublisher.upload()\nUpload all the individual publishers.\n
new Rake::RubyForgePublisher.new(projname, user)\n\n
new CompositePublisher.new()\n\n
add CompositePublisher.add(pub)\nAdd a publisher to the composite.\n
upload CompositePublisher.upload()\nUpload all the individual publishers.\n
new SshDirPublisher.new(host, remote_dir, local_dir)\n\n
upload SshDirPublisher.upload()\n\n
upload SshFreshDirPublisher.upload()\n\n
new SshFilePublisher.new(host, remote_dir, local_dir, *files)\nCreate a publisher using the give host information.\n
upload SshFilePublisher.upload()\nUpload the local directory to the remote directory.\n
new Rake::Application.new()\nInitialize a Rake::Application object.\n
add_import Rake::Application.add_import(fn)\nAdd a file to the list of files to be imported.\n
add_loader Rake::Application.add_loader(ext, loader)\nAdd a loader to handle imported files ending in the extension\n+ext+.\n
collect_tasks Rake::Application.collect_tasks()\nCollect the list of tasks on the command line.  If no tasks are\ngiven, return a list containing only the default task.\nEnvironmental assignments are processed at this time as well.\n
const_warning Rake::Application.const_warning(const_name)\nWarn about deprecated use of top level constant names.\n
deprecate Rake::Application.deprecate(old_usage, new_usage, call_site)\nWarn about deprecated usage.\n\nExample:\n   Rake.application.deprecate("import", "Rake.import", caller.first)\n
display_error_message Rake::Application.display_error_message(ex)\nDisplay the error message that caused the exception.\n
display_prerequisites Rake::Application.display_prerequisites()\nDisplay the tasks and prerequisites\n
display_tasks_and_comments Rake::Application.display_tasks_and_comments()\nDisplay the tasks and comments.\n
dynamic_width Rake::Application.dynamic_width()\nCalculate the dynamic width of the\n
dynamic_width_stty Rake::Application.dynamic_width_stty()\n\n
dynamic_width_tput Rake::Application.dynamic_width_tput()\n\n
find_rakefile_location Rake::Application.find_rakefile_location()\n\n
handle_options Rake::Application.handle_options()\nRead and handle the command line options.\n
have_rakefile Rake::Application.have_rakefile()\nTrue if one of the files in RAKEFILES is in the current directory.\nIf a match is found, it is copied into @rakefile.\n
init Rake::Application.init(app_name='rake')\nInitialize the command line parameters and app name.\n
invoke_task Rake::Application.invoke_task(task_string)\nprivate ----------------------------------------------------------------\n
load_imports Rake::Application.load_imports()\nLoad the pending list of imported files.\n
load_rakefile Rake::Application.load_rakefile()\nFind the rakefile and then load it and any pending imports.\n
options Rake::Application.options()\nApplication options from the command line\n
parse_task_string Rake::Application.parse_task_string(string)\n\n
print_rakefile_directory Rake::Application.print_rakefile_directory(location)\n\n
rake_require Rake::Application.rake_require(file_name, paths=$LOAD_PATH, loaded=$")\nSimilar to the regular Ruby +require+ command, but will check\nfor *.rake files in addition to *.rb files.\n
rakefile_location Rake::Application.rakefile_location(backtrace = caller)\n\n
run Rake::Application.run()\nRun the Rake application.  The run method performs the following\nthree steps:\n\n* Initialize the command line options (+init+).\n* Define the tasks (+load_rakefile+).\n* Run the top level tasks (+run_tasks+).\n\nIf you wish to build a custom rake command, you should call\n+init+ on your application.  Then define any tasks.  Finally,\ncall +top_level+ to run your top level tasks.\n
standard_exception_handling Rake::Application.standard_exception_handling()\nProvide standard exception handling for the given block.\n
standard_rake_options Rake::Application.standard_rake_options()\nA list of all the standard options used in rake, suitable for\npassing to OptionParser.\n
system_dir Rake::Application.system_dir()\nThe directory path containing the system wide rakefiles.\n
terminal_width Rake::Application.terminal_width()\n\n
top_level Rake::Application.top_level()\nRun the top level tasks of a Rake application.\n
truncate Rake::Application.truncate(string, width)\n\n
truncate_output? Rake::Application.truncate_output?()\nWe will truncate output if we are outputting to a TTY or if we've been\ngiven an explicit column width to honor\n
tty_output= Rake::Application.tty_output=( tty_output_state )\nOverride the detected TTY output state (mostly for testing)\n
tty_output? Rake::Application.tty_output?()\nTrue if we are outputting to TTY, false otherwise\n
unix? Rake::Application.unix?()\n\n
windows? Rake::Application.windows?()\n\n
new Rake::PseudoStatus.new(code=0)\n\n
exited? Rake::PseudoStatus.exited?()\n\n
stopped? Rake::PseudoStatus.stopped?()\n\n
to_i Rake::PseudoStatus.to_i()\n\n
new Rake::Application.new()\nInitialize a Rake::Application object.\n
add_import Rake::Application.add_import(fn)\nAdd a file to the list of files to be imported.\n
add_loader Rake::Application.add_loader(ext, loader)\nAdd a loader to handle imported files ending in the extension\n+ext+.\n
collect_tasks Rake::Application.collect_tasks()\nCollect the list of tasks on the command line.  If no tasks are\ngiven, return a list containing only the default task.\nEnvironmental assignments are processed at this time as well.\n
const_warning Rake::Application.const_warning(const_name)\nWarn about deprecated use of top level constant names.\n
deprecate Rake::Application.deprecate(old_usage, new_usage, call_site)\nWarn about deprecated usage.\n\nExample:\n   Rake.application.deprecate("import", "Rake.import", caller.first)\n
display_error_message Rake::Application.display_error_message(ex)\nDisplay the error message that caused the exception.\n
display_prerequisites Rake::Application.display_prerequisites()\nDisplay the tasks and prerequisites\n
display_tasks_and_comments Rake::Application.display_tasks_and_comments()\nDisplay the tasks and comments.\n
dynamic_width Rake::Application.dynamic_width()\nCalculate the dynamic width of the\n
dynamic_width_stty Rake::Application.dynamic_width_stty()\n\n
dynamic_width_tput Rake::Application.dynamic_width_tput()\n\n
find_rakefile_location Rake::Application.find_rakefile_location()\n\n
handle_options Rake::Application.handle_options()\nRead and handle the command line options.\n
have_rakefile Rake::Application.have_rakefile()\nTrue if one of the files in RAKEFILES is in the current directory.\nIf a match is found, it is copied into @rakefile.\n
init Rake::Application.init(app_name='rake')\nInitialize the command line parameters and app name.\n
invoke_task Rake::Application.invoke_task(task_string)\nprivate ----------------------------------------------------------------\n
load_imports Rake::Application.load_imports()\nLoad the pending list of imported files.\n
load_rakefile Rake::Application.load_rakefile()\nFind the rakefile and then load it and any pending imports.\n
options Rake::Application.options()\nApplication options from the command line\n
parse_task_string Rake::Application.parse_task_string(string)\n\n
print_rakefile_directory Rake::Application.print_rakefile_directory(location)\n\n
rake_require Rake::Application.rake_require(file_name, paths=$LOAD_PATH, loaded=$")\nSimilar to the regular Ruby +require+ command, but will check\nfor *.rake files in addition to *.rb files.\n
rakefile_location Rake::Application.rakefile_location(backtrace = caller)\n\n
run Rake::Application.run()\nRun the Rake application.  The run method performs the following\nthree steps:\n\n* Initialize the command line options (+init+).\n* Define the tasks (+load_rakefile+).\n* Run the top level tasks (+run_tasks+).\n\nIf you wish to build a custom rake command, you should call\n+init+ on your application.  Then define any tasks.  Finally,\ncall +top_level+ to run your top level tasks.\n
standard_exception_handling Rake::Application.standard_exception_handling()\nProvide standard exception handling for the given block.\n
standard_rake_options Rake::Application.standard_rake_options()\nA list of all the standard options used in rake, suitable for\npassing to OptionParser.\n
system_dir Rake::Application.system_dir()\nThe directory path containing the system wide rakefiles.\n
terminal_width Rake::Application.terminal_width()\n\n
top_level Rake::Application.top_level()\nRun the top level tasks of a Rake application.\n
truncate Rake::Application.truncate(string, width)\n\n
truncate_output? Rake::Application.truncate_output?()\nWe will truncate output if we are outputting to a TTY or if we've been\ngiven an explicit column width to honor\n
tty_output= Rake::Application.tty_output=( tty_output_state )\nOverride the detected TTY output state (mostly for testing)\n
tty_output? Rake::Application.tty_output?()\nTrue if we are outputting to TTY, false otherwise\n
unix? Rake::Application.unix?()\n\n
windows? Rake::Application.windows?()\n\n
new Rake::PackageTask.new(name=nil, version=nil)\nCreate a Package Task with the given name and version.  Use +:noversion+\nas the version to build a package without a version or to provide a\nfully-versioned package name.\n
define Rake::PackageTask.define()\nCreate the tasks defined by this task library.\n
init Rake::PackageTask.init(name, version)\nInitialization that bypasses the "yield self" and "define" step.\n
package_dir_path Rake::PackageTask.package_dir_path()\n\n
package_name Rake::PackageTask.package_name()\n\n
tar_bz2_file Rake::PackageTask.tar_bz2_file()\n\n
tar_gz_file Rake::PackageTask.tar_gz_file()\n\n
tgz_file Rake::PackageTask.tgz_file()\n\n
zip_file Rake::PackageTask.zip_file()\n\n
new Rake::RuleRecursionOverflowError.new(*args)\n\n
add_target Rake::RuleRecursionOverflowError.add_target(target)\n\n
message Rake::RuleRecursionOverflowError.message()\n\n
append Rake::InvocationChain.append(value, chain)\n\n
new Rake::InvocationChain.new(value, tail)\n\n
append Rake::InvocationChain.append(value)\n\n
member? Rake::InvocationChain.member?(obj)\n\n
to_s Rake::InvocationChain.to_s()\n\n
append Rake::InvocationChain::EmptyInvocationChain.append(value)\n\n
member? Rake::InvocationChain::EmptyInvocationChain.member?(obj)\n\n
to_s Rake::InvocationChain::EmptyInvocationChain.to_s()\n\n
new Rake::NameSpace.new(task_manager, scope_list)\nCreate a namespace lookup object using the given task manager\nand the list of scopes.\n
tasks Rake::NameSpace.tasks()\nReturn the list of tasks defined in this and nested namespaces.\n
load Rake::DefaultLoader.load(fn)\n\n
clear Rake::Task.clear()\nClear the task list.  This cause rake to immediately forget all the\ntasks that have been assigned.  (Normally used in the unit tests.)\n
create_rule Rake::Task.create_rule(*args, &block)\nDefine a rule for synthesizing tasks.\n
define_task Rake::Task.define_task(*args, &block)\nDefine a task given +args+ and an option block.  If a rule with the\ngiven name already exists, the prerequisites and actions are added to\nthe existing task.  Returns the defined task.\n
new Rake::Task.new(task_name, app)\nCreate a task named +task_name+ with no actions or prerequisites. Use\n+enhance+ to add actions and prerequisites.\n
scope_name Rake::Task.scope_name(scope, task_name)\nApply the scope to the task name according to the rules for\nthis kind of task.  Generic tasks will accept the scope as\npart of the name.\n
task_defined? Rake::Task.task_defined?(task_name)\nTRUE if the task name is already defined.\n
tasks Rake::Task.tasks()\nList of all defined tasks.\n
add_description Rake::Task.add_description(description)\nAdd a description to the task.  The description can consist of an option\nargument list (enclosed brackets) and an optional comment.\n
arg_names Rake::Task.arg_names()\nName of arguments for this task.\n
clear Rake::Task.clear()\nClear the existing prerequisites and actions of a rake task.\n
clear_actions Rake::Task.clear_actions()\nClear the existing actions on a rake task.\n
clear_prerequisites Rake::Task.clear_prerequisites()\nClear the existing prerequisites of a rake task.\n
comment= Rake::Task.comment=(description)\nWriting to the comment attribute is the same as adding a description.\n
enhance Rake::Task.enhance(deps=nil, &block)\nEnhance a task with prerequisites or actions.  Returns self.\n
execute Rake::Task.execute(args=nil)\nExecute the actions associated with this task.\n
inspect Rake::Task.inspect()\n\n
investigation Rake::Task.investigation()\nReturn a string describing the internal state of a task.  Useful for\ndebugging.\n
invoke Rake::Task.invoke(*args)\nInvoke the task if it is needed.  Prerequisites are invoked first.\n
name Rake::Task.name()\nName of the task, including any namespace qualifiers.\n
needed? Rake::Task.needed?()\nIs this task needed?\n
prerequisite_tasks Rake::Task.prerequisite_tasks()\nList of prerequisite tasks\n
reenable Rake::Task.reenable()\nReenable the task, allowing its tasks to be executed if the task\nis invoked again.\n
set_arg_names Rake::Task.set_arg_names(args)\nSet the names of the arguments for this task. +args+ should be\nan array of symbols, one for each argument name.\n
source Rake::Task.source()\nFirst source from a rule (nil if no sources)\n
sources Rake::Task.sources()\n\n
timestamp Rake::Task.timestamp()\nTimestamp for this task.  Basic tasks return the current time for their\ntime stamp.  Other tasks can be more sophisticated.\n
to_s Rake::Task.to_s()\nReturn task name\n
new Gem::PackageTask.new(gem_spec)\nCreate a Gem Package task library.  Automatically define the gem if a\nblock is given.  If no block is supplied, then #define needs to be called\nto define the task.\n
define Gem::PackageTask.define()\nCreate the Rake tasks and actions specified by this Gem::PackageTask.\n(+define+ is automatically called if a block is given to +new+).\n
init Gem::PackageTask.init(gem)\nInitialization tasks without the "yield self" or define operations.\n
to_s Rake::EarlyTime.to_s()\n\n
new Rake::FileList.new(*patterns)\nCreate a file list from the globbable patterns given.  If you wish to\nperform multiple includes or excludes at object build time, use the\n"yield self" pattern.\n\nExample:\n  file_list = FileList.new('lib/**/*.rb', 'test/test*.rb')\n\n  pkg_files = FileList.new('lib/**/*') do |fl|\n    fl.exclude(/\bCVS\b/)\n  end\n
add Rake::FileList.add(*filenames)\n\n
clear_exclude Rake::FileList.clear_exclude()\nClear all the exclude patterns so that we exclude nothing.\n
egrep Rake::FileList.egrep(pattern, *options)\nGrep each of the files in the filelist using the given pattern. If a\nblock is given, call the block on each matching line, passing the file\nname, line number, and the matching line of text.  If no block is given,\na standard emacs style file:linenumber:line message will be printed to\nstandard out.  Returns the number of matched items.\n
exclude Rake::FileList.exclude(*patterns, &block)\nRegister a list of file name patterns that should be excluded from the\nlist.  Patterns may be regular expressions, glob patterns or regular\nstrings.  In addition, a block given to exclude will remove entries that\nreturn true when given to the block.\n\nNote that glob patterns are expanded against the file system. If a file\nis explicitly added to a file list, but does not exist in the file\nsystem, then an glob pattern in the exclude list will not exclude the\nfile.\n\nExamples:\n  FileList['a.c', 'b.c'].exclude("a.c") => ['b.c']\n  FileList['a.c', 'b.c'].exclude(/^a/)  => ['b.c']\n\nIf "a.c" is a file, then ...\n  FileList['a.c', 'b.c'].exclude("a.*") => ['b.c']\n\nIf "a.c" is not a file, then ...\n  FileList['a.c', 'b.c'].exclude("a.*") => ['a.c', 'b.c']\n
exclude? Rake::FileList.exclude?(fn)\nShould the given file name be excluded?\n
existing Rake::FileList.existing()\nReturn a new file list that only contains file names from the current\nfile list that exist on the file system.\n
existing! Rake::FileList.existing!()\nModify the current file list so that it contains only file name that\nexist on the file system.\n
ext Rake::FileList.ext(newext='')\nReturn a new FileList with <tt>String#ext</tt> method applied to\neach member of the array.\n\nThis method is a shortcut for:\n\n   array.collect { |item| item.ext(newext) }\n\n+ext+ is a user added method for the Array class.\n
gsub Rake::FileList.gsub(pat, rep)\nReturn a new FileList with the results of running +gsub+ against each\nelement of the original list.\n\nExample:\n  FileList['lib/test/file', 'x/y'].gsub(/\//, "\\")\n     => ['lib\\test\\file', 'x\\y']\n
gsub! Rake::FileList.gsub!(pat, rep)\nSame as +gsub+ except that the original file list is modified.\n
import Rake::FileList.import(array)\n\n
include Rake::FileList.include(*filenames)\nAdd file names defined by glob patterns to the file list.  If an array\nis given, add each element of the array.\n\nExample:\n  file_list.include("*.java", "*.cfg")\n  file_list.include %w( math.c lib.h *.o )\n
is_a? Rake::FileList.is_a?(klass)\nLie about our class.\n
kind_of? Rake::FileList.kind_of?(klass)\n\n
pathmap Rake::FileList.pathmap(spec=nil)\nApply the pathmap spec to each of the included file names, returning a\nnew file list with the modified paths.  (See String#pathmap for\ndetails.)\n
resolve Rake::FileList.resolve()\nResolve all the pending adds now.\n
sub Rake::FileList.sub(pat, rep)\nReturn a new FileList with the results of running +sub+ against each\nelement of the original list.\n\nExample:\n  FileList['a.c', 'b.c'].sub(/\.c$/, '.o')  => ['a.o', 'b.o']\n
sub! Rake::FileList.sub!(pat, rep)\nSame as +sub+ except that the original file list is modified.\n
to_a Rake::FileList.to_a()\nReturn the internal array object.\n
to_ary Rake::FileList.to_ary()\nReturn the internal array object.\n
to_s Rake::FileList.to_s()\nConvert a FileList to a string by joining all elements with a space.\n
needed? Rake::FileCreationTask.needed?()\nIs this file task needed?  Yes if it doesn't exist.\n
timestamp Rake::FileCreationTask.timestamp()\nTime stamp for file creation task.  This time stamp is earlier\nthan any other time stamp.\n
needed? Rake::FileTask.needed?()\nIs this file task needed?  Yes if it doesn't exist, or if its time stamp\nis out of date.\n
timestamp Rake::FileTask.timestamp()\nTime stamp for file task.\n
new Rake::TestTask.new(name=:test)\nCreate a testing task.\n
define Rake::TestTask.define()\nCreate the tasks defined by this task lib.\n
file_list_string Rake::TestTask.file_list_string()\n\n
lib_path Rake::TestTask.lib_path()\n\n
ruby_opts_string Rake::TestTask.ruby_opts_string()\n\n
ruby_version Rake::TestTask.ruby_version()\n\n
run_code Rake::TestTask.run_code()\n\n
test_files= Rake::TestTask.test_files=(list)\nExplicitly define the list of test files to be included in a\ntest.  +list+ is expected to be an array of file names (a\nFileList is acceptable).  If both +pattern+ and +test_files+ are\nused, then the list of test files is the union of the two.\n
load Rake::MakefileLoader.load(fn)\nLoad the makefile dependencies in +fn+.\n
format PrettyPrint.format(output='', maxwidth=79, newline="\n", genspace=lambda {|n|\n' ' * n})\nThis is a convenience method which is same as follows:\n\n  begin\n    q = PrettyPrint.new(output, maxwidth, newline, &genspace)\n    ...\n    q.flush\n    output\n  end\n
new PrettyPrint.new(output='', maxwidth=79, newline="\n", &genspace)\nCreates a buffer for pretty printing.\n\n+output+ is an output target. If it is not specified, '' is assumed. It\nshould have a << method which accepts the first argument +obj+ of\nPrettyPrint#text, the first argument +sep+ of PrettyPrint#breakable, the\nfirst argument +newline+ of PrettyPrint.new, and the result of a given\nblock for PrettyPrint.new.\n\n+maxwidth+ specifies maximum line length. If it is not specified, 79 is\nassumed. However actual outputs may overflow +maxwidth+ if long\nnon-breakable texts are provided.\n\n+newline+ is used for line breaks. "\\n" is used if it is not specified.\n\nThe block is used to generate spaces. {|width| ' ' * width} is used if it\nis not given.\n
singleline_format PrettyPrint.singleline_format(output='', maxwidth=nil, newline=nil,\ngenspace=nil)\nThis is similar to PrettyPrint::format but the result has no breaks.\n\n+maxwidth+, +newline+ and +genspace+ are ignored.\n\nThe invocation of +breakable+ in the block doesn't break a line and is\ntreated as just an invocation of +text+.\n
break_outmost_groups PrettyPrint.break_outmost_groups()\nBreaks the buffer into lines that are shorter than #maxwidth\n
breakable PrettyPrint.breakable(sep=' ', width=sep.length)\nThis says "you can break a line here if necessary", and a +width+\-column\ntext +sep+ is inserted if a line is not broken at the point.\n\nIf +sep+ is not specified, " " is used.\n\nIf +width+ is not specified, +sep.length+ is used. You will have to\nspecify this when +sep+ is a multibyte character, for example.\n
current_group PrettyPrint.current_group()\nReturns the group most recently added to the stack.\n
fill_breakable PrettyPrint.fill_breakable(sep=' ', width=sep.length)\nThis is similar to #breakable except\nthe decision to break or not is determined individually.\n\nTwo #fill_breakable under a group may cause 4 results:\n(break,break), (break,non-break), (non-break,break), (non-break,non-break).\nThis is different to #breakable because two #breakable under a group\nmay cause 2 results:\n(break,break), (non-break,non-break).\n\nThe text sep+ is inserted if a line is not broken at this point.\n\nIf +sep+ is not specified, " " is used.\n\nIf +width+ is not specified, +sep.length+ is used. You will have to\nspecify this when +sep+ is a multibyte character, for example.\n
first? PrettyPrint.first?()\nfirst? is a predicate to test the call is a first call to first? with\ncurrent group.\n\nIt is useful to format comma separated values as:\n\n  q.group(1, '[', ']') {\n    xxx.each {|yyy|\n      unless q.first?\n        q.text ','\n        q.breakable\n      end\n      ... pretty printing yyy ...\n    }\n  }\n\nfirst? is obsoleted in 1.8.2.\n
flush PrettyPrint.flush()\noutputs buffered data.\n
group PrettyPrint.group(indent=0, open_obj='', close_obj='',\nopen_width=open_obj.length, close_width=close_obj.length)\nGroups line break hints added in the block. The line break hints are all\nto be used or not.\n\nIf +indent+ is specified, the method call is regarded as nested by\nnest(indent) { ... }.\n\nIf +open_obj+ is specified, <tt>text open_obj, open_width</tt> is called\nbefore grouping. If +close_obj+ is specified, <tt>text close_obj,\nclose_width</tt> is called after grouping.\n
group_sub PrettyPrint.group_sub()\n\n
nest PrettyPrint.nest(indent)\nIncreases left margin after newline with +indent+ for line breaks added in\nthe block.\n
text PrettyPrint.text(obj, width=obj.length)\nThis adds +obj+ as a text of +width+ columns in width.\n\nIf +width+ is not specified, obj.length is used.\n
new PrettyPrint::Text.new()\n\n
add PrettyPrint::Text.add(obj, width)\n\n
output PrettyPrint::Text.output(out, output_width)\n\n
new PrettyPrint::Breakable.new(sep, width, q)\n\n
output PrettyPrint::Breakable.output(out, output_width)\n\n
new PrettyPrint::Group.new(depth)\n\n
break PrettyPrint::Group.break()\n\n
break? PrettyPrint::Group.break?()\n\n
first? PrettyPrint::Group.first?()\n\n
new PrettyPrint::GroupQueue.new(*groups)\n\n
delete PrettyPrint::GroupQueue.delete(group)\n\n
deq PrettyPrint::GroupQueue.deq()\n\n
enq PrettyPrint::GroupQueue.enq(group)\n\n
new PrettyPrint::SingleLine.new(output, maxwidth=nil, newline=nil)\n\n
breakable PrettyPrint::SingleLine.breakable(sep=' ', width=nil)\n\n
first? PrettyPrint::SingleLine.first?()\n\n
flush PrettyPrint::SingleLine.flush()\n\n
group PrettyPrint::SingleLine.group(indent=nil, open_obj='', close_obj='',\nopen_width=nil, close_width=nil)\n\n
nest PrettyPrint::SingleLine.nest(indent)\n\n
text PrettyPrint::SingleLine.text(obj, width=nil)\n\n
accept_charset CGI.accept_charset()\nReturn the accept character set for all new CGI instances.\n
accept_charset= CGI.accept_charset=(accept_charset)\nSet the accept character set for all new CGI instances.\n
escape CGI.escape(string)\nURL-encode a string.\n  url_encoded_string = CGI::escape("'Stop!' said Fred")\n => "%27Stop%21%27+said+Fred"\n
escapeElement CGI.escapeElement(string, *elements)\nEscape only the tags of certain HTML elements in +string+.\n\nTakes an element or elements or array of elements.  Each element\nis specified by the name of the element, without angle brackets.\nThis matches both the start and the end tag of that element.\nThe attribute list of the open tag will also be escaped (for\ninstance, the double-quotes surrounding attribute values).\n\n  print CGI::escapeElement('<BR><A HREF="url"></A>', "A", "IMG")\n "<BR>&lt;A HREF=&quot;url&quot;&gt;&lt;/A&gt"\n\n  print CGI::escapeElement('<BR><A HREF="url"></A>', ["A", "IMG"])\n "<BR>&lt;A HREF=&quot;url&quot;&gt;&lt;/A&gt"\n
escapeHTML CGI.escapeHTML(string)\nEscape special characters in HTML, namely &\"<>\n  CGI::escapeHTML('Usage: foo "bar" <baz>')\n => "Usage: foo &quot;bar&quot; &lt;baz&gt;"\n
escape_element CGI.escape_element(str)\nSynonym for CGI::escapeElement(str)\n
escape_html CGI.escape_html(str)\nSynonym for CGI::escapeHTML(str)\n
new CGI.new(options = {})\nCreate a new CGI instance.\n\n<tt>tag_maker</tt>::\n  This is the same as using the +options_hash+ form with the value <tt>{\n  :tag_maker => tag_maker }</tt> Note that it is recommended to use the\n  +options_hash+ form, since it also allows you specify the charset you\n  will accept.\n<tt>options_hash</tt>::\n  A Hash that recognizes two options:\n\n  <tt>:accept_charset</tt>::\n    specifies encoding of received query string.  If omitted,\n    <tt>@@accept_charset</tt> is used.  If the encoding is not valid, a\n    CGI::InvalidEncoding will be raised.\n\n    Example. Suppose <tt>@@accept_charset</tt> is "UTF-8"\n\n    when not specified:\n\n        cgi=CGI.new      # @accept_charset # => "UTF-8"\n\n    when specified as "EUC-JP":\n\n        cgi=CGI.new(:accept_charset => "EUC-JP") # => "EUC-JP"\n\n  <tt>:tag_maker</tt>::\n    String that specifies which version of the HTML generation methods to\n    use.  If not specified, no HTML generation methods will be loaded.\n\n    The following values are supported:\n\n    "html3":: HTML 3.x\n    "html4":: HTML 4.0\n    "html4Tr":: HTML 4.0 Transitional\n    "html4Fr":: HTML 4.0 with Framesets\n\n<tt>block</tt>::\n  If provided, the block is called when an invalid encoding is\n  encountered. For example:\n\n    encoding_errors={}\n    cgi=CGI.new(:accept_charset=>"EUC-JP") do |name,value|\n      encoding_errors[name] = value\n    end\n\nFinally, if the CGI object is not created in a standard CGI call\nenvironment (that is, it can't locate REQUEST_METHOD in its environment),\nthen it will run in "offline" mode.  In this mode, it reads its parameters\nfrom the command line or (failing that) from standard input.  Otherwise,\ncookies and other parameters are parsed automatically from the standard\nCGI locations, which varies according to the REQUEST_METHOD.\n
parse CGI.parse(query)\nParse an HTTP query string into a hash of key=>value pairs.\n\n  params = CGI::parse("query_string")\n {"name1" => ["value1", "value2", ...],\n  "name2" => ["value1", "value2", ...], ... }\n
pretty CGI.pretty(string, shift = " ")\nPrettify (indent) an HTML string.\n\n+string+ is the HTML string to indent.  +shift+ is the indentation\nunit to use; it defaults to two spaces.\n\n  print CGI::pretty("<HTML><BODY></BODY></HTML>")\n <HTML>\n   <BODY>\n   </BODY>\n </HTML>\n\n  print CGI::pretty("<HTML><BODY></BODY></HTML>", "\t")\n <HTML>\n         <BODY>\n         </BODY>\n </HTML>\n
rfc1123_date CGI.rfc1123_date(time)\nFormat a +Time+ object as a String using the format specified by RFC 1123.\n\n  CGI::rfc1123_date(Time.now)\n Sat, 01 Jan 2000 00:00:00 GMT\n
unescape CGI.unescape(string,encoding=@@accept_charset)\nURL-decode a string with encoding(optional).\n  string = CGI::unescape("%27Stop%21%27+said+Fred")\n => "'Stop!' said Fred"\n
unescapeElement CGI.unescapeElement(string, *elements)\nUndo escaping such as that done by CGI::escapeElement()\n\n  print CGI::unescapeElement(\n          CGI::escapeHTML('<BR><A HREF="url"></A>'), "A", "IMG")\n "&lt;BR&gt;<A HREF="url"></A>"\n\n  print CGI::unescapeElement(\n          CGI::escapeHTML('<BR><A HREF="url"></A>'), ["A", "IMG"])\n "&lt;BR&gt;<A HREF="url"></A>"\n
unescapeHTML CGI.unescapeHTML(string)\nUnescape a string that has been HTML-escaped\n  CGI::unescapeHTML("Usage: foo &quot;bar&quot; &lt;baz&gt;")\n => "Usage: foo \"bar\" <baz>"\n
unescape_element CGI.unescape_element(str)\nSynonym for CGI::unescapeElement(str)\n
unescape_html CGI.unescape_html(str)\nSynonym for CGI::unescapeHTML(str)\n
header CGI.header(options='text/html')\nCreate an HTTP header block as a string.\n\nIncludes the empty line that ends the header block.\n\n+content_type_string+::\n  If this form is used, this string is the <tt>Content-Type</tt>\n+headers_hash+::\n  A Hash of header values. The following header keys are recognized:\n\n  type:: The Content-Type header.  Defaults to "text/html"\n  charset:: The charset of the body, appended to the Content-Type header.\n  nph:: A boolean value.  If true, prepend protocol string and status\n        code, and date; and sets default values for "server" and\n        "connection" if not explicitly set.\n  status::\n    The HTTP status code as a String, returned as the Status header.  The\n    values are:\n\n    OK:: 200 OK\n    PARTIAL_CONTENT:: 206 Partial Content\n    MULTIPLE_CHOICES:: 300 Multiple Choices\n    MOVED:: 301 Moved Permanently\n    REDIRECT:: 302 Found\n    NOT_MODIFIED:: 304 Not Modified\n    BAD_REQUEST:: 400 Bad Request\n    AUTH_REQUIRED:: 401 Authorization Required\n    FORBIDDEN:: 403 Forbidden\n    NOT_FOUND:: 404 Not Found\n    METHOD_NOT_ALLOWED:: 405 Method Not Allowed\n    NOT_ACCEPTABLE:: 406 Not Acceptable\n    LENGTH_REQUIRED:: 411 Length Required\n    PRECONDITION_FAILED:: 412 Precondition Failed\n    SERVER_ERROR:: 500 Internal Server Error\n    NOT_IMPLEMENTED:: 501 Method Not Implemented\n    BAD_GATEWAY:: 502 Bad Gateway\n    VARIANT_ALSO_VARIES:: 506 Variant Also Negotiates\n\n  server:: The server software, returned as the Server header.\n  connection:: The connection type, returned as the Connection header (for\n               instance, "close".\n  length:: The length of the content that will be sent, returned as the\n           Content-Length header.\n  language:: The language of the content, returned as the Content-Language\n             header.\n  expires:: The time on which the current content expires, as a +Time+\n            object, returned as the Expires header.\n  cookie::\n    A cookie or cookies, returned as one or more Set-Cookie headers.  The\n    value can be the literal string of the cookie; a CGI::Cookie object;\n    an Array of literal cookie strings or Cookie objects; or a hash all of\n    whose values are literal cookie strings or Cookie objects.\n\n    These cookies are in addition to the cookies held in the\n    @output_cookies field.\n\n  Other headers can also be set; they are appended as key: value.\n\nExamples:\n\n  header\n Content-Type: text/html\n\n  header("text/plain")\n Content-Type: text/plain\n\n  header("nph"        => true,\n         "status"     => "OK",  # == "200 OK"\n "status"     => "200 GOOD",\n         "server"     => ENV['SERVER_SOFTWARE'],\n         "connection" => "close",\n         "type"       => "text/html",\n         "charset"    => "iso-2022-jp",\n Content-Type: text/html; charset=iso-2022-jp\n         "length"     => 103,\n         "language"   => "ja",\n         "expires"    => Time.now + 30,\n         "cookie"     => [cookie1, cookie2],\n         "my_header1" => "my_value"\n         "my_header2" => "my_value")\n\nThis method does not perform charset conversion.\n
out CGI.out(options = "text/html")\nPrint an HTTP header and body to $DEFAULT_OUTPUT ($>)\n\n+content_type_string+::\n  If a string is passed, it is assumed to be the content type.\n+headers_hash+::\n  This is a Hash of headers, similar to that used by #header.\n+block+::\n  A block is required and should evaluate to the body of the response.\n\n<tt>Content-Length</tt> is automatically calculated from the size of\nthe String returned by the content block.\n\nIf <tt>ENV['REQUEST_METHOD'] == "HEAD"</tt>, then only the header\nis output (the content block is still required, but it is ignored).\n\nIf the charset is "iso-2022-jp" or "euc-jp" or "shift_jis" then the\ncontent is converted to this charset, and the language is set to "ja".\n\nExample:\n\n  cgi = CGI.new\n  cgi.out{ "string" }\n Content-Type: text/html\n Content-Length: 6\n\n string\n\n  cgi.out("text/plain") { "string" }\n Content-Type: text/plain\n Content-Length: 6\n\n string\n\n  cgi.out("nph"        => true,\n          "status"     => "OK",  # == "200 OK"\n          "server"     => ENV['SERVER_SOFTWARE'],\n          "connection" => "close",\n          "type"       => "text/html",\n          "charset"    => "iso-2022-jp",\n Content-Type: text/html; charset=iso-2022-jp\n          "language"   => "ja",\n          "expires"    => Time.now + (3600 * 24 * 30),\n          "cookie"     => [cookie1, cookie2],\n          "my_header1" => "my_value",\n          "my_header2" => "my_value") { "string" }\n HTTP/1.1 200 OK\n Date: Sun, 15 May 2011 17:35:54 GMT\n Server: Apache 2.2.0\n Connection: close\n Content-Type: text/html; charset=iso-2022-jp\n Content-Length: 6\n Content-Language: ja\n Expires: Tue, 14 Jun 2011 17:35:54 GMT\n Set-Cookie: foo\n Set-Cookie: bar\n my_header1: my_value\n my_header2: my_value\n\n string\n
print CGI.print(*options)\nPrint an argument or list of arguments to the default output stream\n\n  cgi = CGI.new\n  cgi.print    # default:  cgi.print == $DEFAULT_OUTPUT.print\n
new CGI::Session.new(request, option={})\nCreate a new CGI::Session object for +request+.\n\n+request+ is an instance of the +CGI+ class (see cgi.rb).\n+option+ is a hash of options for initialising this\nCGI::Session instance.  The following options are\nrecognised:\n\nsession_key:: the parameter name used for the session id.\n              Defaults to '_session_id'.\nsession_id:: the session id to use.  If not provided, then\n             it is retrieved from the +session_key+ parameter\n             of the request, or automatically generated for\n             a new session.\nnew_session:: if true, force creation of a new session.  If not set,\n              a new session is only created if none currently\n              exists.  If false, a new session is never created,\n              and if none currently exists and the +session_id+\n              option is not set, an ArgumentError is raised.\ndatabase_manager:: the name of the class providing storage facilities\n                   for session state persistence.  Built-in support\n                   is provided for +FileStore+ (the default),\n                   +MemoryStore+, and +PStore+ (from\n                   cgi/session/pstore.rb).  See the documentation for\n                   these classes for more details.\n\nThe following options are also recognised, but only apply if the\nsession id is stored in a cookie.\n\nsession_expires:: the time the current session expires, as a\n                  +Time+ object.  If not set, the session will terminate\n                  when the user's browser is closed.\nsession_domain:: the hostname domain for which this session is valid.\n                 If not set, defaults to the hostname of the server.\nsession_secure:: if +true+, this session will only work over HTTPS.\nsession_path:: the path for which this session applies.  Defaults\n               to the directory of the CGI script.\n\n+option+ is also passed on to the session storage class initializer; see\nthe documentation for each session storage class for the options\nthey support.\n\nThe retrieved or created session is automatically added to +request+\nas a cookie, and also to its +output_hidden+ table, which is used\nto add hidden input elements to forms.\n\n*WARNING* the +output_hidden+\nfields are surrounded by a <fieldset> tag in HTML 4 generation, which\nis _not_ invisible on many browsers; you may wish to disable the\nuse of fieldsets with code similar to the following\n(see http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-list/37805)\n\n  cgi = CGI.new("html4")\n  class << cgi\n      undef_method :fieldset\n  end\n
close CGI::Session.close()\nStore session data on the server and close the session storage.\nFor some session storage types, this is a no-op.\n
delete CGI::Session.delete()\nDelete the session from storage.  Also closes the storage.\n\nNote that the session's data is _not_ automatically deleted\nupon the session expiring.\n
update CGI::Session.update()\nStore session data on the server.  For some session storage types,\nthis is a no-op.\n
new CGI::Session::PStore.new(session, option={})\nCreate a new CGI::Session::PStore instance\n\nThis constructor is used internally by CGI::Session.  The\nuser does not generally need to call it directly.\n\n+session+ is the session for which this instance is being\ncreated.  The session id must only contain alphanumeric\ncharacters; automatically generated session ids observe\nthis requirement.\n\n+option+ is a hash of options for the initializer.  The\nfollowing options are recognised:\n\ntmpdir:: the directory to use for storing the PStore\n         file.  Defaults to Dir::tmpdir (generally "/tmp"\n         on Unix systems).\nprefix:: the prefix to add to the session id when generating\n         the filename for this session's PStore file.\n         Defaults to the empty string.\n\nThis session's PStore file will be created if it does\nnot exist, or opened if it does.\n
close CGI::Session::PStore.close()\nUpdate and close the session's PStore file.\n
delete CGI::Session::PStore.delete()\nClose and delete the session's PStore file.\n
restore CGI::Session::PStore.restore()\nRestore session state from the session's PStore file.\n\nReturns the session state as a hash.\n
update CGI::Session::PStore.update()\nSave session state to the session's PStore file.\n
new CGI::Cookie.new(name = "", *value)\nCreate a new CGI::Cookie object.\n\n+name_string+::\n  The name of the cookie; in this form, there is no #domain or\nexpiration.  The #path is gleaned from the +SCRIPT_NAME+ environment\n  variable, and #secure is false.\n<tt>*value</tt>::\n  value or list of values of the cookie\n+options_hash+::\n  A Hash of options to initialize this Cookie.  Possible options are:\n\n  name:: the name of the cookie.  Required.\n  value:: the cookie's value or list of values.\n  path:: the path for which this cookie applies.  Defaults to the\n         the value of the +SCRIPT_NAME+ environment variable.\n  domain:: the domain for which this cookie applies.\n  expires:: the time at which this cookie expires, as a +Time+ object.\n  secure:: whether this cookie is a secure cookie or not (default to\n           false).  Secure cookies are only transmitted to HTTPS\n           servers.\n\n  These keywords correspond to attributes of the cookie object.\n
parse CGI::Cookie.parse(raw_cookie)\nParse a raw cookie string into a hash of cookie-name=>Cookie\npairs.\n\n  cookies = CGI::Cookie::parse("raw_cookie_string")\n { "name1" => cookie1, "name2" => cookie2, ... }\n
secure= CGI::Cookie.secure=(val)\nSet whether the Cookie is a secure cookie or not.\n\n+val+ must be a boolean.\n
to_s CGI::Cookie.to_s()\nConvert the Cookie to its string representation.\n
value CGI::Cookie.value()\nReturns the value or list of values for this cookie.\n
value= CGI::Cookie.value=(val)\nReplaces the value of this cookie with a new value or list of values.\n
new CGI::Session::FileStore.new(session, option={})\nCreate a new FileStore instance.\n\nThis constructor is used internally by CGI::Session.  The\nuser does not generally need to call it directly.\n\n+session+ is the session for which this instance is being\ncreated.  The session id must only contain alphanumeric\ncharacters; automatically generated session ids observe\nthis requirement.\n\n+option+ is a hash of options for the initializer.  The\nfollowing options are recognised:\n\ntmpdir:: the directory to use for storing the FileStore\n         file.  Defaults to Dir::tmpdir (generally "/tmp"\n         on Unix systems).\nprefix:: the prefix to add to the session id when generating\n         the filename for this session's FileStore file.\n         Defaults to "cgi_sid_".\nsuffix:: the prefix to add to the session id when generating\n         the filename for this session's FileStore file.\n         Defaults to the empty string.\n\nThis session's FileStore file will be created if it does\nnot exist, or opened if it does.\n
close CGI::Session::FileStore.close()\nUpdate and close the session's FileStore file.\n
delete CGI::Session::FileStore.delete()\nClose and delete the session's FileStore file.\n
restore CGI::Session::FileStore.restore()\nRestore session state from the session's FileStore file.\n\nReturns the session state as a hash.\n
update CGI::Session::FileStore.update()\nSave session state to the session's FileStore file.\n
new CGI::Session::MemoryStore.new(session, option=nil)\nCreate a new MemoryStore instance.\n\n+session+ is the session this instance is associated with.\n+option+ is a list of initialisation options.  None are\ncurrently recognised.\n
close CGI::Session::MemoryStore.close()\nClose session storage.\n\nA no-op.\n
delete CGI::Session::MemoryStore.delete()\nDelete the session state.\n
restore CGI::Session::MemoryStore.restore()\nRestore session state.\n\nReturns session data as a hash.\n
update CGI::Session::MemoryStore.update()\nUpdate session state.\n\nA no-op.\n
new CGI::Session::NullStore.new(session, option=nil)\nCreate a new NullStore instance.\n\n+session+ is the session this instance is associated with.\n+option+ is a list of initialisation options.  None are\ncurrently recognised.\n
close CGI::Session::NullStore.close()\nClose session storage.\n\nA no-op.\n
delete CGI::Session::NullStore.delete()\nDelete the session state.\n\nA no-op.\n
restore CGI::Session::NullStore.restore()\nRestore (empty) session state.\n
update CGI::Session::NullStore.update()\nUpdate session state.\n\nA no-op.\n
delegating_block Delegator.delegating_block(mid)\n\n
new Delegator.new(obj)\nPass in the _obj_ to delegate method calls to.  All methods supported by\n_obj_ will be delegated to.\n
__getobj__ Delegator.__getobj__()\nThis method must be overridden by subclasses and should return the object\nmethod calls are being delegated to.\n
__setobj__ Delegator.__setobj__(obj)\nThis method must be overridden by subclasses and change the object delegate\nto _obj_.\n
freeze Delegator.freeze\nFreeze both the object returned by \_\_getobj\_\_ and self.\n
marshal_dump Delegator.marshal_dump()\nSerialization support for the object returned by \_\_getobj\_\_.\n
marshal_load Delegator.marshal_load(data)\nReinitializes delegation from a serialized object.\n
method_missing Delegator.method_missing(m, *args, &block)\nHandles the magic of delegation through \_\_getobj\_\_.\n
methods Delegator.methods()\nReturns the methods available to this delegate object as the union\nof this object's and \_\_getobj\_\_ methods.\n
protected_methods Delegator.protected_methods(all=true)\nReturns the methods available to this delegate object as the union\nof this object's and \_\_getobj\_\_ protected methods.\n
public_methods Delegator.public_methods(all=true)\nReturns the methods available to this delegate object as the union\nof this object's and \_\_getobj\_\_ public methods.\n
respond_to_missing? Delegator.respond_to_missing?(m, include_private)\nChecks for a method provided by this the delegate object by forwarding the\ncall through \_\_getobj\_\_.\n
taint Delegator.taint\nTaint both the object returned by \_\_getobj\_\_ and self.\n
trust Delegator.trust\nTrust both the object returned by \_\_getobj\_\_ and self.\n
untaint Delegator.untaint\nUntaint both the object returned by \_\_getobj\_\_ and self.\n
untrust Delegator.untrust\nUntrust both the object returned by \_\_getobj\_\_ and self.\n
__getobj__ SimpleDelegator.__getobj__()\nReturns the current object method calls are being delegated to.\n
__setobj__ SimpleDelegator.__setobj__(obj)\nChanges the delegate object to _obj_.\n\nIt's important to note that this does *not* cause SimpleDelegator's methods\nto change.  Because of this, you probably only want to change delegation\nto objects of the same type as the original delegate.\n\nHere's an example of changing the delegation object.\n\n  names = SimpleDelegator.new(%w{James Edward Gray II})\n  puts names[1]    # => Edward\n  names.__setobj__(%w{Gavin Sinclair})\n  puts names[1]    # => Sinclair\n
new Net::FTP.new(host = nil, user = nil, passwd = nil, acct = nil)\nCreates and returns a new +FTP+ object. If a +host+ is given, a connection\nis made. Additionally, if the +user+ is given, the given user name,\npassword, and (optionally) account are used to log in.  See #login.\n
open Net::FTP.open(host, user = nil, passwd = nil, acct = nil)\nA synonym for <tt>FTP.new</tt>, but with a mandatory host parameter.\n\nIf a block is given, it is passed the +FTP+ object, which will be closed\nwhen the block finishes, or when an exception is raised.\n
abort Net::FTP.abort()\nAborts the previous command (ABOR command).\n
acct Net::FTP.acct(account)\nSends the ACCT command.\n\nThis is a less common FTP command, to send account\ninformation if the destination host requires it.\n
binary= Net::FTP.binary=(newmode)\nA setter to toggle transfers in binary mode.\n+newmode+ is either +true+ or +false+\n
chdir Net::FTP.chdir(dirname)\nChanges the (remote) directory.\n
close Net::FTP.close()\nCloses the connection.  Further operations are impossible until you open\na new connection with #connect.\n
closed? Net::FTP.closed?()\nReturns +true+ iff the connection is closed.\n
connect Net::FTP.connect(host, port = FTP_PORT)\nEstablishes an FTP connection to host, optionally overriding the default\nport. If the environment variable +SOCKS_SERVER+ is set, sets up the\nconnection through a SOCKS proxy. Raises an exception (typically\n<tt>Errno::ECONNREFUSED</tt>) if the connection cannot be established.\n
delete Net::FTP.delete(filename)\nDeletes a file on the server.\n
dir Net::FTP.dir(*args)\n\n
get Net::FTP.get(remotefile, localfile = File.basename(remotefile), blocksize =\nDEFAULT_BLOCKSIZE)\nRetrieves +remotefile+ in whatever mode the session is set (text or\nbinary).  See #gettextfile and #getbinaryfile.\n
getbinaryfile Net::FTP.getbinaryfile(remotefile, localfile = File.basename(remotefile),\nblocksize = DEFAULT_BLOCKSIZE)\nRetrieves +remotefile+ in binary mode, storing the result in +localfile+.\nIf +localfile+ is nil, returns retrieved data.\nIf a block is supplied, it is passed the retrieved data in +blocksize+\nchunks.\n
getdir Net::FTP.getdir()\n\n
gettextfile Net::FTP.gettextfile(remotefile, localfile = File.basename(remotefile))\nRetrieves +remotefile+ in ASCII (text) mode, storing the result in\n+localfile+.\nIf +localfile+ is nil, returns retrieved data.\nIf a block is supplied, it is passed the retrieved data one\nline at a time.\n
help Net::FTP.help(arg = nil)\nIssues the HELP command.\n
list Net::FTP.list(*args)\nReturns an array of file information in the directory (the output is like\n`ls -l`).  If a block is given, it iterates through the listing.\n
login Net::FTP.login(user = "anonymous", passwd = nil, acct = nil)\nLogs in to the remote host. The session must have been previously\nconnected.  If +user+ is the string "anonymous" and the +password+ is\n+nil+, a password of <tt>user@host</tt> is synthesized. If the +acct+\nparameter is not +nil+, an FTP ACCT command is sent following the\nsuccessful login.  Raises an exception on error (typically\n<tt>Net::FTPPermError</tt>).\n
ls Net::FTP.ls(*args)\n\n
mdtm Net::FTP.mdtm(filename)\nIssues the MDTM command.  TODO: more info.\n
mkdir Net::FTP.mkdir(dirname)\nCreates a remote directory.\n
mtime Net::FTP.mtime(filename, local = false)\nReturns the last modification time of the (remote) file.  If +local+ is\n+true+, it is returned as a local time, otherwise it's a UTC time.\n
nlst Net::FTP.nlst(dir = nil)\nReturns an array of filenames in the remote directory.\n
noop Net::FTP.noop()\nIssues a NOOP command.\n\nDoes nothing except return a response.\n
put Net::FTP.put(localfile, remotefile = File.basename(localfile), blocksize =\nDEFAULT_BLOCKSIZE, &block)\nTransfers +localfile+ to the server in whatever mode the session is set\n(text or binary).  See #puttextfile and #putbinaryfile.\n
putbinaryfile Net::FTP.putbinaryfile(localfile, remotefile = File.basename(localfile),\nblocksize = DEFAULT_BLOCKSIZE)\nTransfers +localfile+ to the server in binary mode, storing the result in\n+remotefile+. If a block is supplied, calls it, passing in the transmitted\ndata in +blocksize+ chunks.\n
puttextfile Net::FTP.puttextfile(localfile, remotefile = File.basename(localfile))\nTransfers +localfile+ to the server in ASCII (text) mode, storing the result\nin +remotefile+. If callback or an associated block is supplied, calls it,\npassing in the transmitted data one line at a time.\n
pwd Net::FTP.pwd()\nReturns the current remote directory.\n
quit Net::FTP.quit()\nExits the FTP session.\n
rename Net::FTP.rename(fromname, toname)\nRenames a file on the server.\n
retrbinary Net::FTP.retrbinary(cmd, blocksize, rest_offset = nil)\nPuts the connection into binary (image) mode, issues the given command,\nand fetches the data returned, passing it to the associated block in\nchunks of +blocksize+ characters. Note that +cmd+ is a server command\n(such as "RETR myfile").\n
retrlines Net::FTP.retrlines(cmd)\nPuts the connection into ASCII (text) mode, issues the given command, and\npasses the resulting data, one line at a time, to the associated block. If\nno block is given, prints the lines. Note that +cmd+ is a server command\n(such as "RETR myfile").\n
rmdir Net::FTP.rmdir(dirname)\nRemoves a remote directory.\n
sendcmd Net::FTP.sendcmd(cmd)\nSends a command and returns the response.\n
set_socket Net::FTP.set_socket(sock, get_greeting = true)\nWRITEME or make private\n
site Net::FTP.site(arg)\nIssues a SITE command.\n
size Net::FTP.size(filename)\nReturns the size of the given (remote) filename.\n
status Net::FTP.status()\nReturns the status (STAT command).\n
storbinary Net::FTP.storbinary(cmd, file, blocksize, rest_offset = nil)\nPuts the connection into binary (image) mode, issues the given server-side\ncommand (such as "STOR myfile"), and sends the contents of the file named\n+file+ to the server. If the optional block is given, it also passes it\nthe data, in chunks of +blocksize+ characters.\n
storlines Net::FTP.storlines(cmd, file)\nPuts the connection into ASCII (text) mode, issues the given server-side\ncommand (such as "STOR myfile"), and sends the contents of the file\nnamed +file+ to the server, one line at a time. If the optional block is\ngiven, it also passes it the lines.\n
system Net::FTP.system()\nReturns system information.\n
voidcmd Net::FTP.voidcmd(cmd)\nSends a command and expect a response beginning with '2'.\n
Proxy Net::HTTP.Proxy(p_addr, p_port = nil, p_user = nil, p_pass = nil)\nCreates an HTTP proxy class which behaves like Net::HTTP, but\nperforms all access via the specified proxy.\n\nThe arguments are the DNS name or IP address of the proxy host,\nthe port to use to access the proxy, and a username and password\nif authorization is required to use the proxy.\n\nYou can replace any use of the Net::HTTP class with use of the\nproxy class created.\n\nIf +p_addr+ is nil, this method returns self (a Net::HTTP object).\n Example\n  proxy_class = Net::HTTP::Proxy('proxy.example.com', 8080)\n\n  proxy_class.start('www.ruby-lang.org') {|http|\n connecting proxy.foo.org:8080\n  }\n\nYou may use them to work with authorization-enabled proxies:\n\n  proxy_host = 'your.proxy.example'\n  proxy_port = 8080\n  proxy_user = 'user'\n  proxy_pass = 'pass'\n\n  proxy = Net::HTTP::Proxy(proxy_host, proxy_port, proxy_user, proxy_pass)\n  proxy.start('www.example.com') { |http|\n always connect to your.proxy.example:8080 using specified username\n and password\n  }\n\nNote that net/http does not use the HTTP_PROXY environment variable.\nIf you want to use a proxy, you must set it explicitly.\n
default_port Net::HTTP.default_port()\nThe default port to use for HTTP requests; defaults to 80.\n
get Net::HTTP.get(uri_or_host, path = nil, port = nil)\nSends a GET request to the target and returns the HTTP response\nas a string.  The target can either be specified as\n(+uri+), or as (+host+, +path+, +port+ = 80); so:\n\n   print Net::HTTP.get(URI('http://www.example.com/index.html'))\n\nor:\n\n   print Net::HTTP.get('www.example.com', '/index.html')\n
get_print Net::HTTP.get_print(uri_or_host, path = nil, port = nil)\nGets the body text from the target and outputs it to $stdout.  The\ntarget can either be specified as\n(+uri+), or as (+host+, +path+, +port+ = 80); so:\n\n   Net::HTTP.get_print URI('http://www.example.com/index.html')\n\nor:\n\n   Net::HTTP.get_print 'www.example.com', '/index.html'\n
get_response Net::HTTP.get_response(uri_or_host, path = nil, port = nil, &block)\nSends a GET request to the target and returns the HTTP response\nas a Net::HTTPResponse object.  The target can either be specified as\n(+uri+), or as (+host+, +path+, +port+ = 80); so:\n\n   res = Net::HTTP.get_response(URI('http://www.example.com/index.html'))\n   print res.body\n\nor:\n\n   res = Net::HTTP.get_response('www.example.com', '/index.html')\n   print res.body\n
http_default_port Net::HTTP.http_default_port()\nThe default port to use for HTTP requests; defaults to 80.\n
https_default_port Net::HTTP.https_default_port()\nThe default port to use for HTTPS requests; defaults to 443.\n
is_version_1_2? Net::HTTP.is_version_1_2?()\n\n
new Net::HTTP.new(address, port = nil, p_addr = nil, p_port = nil, p_user = nil,\np_pass = nil)\nCreates a new Net::HTTP object without opening a TCP connection or\nHTTP session.\nThe +address+ should be a DNS hostname or IP address.\nIf +p_addr+ is given, creates a Net::HTTP object with proxy support.\n
new Net::HTTP.new(address, port = nil)\nCreates a new Net::HTTP object for the specified server address,\nwithout opening the TCP connection or initializing the HTTP session.\nThe +address+ should be a DNS hostname or IP address.\n
newobj Net::HTTP.newobj(address, port = nil, p_addr = nil, p_port = nil, p_user =\nnil, p_pass = nil)\n\n
post_form Net::HTTP.post_form(url, params)\nPosts HTML form data to the specified URI object.\nThe form data must be provided as a Hash mapping from String to String.\nExample:\n\n  { "cmd" => "search", "q" => "ruby", "max" => "50" }\n\nThis method also does Basic Authentication iff +url+.user exists.\nBut userinfo for authentication is deprecated (RFC3986).\nSo this feature will be removed.\n\nExample:\n\n  require 'net/http'\n  require 'uri'\n\n  HTTP.post_form URI('http://www.example.com/search.cgi'),\n                 { "q" => "ruby", "max" => "50" }\n
proxy_class? Net::HTTP.proxy_class?()\nreturns true if self is a class which was created by HTTP::Proxy.\n
start Net::HTTP.start(address, *arg)\nCreates a new Net::HTTP object, then additionally opens the TCP\nconnection and HTTP session.\n\nArguments are the following:\n_address_ :: hostname or IP address of the server\n_port_    :: port of the server\n_p_addr_  :: address of proxy\n_p_port_  :: port of proxy\n_p_user_  :: user of proxy\n_p_pass_  :: pass of proxy\n_opt_     :: optional hash\n\n_opt_ sets following values by its accessor.\nThe keys are ca_file, ca_path, cert, cert_store, ciphers,\nclose_on_empty_response, key, open_timeout, read_timeout, ssl_timeout,\nssl_version, use_ssl, verify_callback, verify_depth and verify_mode.\nIf you set :use_ssl as true, you can use https and default value of\nverify_mode is set as OpenSSL::SSL::VERIFY_PEER.\n\nIf the optional block is given, the newly\ncreated Net::HTTP object is passed to it and closed when the\nblock finishes.  In this case, the return value of this method\nis the return value of the block.  If no block is given, the\nreturn value of this method is the newly created Net::HTTP object\nitself, and the caller is responsible for closing it upon completion\nusing the finish() method.\n
version_1_2 Net::HTTP.version_1_2()\nTurns on net/http 1.2 (ruby 1.8) features.\nDefaults to ON in ruby 1.8 or later.\n
version_1_2? Net::HTTP.version_1_2?()\nReturns true if net/http is in version 1.2 mode.\nDefaults to true.\n
active? Net::HTTP.active?()\n\n
continue_timeout= Net::HTTP.continue_timeout=(sec)\nSetter for the continue_timeout attribute.\n
copy Net::HTTP.copy(path, initheader = nil)\nSends a COPY request to the +path+ and gets a response,\nas an HTTPResponse object.\n
delete Net::HTTP.delete(path, initheader = {'Depth' => 'Infinity'})\nSends a DELETE request to the +path+ and gets a response,\nas an HTTPResponse object.\n
finish Net::HTTP.finish()\nFinishes the HTTP session and closes the TCP connection.\nRaises IOError if the session has not been started.\n
get Net::HTTP.get(path, initheader = {}, dest = nil)\nGets data from +path+ on the connected-to host.\n+initheader+ must be a Hash like { 'Accept' => '*/*', ... },\nand it defaults to an empty hash.\nIf +initheader+ doesn't have the key 'accept-encoding', then\na value of "gzip;q=1.0,deflate;q=0.6,identity;q=0.3" is used,\nso that gzip compression is used in preference to deflate\ncompression, which is used in preference to no compression.\nRuby doesn't have libraries to support the compress (Lempel-Ziv)\ncompression, so that is not supported.  The intent of this is\nto reduce bandwidth by default.   If this routine sets up\ncompression, then it does the decompression also, removing\nthe header as well to prevent confusion.  Otherwise\nit leaves the body as it found it.\n\nThis method returns a Net::HTTPResponse object.\n\nIf called with a block, yields each fragment of the\nentity body in turn as a string as it is read from\nthe socket.  Note that in this case, the returned response\nobject will *not* contain a (meaningful) body.\n\n+dest+ argument is obsolete.\nIt still works but you must not use it.\n\nThis method never raises an exception.\n\n    response = http.get('/index.html')\n using block\n    File.open('result.txt', 'w') {|f|\n      http.get('/~foo/') do |str|\n        f.write str\n      end\n    }\n
get2 Net::HTTP.get2(path, initheader = nil)\n\n
head Net::HTTP.head(path, initheader = nil)\nGets only the header from +path+ on the connected-to host.\n+header+ is a Hash like { 'Accept' => '*/*', ... }.\n\nThis method returns a Net::HTTPResponse object.\n\nThis method never raises an exception.\n\n    response = nil\n    Net::HTTP.start('some.www.server', 80) {|http|\n      response = http.head('/index.html')\n    }\n    p response['content-type']\n
head2 Net::HTTP.head2(path, initheader = nil, &block)\n\n
inspect Net::HTTP.inspect()\n\n
lock Net::HTTP.lock(path, body, initheader = nil)\nSends a LOCK request to the +path+ and gets a response,\nas an HTTPResponse object.\n
mkcol Net::HTTP.mkcol(path, body = nil, initheader = nil)\nSends a MKCOL request to the +path+ and gets a response,\nas an HTTPResponse object.\n
move Net::HTTP.move(path, initheader = nil)\nSends a MOVE request to the +path+ and gets a response,\nas an HTTPResponse object.\n
options Net::HTTP.options(path, initheader = nil)\nSends a OPTIONS request to the +path+ and gets a response,\nas an HTTPResponse object.\n
patch Net::HTTP.patch(path, data, initheader = nil, dest = nil)\nSends a PATCH request to the +path+ and gets a response,\nas an HTTPResponse object.\n
peer_cert Net::HTTP.peer_cert()\nReturns the X.509 certificates the server presented.\n
post Net::HTTP.post(path, data, initheader = nil, dest = nil)\nPosts +data+ (must be a String) to +path+. +header+ must be a Hash\nlike { 'Accept' => '*/*', ... }.\n\nThis method returns a Net::HTTPResponse object.\n\nIf called with a block, yields each fragment of the\nentity body in turn as a string as it is read from\nthe socket.  Note that in this case, the returned response\nobject will *not* contain a (meaningful) body.\n\n+dest+ argument is obsolete.\nIt still works but you must not use it.\n\nThis method never raises exception.\n\n    response = http.post('/cgi-bin/search.rb', 'query=foo')\n using block\n    File.open('result.txt', 'w') {|f|\n      http.post('/cgi-bin/search.rb', 'query=foo') do |str|\n        f.write str\n      end\n    }\n\nYou should set Content-Type: header field for POST.\nIf no Content-Type: field given, this method uses\n"application/x-www-form-urlencoded" by default.\n
post2 Net::HTTP.post2(path, data, initheader = nil)\n\n
propfind Net::HTTP.propfind(path, body = nil, initheader = {'Depth' => '0'})\nSends a PROPFIND request to the +path+ and gets a response,\nas an HTTPResponse object.\n
proppatch Net::HTTP.proppatch(path, body, initheader = nil)\nSends a PROPPATCH request to the +path+ and gets a response,\nas an HTTPResponse object.\n
proxy? Net::HTTP.proxy?()\nTrue if self is a HTTP proxy class.\n
proxy_address Net::HTTP.proxy_address()\nA convenience method for accessing value of proxy_address from Net::HTTP.\n
proxy_pass Net::HTTP.proxy_pass()\nA convenience method for accessing value of proxy_pass from Net::HTTP.\n
proxy_port Net::HTTP.proxy_port()\nA convenience method for accessing value of proxy_port from Net::HTTP.\n
proxy_user Net::HTTP.proxy_user()\nA convenience method for accessing value of proxy_user from Net::HTTP.\n
proxyaddr Net::HTTP.proxyaddr()\n\n
proxyport Net::HTTP.proxyport()\n\n
read_timeout= Net::HTTP.read_timeout=(sec)\nSetter for the read_timeout attribute.\n
request Net::HTTP.request(req, body = nil)\nSends an HTTPRequest object +req+ to the HTTP server.\n\nIf +req+ is a Net::HTTP::Post or Net::HTTP::Put request containing\ndata, the data is also sent. Providing data for a Net::HTTP::Head or\nNet::HTTP::Get request results in an ArgumentError.\n\nReturns an HTTPResponse object.\n\nWhen called with a block, passes an HTTPResponse object to the block.\nThe body of the response will not have been read yet;\nthe block can process it using HTTPResponse#read_body,\nif desired.\n\nThis method never raises Net::* exceptions.\n
request_get Net::HTTP.request_get(path, initheader = nil)\nSends a GET request to the +path+.\nReturns the response as a Net::HTTPResponse object.\n\nWhen called with a block, passes an HTTPResponse object to the block.\nThe body of the response will not have been read yet;\nthe block can process it using HTTPResponse#read_body,\nif desired.\n\nReturns the response.\n\nThis method never raises Net::* exceptions.\n\n    response = http.request_get('/index.html')\n The entity body is already read in this case.\n    p response['content-type']\n    puts response.body\n Using a block\n    http.request_get('/index.html') {|response|\n      p response['content-type']\n      response.read_body do |str|   # read body now\n        print str\n      end\n    }\n
request_head Net::HTTP.request_head(path, initheader = nil, &block)\nSends a HEAD request to the +path+ and returns the response\nas a Net::HTTPResponse object.\n\nReturns the response.\n\nThis method never raises Net::* exceptions.\n\n    response = http.request_head('/index.html')\n    p response['content-type']\n
request_post Net::HTTP.request_post(path, data, initheader = nil)\nSends a POST request to the +path+.\n\nReturns the response as a Net::HTTPResponse object.\n\nWhen called with a block, the block is passed an HTTPResponse\nobject.  The body of that response will not have been read yet;\nthe block can process it using HTTPResponse#read_body, if desired.\n\nReturns the response.\n\nThis method never raises Net::* exceptions.\n example\n    response = http.request_post('/cgi-bin/nice.rb', 'datadatadata...')\n    p response.status\n    puts response.body          # body is already read in this case\n using block\n    http.request_post('/cgi-bin/nice.rb', 'datadatadata...') {|response|\n      p response.status\n      p response['content-type']\n      response.read_body do |str|   # read body now\n        print str\n      end\n    }\n
send_request Net::HTTP.send_request(name, path, data = nil, header = nil)\nSends an HTTP request to the HTTP server.\nAlso sends a DATA string if +data+ is given.\n\nReturns a Net::HTTPResponse object.\n\nThis method never raises Net::* exceptions.\n\n   response = http.send_request('GET', '/index.html')\n   puts response.body\n
set_debug_output Net::HTTP.set_debug_output(output)\n*WARNING* This method opens a serious security hole.\nNever use this method in production code.\n\nSets an output stream for debugging.\n\n  http = Net::HTTP.new\n  http.set_debug_output $stderr\n  http.start { .... }\n
start Net::HTTP.start()\nOpens a TCP connection and HTTP session.\n\nWhen this method is called with a block, it passes the Net::HTTP\nobject to the block, and closes the TCP connection and HTTP session\nafter the block has been executed.\n\nWhen called with a block, it returns the return value of the\nblock; otherwise, it returns self.\n
started? Net::HTTP.started?()\nReturns true if the HTTP session has been started.\n
trace Net::HTTP.trace(path, initheader = nil)\nSends a TRACE request to the +path+ and gets a response,\nas an HTTPResponse object.\n
unlock Net::HTTP.unlock(path, body, initheader = nil)\nSends a UNLOCK request to the +path+ and gets a response,\nas an HTTPResponse object.\n
use_ssl= Net::HTTP.use_ssl=(flag)\nTurn on/off SSL.\nThis flag must be set before starting session.\nIf you change use_ssl value after session started,\na Net::HTTP object raises IOError.\n
use_ssl? Net::HTTP.use_ssl?()\nReturns true if SSL/TLS is being used with HTTP.\n
Proxy Net::HTTPSession.Proxy(p_addr, p_port = nil, p_user = nil, p_pass = nil)\nCreates an HTTP proxy class which behaves like Net::HTTP, but\nperforms all access via the specified proxy.\n\nThe arguments are the DNS name or IP address of the proxy host,\nthe port to use to access the proxy, and a username and password\nif authorization is required to use the proxy.\n\nYou can replace any use of the Net::HTTP class with use of the\nproxy class created.\n\nIf +p_addr+ is nil, this method returns self (a Net::HTTP object).\n Example\n  proxy_class = Net::HTTP::Proxy('proxy.example.com', 8080)\n\n  proxy_class.start('www.ruby-lang.org') {|http|\n connecting proxy.foo.org:8080\n  }\n\nYou may use them to work with authorization-enabled proxies:\n\n  proxy_host = 'your.proxy.example'\n  proxy_port = 8080\n  proxy_user = 'user'\n  proxy_pass = 'pass'\n\n  proxy = Net::HTTP::Proxy(proxy_host, proxy_port, proxy_user, proxy_pass)\n  proxy.start('www.example.com') { |http|\n always connect to your.proxy.example:8080 using specified username\n and password\n  }\n\nNote that net/http does not use the HTTP_PROXY environment variable.\nIf you want to use a proxy, you must set it explicitly.\n
default_port Net::HTTPSession.default_port()\nThe default port to use for HTTP requests; defaults to 80.\n
get Net::HTTPSession.get(uri_or_host, path = nil, port = nil)\nSends a GET request to the target and returns the HTTP response\nas a string.  The target can either be specified as\n(+uri+), or as (+host+, +path+, +port+ = 80); so:\n\n   print Net::HTTP.get(URI('http://www.example.com/index.html'))\n\nor:\n\n   print Net::HTTP.get('www.example.com', '/index.html')\n
get_print Net::HTTPSession.get_print(uri_or_host, path = nil, port = nil)\nGets the body text from the target and outputs it to $stdout.  The\ntarget can either be specified as\n(+uri+), or as (+host+, +path+, +port+ = 80); so:\n\n   Net::HTTP.get_print URI('http://www.example.com/index.html')\n\nor:\n\n   Net::HTTP.get_print 'www.example.com', '/index.html'\n
get_response Net::HTTPSession.get_response(uri_or_host, path = nil, port = nil, &block)\nSends a GET request to the target and returns the HTTP response\nas a Net::HTTPResponse object.  The target can either be specified as\n(+uri+), or as (+host+, +path+, +port+ = 80); so:\n\n   res = Net::HTTP.get_response(URI('http://www.example.com/index.html'))\n   print res.body\n\nor:\n\n   res = Net::HTTP.get_response('www.example.com', '/index.html')\n   print res.body\n
http_default_port Net::HTTPSession.http_default_port()\nThe default port to use for HTTP requests; defaults to 80.\n
https_default_port Net::HTTPSession.https_default_port()\nThe default port to use for HTTPS requests; defaults to 443.\n
is_version_1_2? Net::HTTPSession.is_version_1_2?()\n\n
new Net::HTTPSession.new(address, port = nil, p_addr = nil, p_port = nil, p_user =\nnil, p_pass = nil)\nCreates a new Net::HTTP object without opening a TCP connection or\nHTTP session.\nThe +address+ should be a DNS hostname or IP address.\nIf +p_addr+ is given, creates a Net::HTTP object with proxy support.\n
new Net::HTTPSession.new(address, port = nil)\nCreates a new Net::HTTP object for the specified server address,\nwithout opening the TCP connection or initializing the HTTP session.\nThe +address+ should be a DNS hostname or IP address.\n
newobj Net::HTTPSession.newobj(address, port = nil, p_addr = nil, p_port = nil,\np_user = nil, p_pass = nil)\n\n
post_form Net::HTTPSession.post_form(url, params)\nPosts HTML form data to the specified URI object.\nThe form data must be provided as a Hash mapping from String to String.\nExample:\n\n  { "cmd" => "search", "q" => "ruby", "max" => "50" }\n\nThis method also does Basic Authentication iff +url+.user exists.\nBut userinfo for authentication is deprecated (RFC3986).\nSo this feature will be removed.\n\nExample:\n\n  require 'net/http'\n  require 'uri'\n\n  HTTP.post_form URI('http://www.example.com/search.cgi'),\n                 { "q" => "ruby", "max" => "50" }\n
proxy_class? Net::HTTPSession.proxy_class?()\nreturns true if self is a class which was created by HTTP::Proxy.\n
start Net::HTTPSession.start(address, *arg)\nCreates a new Net::HTTP object, then additionally opens the TCP\nconnection and HTTP session.\n\nArguments are the following:\n_address_ :: hostname or IP address of the server\n_port_    :: port of the server\n_p_addr_  :: address of proxy\n_p_port_  :: port of proxy\n_p_user_  :: user of proxy\n_p_pass_  :: pass of proxy\n_opt_     :: optional hash\n\n_opt_ sets following values by its accessor.\nThe keys are ca_file, ca_path, cert, cert_store, ciphers,\nclose_on_empty_response, key, open_timeout, read_timeout, ssl_timeout,\nssl_version, use_ssl, verify_callback, verify_depth and verify_mode.\nIf you set :use_ssl as true, you can use https and default value of\nverify_mode is set as OpenSSL::SSL::VERIFY_PEER.\n\nIf the optional block is given, the newly\ncreated Net::HTTP object is passed to it and closed when the\nblock finishes.  In this case, the return value of this method\nis the return value of the block.  If no block is given, the\nreturn value of this method is the newly created Net::HTTP object\nitself, and the caller is responsible for closing it upon completion\nusing the finish() method.\n
version_1_2 Net::HTTPSession.version_1_2()\nTurns on net/http 1.2 (ruby 1.8) features.\nDefaults to ON in ruby 1.8 or later.\n
version_1_2? Net::HTTPSession.version_1_2?()\nReturns true if net/http is in version 1.2 mode.\nDefaults to true.\n
active? Net::HTTPSession.active?()\n\n
continue_timeout= Net::HTTPSession.continue_timeout=(sec)\nSetter for the continue_timeout attribute.\n
copy Net::HTTPSession.copy(path, initheader = nil)\nSends a COPY request to the +path+ and gets a response,\nas an HTTPResponse object.\n
delete Net::HTTPSession.delete(path, initheader = {'Depth' => 'Infinity'})\nSends a DELETE request to the +path+ and gets a response,\nas an HTTPResponse object.\n
finish Net::HTTPSession.finish()\nFinishes the HTTP session and closes the TCP connection.\nRaises IOError if the session has not been started.\n
get Net::HTTPSession.get(path, initheader = {}, dest = nil)\nGets data from +path+ on the connected-to host.\n+initheader+ must be a Hash like { 'Accept' => '*/*', ... },\nand it defaults to an empty hash.\nIf +initheader+ doesn't have the key 'accept-encoding', then\na value of "gzip;q=1.0,deflate;q=0.6,identity;q=0.3" is used,\nso that gzip compression is used in preference to deflate\ncompression, which is used in preference to no compression.\nRuby doesn't have libraries to support the compress (Lempel-Ziv)\ncompression, so that is not supported.  The intent of this is\nto reduce bandwidth by default.   If this routine sets up\ncompression, then it does the decompression also, removing\nthe header as well to prevent confusion.  Otherwise\nit leaves the body as it found it.\n\nThis method returns a Net::HTTPResponse object.\n\nIf called with a block, yields each fragment of the\nentity body in turn as a string as it is read from\nthe socket.  Note that in this case, the returned response\nobject will *not* contain a (meaningful) body.\n\n+dest+ argument is obsolete.\nIt still works but you must not use it.\n\nThis method never raises an exception.\n\n    response = http.get('/index.html')\n using block\n    File.open('result.txt', 'w') {|f|\n      http.get('/~foo/') do |str|\n        f.write str\n      end\n    }\n
get2 Net::HTTPSession.get2(path, initheader = nil)\n\n
head Net::HTTPSession.head(path, initheader = nil)\nGets only the header from +path+ on the connected-to host.\n+header+ is a Hash like { 'Accept' => '*/*', ... }.\n\nThis method returns a Net::HTTPResponse object.\n\nThis method never raises an exception.\n\n    response = nil\n    Net::HTTP.start('some.www.server', 80) {|http|\n      response = http.head('/index.html')\n    }\n    p response['content-type']\n
head2 Net::HTTPSession.head2(path, initheader = nil, &block)\n\n
inspect Net::HTTPSession.inspect()\n\n
lock Net::HTTPSession.lock(path, body, initheader = nil)\nSends a LOCK request to the +path+ and gets a response,\nas an HTTPResponse object.\n
mkcol Net::HTTPSession.mkcol(path, body = nil, initheader = nil)\nSends a MKCOL request to the +path+ and gets a response,\nas an HTTPResponse object.\n
move Net::HTTPSession.move(path, initheader = nil)\nSends a MOVE request to the +path+ and gets a response,\nas an HTTPResponse object.\n
options Net::HTTPSession.options(path, initheader = nil)\nSends a OPTIONS request to the +path+ and gets a response,\nas an HTTPResponse object.\n
patch Net::HTTPSession.patch(path, data, initheader = nil, dest = nil)\nSends a PATCH request to the +path+ and gets a response,\nas an HTTPResponse object.\n
peer_cert Net::HTTPSession.peer_cert()\nReturns the X.509 certificates the server presented.\n
post Net::HTTPSession.post(path, data, initheader = nil, dest = nil)\nPosts +data+ (must be a String) to +path+. +header+ must be a Hash\nlike { 'Accept' => '*/*', ... }.\n\nThis method returns a Net::HTTPResponse object.\n\nIf called with a block, yields each fragment of the\nentity body in turn as a string as it is read from\nthe socket.  Note that in this case, the returned response\nobject will *not* contain a (meaningful) body.\n\n+dest+ argument is obsolete.\nIt still works but you must not use it.\n\nThis method never raises exception.\n\n    response = http.post('/cgi-bin/search.rb', 'query=foo')\n using block\n    File.open('result.txt', 'w') {|f|\n      http.post('/cgi-bin/search.rb', 'query=foo') do |str|\n        f.write str\n      end\n    }\n\nYou should set Content-Type: header field for POST.\nIf no Content-Type: field given, this method uses\n"application/x-www-form-urlencoded" by default.\n
post2 Net::HTTPSession.post2(path, data, initheader = nil)\n\n
propfind Net::HTTPSession.propfind(path, body = nil, initheader = {'Depth' => '0'})\nSends a PROPFIND request to the +path+ and gets a response,\nas an HTTPResponse object.\n
proppatch Net::HTTPSession.proppatch(path, body, initheader = nil)\nSends a PROPPATCH request to the +path+ and gets a response,\nas an HTTPResponse object.\n
proxy? Net::HTTPSession.proxy?()\nTrue if self is a HTTP proxy class.\n
proxy_address Net::HTTPSession.proxy_address()\nA convenience method for accessing value of proxy_address from Net::HTTP.\n
proxy_pass Net::HTTPSession.proxy_pass()\nA convenience method for accessing value of proxy_pass from Net::HTTP.\n
proxy_port Net::HTTPSession.proxy_port()\nA convenience method for accessing value of proxy_port from Net::HTTP.\n
proxy_user Net::HTTPSession.proxy_user()\nA convenience method for accessing value of proxy_user from Net::HTTP.\n
proxyaddr Net::HTTPSession.proxyaddr()\n\n
proxyport Net::HTTPSession.proxyport()\n\n
read_timeout= Net::HTTPSession.read_timeout=(sec)\nSetter for the read_timeout attribute.\n
request Net::HTTPSession.request(req, body = nil)\nSends an HTTPRequest object +req+ to the HTTP server.\n\nIf +req+ is a Net::HTTP::Post or Net::HTTP::Put request containing\ndata, the data is also sent. Providing data for a Net::HTTP::Head or\nNet::HTTP::Get request results in an ArgumentError.\n\nReturns an HTTPResponse object.\n\nWhen called with a block, passes an HTTPResponse object to the block.\nThe body of the response will not have been read yet;\nthe block can process it using HTTPResponse#read_body,\nif desired.\n\nThis method never raises Net::* exceptions.\n
request_get Net::HTTPSession.request_get(path, initheader = nil)\nSends a GET request to the +path+.\nReturns the response as a Net::HTTPResponse object.\n\nWhen called with a block, passes an HTTPResponse object to the block.\nThe body of the response will not have been read yet;\nthe block can process it using HTTPResponse#read_body,\nif desired.\n\nReturns the response.\n\nThis method never raises Net::* exceptions.\n\n    response = http.request_get('/index.html')\n The entity body is already read in this case.\n    p response['content-type']\n    puts response.body\n Using a block\n    http.request_get('/index.html') {|response|\n      p response['content-type']\n      response.read_body do |str|   # read body now\n        print str\n      end\n    }\n
request_head Net::HTTPSession.request_head(path, initheader = nil, &block)\nSends a HEAD request to the +path+ and returns the response\nas a Net::HTTPResponse object.\n\nReturns the response.\n\nThis method never raises Net::* exceptions.\n\n    response = http.request_head('/index.html')\n    p response['content-type']\n
request_post Net::HTTPSession.request_post(path, data, initheader = nil)\nSends a POST request to the +path+.\n\nReturns the response as a Net::HTTPResponse object.\n\nWhen called with a block, the block is passed an HTTPResponse\nobject.  The body of that response will not have been read yet;\nthe block can process it using HTTPResponse#read_body, if desired.\n\nReturns the response.\n\nThis method never raises Net::* exceptions.\n example\n    response = http.request_post('/cgi-bin/nice.rb', 'datadatadata...')\n    p response.status\n    puts response.body          # body is already read in this case\n using block\n    http.request_post('/cgi-bin/nice.rb', 'datadatadata...') {|response|\n      p response.status\n      p response['content-type']\n      response.read_body do |str|   # read body now\n        print str\n      end\n    }\n
send_request Net::HTTPSession.send_request(name, path, data = nil, header = nil)\nSends an HTTP request to the HTTP server.\nAlso sends a DATA string if +data+ is given.\n\nReturns a Net::HTTPResponse object.\n\nThis method never raises Net::* exceptions.\n\n   response = http.send_request('GET', '/index.html')\n   puts response.body\n
set_debug_output Net::HTTPSession.set_debug_output(output)\n*WARNING* This method opens a serious security hole.\nNever use this method in production code.\n\nSets an output stream for debugging.\n\n  http = Net::HTTP.new\n  http.set_debug_output $stderr\n  http.start { .... }\n
start Net::HTTPSession.start()\nOpens a TCP connection and HTTP session.\n\nWhen this method is called with a block, it passes the Net::HTTP\nobject to the block, and closes the TCP connection and HTTP session\nafter the block has been executed.\n\nWhen called with a block, it returns the return value of the\nblock; otherwise, it returns self.\n
started? Net::HTTPSession.started?()\nReturns true if the HTTP session has been started.\n
trace Net::HTTPSession.trace(path, initheader = nil)\nSends a TRACE request to the +path+ and gets a response,\nas an HTTPResponse object.\n
unlock Net::HTTPSession.unlock(path, body, initheader = nil)\nSends a UNLOCK request to the +path+ and gets a response,\nas an HTTPResponse object.\n
use_ssl= Net::HTTPSession.use_ssl=(flag)\nTurn on/off SSL.\nThis flag must be set before starting session.\nIf you change use_ssl value after session started,\na Net::HTTP object raises IOError.\n
use_ssl? Net::HTTPSession.use_ssl?()\nReturns true if SSL/TLS is being used with HTTP.\n
new Net::HTTPGenericRequest.new(m, reqbody, resbody, path, initheader = nil)\n\n
body= Net::HTTPGenericRequest.body=(str)\n\n
body_exist? Net::HTTPGenericRequest.body_exist?()\n\n
body_stream= Net::HTTPGenericRequest.body_stream=(input)\n\n
inspect Net::HTTPGenericRequest.inspect()\n\n
request_body_permitted? Net::HTTPGenericRequest.request_body_permitted?()\n\n
response_body_permitted? Net::HTTPGenericRequest.response_body_permitted?()\n\n
new Net::HTTPRequest.new(path, initheader = nil)\nCreates HTTP request object.\n
body_permitted? Net::HTTPResponse.body_permitted?()\ntrue if the response has a body.\n
body Net::HTTPResponse.body()\nReturns the full entity body.\n\nCalling this method a second or subsequent time will return the\nstring already read.\n\n  http.request_get('/index.html') {|res|\n    puts res.body\n  }\n\n  http.request_get('/index.html') {|res|\n    p res.body.object_id   # 538149362\n    p res.body.object_id   # 538149362\n  }\n
body= Net::HTTPResponse.body=(value)\nBecause it may be necessary to modify the body, Eg, decompression\nthis method facilitates that.\n
entity Net::HTTPResponse.entity()\n\n
inspect Net::HTTPResponse.inspect()\n\n
read_body Net::HTTPResponse.read_body(dest = nil, &block)\nGets the entity body returned by the remote HTTP server.\n\nIf a block is given, the body is passed to the block, and\nthe body is provided in fragments, as it is read in from the socket.\n\nCalling this method a second or subsequent time for the same\nHTTPResponse object will return the value already read.\n\n  http.request_get('/index.html') {|res|\n    puts res.read_body\n  }\n\n  http.request_get('/index.html') {|res|\n    p res.read_body.object_id   # 538149362\n    p res.read_body.object_id   # 538149362\n  }\n using iterator\n  http.request_get('/index.html') {|res|\n    res.read_body do |segment|\n      print segment\n    end\n  }\n
value Net::HTTPResponse.value()\nRaises an HTTP error if the response is not 2xx (success).\n
add_authenticator Net::IMAP.add_authenticator(auth_type, authenticator)\nAdds an authenticator for Net::IMAP#authenticate.  +auth_type+\nis the type of authentication this authenticator supports\n(for instance, "LOGIN").  The +authenticator+ is an object\nwhich defines a process() method to handle authentication with\nthe server.  See Net::IMAP::LoginAuthenticator,\nNet::IMAP::CramMD5Authenticator, and Net::IMAP::DigestMD5Authenticator\nfor examples.\n\nIf +auth_type+ refers to an existing authenticator, it will be\nreplaced by the new one.\n
debug Net::IMAP.debug()\nReturns the debug mode.\n
debug= Net::IMAP.debug=(val)\nSets the debug mode.\n
decode_utf7 Net::IMAP.decode_utf7(s)\nDecode a string from modified UTF-7 format to UTF-8.\n\nUTF-7 is a 7-bit encoding of Unicode [UTF7].  IMAP uses a\nslightly modified version of this to encode mailbox names\ncontaining non-ASCII characters; see [IMAP] section 5.1.3.\n\nNet::IMAP does _not_ automatically encode and decode\nmailbox names to and from utf7.\n
encode_utf7 Net::IMAP.encode_utf7(s)\nEncode a string from UTF-8 format to modified UTF-7.\n
format_date Net::IMAP.format_date(time)\nFormats +time+ as an IMAP-style date.\n
format_datetime Net::IMAP.format_datetime(time)\nFormats +time+ as an IMAP-style date-time.\n
max_flag_count Net::IMAP.max_flag_count()\nReturns the max number of flags interned to symbols.\n
max_flag_count= Net::IMAP.max_flag_count=(count)\nSets the max number of flags interned to symbols.\n
new Net::IMAP.new(host, port_or_options = {}, usessl = false, certs = nil,\nverify = true)\nCreates a new Net::IMAP object and connects it to the specified\n+host+.\n\n+options+ is an option hash, each key of which is a symbol.\n\nThe available options are:\n\nport::  port number (default value is 143 for imap, or 993 for imaps)\nssl::   if options[:ssl] is true, then an attempt will be made\n        to use SSL (now TLS) to connect to the server.  For this to work\n        OpenSSL [OSSL] and the Ruby OpenSSL [RSSL] extensions need to\n        be installed.\n        if options[:ssl] is a hash, it's passed to\n        OpenSSL::SSL::SSLContext#set_params as parameters.\n\nThe most common errors are:\n\nErrno::ECONNREFUSED:: connection refused by +host+ or an intervening\n                      firewall.\nErrno::ETIMEDOUT:: connection timed out (possibly due to packets\n                   being dropped by an intervening firewall).\nErrno::ENETUNREACH:: there is no route to that network.\nSocketError:: hostname not known or other socket error.\nNet::IMAP::ByeResponseError:: we connected to the host, but they\n                              immediately said goodbye to us.\n
add_response_handler Net::IMAP.add_response_handler(handler = Proc.new)\nAdds a response handler. For example, to detect when\nthe server sends us a new EXISTS response (which normally\nindicates new messages being added to the mail box),\nyou could add the following handler after selecting the\nmailbox.\n\n  imap.add_response_handler { |resp|\n    if resp.kind_of?(Net::IMAP::UntaggedResponse) and resp.name == "EXISTS"\n      puts "Mailbox now has #{resp.data} messages"\n    end\n  }\n
append Net::IMAP.append(mailbox, message, flags = nil, date_time = nil)\nSends a APPEND command to append the +message+ to the end of\nthe +mailbox+. The optional +flags+ argument is an array of\nflags to initially passing to the new message.  The optional\n+date_time+ argument specifies the creation time to assign to the\nnew message; it defaults to the current time.\nFor example:\n\n  imap.append("inbox", <<EOF.gsub(/\\n/, "\r\\n"), [:Seen], Time.now)\n  Subject: hello\n  From: shugo@ruby-lang.org\n  To: shugo@ruby-lang.org\n\n  hello world\n  EOF\n\nA Net::IMAP::NoResponseError is raised if the mailbox does\nnot exist (it is not created automatically), or if the flags,\ndate_time, or message arguments contain errors.\n
authenticate Net::IMAP.authenticate(auth_type, *args)\nSends an AUTHENTICATE command to authenticate the client.\nThe +auth_type+ parameter is a string that represents\nthe authentication mechanism to be used. Currently Net::IMAP\nsupports authentication mechanisms:\n\n  LOGIN:: login using cleartext user and password.\n  CRAM-MD5:: login with cleartext user and encrypted password\n             (see [RFC-2195] for a full description).  This\n             mechanism requires that the server have the user's\n             password stored in clear-text password.\n\nFor both these mechanisms, there should be two +args+: username\nand (cleartext) password.  A server may not support one or other\nof these mechanisms; check #capability() for a capability of\nthe form "AUTH=LOGIN" or "AUTH=CRAM-MD5".\n\nAuthentication is done using the appropriate authenticator object:\nsee @@authenticators for more information on plugging in your own\nauthenticator.\n\nFor example:\n\n   imap.authenticate('LOGIN', user, password)\n\nA Net::IMAP::NoResponseError is raised if authentication fails.\n
capability Net::IMAP.capability()\nSends a CAPABILITY command, and returns an array of\ncapabilities that the server supports.  Each capability\nis a string.  See [IMAP] for a list of possible\ncapabilities.\n\nNote that the Net::IMAP class does not modify its\nbehaviour according to the capabilities of the server;\nit is up to the user of the class to ensure that\na certain capability is supported by a server before\nusing it.\n
check Net::IMAP.check()\nSends a CHECK command to request a checkpoint of the currently\nselected mailbox.  This performs implementation-specific\nhousekeeping, for instance, reconciling the mailbox's\nin-memory and on-disk state.\n
close Net::IMAP.close()\nSends a CLOSE command to close the currently selected mailbox.\nThe CLOSE command permanently removes from the mailbox all\nmessages that have the \Deleted flag set.\n
copy Net::IMAP.copy(set, mailbox)\nSends a COPY command to copy the specified message(s) to the end\nof the specified destination +mailbox+. The +set+ parameter is\na number or an array of numbers or a Range object. The number is\na message sequence number.\n
create Net::IMAP.create(mailbox)\nSends a CREATE command to create a new +mailbox+.\n\nA Net::IMAP::NoResponseError is raised if a mailbox with that name\ncannot be created.\n
delete Net::IMAP.delete(mailbox)\nSends a DELETE command to remove the +mailbox+.\n\nA Net::IMAP::NoResponseError is raised if a mailbox with that name\ncannot be deleted, either because it does not exist or because the\nclient does not have permission to delete it.\n
disconnect Net::IMAP.disconnect()\nDisconnects from the server.\n
disconnected? Net::IMAP.disconnected?()\nReturns true if disconnected from the server.\n
examine Net::IMAP.examine(mailbox)\nSends a EXAMINE command to select a +mailbox+ so that messages\nin the +mailbox+ can be accessed.  Behaves the same as #select(),\nexcept that the selected +mailbox+ is identified as read-only.\n\nA Net::IMAP::NoResponseError is raised if the mailbox does not\nexist or is for some reason non-examinable.\n
expunge Net::IMAP.expunge()\nSends a EXPUNGE command to permanently remove from the currently\nselected mailbox all messages that have the \Deleted flag set.\n
fetch Net::IMAP.fetch(set, attr)\nSends a FETCH command to retrieve data associated with a message\nin the mailbox. The +set+ parameter is a number or an array of\nnumbers or a Range object. The number is a message sequence\nnumber.  +attr+ is a list of attributes to fetch; see the\ndocumentation for Net::IMAP::FetchData for a list of valid\nattributes.\nThe return value is an array of Net::IMAP::FetchData. For example:\n\n  p imap.fetch(6..8, "UID")\n=> [#<Net::IMAP::FetchData seqno=6, attr={"UID"=>98}>, \\\n<Net::IMAP::FetchData seqno=7, attr={"UID"=>99}>, \\\n<Net::IMAP::FetchData seqno=8, attr={"UID"=>100}>]\n  p imap.fetch(6, "BODY[HEADER.FIELDS (SUBJECT)]")\n=> [#<Net::IMAP::FetchData seqno=6, attr={"BODY[HEADER.FIELDS\n(SUBJECT)]"=>"Subject: test\r\\n\r\\n"}>]\n  data = imap.uid_fetch(98, ["RFC822.SIZE", "INTERNALDATE"])[0]\n  p data.seqno\n=> 6\n  p data.attr["RFC822.SIZE"]\n=> 611\n  p data.attr["INTERNALDATE"]\n=> "12-Oct-2000 22:40:59 +0900"\n  p data.attr["UID"]\n=> 98\n
getacl Net::IMAP.getacl(mailbox)\nSend the GETACL command along with specified +mailbox+.\nIf this mailbox exists, an array containing objects of\nNet::IMAP::MailboxACLItem will be returned.\n
getquota Net::IMAP.getquota(mailbox)\nSends the GETQUOTA command along with specified +mailbox+.\nIf this mailbox exists, then an array containing a\nNet::IMAP::MailboxQuota object is returned.  This\ncommand generally is only available to server admin.\n
getquotaroot Net::IMAP.getquotaroot(mailbox)\nSends the GETQUOTAROOT command along with specified +mailbox+.\nThis command is generally available to both admin and user.\nIf mailbox exists, returns an array containing objects of\nNet::IMAP::MailboxQuotaRoot and Net::IMAP::MailboxQuota.\n
idle Net::IMAP.idle(&response_handler)\nSends an IDLE command that waits for notifications of new or expunged\nmessages.  Yields responses from the server during the IDLE.\n\nUse #idle_done() to leave IDLE.\n
idle_done Net::IMAP.idle_done()\nLeaves IDLE.\n
list Net::IMAP.list(refname, mailbox)\nSends a LIST command, and returns a subset of names from\nthe complete set of all names available to the client.\n+refname+ provides a context (for instance, a base directory\nin a directory-based mailbox hierarchy).  +mailbox+ specifies\na mailbox or (via wildcards) mailboxes under that context.\nTwo wildcards may be used in +mailbox+: '*', which matches\nall characters *including* the hierarchy delimiter (for instance,\n'/' on a UNIX-hosted directory-based mailbox hierarchy); and '%',\nwhich matches all characters *except* the hierarchy delimiter.\n\nIf +refname+ is empty, +mailbox+ is used directly to determine\nwhich mailboxes to match.  If +mailbox+ is empty, the root\nname of +refname+ and the hierarchy delimiter are returned.\n\nThe return value is an array of +Net::IMAP::MailboxList+. For example:\n\n  imap.create("foo/bar")\n  imap.create("foo/baz")\n  p imap.list("", "foo/%")\n=> [#<Net::IMAP::MailboxList attr=[:Noselect], delim="/", name="foo/">, \\\n<Net::IMAP::MailboxList attr=[:Noinferiors, :Marked], delim="/",\nname="foo/bar">, \\\n<Net::IMAP::MailboxList attr=[:Noinferiors], delim="/", name="foo/baz">]\n
login Net::IMAP.login(user, password)\nSends a LOGIN command to identify the client and carries\nthe plaintext +password+ authenticating this +user+.  Note\nthat, unlike calling #authenticate() with an +auth_type+\nof "LOGIN", #login() does *not* use the login authenticator.\n\nA Net::IMAP::NoResponseError is raised if authentication fails.\n
logout Net::IMAP.logout()\nSends a LOGOUT command to inform the server that the client is\ndone with the connection.\n
lsub Net::IMAP.lsub(refname, mailbox)\nSends a LSUB command, and returns a subset of names from the set\nof names that the user has declared as being "active" or\n"subscribed".  +refname+ and +mailbox+ are interpreted as\nfor #list().\nThe return value is an array of +Net::IMAP::MailboxList+.\n
noop Net::IMAP.noop()\nSends a NOOP command to the server. It does nothing.\n
remove_response_handler Net::IMAP.remove_response_handler(handler)\nRemoves the response handler.\n
rename Net::IMAP.rename(mailbox, newname)\nSends a RENAME command to change the name of the +mailbox+ to\n+newname+.\n\nA Net::IMAP::NoResponseError is raised if a mailbox with the\nname +mailbox+ cannot be renamed to +newname+ for whatever\nreason; for instance, because +mailbox+ does not exist, or\nbecause there is already a mailbox with the name +newname+.\n
search Net::IMAP.search(keys, charset = nil)\nSends a SEARCH command to search the mailbox for messages that\nmatch the given searching criteria, and returns message sequence\nnumbers.  +keys+ can either be a string holding the entire\nsearch string, or a single-dimension array of search keywords and\narguments.  The following are some common search criteria;\nsee [IMAP] section 6.4.4 for a full list.\n\n<message set>:: a set of message sequence numbers.  ',' indicates\n                an interval, ':' indicates a range.  For instance,\n                '2,10:12,15' means "2,10,11,12,15".\n\nBEFORE <date>:: messages with an internal date strictly before\n                <date>.  The date argument has a format similar\n                to 8-Aug-2002.\n\nBODY <string>:: messages that contain <string> within their body.\n\nCC <string>:: messages containing <string> in their CC field.\n\nFROM <string>:: messages that contain <string> in their FROM field.\n\nNEW:: messages with the \Recent, but not the \Seen, flag set.\n\nNOT <search-key>:: negate the following search key.\n\nOR <search-key> <search-key>:: "or" two search keys together.\n\nON <date>:: messages with an internal date exactly equal to <date>,\n            which has a format similar to 8-Aug-2002.\n\nSINCE <date>:: messages with an internal date on or after <date>.\n\nSUBJECT <string>:: messages with <string> in their subject.\n\nTO <string>:: messages with <string> in their TO field.\n\nFor example:\n\n  p imap.search(["SUBJECT", "hello", "NOT", "NEW"])\n=> [1, 6, 7, 8]\n
select Net::IMAP.select(mailbox)\nSends a SELECT command to select a +mailbox+ so that messages\nin the +mailbox+ can be accessed.\n\nAfter you have selected a mailbox, you may retrieve the\nnumber of items in that mailbox from @responses["EXISTS"][-1],\nand the number of recent messages from @responses["RECENT"][-1].\nNote that these values can change if new messages arrive\nduring a session; see #add_response_handler() for a way of\ndetecting this event.\n\nA Net::IMAP::NoResponseError is raised if the mailbox does not\nexist or is for some reason non-selectable.\n
setacl Net::IMAP.setacl(mailbox, user, rights)\nSends the SETACL command along with +mailbox+, +user+ and the\n+rights+ that user is to have on that mailbox.  If +rights+ is nil,\nthen that user will be stripped of any rights to that mailbox.\nThe IMAP ACL commands are described in [RFC-2086].\n
setquota Net::IMAP.setquota(mailbox, quota)\nSends a SETQUOTA command along with the specified +mailbox+ and\n+quota+.  If +quota+ is nil, then quota will be unset for that\nmailbox.  Typically one needs to be logged in as server admin\nfor this to work.  The IMAP quota commands are described in\n[RFC-2087].\n
sort Net::IMAP.sort(sort_keys, search_keys, charset)\nSends a SORT command to sort messages in the mailbox.\nReturns an array of message sequence numbers. For example:\n\n  p imap.sort(["FROM"], ["ALL"], "US-ASCII")\n=> [1, 2, 3, 5, 6, 7, 8, 4, 9]\n  p imap.sort(["DATE"], ["SUBJECT", "hello"], "US-ASCII")\n=> [6, 7, 8, 1]\n\nSee [SORT-THREAD-EXT] for more details.\n
starttls Net::IMAP.starttls(options = {}, verify = true)\nSends a STARTTLS command to start TLS session.\n
status Net::IMAP.status(mailbox, attr)\nSends a STATUS command, and returns the status of the indicated\n+mailbox+. +attr+ is a list of one or more attributes that\nwe are request the status of.  Supported attributes include:\n\n  MESSAGES:: the number of messages in the mailbox.\n  RECENT:: the number of recent messages in the mailbox.\n  UNSEEN:: the number of unseen messages in the mailbox.\n\nThe return value is a hash of attributes. For example:\n\n  p imap.status("inbox", ["MESSAGES", "RECENT"])\n=> {"RECENT"=>0, "MESSAGES"=>44}\n\nA Net::IMAP::NoResponseError is raised if status values\nfor +mailbox+ cannot be returned, for instance because it\ndoes not exist.\n
store Net::IMAP.store(set, attr, flags)\nSends a STORE command to alter data associated with messages\nin the mailbox, in particular their flags. The +set+ parameter\nis a number or an array of numbers or a Range object. Each number\nis a message sequence number.  +attr+ is the name of a data item\nto store: 'FLAGS' means to replace the message's flag list\nwith the provided one; '+FLAGS' means to add the provided flags;\nand '-FLAGS' means to remove them.  +flags+ is a list of flags.\n\nThe return value is an array of Net::IMAP::FetchData. For example:\n\n  p imap.store(6..8, "+FLAGS", [:Deleted])\n=> [#<Net::IMAP::FetchData seqno=6, attr={"FLAGS"=>[:Seen, :Deleted]}>, \\\n<Net::IMAP::FetchData seqno=7, attr={"FLAGS"=>[:Seen, :Deleted]}>, \\\n<Net::IMAP::FetchData seqno=8, attr={"FLAGS"=>[:Seen, :Deleted]}>]\n
subscribe Net::IMAP.subscribe(mailbox)\nSends a SUBSCRIBE command to add the specified +mailbox+ name to\nthe server's set of "active" or "subscribed" mailboxes as returned\nby #lsub().\n\nA Net::IMAP::NoResponseError is raised if +mailbox+ cannot be\nsubscribed to, for instance because it does not exist.\n
thread Net::IMAP.thread(algorithm, search_keys, charset)\nAs for #search(), but returns message sequence numbers in threaded\nformat, as a Net::IMAP::ThreadMember tree.  The supported algorithms\nare:\n\nORDEREDSUBJECT:: split into single-level threads according to subject,\n                 ordered by date.\nREFERENCES:: split into threads by parent/child relationships determined\n             by which message is a reply to which.\n\nUnlike #search(), +charset+ is a required argument.  US-ASCII\nand UTF-8 are sample values.\n\nSee [SORT-THREAD-EXT] for more details.\n
uid_copy Net::IMAP.uid_copy(set, mailbox)\nAs for #copy(), but +set+ contains unique identifiers.\n
uid_fetch Net::IMAP.uid_fetch(set, attr)\nAs for #fetch(), but +set+ contains unique identifiers.\n
uid_search Net::IMAP.uid_search(keys, charset = nil)\nAs for #search(), but returns unique identifiers.\n
uid_sort Net::IMAP.uid_sort(sort_keys, search_keys, charset)\nAs for #sort(), but returns an array of unique identifiers.\n
uid_store Net::IMAP.uid_store(set, attr, flags)\nAs for #store(), but +set+ contains unique identifiers.\n
uid_thread Net::IMAP.uid_thread(algorithm, search_keys, charset)\nAs for #thread(), but returns unique identifiers instead of\nmessage sequence numbers.\n
unsubscribe Net::IMAP.unsubscribe(mailbox)\nSends a UNSUBSCRIBE command to remove the specified +mailbox+ name\nfrom the server's set of "active" or "subscribed" mailboxes.\n\nA Net::IMAP::NoResponseError is raised if +mailbox+ cannot be\nunsubscribed from, for instance because the client is not currently\nsubscribed to it.\n
xlist Net::IMAP.xlist(refname, mailbox)\nSends a XLIST command, and returns a subset of names from\nthe complete set of all names available to the client.\n+refname+ provides a context (for instance, a base directory\nin a directory-based mailbox hierarchy).  +mailbox+ specifies\na mailbox or (via wildcards) mailboxes under that context.\nTwo wildcards may be used in +mailbox+: '*', which matches\nall characters *including* the hierarchy delimiter (for instance,\n'/' on a UNIX-hosted directory-based mailbox hierarchy); and '%',\nwhich matches all characters *except* the hierarchy delimiter.\n\nIf +refname+ is empty, +mailbox+ is used directly to determine\nwhich mailboxes to match.  If +mailbox+ is empty, the root\nname of +refname+ and the hierarchy delimiter are returned.\n\nThe XLIST command is like the LIST command except that the flags\nreturned refer to the function of the folder/mailbox, e.g. :Sent\n\nThe return value is an array of +Net::IMAP::MailboxList+. For example:\n\n  imap.create("foo/bar")\n  imap.create("foo/baz")\n  p imap.xlist("", "foo/%")\n=> [#<Net::IMAP::MailboxList attr=[:Noselect], delim="/", name="foo/">, \\\n<Net::IMAP::MailboxList attr=[:Noinferiors, :Marked], delim="/",\nname="foo/bar">, \\\n<Net::IMAP::MailboxList attr=[:Noinferiors], delim="/", name="foo/baz">]\n
media_subtype Net::IMAP::BodyTypeBasic.media_subtype()\nObsolete: use +subtype+ instead.  Calling this will\ngenerate a warning message to +stderr+, then return\nthe value of +subtype+.\n
multipart? Net::IMAP::BodyTypeBasic.multipart?()\n\n
media_subtype Net::IMAP::BodyTypeText.media_subtype()\nObsolete: use +subtype+ instead.  Calling this will\ngenerate a warning message to +stderr+, then return\nthe value of +subtype+.\n
multipart? Net::IMAP::BodyTypeText.multipart?()\n\n
media_subtype Net::IMAP::BodyTypeMessage.media_subtype()\nObsolete: use +subtype+ instead.  Calling this will\ngenerate a warning message to +stderr+, then return\nthe value of +subtype+.\n
multipart? Net::IMAP::BodyTypeMessage.multipart?()\n\n
media_subtype Net::IMAP::BodyTypeMultipart.media_subtype()\nObsolete: use +subtype+ instead.  Calling this will\ngenerate a warning message to +stderr+, then return\nthe value of +subtype+.\n
multipart? Net::IMAP::BodyTypeMultipart.multipart?()\n\n
new Net::IMAP::LoginAuthenticator.new(user, password)\n\n
process Net::IMAP::LoginAuthenticator.process(data)\n\n
new Net::IMAP::PlainAuthenticator.new(user, password)\n\n
process Net::IMAP::PlainAuthenticator.process(data)\n\n
new Net::IMAP::CramMD5Authenticator.new(user, password)\n\n
process Net::IMAP::CramMD5Authenticator.process(challenge)\n\n
new Net::IMAP::DigestMD5Authenticator.new(user, password, authname = nil)\n\n
process Net::IMAP::DigestMD5Authenticator.process(challenge)\n\n
new Net::IMAP::ResponseError.new(response)\n\n
APOP Net::POP3.APOP(isapop)\nReturns the APOP class if +isapop+ is true; otherwise, returns\nthe POP class.  For example:\n Example 1\n    pop = Net::POP3::APOP($is_apop).new(addr, port)\n Example 2\n    Net::POP3::APOP($is_apop).start(addr, port) do |pop|\n      ....\n    end\n
auth_only Net::POP3.auth_only(address, port = nil, account = nil, password = nil,\nisapop = false)\nOpens a POP3 session, attempts authentication, and quits.\n\nThis method raises POPAuthenticationError if authentication fails.\n\n=== Example: normal POP3\n\n    Net::POP3.auth_only('pop.example.com', 110,\n                        'YourAccount', 'YourPassword')\n\n=== Example: APOP\n\n    Net::POP3.auth_only('pop.example.com', 110,\n                        'YourAccount', 'YourPassword', true)\n
certs Net::POP3.certs()\nreturns the :ca_file or :ca_path from POP3.ssh_params\n
create_ssl_params Net::POP3.create_ssl_params(verify_or_params = {}, certs = nil)\nConstructs proper parameters from arguments\n
default_pop3_port Net::POP3.default_pop3_port()\nThe default port for POP3 connections, port 110\n
default_pop3s_port Net::POP3.default_pop3s_port()\nThe default port for POP3S connections, port 995\n
default_port Net::POP3.default_port()\nreturns the port for POP3\n
delete_all Net::POP3.delete_all(address, port = nil, account = nil, password = nil,\nisapop = false, &block)\nStarts a POP3 session and deletes all messages on the server.\nIf a block is given, each POPMail object is yielded to it before\nbeing deleted.\n\nThis method raises a POPAuthenticationError if authentication fails.\n\n=== Example\n\n    Net::POP3.delete_all('pop.example.com', 110,\n                         'YourAccount', 'YourPassword') do |m|\n      file.write m.pop\n    end\n
disable_ssl Net::POP3.disable_ssl()\nDisable SSL for all new instances.\n
enable_ssl Net::POP3.enable_ssl(*args)\nEnable SSL for all new instances.\n+params+ is passed to OpenSSL::SSLContext#set_params.\n
foreach Net::POP3.foreach(address, port = nil, account = nil, password = nil, isapop\n= false)\nStarts a POP3 session and iterates over each POPMail object,\nyielding it to the +block+.\nThis method is equivalent to:\n\n    Net::POP3.start(address, port, account, password) do |pop|\n      pop.each_mail do |m|\n        yield m\n      end\n    end\n\nThis method raises a POPAuthenticationError if authentication fails.\n\n=== Example\n\n    Net::POP3.foreach('pop.example.com', 110,\n                      'YourAccount', 'YourPassword') do |m|\n      file.write m.pop\n      m.delete if $DELETE\n    end\n
new Net::POP3.new(addr, port = nil, isapop = false)\nCreates a new POP3 object.\n\n+address+ is the hostname or ip address of your POP3 server.\n\nThe optional +port+ is the port to connect to.\n\nThe optional +isapop+ specifies whether this connection is going\nto use APOP authentication; it defaults to +false+.\n\nThis method does *not* open the TCP connection.\n
ssl_params Net::POP3.ssl_params()\nreturns the SSL Parameters\n\nsee also POP3.enable_ssl\n
start Net::POP3.start(address, port = nil, account = nil, password = nil, isapop\n= false)\nCreates a new POP3 object and open the connection.  Equivalent to\n\n  Net::POP3.new(address, port, isapop).start(account, password)\n\nIf +block+ is provided, yields the newly-opened POP3 object to it,\nand automatically closes it at the end of the session.\n\n=== Example\n\n   Net::POP3.start(addr, port, account, password) do |pop|\n     pop.each_mail do |m|\n       file.write m.pop\n       m.delete\n     end\n   end\n
use_ssl? Net::POP3.use_ssl?()\nreturns +true+ if POP3.ssl_params is set\n
verify Net::POP3.verify()\nreturns whether verify_mode is enable from POP3.ssl_params\n
active? Net::POP3.active?()\n\n
apop? Net::POP3.apop?()\nDoes this instance use APOP authentication?\n
auth_only Net::POP3.auth_only(account, password)\nStarts a pop3 session, attempts authentication, and quits.\nThis method must not be called while POP3 session is opened.\nThis method raises POPAuthenticationError if authentication fails.\n
delete_all Net::POP3.delete_all()\nDeletes all messages on the server.\n\nIf called with a block, yields each message in turn before deleting it.\n\n=== Example\n\n    n = 1\n    pop.delete_all do |m|\n      File.open("inbox/#{n}") do |f|\n        f.write m.pop\n      end\n      n += 1\n    end\n\nThis method raises a POPError if an error occurs.\n
disable_ssl Net::POP3.disable_ssl()\nDisable SSL for all new instances.\n
each Net::POP3.each()\n\n
each_mail Net::POP3.each_mail()\nYields each message to the passed-in block in turn.\nEquivalent to:\n\n  pop3.mails.each do |popmail|\n    ....\n  end\n\nThis method raises a POPError if an error occurs.\n
enable_ssl Net::POP3.enable_ssl(verify_or_params = {}, certs = nil, port = nil)\nEnables SSL for this instance.  Must be called before the connection is\nestablished to have any effect.\n+params[:port]+ is port to establish the SSL connection on; Defaults to 995.\n+params+ (except :port) is passed to OpenSSL::SSLContext#set_params.\n
finish Net::POP3.finish()\nFinishes a POP3 session and closes TCP connection.\n
inspect Net::POP3.inspect()\nProvide human-readable stringification of class state.\n
logging Net::POP3.logging(msg)\ndeguging output for +msg+\n
mails Net::POP3.mails()\nReturns an array of Net::POPMail objects, representing all the\nmessages on the server.  This array is renewed when the session\nrestarts; otherwise, it is fetched from the server the first time\nthis method is called (directly or indirectly) and cached.\n\nThis method raises a POPError if an error occurs.\n
n_bytes Net::POP3.n_bytes()\nReturns the total size in bytes of all the messages on the POP server.\n
n_mails Net::POP3.n_mails()\nReturns the number of messages on the POP server.\n
port Net::POP3.port()\nThe port number to connect to.\n
read_timeout= Net::POP3.read_timeout=(sec)\nSet the read timeout.\n
reset Net::POP3.reset()\nResets the session.  This clears all "deleted" marks from messages.\n\nThis method raises a POPError if an error occurs.\n
set_debug_output Net::POP3.set_debug_output(arg)\n*WARNING*: This method causes a serious security hole.\nUse this method only for debugging.\n\nSet an output stream for debugging.\n\n=== Example\n\n  pop = Net::POP.new(addr, port)\n  pop.set_debug_output $stderr\n  pop.start(account, passwd) do |pop|\n    ....\n  end\n
start Net::POP3.start(account, password)\nStarts a POP3 session.\n\nWhen called with block, gives a POP3 object to the block and\ncloses the session after block call finishes.\n\nThis method raises a POPAuthenticationError if authentication fails.\n
started? Net::POP3.started?()\n+true+ if the POP3 session has started.\n
use_ssl? Net::POP3.use_ssl?()\ndoes this instance use SSL?\n
APOP Net::POP.APOP(isapop)\nReturns the APOP class if +isapop+ is true; otherwise, returns\nthe POP class.  For example:\n Example 1\n    pop = Net::POP3::APOP($is_apop).new(addr, port)\n Example 2\n    Net::POP3::APOP($is_apop).start(addr, port) do |pop|\n      ....\n    end\n
auth_only Net::POP.auth_only(address, port = nil, account = nil, password = nil,\nisapop = false)\nOpens a POP3 session, attempts authentication, and quits.\n\nThis method raises POPAuthenticationError if authentication fails.\n\n=== Example: normal POP3\n\n    Net::POP3.auth_only('pop.example.com', 110,\n                        'YourAccount', 'YourPassword')\n\n=== Example: APOP\n\n    Net::POP3.auth_only('pop.example.com', 110,\n                        'YourAccount', 'YourPassword', true)\n
certs Net::POP.certs()\nreturns the :ca_file or :ca_path from POP3.ssh_params\n
create_ssl_params Net::POP.create_ssl_params(verify_or_params = {}, certs = nil)\nConstructs proper parameters from arguments\n
default_pop3_port Net::POP.default_pop3_port()\nThe default port for POP3 connections, port 110\n
default_pop3s_port Net::POP.default_pop3s_port()\nThe default port for POP3S connections, port 995\n
default_port Net::POP.default_port()\nreturns the port for POP3\n
delete_all Net::POP.delete_all(address, port = nil, account = nil, password = nil,\nisapop = false, &block)\nStarts a POP3 session and deletes all messages on the server.\nIf a block is given, each POPMail object is yielded to it before\nbeing deleted.\n\nThis method raises a POPAuthenticationError if authentication fails.\n\n=== Example\n\n    Net::POP3.delete_all('pop.example.com', 110,\n                         'YourAccount', 'YourPassword') do |m|\n      file.write m.pop\n    end\n
disable_ssl Net::POP.disable_ssl()\nDisable SSL for all new instances.\n
enable_ssl Net::POP.enable_ssl(*args)\nEnable SSL for all new instances.\n+params+ is passed to OpenSSL::SSLContext#set_params.\n
foreach Net::POP.foreach(address, port = nil, account = nil, password = nil, isapop\n= false)\nStarts a POP3 session and iterates over each POPMail object,\nyielding it to the +block+.\nThis method is equivalent to:\n\n    Net::POP3.start(address, port, account, password) do |pop|\n      pop.each_mail do |m|\n        yield m\n      end\n    end\n\nThis method raises a POPAuthenticationError if authentication fails.\n\n=== Example\n\n    Net::POP3.foreach('pop.example.com', 110,\n                      'YourAccount', 'YourPassword') do |m|\n      file.write m.pop\n      m.delete if $DELETE\n    end\n
new Net::POP.new(addr, port = nil, isapop = false)\nCreates a new POP3 object.\n\n+address+ is the hostname or ip address of your POP3 server.\n\nThe optional +port+ is the port to connect to.\n\nThe optional +isapop+ specifies whether this connection is going\nto use APOP authentication; it defaults to +false+.\n\nThis method does *not* open the TCP connection.\n
ssl_params Net::POP.ssl_params()\nreturns the SSL Parameters\n\nsee also POP3.enable_ssl\n
start Net::POP.start(address, port = nil, account = nil, password = nil, isapop\n= false)\nCreates a new POP3 object and open the connection.  Equivalent to\n\n  Net::POP3.new(address, port, isapop).start(account, password)\n\nIf +block+ is provided, yields the newly-opened POP3 object to it,\nand automatically closes it at the end of the session.\n\n=== Example\n\n   Net::POP3.start(addr, port, account, password) do |pop|\n     pop.each_mail do |m|\n       file.write m.pop\n       m.delete\n     end\n   end\n
use_ssl? Net::POP.use_ssl?()\nreturns +true+ if POP3.ssl_params is set\n
verify Net::POP.verify()\nreturns whether verify_mode is enable from POP3.ssl_params\n
active? Net::POP.active?()\n\n
apop? Net::POP.apop?()\nDoes this instance use APOP authentication?\n
auth_only Net::POP.auth_only(account, password)\nStarts a pop3 session, attempts authentication, and quits.\nThis method must not be called while POP3 session is opened.\nThis method raises POPAuthenticationError if authentication fails.\n
delete_all Net::POP.delete_all()\nDeletes all messages on the server.\n\nIf called with a block, yields each message in turn before deleting it.\n\n=== Example\n\n    n = 1\n    pop.delete_all do |m|\n      File.open("inbox/#{n}") do |f|\n        f.write m.pop\n      end\n      n += 1\n    end\n\nThis method raises a POPError if an error occurs.\n
disable_ssl Net::POP.disable_ssl()\nDisable SSL for all new instances.\n
each Net::POP.each()\n\n
each_mail Net::POP.each_mail()\nYields each message to the passed-in block in turn.\nEquivalent to:\n\n  pop3.mails.each do |popmail|\n    ....\n  end\n\nThis method raises a POPError if an error occurs.\n
enable_ssl Net::POP.enable_ssl(verify_or_params = {}, certs = nil, port = nil)\nEnables SSL for this instance.  Must be called before the connection is\nestablished to have any effect.\n+params[:port]+ is port to establish the SSL connection on; Defaults to 995.\n+params+ (except :port) is passed to OpenSSL::SSLContext#set_params.\n
finish Net::POP.finish()\nFinishes a POP3 session and closes TCP connection.\n
inspect Net::POP.inspect()\nProvide human-readable stringification of class state.\n
logging Net::POP.logging(msg)\ndeguging output for +msg+\n
mails Net::POP.mails()\nReturns an array of Net::POPMail objects, representing all the\nmessages on the server.  This array is renewed when the session\nrestarts; otherwise, it is fetched from the server the first time\nthis method is called (directly or indirectly) and cached.\n\nThis method raises a POPError if an error occurs.\n
n_bytes Net::POP.n_bytes()\nReturns the total size in bytes of all the messages on the POP server.\n
n_mails Net::POP.n_mails()\nReturns the number of messages on the POP server.\n
port Net::POP.port()\nThe port number to connect to.\n
read_timeout= Net::POP.read_timeout=(sec)\nSet the read timeout.\n
reset Net::POP.reset()\nResets the session.  This clears all "deleted" marks from messages.\n\nThis method raises a POPError if an error occurs.\n
set_debug_output Net::POP.set_debug_output(arg)\n*WARNING*: This method causes a serious security hole.\nUse this method only for debugging.\n\nSet an output stream for debugging.\n\n=== Example\n\n  pop = Net::POP.new(addr, port)\n  pop.set_debug_output $stderr\n  pop.start(account, passwd) do |pop|\n    ....\n  end\n
start Net::POP.start(account, password)\nStarts a POP3 session.\n\nWhen called with block, gives a POP3 object to the block and\ncloses the session after block call finishes.\n\nThis method raises a POPAuthenticationError if authentication fails.\n
started? Net::POP.started?()\n+true+ if the POP3 session has started.\n
use_ssl? Net::POP.use_ssl?()\ndoes this instance use SSL?\n
APOP Net::POPSession.APOP(isapop)\nReturns the APOP class if +isapop+ is true; otherwise, returns\nthe POP class.  For example:\n Example 1\n    pop = Net::POP3::APOP($is_apop).new(addr, port)\n Example 2\n    Net::POP3::APOP($is_apop).start(addr, port) do |pop|\n      ....\n    end\n
auth_only Net::POPSession.auth_only(address, port = nil, account = nil, password =\nnil, isapop = false)\nOpens a POP3 session, attempts authentication, and quits.\n\nThis method raises POPAuthenticationError if authentication fails.\n\n=== Example: normal POP3\n\n    Net::POP3.auth_only('pop.example.com', 110,\n                        'YourAccount', 'YourPassword')\n\n=== Example: APOP\n\n    Net::POP3.auth_only('pop.example.com', 110,\n                        'YourAccount', 'YourPassword', true)\n
certs Net::POPSession.certs()\nreturns the :ca_file or :ca_path from POP3.ssh_params\n
create_ssl_params Net::POPSession.create_ssl_params(verify_or_params = {}, certs = nil)\nConstructs proper parameters from arguments\n
default_pop3_port Net::POPSession.default_pop3_port()\nThe default port for POP3 connections, port 110\n
default_pop3s_port Net::POPSession.default_pop3s_port()\nThe default port for POP3S connections, port 995\n
default_port Net::POPSession.default_port()\nreturns the port for POP3\n
delete_all Net::POPSession.delete_all(address, port = nil, account = nil, password =\nnil, isapop = false, &block)\nStarts a POP3 session and deletes all messages on the server.\nIf a block is given, each POPMail object is yielded to it before\nbeing deleted.\n\nThis method raises a POPAuthenticationError if authentication fails.\n\n=== Example\n\n    Net::POP3.delete_all('pop.example.com', 110,\n                         'YourAccount', 'YourPassword') do |m|\n      file.write m.pop\n    end\n
disable_ssl Net::POPSession.disable_ssl()\nDisable SSL for all new instances.\n
enable_ssl Net::POPSession.enable_ssl(*args)\nEnable SSL for all new instances.\n+params+ is passed to OpenSSL::SSLContext#set_params.\n
foreach Net::POPSession.foreach(address, port = nil, account = nil, password = nil,\nisapop = false)\nStarts a POP3 session and iterates over each POPMail object,\nyielding it to the +block+.\nThis method is equivalent to:\n\n    Net::POP3.start(address, port, account, password) do |pop|\n      pop.each_mail do |m|\n        yield m\n      end\n    end\n\nThis method raises a POPAuthenticationError if authentication fails.\n\n=== Example\n\n    Net::POP3.foreach('pop.example.com', 110,\n                      'YourAccount', 'YourPassword') do |m|\n      file.write m.pop\n      m.delete if $DELETE\n    end\n
new Net::POPSession.new(addr, port = nil, isapop = false)\nCreates a new POP3 object.\n\n+address+ is the hostname or ip address of your POP3 server.\n\nThe optional +port+ is the port to connect to.\n\nThe optional +isapop+ specifies whether this connection is going\nto use APOP authentication; it defaults to +false+.\n\nThis method does *not* open the TCP connection.\n
ssl_params Net::POPSession.ssl_params()\nreturns the SSL Parameters\n\nsee also POP3.enable_ssl\n
start Net::POPSession.start(address, port = nil, account = nil, password = nil,\nisapop = false)\nCreates a new POP3 object and open the connection.  Equivalent to\n\n  Net::POP3.new(address, port, isapop).start(account, password)\n\nIf +block+ is provided, yields the newly-opened POP3 object to it,\nand automatically closes it at the end of the session.\n\n=== Example\n\n   Net::POP3.start(addr, port, account, password) do |pop|\n     pop.each_mail do |m|\n       file.write m.pop\n       m.delete\n     end\n   end\n
use_ssl? Net::POPSession.use_ssl?()\nreturns +true+ if POP3.ssl_params is set\n
verify Net::POPSession.verify()\nreturns whether verify_mode is enable from POP3.ssl_params\n
active? Net::POPSession.active?()\n\n
apop? Net::POPSession.apop?()\nDoes this instance use APOP authentication?\n
auth_only Net::POPSession.auth_only(account, password)\nStarts a pop3 session, attempts authentication, and quits.\nThis method must not be called while POP3 session is opened.\nThis method raises POPAuthenticationError if authentication fails.\n
delete_all Net::POPSession.delete_all()\nDeletes all messages on the server.\n\nIf called with a block, yields each message in turn before deleting it.\n\n=== Example\n\n    n = 1\n    pop.delete_all do |m|\n      File.open("inbox/#{n}") do |f|\n        f.write m.pop\n      end\n      n += 1\n    end\n\nThis method raises a POPError if an error occurs.\n
disable_ssl Net::POPSession.disable_ssl()\nDisable SSL for all new instances.\n
each Net::POPSession.each()\n\n
each_mail Net::POPSession.each_mail()\nYields each message to the passed-in block in turn.\nEquivalent to:\n\n  pop3.mails.each do |popmail|\n    ....\n  end\n\nThis method raises a POPError if an error occurs.\n
enable_ssl Net::POPSession.enable_ssl(verify_or_params = {}, certs = nil, port = nil)\nEnables SSL for this instance.  Must be called before the connection is\nestablished to have any effect.\n+params[:port]+ is port to establish the SSL connection on; Defaults to 995.\n+params+ (except :port) is passed to OpenSSL::SSLContext#set_params.\n
finish Net::POPSession.finish()\nFinishes a POP3 session and closes TCP connection.\n
inspect Net::POPSession.inspect()\nProvide human-readable stringification of class state.\n
logging Net::POPSession.logging(msg)\ndeguging output for +msg+\n
mails Net::POPSession.mails()\nReturns an array of Net::POPMail objects, representing all the\nmessages on the server.  This array is renewed when the session\nrestarts; otherwise, it is fetched from the server the first time\nthis method is called (directly or indirectly) and cached.\n\nThis method raises a POPError if an error occurs.\n
n_bytes Net::POPSession.n_bytes()\nReturns the total size in bytes of all the messages on the POP server.\n
n_mails Net::POPSession.n_mails()\nReturns the number of messages on the POP server.\n
port Net::POPSession.port()\nThe port number to connect to.\n
read_timeout= Net::POPSession.read_timeout=(sec)\nSet the read timeout.\n
reset Net::POPSession.reset()\nResets the session.  This clears all "deleted" marks from messages.\n\nThis method raises a POPError if an error occurs.\n
set_debug_output Net::POPSession.set_debug_output(arg)\n*WARNING*: This method causes a serious security hole.\nUse this method only for debugging.\n\nSet an output stream for debugging.\n\n=== Example\n\n  pop = Net::POP.new(addr, port)\n  pop.set_debug_output $stderr\n  pop.start(account, passwd) do |pop|\n    ....\n  end\n
start Net::POPSession.start(account, password)\nStarts a POP3 session.\n\nWhen called with block, gives a POP3 object to the block and\ncloses the session after block call finishes.\n\nThis method raises a POPAuthenticationError if authentication fails.\n
started? Net::POPSession.started?()\n+true+ if the POP3 session has started.\n
use_ssl? Net::POPSession.use_ssl?()\ndoes this instance use SSL?\n
APOP Net::POP3Session.APOP(isapop)\nReturns the APOP class if +isapop+ is true; otherwise, returns\nthe POP class.  For example:\n Example 1\n    pop = Net::POP3::APOP($is_apop).new(addr, port)\n Example 2\n    Net::POP3::APOP($is_apop).start(addr, port) do |pop|\n      ....\n    end\n
auth_only Net::POP3Session.auth_only(address, port = nil, account = nil, password =\nnil, isapop = false)\nOpens a POP3 session, attempts authentication, and quits.\n\nThis method raises POPAuthenticationError if authentication fails.\n\n=== Example: normal POP3\n\n    Net::POP3.auth_only('pop.example.com', 110,\n                        'YourAccount', 'YourPassword')\n\n=== Example: APOP\n\n    Net::POP3.auth_only('pop.example.com', 110,\n                        'YourAccount', 'YourPassword', true)\n
certs Net::POP3Session.certs()\nreturns the :ca_file or :ca_path from POP3.ssh_params\n
create_ssl_params Net::POP3Session.create_ssl_params(verify_or_params = {}, certs = nil)\nConstructs proper parameters from arguments\n
default_pop3_port Net::POP3Session.default_pop3_port()\nThe default port for POP3 connections, port 110\n
default_pop3s_port Net::POP3Session.default_pop3s_port()\nThe default port for POP3S connections, port 995\n
default_port Net::POP3Session.default_port()\nreturns the port for POP3\n
delete_all Net::POP3Session.delete_all(address, port = nil, account = nil, password =\nnil, isapop = false, &block)\nStarts a POP3 session and deletes all messages on the server.\nIf a block is given, each POPMail object is yielded to it before\nbeing deleted.\n\nThis method raises a POPAuthenticationError if authentication fails.\n\n=== Example\n\n    Net::POP3.delete_all('pop.example.com', 110,\n                         'YourAccount', 'YourPassword') do |m|\n      file.write m.pop\n    end\n
disable_ssl Net::POP3Session.disable_ssl()\nDisable SSL for all new instances.\n
enable_ssl Net::POP3Session.enable_ssl(*args)\nEnable SSL for all new instances.\n+params+ is passed to OpenSSL::SSLContext#set_params.\n
foreach Net::POP3Session.foreach(address, port = nil, account = nil, password = nil,\nisapop = false)\nStarts a POP3 session and iterates over each POPMail object,\nyielding it to the +block+.\nThis method is equivalent to:\n\n    Net::POP3.start(address, port, account, password) do |pop|\n      pop.each_mail do |m|\n        yield m\n      end\n    end\n\nThis method raises a POPAuthenticationError if authentication fails.\n\n=== Example\n\n    Net::POP3.foreach('pop.example.com', 110,\n                      'YourAccount', 'YourPassword') do |m|\n      file.write m.pop\n      m.delete if $DELETE\n    end\n
new Net::POP3Session.new(addr, port = nil, isapop = false)\nCreates a new POP3 object.\n\n+address+ is the hostname or ip address of your POP3 server.\n\nThe optional +port+ is the port to connect to.\n\nThe optional +isapop+ specifies whether this connection is going\nto use APOP authentication; it defaults to +false+.\n\nThis method does *not* open the TCP connection.\n
ssl_params Net::POP3Session.ssl_params()\nreturns the SSL Parameters\n\nsee also POP3.enable_ssl\n
start Net::POP3Session.start(address, port = nil, account = nil, password = nil,\nisapop = false)\nCreates a new POP3 object and open the connection.  Equivalent to\n\n  Net::POP3.new(address, port, isapop).start(account, password)\n\nIf +block+ is provided, yields the newly-opened POP3 object to it,\nand automatically closes it at the end of the session.\n\n=== Example\n\n   Net::POP3.start(addr, port, account, password) do |pop|\n     pop.each_mail do |m|\n       file.write m.pop\n       m.delete\n     end\n   end\n
use_ssl? Net::POP3Session.use_ssl?()\nreturns +true+ if POP3.ssl_params is set\n
verify Net::POP3Session.verify()\nreturns whether verify_mode is enable from POP3.ssl_params\n
active? Net::POP3Session.active?()\n\n
apop? Net::POP3Session.apop?()\nDoes this instance use APOP authentication?\n
auth_only Net::POP3Session.auth_only(account, password)\nStarts a pop3 session, attempts authentication, and quits.\nThis method must not be called while POP3 session is opened.\nThis method raises POPAuthenticationError if authentication fails.\n
delete_all Net::POP3Session.delete_all()\nDeletes all messages on the server.\n\nIf called with a block, yields each message in turn before deleting it.\n\n=== Example\n\n    n = 1\n    pop.delete_all do |m|\n      File.open("inbox/#{n}") do |f|\n        f.write m.pop\n      end\n      n += 1\n    end\n\nThis method raises a POPError if an error occurs.\n
disable_ssl Net::POP3Session.disable_ssl()\nDisable SSL for all new instances.\n
each Net::POP3Session.each()\n\n
each_mail Net::POP3Session.each_mail()\nYields each message to the passed-in block in turn.\nEquivalent to:\n\n  pop3.mails.each do |popmail|\n    ....\n  end\n\nThis method raises a POPError if an error occurs.\n
enable_ssl Net::POP3Session.enable_ssl(verify_or_params = {}, certs = nil, port = nil)\nEnables SSL for this instance.  Must be called before the connection is\nestablished to have any effect.\n+params[:port]+ is port to establish the SSL connection on; Defaults to 995.\n+params+ (except :port) is passed to OpenSSL::SSLContext#set_params.\n
finish Net::POP3Session.finish()\nFinishes a POP3 session and closes TCP connection.\n
inspect Net::POP3Session.inspect()\nProvide human-readable stringification of class state.\n
logging Net::POP3Session.logging(msg)\ndeguging output for +msg+\n
mails Net::POP3Session.mails()\nReturns an array of Net::POPMail objects, representing all the\nmessages on the server.  This array is renewed when the session\nrestarts; otherwise, it is fetched from the server the first time\nthis method is called (directly or indirectly) and cached.\n\nThis method raises a POPError if an error occurs.\n
n_bytes Net::POP3Session.n_bytes()\nReturns the total size in bytes of all the messages on the POP server.\n
n_mails Net::POP3Session.n_mails()\nReturns the number of messages on the POP server.\n
port Net::POP3Session.port()\nThe port number to connect to.\n
read_timeout= Net::POP3Session.read_timeout=(sec)\nSet the read timeout.\n
reset Net::POP3Session.reset()\nResets the session.  This clears all "deleted" marks from messages.\n\nThis method raises a POPError if an error occurs.\n
set_debug_output Net::POP3Session.set_debug_output(arg)\n*WARNING*: This method causes a serious security hole.\nUse this method only for debugging.\n\nSet an output stream for debugging.\n\n=== Example\n\n  pop = Net::POP.new(addr, port)\n  pop.set_debug_output $stderr\n  pop.start(account, passwd) do |pop|\n    ....\n  end\n
start Net::POP3Session.start(account, password)\nStarts a POP3 session.\n\nWhen called with block, gives a POP3 object to the block and\ncloses the session after block call finishes.\n\nThis method raises a POPAuthenticationError if authentication fails.\n
started? Net::POP3Session.started?()\n+true+ if the POP3 session has started.\n
use_ssl? Net::POP3Session.use_ssl?()\ndoes this instance use SSL?\n
apop? Net::APOP.apop?()\nAlways returns true.\n
apop? Net::APOPSession.apop?()\nAlways returns true.\n
all Net::POPMail.all( dest = '' )\n\n
delete Net::POPMail.delete()\nMarks a message for deletion on the server.  Deletion does not\nactually occur until the end of the session; deletion may be\ncancelled for _all_ marked messages by calling POP3#reset().\n\nThis method raises a POPError if an error occurs.\n\n=== Example\n\n    POP3.start('pop.example.com', 110,\n               'YourAccount, 'YourPassword') do |pop|\n      n = 1\n      pop.mails.each do |popmail|\n        File.open("inbox/#{n}", 'w') do |f|\n          f.write popmail.pop\n        end\n        popmail.delete         ####\n        n += 1\n      end\n    end\n
delete! Net::POPMail.delete!()\n\n
deleted? Net::POPMail.deleted?()\nTrue if the mail has been deleted.\n
header Net::POPMail.header(dest = '')\nFetches the message header.\n\nThe optional +dest+ argument is obsolete.\n\nThis method raises a POPError if an error occurs.\n
inspect Net::POPMail.inspect()\nProvide human-readable stringification of class state.\n
mail Net::POPMail.mail( dest = '' )\n\n
pop Net::POPMail.pop( dest = '' )\nThis method fetches the message.  If called with a block, the\nmessage is yielded to the block one chunk at a time.  If called\nwithout a block, the message is returned as a String.  The optional\n+dest+ argument will be prepended to the returned String; this\nargument is essentially obsolete.\n\n=== Example without block\n\n    POP3.start('pop.example.com', 110,\n               'YourAccount, 'YourPassword') do |pop|\n      n = 1\n      pop.mails.each do |popmail|\n        File.open("inbox/#{n}", 'w') do |f|\n          f.write popmail.pop\n        end\n        popmail.delete\n        n += 1\n      end\n    end\n\n=== Example with block\n\n    POP3.start('pop.example.com', 110,\n               'YourAccount, 'YourPassword') do |pop|\n      n = 1\n      pop.mails.each do |popmail|\n        File.open("inbox/#{n}", 'w') do |f|\n          popmail.pop do |chunk|            ####\n            f.write chunk\n          end\n        end\n        n += 1\n      end\n    end\n\nThis method raises a POPError if an error occurs.\n
top Net::POPMail.top(lines, dest = '')\nFetches the message header and +lines+ lines of body.\n\nThe optional +dest+ argument is obsolete.\n\nThis method raises a POPError if an error occurs.\n
uidl Net::POPMail.uidl()\n\n
unique_id Net::POPMail.unique_id()\nReturns the unique-id of the message.\nNormally the unique-id is a hash string of the message.\n\nThis method raises a POPError if an error occurs.\n
default_port Net::SMTP.default_port()\nThe default SMTP port number, 25.\n
default_ssl_context Net::SMTP.default_ssl_context()\n\n
default_ssl_port Net::SMTP.default_ssl_port()\n\n
default_submission_port Net::SMTP.default_submission_port()\nThe default mail submission port number, 587.\n
default_tls_port Net::SMTP.default_tls_port()\nThe default SMTPS port number, 465.\n
new Net::SMTP.new(address, port = nil)\nCreates a new Net::SMTP object.\n\n+address+ is the hostname or ip address of your SMTP\nserver.  +port+ is the port to connect to; it defaults to\nport 25.\n\nThis method does not open the TCP connection.  You can use\nSMTP.start instead of SMTP.new if you want to do everything\nat once.  Otherwise, follow SMTP.new with SMTP#start.\n
start Net::SMTP.start(address, port = nil, helo = 'localhost', user = nil, secret =\nnil, authtype = nil)\nCreates a new Net::SMTP object and connects to the server.\n\nThis method is equivalent to:\n\n  Net::SMTP.new(address, port).start(helo_domain, account, password, authtype)\n\n=== Example\n\n    Net::SMTP.start('your.smtp.server') do |smtp|\n      smtp.send_message msgstr, 'from@example.com', ['dest@example.com']\n    end\n\n=== Block Usage\n\nIf called with a block, the newly-opened Net::SMTP object is yielded\nto the block, and automatically closed when the block finishes.  If called\nwithout a block, the newly-opened Net::SMTP object is returned to\nthe caller, and it is the caller's responsibility to close it when\nfinished.\n\n=== Parameters\n\n+address+ is the hostname or ip address of your smtp server.\n\n+port+ is the port to connect to; it defaults to port 25.\n\n+helo+ is the _HELO_ _domain_ provided by the client to the\nserver (see overview comments); it defaults to 'localhost'.\n\nThe remaining arguments are used for SMTP authentication, if required\nor desired.  +user+ is the account name; +secret+ is your password\nor other authentication token; and +authtype+ is the authentication\ntype, one of :plain, :login, or :cram_md5.  See the discussion of\nSMTP Authentication in the overview notes.\n\n=== Errors\n\nThis method may raise:\n\n* Net::SMTPAuthenticationError\n* Net::SMTPServerBusy\n* Net::SMTPSyntaxError\n* Net::SMTPFatalError\n* Net::SMTPUnknownError\n* IOError\n* TimeoutError\n
auth_cram_md5 Net::SMTP.auth_cram_md5(user, secret)\n\n
auth_login Net::SMTP.auth_login(user, secret)\n\n
auth_plain Net::SMTP.auth_plain(user, secret)\n\n
authenticate Net::SMTP.authenticate(user, secret, authtype = DEFAULT_AUTH_TYPE)\n\n
capable_auth_types Net::SMTP.capable_auth_types()\nReturns supported authentication methods on this server.\nYou cannot get valid value before opening SMTP session.\n
capable_cram_md5_auth? Net::SMTP.capable_cram_md5_auth?()\ntrue if server advertises AUTH CRAM-MD5.\nYou cannot get valid value before opening SMTP session.\n
capable_login_auth? Net::SMTP.capable_login_auth?()\ntrue if server advertises AUTH LOGIN.\nYou cannot get valid value before opening SMTP session.\n
capable_plain_auth? Net::SMTP.capable_plain_auth?()\ntrue if server advertises AUTH PLAIN.\nYou cannot get valid value before opening SMTP session.\n
capable_starttls? Net::SMTP.capable_starttls?()\ntrue if server advertises STARTTLS.\nYou cannot get valid value before opening SMTP session.\n
data Net::SMTP.data(msgstr = nil)\nThis method sends a message.\nIf +msgstr+ is given, sends it as a message.\nIf block is given, yield a message writer stream.\nYou must write message before the block is closed.\n Example 1 (by string)\n  smtp.data(<<EndMessage)\n  From: john@example.com\n  To: betty@example.com\n  Subject: I found a bug\n\n  Check vm.c:58879.\n  EndMessage\n Example 2 (by block)\n  smtp.data {|f|\n    f.puts "From: john@example.com"\n    f.puts "To: betty@example.com"\n    f.puts "Subject: I found a bug"\n    f.puts ""\n    f.puts "Check vm.c:58879."\n  }\n
debug_output= Net::SMTP.debug_output=(arg)\nWARNING: This method causes serious security holes.\nUse this method for only debugging.\n\nSet an output stream for debug logging.\nYou must call this before #start.\n example\n  smtp = Net::SMTP.new(addr, port)\n  smtp.set_debug_output $stderr\n  smtp.start do |smtp|\n    ....\n  end\n
disable_ssl Net::SMTP.disable_ssl()\n\n
disable_starttls Net::SMTP.disable_starttls()\nDisables SMTP/TLS (STARTTLS) for this object.  Must be called\nbefore the connection is established to have any effect.\n
disable_tls Net::SMTP.disable_tls()\nDisables SMTP/TLS for this object.  Must be called before the\nconnection is established to have any effect.\n
ehlo Net::SMTP.ehlo(domain)\n\n
enable_ssl Net::SMTP.enable_ssl(context = SMTP.default_ssl_context)\n\n
enable_starttls Net::SMTP.enable_starttls(context = SMTP.default_ssl_context)\nEnables SMTP/TLS (STARTTLS) for this object.\n+context+ is a OpenSSL::SSL::SSLContext object.\n
enable_starttls_auto Net::SMTP.enable_starttls_auto(context = SMTP.default_ssl_context)\nEnables SMTP/TLS (STARTTLS) for this object if server accepts.\n+context+ is a OpenSSL::SSL::SSLContext object.\n
enable_tls Net::SMTP.enable_tls(context = SMTP.default_ssl_context)\nEnables SMTP/TLS (SMTPS: SMTP over direct TLS connection) for\nthis object.  Must be called before the connection is established\nto have any effect.  +context+ is a OpenSSL::SSL::SSLContext object.\n
finish Net::SMTP.finish()\nFinishes the SMTP session and closes TCP connection.\nRaises IOError if not started.\n
helo Net::SMTP.helo(domain)\n\n
inspect Net::SMTP.inspect()\nProvide human-readable stringification of class state.\n
mailfrom Net::SMTP.mailfrom(from_addr)\n\n
open_message_stream Net::SMTP.open_message_stream(from_addr, *to_addrs)\nOpens a message writer stream and gives it to the block.\nThe stream is valid only in the block, and has these methods:\n\nputs(str = '')::       outputs STR and CR LF.\nprint(str)::           outputs STR.\nprintf(fmt, *args)::   outputs sprintf(fmt,*args).\nwrite(str)::           outputs STR and returns the length of written bytes.\n<<(str)::              outputs STR and returns self.\n\nIf a single CR ("\r") or LF ("\\n") is found in the message,\nit is converted to the CR LF pair.  You cannot send a binary\nmessage with this method.\n\n=== Parameters\n\n+from_addr+ is a String representing the source mail address.\n\n+to_addr+ is a String or Strings or Array of Strings, representing\nthe destination mail address or addresses.\n\n=== Example\n\n    Net::SMTP.start('smtp.example.com', 25) do |smtp|\n      smtp.open_message_stream('from@example.com', ['dest@example.com']) do |f|\n        f.puts 'From: from@example.com'\n        f.puts 'To: dest@example.com'\n        f.puts 'Subject: test message'\n        f.puts\n        f.puts 'This is a test message.'\n      end\n    end\n\n=== Errors\n\nThis method may raise:\n\n* Net::SMTPServerBusy\n* Net::SMTPSyntaxError\n* Net::SMTPFatalError\n* Net::SMTPUnknownError\n* IOError\n* TimeoutError\n
quit Net::SMTP.quit()\n\n
rcptto Net::SMTP.rcptto(to_addr)\n\n
rcptto_list Net::SMTP.rcptto_list(to_addrs)\n\n
read_timeout= Net::SMTP.read_timeout=(sec)\nSet the number of seconds to wait until timing-out a read(2)\ncall.\n
ready Net::SMTP.ready(from_addr, *to_addrs)\n\n
send_mail Net::SMTP.send_mail(msgstr, from_addr, *to_addrs)\n\n
send_message Net::SMTP.send_message(msgstr, from_addr, *to_addrs)\nSends +msgstr+ as a message.  Single CR ("\r") and LF ("\\n") found\nin the +msgstr+, are converted into the CR LF pair.  You cannot send a\nbinary message with this method. +msgstr+ should include both\nthe message headers and body.\n\n+from_addr+ is a String representing the source mail address.\n\n+to_addr+ is a String or Strings or Array of Strings, representing\nthe destination mail address or addresses.\n\n=== Example\n\n    Net::SMTP.start('smtp.example.com') do |smtp|\n      smtp.send_message msgstr,\n                        'from@example.com',\n                        ['dest@example.com', 'dest2@example.com']\n    end\n\n=== Errors\n\nThis method may raise:\n\n* Net::SMTPServerBusy\n* Net::SMTPSyntaxError\n* Net::SMTPFatalError\n* Net::SMTPUnknownError\n* IOError\n* TimeoutError\n
sendmail Net::SMTP.sendmail(msgstr, from_addr, *to_addrs)\n\n
set_debug_output Net::SMTP.set_debug_output(arg)\n\n
ssl? Net::SMTP.ssl?()\n\n
start Net::SMTP.start(helo = 'localhost', user = nil, secret = nil, authtype = nil)\nOpens a TCP connection and starts the SMTP session.\n\n=== Parameters\n\n+helo+ is the _HELO_ _domain_ that you'll dispatch mails from; see\nthe discussion in the overview notes.\n\nIf both of +user+ and +secret+ are given, SMTP authentication\nwill be attempted using the AUTH command.  +authtype+ specifies\nthe type of authentication to attempt; it must be one of\n:login, :plain, and :cram_md5.  See the notes on SMTP Authentication\nin the overview.\n\n=== Block Usage\n\nWhen this methods is called with a block, the newly-started SMTP\nobject is yielded to the block, and automatically closed after\nthe block call finishes.  Otherwise, it is the caller's\nresponsibility to close the session when finished.\n\n=== Example\n\nThis is very similar to the class method SMTP.start.\n\n    require 'net/smtp'\n    smtp = Net::SMTP.new('smtp.mail.server', 25)\n    smtp.start(helo_domain, account, password, authtype) do |smtp|\n      smtp.send_message msgstr, 'from@example.com', ['dest@example.com']\n    end\n\nThe primary use of this method (as opposed to SMTP.start)\nis probably to set debugging (#set_debug_output) or ESMTP\n(#esmtp=), which must be done before the session is\nstarted.\n\n=== Errors\n\nIf session has already been started, an IOError will be raised.\n\nThis method may raise:\n\n* Net::SMTPAuthenticationError\n* Net::SMTPServerBusy\n* Net::SMTPSyntaxError\n* Net::SMTPFatalError\n* Net::SMTPUnknownError\n* IOError\n* TimeoutError\n
started? Net::SMTP.started?()\n+true+ if the SMTP session has been started.\n
starttls Net::SMTP.starttls()\nSMTP command dispatcher\n
starttls? Net::SMTP.starttls?()\nReturns truth value if this object uses STARTTLS.\nIf this object always uses STARTTLS, returns :always.\nIf this object uses STARTTLS when the server support TLS, returns :auto.\n
starttls_always? Net::SMTP.starttls_always?()\ntrue if this object uses STARTTLS.\n
starttls_auto? Net::SMTP.starttls_auto?()\ntrue if this object uses STARTTLS when server advertises STARTTLS.\n
tls? Net::SMTP.tls?()\ntrue if this object uses SMTP/TLS (SMTPS).\n
new Net::SMTP::Response.new(status, string)\nCreates a new instance of the Response class and sets the status and\nstring attributes\n
parse Net::SMTP::Response.parse(str)\nParses the received response and separates the reply code and the human\nreadable reply text\n
capabilities Net::SMTP::Response.capabilities()\nReturns a hash of the human readable reply text in the response if it\nis multiple lines. It does not return the first line. The key of the\nhash is the first word the value of the hash is an array with each word\nthereafter being a value in the array\n
continue? Net::SMTP::Response.continue?()\nDetermines whether the response received was a Positive Intermediate\nreply (3xx reply code)\n
cram_md5_challenge Net::SMTP::Response.cram_md5_challenge()\nCreates a CRAM-MD5 challenge. You can view more information on CRAM-MD5\non Wikipedia: http://en.wikipedia.org/wiki/CRAM-MD5\n
exception_class Net::SMTP::Response.exception_class()\nDetermines whether there was an error and raies the appropriate error\nbased on the reply code of the response\n
message Net::SMTP::Response.message()\nThe first line of the human readable reply text\n
status_type_char Net::SMTP::Response.status_type_char()\nTakes the first digit of the reply code to determine the status type\n
success? Net::SMTP::Response.success?()\nDetermines whether the response received was a Positive Completion\nreply (2xx reply code)\n
default_port Net::SMTPSession.default_port()\nThe default SMTP port number, 25.\n
default_ssl_context Net::SMTPSession.default_ssl_context()\n\n
default_ssl_port Net::SMTPSession.default_ssl_port()\n\n
default_submission_port Net::SMTPSession.default_submission_port()\nThe default mail submission port number, 587.\n
default_tls_port Net::SMTPSession.default_tls_port()\nThe default SMTPS port number, 465.\n
new Net::SMTPSession.new(address, port = nil)\nCreates a new Net::SMTP object.\n\n+address+ is the hostname or ip address of your SMTP\nserver.  +port+ is the port to connect to; it defaults to\nport 25.\n\nThis method does not open the TCP connection.  You can use\nSMTP.start instead of SMTP.new if you want to do everything\nat once.  Otherwise, follow SMTP.new with SMTP#start.\n
start Net::SMTPSession.start(address, port = nil, helo = 'localhost', user = nil,\nsecret = nil, authtype = nil)\nCreates a new Net::SMTP object and connects to the server.\n\nThis method is equivalent to:\n\n  Net::SMTP.new(address, port).start(helo_domain, account, password, authtype)\n\n=== Example\n\n    Net::SMTP.start('your.smtp.server') do |smtp|\n      smtp.send_message msgstr, 'from@example.com', ['dest@example.com']\n    end\n\n=== Block Usage\n\nIf called with a block, the newly-opened Net::SMTP object is yielded\nto the block, and automatically closed when the block finishes.  If called\nwithout a block, the newly-opened Net::SMTP object is returned to\nthe caller, and it is the caller's responsibility to close it when\nfinished.\n\n=== Parameters\n\n+address+ is the hostname or ip address of your smtp server.\n\n+port+ is the port to connect to; it defaults to port 25.\n\n+helo+ is the _HELO_ _domain_ provided by the client to the\nserver (see overview comments); it defaults to 'localhost'.\n\nThe remaining arguments are used for SMTP authentication, if required\nor desired.  +user+ is the account name; +secret+ is your password\nor other authentication token; and +authtype+ is the authentication\ntype, one of :plain, :login, or :cram_md5.  See the discussion of\nSMTP Authentication in the overview notes.\n\n=== Errors\n\nThis method may raise:\n\n* Net::SMTPAuthenticationError\n* Net::SMTPServerBusy\n* Net::SMTPSyntaxError\n* Net::SMTPFatalError\n* Net::SMTPUnknownError\n* IOError\n* TimeoutError\n
auth_cram_md5 Net::SMTPSession.auth_cram_md5(user, secret)\n\n
auth_login Net::SMTPSession.auth_login(user, secret)\n\n
auth_plain Net::SMTPSession.auth_plain(user, secret)\n\n
authenticate Net::SMTPSession.authenticate(user, secret, authtype = DEFAULT_AUTH_TYPE)\n\n
capable_auth_types Net::SMTPSession.capable_auth_types()\nReturns supported authentication methods on this server.\nYou cannot get valid value before opening SMTP session.\n
capable_cram_md5_auth? Net::SMTPSession.capable_cram_md5_auth?()\ntrue if server advertises AUTH CRAM-MD5.\nYou cannot get valid value before opening SMTP session.\n
capable_login_auth? Net::SMTPSession.capable_login_auth?()\ntrue if server advertises AUTH LOGIN.\nYou cannot get valid value before opening SMTP session.\n
capable_plain_auth? Net::SMTPSession.capable_plain_auth?()\ntrue if server advertises AUTH PLAIN.\nYou cannot get valid value before opening SMTP session.\n
capable_starttls? Net::SMTPSession.capable_starttls?()\ntrue if server advertises STARTTLS.\nYou cannot get valid value before opening SMTP session.\n
data Net::SMTPSession.data(msgstr = nil)\nThis method sends a message.\nIf +msgstr+ is given, sends it as a message.\nIf block is given, yield a message writer stream.\nYou must write message before the block is closed.\n Example 1 (by string)\n  smtp.data(<<EndMessage)\n  From: john@example.com\n  To: betty@example.com\n  Subject: I found a bug\n\n  Check vm.c:58879.\n  EndMessage\n Example 2 (by block)\n  smtp.data {|f|\n    f.puts "From: john@example.com"\n    f.puts "To: betty@example.com"\n    f.puts "Subject: I found a bug"\n    f.puts ""\n    f.puts "Check vm.c:58879."\n  }\n
debug_output= Net::SMTPSession.debug_output=(arg)\nWARNING: This method causes serious security holes.\nUse this method for only debugging.\n\nSet an output stream for debug logging.\nYou must call this before #start.\n example\n  smtp = Net::SMTP.new(addr, port)\n  smtp.set_debug_output $stderr\n  smtp.start do |smtp|\n    ....\n  end\n
disable_ssl Net::SMTPSession.disable_ssl()\n\n
disable_starttls Net::SMTPSession.disable_starttls()\nDisables SMTP/TLS (STARTTLS) for this object.  Must be called\nbefore the connection is established to have any effect.\n
disable_tls Net::SMTPSession.disable_tls()\nDisables SMTP/TLS for this object.  Must be called before the\nconnection is established to have any effect.\n
ehlo Net::SMTPSession.ehlo(domain)\n\n
enable_ssl Net::SMTPSession.enable_ssl(context = SMTP.default_ssl_context)\n\n
enable_starttls Net::SMTPSession.enable_starttls(context = SMTP.default_ssl_context)\nEnables SMTP/TLS (STARTTLS) for this object.\n+context+ is a OpenSSL::SSL::SSLContext object.\n
enable_starttls_auto Net::SMTPSession.enable_starttls_auto(context = SMTP.default_ssl_context)\nEnables SMTP/TLS (STARTTLS) for this object if server accepts.\n+context+ is a OpenSSL::SSL::SSLContext object.\n
enable_tls Net::SMTPSession.enable_tls(context = SMTP.default_ssl_context)\nEnables SMTP/TLS (SMTPS: SMTP over direct TLS connection) for\nthis object.  Must be called before the connection is established\nto have any effect.  +context+ is a OpenSSL::SSL::SSLContext object.\n
finish Net::SMTPSession.finish()\nFinishes the SMTP session and closes TCP connection.\nRaises IOError if not started.\n
helo Net::SMTPSession.helo(domain)\n\n
inspect Net::SMTPSession.inspect()\nProvide human-readable stringification of class state.\n
mailfrom Net::SMTPSession.mailfrom(from_addr)\n\n
open_message_stream Net::SMTPSession.open_message_stream(from_addr, *to_addrs)\nOpens a message writer stream and gives it to the block.\nThe stream is valid only in the block, and has these methods:\n\nputs(str = '')::       outputs STR and CR LF.\nprint(str)::           outputs STR.\nprintf(fmt, *args)::   outputs sprintf(fmt,*args).\nwrite(str)::           outputs STR and returns the length of written bytes.\n<<(str)::              outputs STR and returns self.\n\nIf a single CR ("\r") or LF ("\\n") is found in the message,\nit is converted to the CR LF pair.  You cannot send a binary\nmessage with this method.\n\n=== Parameters\n\n+from_addr+ is a String representing the source mail address.\n\n+to_addr+ is a String or Strings or Array of Strings, representing\nthe destination mail address or addresses.\n\n=== Example\n\n    Net::SMTP.start('smtp.example.com', 25) do |smtp|\n      smtp.open_message_stream('from@example.com', ['dest@example.com']) do |f|\n        f.puts 'From: from@example.com'\n        f.puts 'To: dest@example.com'\n        f.puts 'Subject: test message'\n        f.puts\n        f.puts 'This is a test message.'\n      end\n    end\n\n=== Errors\n\nThis method may raise:\n\n* Net::SMTPServerBusy\n* Net::SMTPSyntaxError\n* Net::SMTPFatalError\n* Net::SMTPUnknownError\n* IOError\n* TimeoutError\n
quit Net::SMTPSession.quit()\n\n
rcptto Net::SMTPSession.rcptto(to_addr)\n\n
rcptto_list Net::SMTPSession.rcptto_list(to_addrs)\n\n
read_timeout= Net::SMTPSession.read_timeout=(sec)\nSet the number of seconds to wait until timing-out a read(2)\ncall.\n
ready Net::SMTPSession.ready(from_addr, *to_addrs)\n\n
send_mail Net::SMTPSession.send_mail(msgstr, from_addr, *to_addrs)\n\n
send_message Net::SMTPSession.send_message(msgstr, from_addr, *to_addrs)\nSends +msgstr+ as a message.  Single CR ("\r") and LF ("\\n") found\nin the +msgstr+, are converted into the CR LF pair.  You cannot send a\nbinary message with this method. +msgstr+ should include both\nthe message headers and body.\n\n+from_addr+ is a String representing the source mail address.\n\n+to_addr+ is a String or Strings or Array of Strings, representing\nthe destination mail address or addresses.\n\n=== Example\n\n    Net::SMTP.start('smtp.example.com') do |smtp|\n      smtp.send_message msgstr,\n                        'from@example.com',\n                        ['dest@example.com', 'dest2@example.com']\n    end\n\n=== Errors\n\nThis method may raise:\n\n* Net::SMTPServerBusy\n* Net::SMTPSyntaxError\n* Net::SMTPFatalError\n* Net::SMTPUnknownError\n* IOError\n* TimeoutError\n
sendmail Net::SMTPSession.sendmail(msgstr, from_addr, *to_addrs)\n\n
set_debug_output Net::SMTPSession.set_debug_output(arg)\n\n
ssl? Net::SMTPSession.ssl?()\n\n
start Net::SMTPSession.start(helo = 'localhost', user = nil, secret = nil, authtype\n= nil)\nOpens a TCP connection and starts the SMTP session.\n\n=== Parameters\n\n+helo+ is the _HELO_ _domain_ that you'll dispatch mails from; see\nthe discussion in the overview notes.\n\nIf both of +user+ and +secret+ are given, SMTP authentication\nwill be attempted using the AUTH command.  +authtype+ specifies\nthe type of authentication to attempt; it must be one of\n:login, :plain, and :cram_md5.  See the notes on SMTP Authentication\nin the overview.\n\n=== Block Usage\n\nWhen this methods is called with a block, the newly-started SMTP\nobject is yielded to the block, and automatically closed after\nthe block call finishes.  Otherwise, it is the caller's\nresponsibility to close the session when finished.\n\n=== Example\n\nThis is very similar to the class method SMTP.start.\n\n    require 'net/smtp'\n    smtp = Net::SMTP.new('smtp.mail.server', 25)\n    smtp.start(helo_domain, account, password, authtype) do |smtp|\n      smtp.send_message msgstr, 'from@example.com', ['dest@example.com']\n    end\n\nThe primary use of this method (as opposed to SMTP.start)\nis probably to set debugging (#set_debug_output) or ESMTP\n(#esmtp=), which must be done before the session is\nstarted.\n\n=== Errors\n\nIf session has already been started, an IOError will be raised.\n\nThis method may raise:\n\n* Net::SMTPAuthenticationError\n* Net::SMTPServerBusy\n* Net::SMTPSyntaxError\n* Net::SMTPFatalError\n* Net::SMTPUnknownError\n* IOError\n* TimeoutError\n
started? Net::SMTPSession.started?()\n+true+ if the SMTP session has been started.\n
starttls Net::SMTPSession.starttls()\nSMTP command dispatcher\n
starttls? Net::SMTPSession.starttls?()\nReturns truth value if this object uses STARTTLS.\nIf this object always uses STARTTLS, returns :always.\nIf this object uses STARTTLS when the server support TLS, returns :auto.\n
starttls_always? Net::SMTPSession.starttls_always?()\ntrue if this object uses STARTTLS.\n
starttls_auto? Net::SMTPSession.starttls_auto?()\ntrue if this object uses STARTTLS when server advertises STARTTLS.\n
tls? Net::SMTPSession.tls?()\ntrue if this object uses SMTP/TLS (SMTPS).\n
new Net::Telnet.new(options)\nCreates a new Net::Telnet object.\n\nAttempts to connect to the host (unless the Proxy option is\nprovided: see below).  If a block is provided, it is yielded\nstatus messages on the attempt to connect to the server, of\nthe form:\n\n  Trying localhost...\n  Connected to localhost.\n\n+options+ is a hash of options.  The following example lists\nall options and their default values.\n\n  host = Net::Telnet::new(\n           "Host"       => "localhost",  # default: "localhost"\n           "Port"       => 23,           # default: 23\n           "Binmode"    => false,        # default: false\n           "Output_log" => "output_log", # default: nil (no output)\n           "Dump_log"   => "dump_log",   # default: nil (no output)\n           "Prompt"     => /[$%#>] \z/n, # default: /[$%#>] \z/n\n           "Telnetmode" => true,         # default: true\n           "Timeout"    => 10,           # default: 10\n if ignore timeout then set "Timeout" to false.\n           "Waittime"   => 0,            # default: 0\n           "Proxy"      => proxy         # default: nil\n proxy is Net::Telnet or IO object\n         )\n\nThe options have the following meanings:\n\nHost:: the hostname or IP address of the host to connect to, as a String.\n       Defaults to "localhost".\n\nPort:: the port to connect to.  Defaults to 23.\n\nBinmode:: if false (the default), newline substitution is performed.\n          Outgoing LF is\n          converted to CRLF, and incoming CRLF is converted to LF.  If\n          true, this substitution is not performed.  This value can\n          also be set with the #binmode() method.  The\n          outgoing conversion only applies to the #puts() and #print()\n          methods, not the #write() method.  The precise nature of\n          the newline conversion is also affected by the telnet options\n          SGA and BIN.\n\nOutput_log:: the name of the file to write connection status messages\n             and all received traffic to.  In the case of a proper\n             Telnet session, this will include the client input as\n             echoed by the host; otherwise, it only includes server\n             responses.  Output is appended verbatim to this file.\n             By default, no output log is kept.\n\nDump_log:: as for Output_log, except that output is written in hexdump\n           format (16 bytes per line as hex pairs, followed by their\n           printable equivalent), with connection status messages\n           preceded by '#', sent traffic preceded by '>', and\n           received traffic preceded by '<'.  By default, not dump log\n           is kept.\n\nPrompt:: a regular expression matching the host's command-line prompt\n         sequence.  This is needed by the Telnet class to determine\n         when the output from a command has finished and the host is\n         ready to receive a new command.  By default, this regular\n         expression is /[$%#>] \z/n.\n\nTelnetmode:: a boolean value, true by default.  In telnet mode,\n             traffic received from the host is parsed for special\n             command sequences, and these sequences are escaped\n             in outgoing traffic sent using #puts() or #print()\n             (but not #write()).  If you are using the Net::Telnet\n             object to connect to a non-telnet service (such as\n             SMTP or POP), this should be set to "false" to prevent\n             undesired data corruption.  This value can also be set\n             by the #telnetmode() method.\n\nTimeout:: the number of seconds to wait before timing out both the\n          initial attempt to connect to host (in this constructor),\n          and all attempts to read data from the host (in #waitfor(),\ncmd(), and #login()).  Exceeding this timeout causes a\n          TimeoutError to be raised.  The default value is 10 seconds.\n          You can disable the timeout by setting this value to false.\n          In this case, the connect attempt will eventually timeout\n          on the underlying connect(2) socket call with an\n          Errno::ETIMEDOUT error (but generally only after a few\n          minutes), but other attempts to read data from the host\n          will hand indefinitely if no data is forthcoming.\n\nWaittime:: the amount of time to wait after seeing what looks like a\n           prompt (that is, received data that matches the Prompt\n           option regular expression) to see if more data arrives.\n           If more data does arrive in this time, Net::Telnet assumes\n           that what it saw was not really a prompt.  This is to try to\n           avoid false matches, but it can also lead to missing real\n           prompts (if, for instance, a background process writes to\n           the terminal soon after the prompt is displayed).  By\n           default, set to 0, meaning not to wait for more data.\n\nProxy:: a proxy object to used instead of opening a direct connection\n        to the host.  Must be either another Net::Telnet object or\n        an IO object.  If it is another Net::Telnet object, this\n        instance will use that one's socket for communication.  If an\n        IO object, it is used directly for communication.  Any other\n        kind of object will cause an error to be raised.\n
binmode Net::Telnet.binmode(mode = nil)\nTurn newline conversion on (+mode+ == false) or off (+mode+ == true),\nor return the current value (+mode+ is not specified).\n
binmode= Net::Telnet.binmode=(mode)\nTurn newline conversion on (false) or off (true).\n
close Net::Telnet.close()\nCloses the connection\n
cmd Net::Telnet.cmd(options)\nSend a command to the host.\n\nMore exactly, sends a string to the host, and reads in all received\ndata until is sees the prompt or other matched sequence.\n\nIf a block is given, the received data will be yielded to it as\nit is read in.  Whether a block is given or not, the received data\nwill be return as a string.  Note that the received data includes\nthe prompt and in most cases the host's echo of our command.\n\n+options+ is either a String, specified the string or command to\nsend to the host; or it is a hash of options.  If a hash, the\nfollowing options can be specified:\n\nString:: the command or other string to send to the host.\nMatch:: a regular expression, the sequence to look for in\n        the received data before returning.  If not specified,\n        the Prompt option value specified when this instance\n        was created will be used, or, failing that, the default\n        prompt of /[$%#>] \z/n.\nTimeout:: the seconds to wait for data from the host before raising\n          a Timeout error.  If not specified, the Timeout option\n          value specified when this instance was created will be\n          used, or, failing that, the default value of 10 seconds.\n\nThe command or other string will have the newline sequence appended\nto it.\n
login Net::Telnet.login(options, password = nil)\nLogin to the host with a given username and password.\n\nThe username and password can either be provided as two string\narguments in that order, or as a hash with keys "Name" and\n"Password".\n\nThis method looks for the strings "login" and "Password" from the\nhost to determine when to send the username and password.  If the\nlogin sequence does not follow this pattern (for instance, you\nare connecting to a service other than telnet), you will need\nto handle login yourself.\n\nThe password can be omitted, either by only\nprovided one String argument, which will be used as the username,\nor by providing a has that has no "Password" key.  In this case,\nthe method will not look for the "Password:" prompt; if it is\nsent, it will have to be dealt with by later calls.\n\nThe method returns all data received during the login process from\nthe host, including the echoed username but not the password (which\nthe host should not echo).  If a block is passed in, this received\ndata is also yielded to the block as it is received.\n
preprocess Net::Telnet.preprocess(string)\nPreprocess received data from the host.\n\nPerforms newline conversion and detects telnet command sequences.\nCalled automatically by #waitfor().  You should only use this\nmethod yourself if you have read input directly using sysread()\nor similar, and even then only if in telnet mode.\n
print Net::Telnet.print(string)\nSends a string to the host.\n\nThis does _not_ automatically append a newline to the string.  Embedded\nnewlines may be converted and telnet command sequences escaped\ndepending upon the values of telnetmode, binmode, and telnet options\nset by the host.\n
puts Net::Telnet.puts(string)\nSends a string to the host.\n\nSame as #print(), but appends a newline to the string.\n
telnetmode Net::Telnet.telnetmode(mode = nil)\nSet telnet command interpretation on (+mode+ == true) or off\n(+mode+ == false), or return the current value (+mode+ not\nprovided).  It should be on for true telnet sessions, off if\nusing Net::Telnet to connect to a non-telnet service such\nas SMTP.\n
telnetmode= Net::Telnet.telnetmode=(mode)\nTurn telnet command interpretation on (true) or off (false).  It\nshould be on for true telnet sessions, off if using Net::Telnet\nto connect to a non-telnet service such as SMTP.\n
waitfor Net::Telnet.waitfor(options)\nRead data from the host until a certain sequence is matched.\n\nIf a block is given, the received data will be yielded as it\nis read in (not necessarily all in one go), or nil if EOF\noccurs before any data is received.  Whether a block is given\nor not, all data read will be returned in a single string, or again\nnil if EOF occurs before any data is received.  Note that\nreceived data includes the matched sequence we were looking for.\n\n+options+ can be either a regular expression or a hash of options.\nIf a regular expression, this specifies the data to wait for.\nIf a hash, this can specify the following options:\n\nMatch:: a regular expression, specifying the data to wait for.\nPrompt:: as for Match; used only if Match is not specified.\nString:: as for Match, except a string that will be converted\n         into a regular expression.  Used only if Match and\n         Prompt are not specified.\nTimeout:: the number of seconds to wait for data from the host\n          before raising a TimeoutError.  If set to false,\n          no timeout will occur.  If not specified, the\n          Timeout option value specified when this instance\n          was created will be used, or, failing that, the\n          default value of 10 seconds.\nWaittime:: the number of seconds to wait after matching against\n           the input data to see if more data arrives.  If more\n           data arrives within this time, we will judge ourselves\n           not to have matched successfully, and will continue\n           trying to match.  If not specified, the Waittime option\n           value specified when this instance was created will be\n           used, or, failing that, the default value of 0 seconds,\n           which means not to wait for more input.\nFailEOF:: if true, when the remote end closes the connection then an\n          EOFError will be raised. Otherwise, defaults to the old\n          behaviour that the function will return whatever data\n          has been received already, or nil if nothing was received.\n
write Net::Telnet.write(string)\nWrite +string+ to the host.\n\nDoes not perform any conversions on +string+.  Will log +string+ to the\ndumplog, if the Dump_log option is set.\n
new Rake::FileList.new(*patterns)\nCreate a file list from the globbable patterns given.  If you wish to\nperform multiple includes or excludes at object build time, use the\n"yield self" pattern.\n\nExample:\n  file_list = FileList.new('lib/**/*.rb', 'test/test*.rb')\n\n  pkg_files = FileList.new('lib/**/*') do |fl|\n    fl.exclude(/\bCVS\b/)\n  end\n
add Rake::FileList.add(*filenames)\n\n
clear_exclude Rake::FileList.clear_exclude()\nClear all the exclude patterns so that we exclude nothing.\n
egrep Rake::FileList.egrep(pattern, *options)\nGrep each of the files in the filelist using the given pattern. If a\nblock is given, call the block on each matching line, passing the file\nname, line number, and the matching line of text.  If no block is given,\na standard emacs style file:linenumber:line message will be printed to\nstandard out.  Returns the number of matched items.\n
exclude Rake::FileList.exclude(*patterns, &block)\nRegister a list of file name patterns that should be excluded from the\nlist.  Patterns may be regular expressions, glob patterns or regular\nstrings.  In addition, a block given to exclude will remove entries that\nreturn true when given to the block.\n\nNote that glob patterns are expanded against the file system. If a file\nis explicitly added to a file list, but does not exist in the file\nsystem, then an glob pattern in the exclude list will not exclude the\nfile.\n\nExamples:\n  FileList['a.c', 'b.c'].exclude("a.c") => ['b.c']\n  FileList['a.c', 'b.c'].exclude(/^a/)  => ['b.c']\n\nIf "a.c" is a file, then ...\n  FileList['a.c', 'b.c'].exclude("a.*") => ['b.c']\n\nIf "a.c" is not a file, then ...\n  FileList['a.c', 'b.c'].exclude("a.*") => ['a.c', 'b.c']\n
exclude? Rake::FileList.exclude?(fn)\nShould the given file name be excluded?\n
existing Rake::FileList.existing()\nReturn a new file list that only contains file names from the current\nfile list that exist on the file system.\n
existing! Rake::FileList.existing!()\nModify the current file list so that it contains only file name that\nexist on the file system.\n
ext Rake::FileList.ext(newext='')\nReturn a new FileList with <tt>String#ext</tt> method applied to\neach member of the array.\n\nThis method is a shortcut for:\n\n   array.collect { |item| item.ext(newext) }\n\n+ext+ is a user added method for the Array class.\n
gsub Rake::FileList.gsub(pat, rep)\nReturn a new FileList with the results of running +gsub+ against each\nelement of the original list.\n\nExample:\n  FileList['lib/test/file', 'x/y'].gsub(/\//, "\\")\n     => ['lib\\test\\file', 'x\\y']\n
gsub! Rake::FileList.gsub!(pat, rep)\nSame as +gsub+ except that the original file list is modified.\n
import Rake::FileList.import(array)\n\n
include Rake::FileList.include(*filenames)\nAdd file names defined by glob patterns to the file list.  If an array\nis given, add each element of the array.\n\nExample:\n  file_list.include("*.java", "*.cfg")\n  file_list.include %w( math.c lib.h *.o )\n
is_a? Rake::FileList.is_a?(klass)\nLie about our class.\n
kind_of? Rake::FileList.kind_of?(klass)\n\n
pathmap Rake::FileList.pathmap(spec=nil)\nApply the pathmap spec to each of the included file names, returning a\nnew file list with the modified paths.  (See String#pathmap for\ndetails.)\n
resolve Rake::FileList.resolve()\nResolve all the pending adds now.\n
sub Rake::FileList.sub(pat, rep)\nReturn a new FileList with the results of running +sub+ against each\nelement of the original list.\n\nExample:\n  FileList['a.c', 'b.c'].sub(/\.c$/, '.o')  => ['a.o', 'b.o']\n
sub! Rake::FileList.sub!(pat, rep)\nSame as +sub+ except that the original file list is modified.\n
to_a Rake::FileList.to_a()\nReturn the internal array object.\n
to_ary Rake::FileList.to_ary()\nReturn the internal array object.\n
to_s Rake::FileList.to_s()\nConvert a FileList to a string by joining all elements with a space.\n
expect MiniTest::Mock.expect(name, retval, args=[])\nExpect that method +name+ is called, optionally with +args+, and returns\n+retval+.\n\n  @mock.expect(:meaning_of_life, 42)\n  @mock.meaning_of_life # => 42\n\n  @mock.expect(:do_something_with, true, [some_obj, true])\n  @mock.do_something_with(some_obj, true) # => true\n\n+args+ is compared to the expected args using case equality (ie, the\n'===' operator), allowing for less specific expectations.\n\n  @mock.expect(:uses_any_string, true, [String])\n  @mock.uses_any_string("foo") # => true\n  @mock.verify  # => true\n\n  @mock.expect(:uses_one_string, true, ["foo"]\n  @mock.uses_one_string("bar") # => true\n  @mock.verify  # => raises MockExpectationError\n
verify MiniTest::Mock.verify()\nVerify that all methods were called as expected. Raises\n+MockExpectationError+ if the mock object was not called as\nexpected.\n
new PrideIO.new(io)\n\n
method_missing PrideIO.method_missing(msg, *args)\n\n
pride PrideIO.pride(string)\n\n
print PrideIO.print(o)\n\n
puts PrideIO.puts(*o)\n\n
new PrideLOL.new(io)\n\n
pride PrideLOL.pride(string)\n\n
after MiniTest::Spec.after(type = :each, &block)\nDefine an 'after' action. Inherits the way normal methods should.\n\nNOTE: +type+ is ignored and is only there to make porting easier.\n\nEquivalent to MiniTest::Unit::TestCase#teardown.\n
before MiniTest::Spec.before(type = :each, &block)\nDefine a 'before' action. Inherits the way normal methods should.\n\nNOTE: +type+ is ignored and is only there to make porting easier.\n\nEquivalent to MiniTest::Unit::TestCase#setup.\n
bench MiniTest::Spec.bench(name, &block)\nThis is used to define a new benchmark method. You usually don't\nuse this directly and is intended for those needing to write new\nperformance curve fits (eg: you need a specific polynomial fit).\n\nSee ::bench_performance_linear for an example of how to use this.\n
bench_performance_constant MiniTest::Spec.bench_performance_constant(name, threshold = 0.99, &work)\nCreate a benchmark that verifies that the performance is constant.\n\n  describe "my class" do\n    bench_performance_constant "zoom_algorithm!" do\n      @obj.zoom_algorithm!\n    end\n  end\n
bench_performance_exponential MiniTest::Spec.bench_performance_exponential(name, threshold = 0.99, &work)\nCreate a benchmark that verifies that the performance is exponential.\n\n  describe "my class" do\n    bench_performance_exponential "algorithm" do\n      @obj.algorithm\n    end\n  end\n
bench_performance_linear MiniTest::Spec.bench_performance_linear(name, threshold = 0.99, &work)\nCreate a benchmark that verifies that the performance is linear.\n\n  describe "my class" do\n    bench_performance_linear "fast_algorithm", 0.9999 do\n      @obj.fast_algorithm\n    end\n  end\n
bench_range MiniTest::Spec.bench_range(&block)\n\n
children MiniTest::Spec.children()\nReturns the children of this spec.\n
it MiniTest::Spec.it(desc, &block)\nDefine an expectation with name +desc+. Name gets morphed to a\nproper test method name. For some freakish reason, people who\nwrite specs don't like class inheritence, so this goes way out of\nits way to make sure that expectations aren't inherited.\n\nHint: If you _do_ want inheritence, use minitest/unit. You can mix\nand match between assertions and expectations as much as you want.\n
let MiniTest::Spec.let(name, &block)\n\n
register_spec_type MiniTest::Spec.register_spec_type(*args, &block)\nRegister a new type of spec that matches the spec's description.\nThis method can take either a Regexp and a spec class or a spec\nclass and a block that takes the description and returns true if\nit matches.\n\nEg:\n\n    register_spec_type(/Controller$/, MiniTest::Spec::Rails)\n\nor:\n\n    register_spec_type(MiniTest::Spec::RailsModel) do |desc|\n      desc.superclass == ActiveRecord::Base\n    end\n
spec_type MiniTest::Spec.spec_type(desc)\nFigure out the spec class to use based on a spec's description. Eg:\n\n    spec_type("BlahController") # => MiniTest::Spec::Rails\n
subject MiniTest::Spec.subject(&block)\n\n
after_tests MiniTest::Unit.after_tests()\nA simple hook allowing you to run a block of code after the\ntests are done. Eg:\n\n  MiniTest::Unit.after_tests { p $debugging_info }\n
autorun MiniTest::Unit.autorun()\nRegisters MiniTest::Unit to run tests at process exit\n
out MiniTest::Unit.out()\nReturns the stream to use for output.\n\nDEPRECATED: use ::output instead.\n
output MiniTest::Unit.output()\nReturns the stream to use for output.\n
output= MiniTest::Unit.output=(stream)\nSets MiniTest::Unit to write output to +stream+.  $stdout is the default\noutput\n
plugins MiniTest::Unit.plugins()\nReturn all plugins' run methods (methods that start with "run_").\n
runner MiniTest::Unit.runner()\nReturns the MiniTest::Unit subclass instance that will be used\nto run the tests. A MiniTest::Unit instance is the default\nrunner.\n
runner= MiniTest::Unit.runner=(runner)\nTells MiniTest::Unit to delegate to +runner+, an instance of a\nMiniTest::Unit subclass, when MiniTest::Unit#run is called.\n
_run MiniTest::Unit._run(args = [])\nTop level driver, controls all output and filtering.\n
_run_anything MiniTest::Unit._run_anything(type)\n\n
_run_suite MiniTest::Unit._run_suite(suite, type)\n\n
_run_suites MiniTest::Unit._run_suites(suites, type)\n\n
options MiniTest::Unit.options()\n\n
output MiniTest::Unit.output()\n\n
process_args MiniTest::Unit.process_args(args = [])\n\n
puke MiniTest::Unit.puke(klass, meth, e)\nWrites status for failed test +meth+ in +klass+ which finished with\nexception +e+\n
run MiniTest::Unit.run(args = [])\nBegins the full test run. Delegates to +runner+'s #_run method.\n
run_tests MiniTest::Unit.run_tests()\nRuns test suites matching +filter+.\n
status MiniTest::Unit.status(io = self.output)\nWrites status to +io+\n
add_setup_hook MiniTest::Unit::TestCase.add_setup_hook(arg=nil, &block)\nAdds a block of code that will be executed before every TestCase is\nrun. Equivalent to +setup+, but usable multiple times and without\nre-opening any classes.\n\nAll of the setup hooks will run in order after the +setup+ method, if\none is defined.\n\nThe argument can be any object that responds to #call or a block.\nThat means that this call,\n\n    MiniTest::TestCase.add_setup_hook { puts "foo" }\n\n... is equivalent to:\n\n    module MyTestSetup\n      def call\n        puts "foo"\n      end\n    end\n\n    MiniTest::TestCase.add_setup_hook MyTestSetup\n\nThe blocks passed to +add_setup_hook+ take an optional parameter that\nwill be the TestCase instance that is executing the block.\n
add_teardown_hook MiniTest::Unit::TestCase.add_teardown_hook(arg=nil, &block)\nAdds a block of code that will be executed after every TestCase is\nrun. Equivalent to +teardown+, but usable multiple times and without\nre-opening any classes.\n\nAll of the teardown hooks will run in reverse order after the\n+teardown+ method, if one is defined.\n\nThe argument can be any object that responds to #call or a block.\nThat means that this call,\n\n    MiniTest::TestCase.add_teardown_hook { puts "foo" }\n\n... is equivalent to:\n\n    module MyTestTeardown\n      def call\n        puts "foo"\n      end\n    end\n\n    MiniTest::TestCase.add_teardown_hook MyTestTeardown\n\nThe blocks passed to +add_teardown_hook+ take an optional parameter\nthat will be the TestCase instance that is executing the block.\n
bench_exp MiniTest::Unit::TestCase.bench_exp(min, max, base = 10)\nReturns a set of ranges stepped exponentially from +min+ to\n+max+ by powers of +base+. Eg:\n\n  bench_exp(2, 16, 2) # => [2, 4, 8, 16]\n
bench_linear MiniTest::Unit::TestCase.bench_linear(min, max, step = 10)\nReturns a set of ranges stepped linearly from +min+ to +max+ by\n+step+. Eg:\n\n  bench_linear(20, 40, 10) # => [20, 30, 40]\n
bench_range MiniTest::Unit::TestCase.bench_range()\nSpecifies the ranges used for benchmarking for that class.\nDefaults to exponential growth from 1 to 10k by powers of 10.\nOverride if you need different ranges for your benchmarks.\n\nSee also: ::bench_exp and ::bench_linear.\n
benchmark_suites MiniTest::Unit::TestCase.benchmark_suites()\nReturns all test suites that have benchmark methods.\n
i_suck_and_my_tests_are_order_dependent! MiniTest::Unit::TestCase.i_suck_and_my_tests_are_order_dependent!()\nCall this at the top of your tests when you absolutely\npositively need to have ordered tests. In doing so, you're\nadmitting that you suck and your tests are weak.\n
assert_performance MiniTest::Unit::TestCase.assert_performance(validation, &work)\nRuns the given +work+, gathering the times of each run. Range\nand times are then passed to a given +validation+ proc. Outputs\nthe benchmark name and times in tab-separated format, making it\neasy to paste into a spreadsheet for graphing or further\nanalysis.\n\nRanges are specified by ::bench_range.\n\nEg:\n\n  def bench_algorithm\n    validation = proc { |x, y| ... }\n    assert_performance validation do |x|\n      @obj.algorithm\n    end\n  end\n
assert_performance_constant MiniTest::Unit::TestCase.assert_performance_constant(threshold = 0.99, &work)\nRuns the given +work+ and asserts that the times gathered fit to\nmatch a constant rate (eg, linear slope == 0) within a given\n+threshold+. Note: because we're testing for a slope of 0, R^2\nis not a good determining factor for the fit, so the threshold\nis applied against the slope itself. As such, you probably want\nto tighten it from the default.\n\nSee http://www.graphpad.com/curvefit/goodness_of_fit.htm for\nmore details.\n\nFit is calculated by #fit_linear.\n\nRanges are specified by ::bench_range.\n\nEg:\n\n  def bench_algorithm\n    assert_performance_constant 0.9999 do |x|\n      @obj.algorithm\n    end\n  end\n
assert_performance_exponential MiniTest::Unit::TestCase.assert_performance_exponential(threshold = 0.99,\n&work)\nRuns the given +work+ and asserts that the times gathered fit to\nmatch a exponential curve within a given error +threshold+.\n\nFit is calculated by #fit_exponential.\n\nRanges are specified by ::bench_range.\n\nEg:\n\n  def bench_algorithm\n    assert_performance_exponential 0.9999 do |x|\n      @obj.algorithm\n    end\n  end\n
assert_performance_linear MiniTest::Unit::TestCase.assert_performance_linear(threshold = 0.99, &work)\nRuns the given +work+ and asserts that the times gathered fit to\nmatch a straight line within a given error +threshold+.\n\nFit is calculated by #fit_linear.\n\nRanges are specified by ::bench_range.\n\nEg:\n\n  def bench_algorithm\n    assert_performance_linear 0.9999 do |x|\n      @obj.algorithm\n    end\n  end\n
assert_performance_power MiniTest::Unit::TestCase.assert_performance_power(threshold = 0.99, &work)\nRuns the given +work+ and asserts that the times gathered curve\nfit to match a power curve within a given error +threshold+.\n\nFit is calculated by #fit_power.\n\nRanges are specified by ::bench_range.\n\nEg:\n\n  def bench_algorithm\n    assert_performance_power 0.9999 do |x|\n      @obj.algorithm\n    end\n  end\n
fit_error MiniTest::Unit::TestCase.fit_error(xys)\nTakes an array of x/y pairs and calculates the general R^2 value.\n\nSee: http://en.wikipedia.org/wiki/Coefficient_of_determination\n
fit_exponential MiniTest::Unit::TestCase.fit_exponential(xs, ys)\nTo fit a functional form: y = ae^(bx).\n\nTakes x and y values and returns [a, b, r^2].\n\nSee: http://mathworld.wolfram.com/LeastSquaresFittingExponential.html\n
fit_linear MiniTest::Unit::TestCase.fit_linear(xs, ys)\nFits the functional form: a + bx.\n\nTakes x and y values and returns [a, b, r^2].\n\nSee: http://mathworld.wolfram.com/LeastSquaresFitting.html\n
fit_power MiniTest::Unit::TestCase.fit_power(xs, ys)\nTo fit a functional form: y = ax^b.\n\nTakes x and y values and returns [a, b, r^2].\n\nSee: http://mathworld.wolfram.com/LeastSquaresFittingPowerLaw.html\n
io MiniTest::Unit::TestCase.io()\n\n
io? MiniTest::Unit::TestCase.io?()\n\n
passed? MiniTest::Unit::TestCase.passed?()\nReturns true if the test passed.\n
run MiniTest::Unit::TestCase.run(runner)\nRuns the tests reporting the status to +runner+\n
setup MiniTest::Unit::TestCase.setup()\nRuns before every test. Use this to refactor test initialization.\n
sigma MiniTest::Unit::TestCase.sigma(enum, &block)\nEnumerates over +enum+ mapping +block+ if given, returning the\nsum of the result. Eg:\n\n  sigma([1, 2, 3])                # => 1 + 2 + 3 => 7\n  sigma([1, 2, 3]) { |n| n ** 2 } # => 1 + 4 + 9 => 14\n
teardown MiniTest::Unit::TestCase.teardown()\nRuns after every test. Use this to refactor test cleanup.\n
validation_for_fit MiniTest::Unit::TestCase.validation_for_fit(msg, threshold)\nReturns a proc that calls the specified fit method and asserts\nthat the error is within a tolerable threshold.\n
new OpenStruct.new(hash=nil)\nCreates a new OpenStruct object.  By default, the resulting OpenStruct\nobject will have no attributes.\n\nThe optional +hash+, if given, will generate attributes and values.\nFor example:\n\n  require 'ostruct'\n  hash = { "country" => "Australia", :population => 20_000_000 }\n  data = OpenStruct.new(hash)\n\n  p data        # -> <OpenStruct country="Australia" population=20000000>\n
delete_field OpenStruct.delete_field(name)\nRemove the named field from the object. Returns the value that the field\ncontained if it was defined.\n\n  require 'ostruct'\n\n  person = OpenStruct.new('name' => 'John Smith', 'age' => 70)\n\n  person.delete_field('name')  # => 'John Smith'\n
initialize_copy OpenStruct.initialize_copy(orig)\nDuplicate an OpenStruct object members.\n
inspect OpenStruct.inspect()\nReturns a string containing a detailed summary of the keys and values.\n
marshal_dump OpenStruct.marshal_dump()\nProvides marshalling support for use by the Marshal library. Returning the\nunderlying Hash table that contains the functions defined as the keys and\nthe values assigned to them.\n\n   require 'ostruct'\n\n   person = OpenStruct.new\n   person.name = 'John Smith'\n   person.age  = 70\n\n   person.marshal_dump # => { :name => 'John Smith', :age => 70 }\n
marshal_load OpenStruct.marshal_load(x)\nProvides marshalling support for use by the Marshal library. Accepting\na Hash of keys and values which will be used to populate the internal table\n\n   require 'ostruct'\n\n   event = OpenStruct.new\n   hash = { 'time' => Time.now, 'title' => 'Birthday Party' }\n   event.marshal_load(hash)\n   event.title # => 'Birthday Party'\n
modifiable OpenStruct.modifiable()\nmodifiable is used internally to check if the OpenStruct is able to be\nmodified before granting access to the internal Hash table to be modified.\n
new_ostruct_member OpenStruct.new_ostruct_member(name)\nnew_ostruct_member is used internally to defined properties on the\nOpenStruct. It does this by using the metaprogramming function\ndefine_method for both the getter method and the setter method.\n
to_s OpenStruct.to_s()\n\n
delete YAML::DBM.delete( key )\nDeletes value from database associated with +key+.\n\nReturns value or +nil+.\n
delete_if YAML::DBM.delete_if()\nCalls the given block once for each +key+, +value+ pair in the database.\nDeletes all entries for which the block returns true.\n\nReturns +self+.\n
each YAML::DBM.each()\n\n
each_pair YAML::DBM.each_pair()\nCalls the given block once for each +key+, +value+ pair in the database.\n\nReturns +self+.\n
each_value YAML::DBM.each_value()\nCalls the given block for each value in database.\n\nReturns +self+.\n
fetch YAML::DBM.fetch( keystr, ifnone = nil )\nReturn value associated with +key+.\n\nIf there is no value for +key+ and no block is given, returns +ifnone+.\n\nOtherwise, calls block passing in the given +key+.\n
has_value? YAML::DBM.has_value?( val )\nReturns true if specified value is found in the database.\n
index YAML::DBM.index( keystr )\nDeprecated, used YAML::DBM#key instead.\n
invert YAML::DBM.invert()\nReturns a Hash (not a DBM database) created by using each value in the\ndatabase as a key, with the corresponding key as its value.\n\nNote that all values in the hash will be Strings, but the keys will be\nactual objects.\n
reject YAML::DBM.reject()\nConverts the contents of the database to an in-memory Hash, then calls\nHash#reject with the specified code block, returning a new Hash.\n
replace YAML::DBM.replace( hsh )\nReplaces the contents of the database with the contents of the specified\nobject. Takes any object which implements the each_pair method, including\nHash and DBM objects.\n
select YAML::DBM.select( *keys )\nIf a block is provided, returns a new array containing [key, value] pairs\nfor which the block returns true.\n\nOtherwise, same as #values_at\n
shift YAML::DBM.shift()\nRemoves a [key, value] pair from the database, and returns it.\nIf the database is empty, returns +nil+.\n\nThe order in which values are removed/returned is not guaranteed.\n
store YAML::DBM.store( key, val )\nStores +value+ in database with +key+ as the index. +value+ is converted\nto YAML before being stored.\n\nReturns +value+\n
to_a YAML::DBM.to_a()\nConverts the contents of the database to an array of [key, value] arrays,\nand returns it.\n
to_hash YAML::DBM.to_hash()\nConverts the contents of the database to an in-memory Hash object, and\nreturns it.\n
update YAML::DBM.update( hsh )\nUpdates the database with multiple values from the specified object.\nTakes any object which implements the each_pair method, including\nHash and DBM objects.\n\nReturns +self+.\n
values YAML::DBM.values()\nReturns an array of values from the database.\n
values_at YAML::DBM.values_at( *keys )\nReturns an array containing the values associated with the given keys.\n
new YAML::Store.new( *o )\nCreates a new YAML::Store object, which will store data in +file_name+.\nIf the file does not already exist, it will be created.\n\nOptions passed in through +yaml_opts+ will be used when converting the\nstore to YAML via Hash#to_yaml().\n
new WeakRef.new(orig)\nCreates a weak reference to +orig+\n
weakref_alive? WeakRef.weakref_alive?()\nReturns true if the referenced object is still alive.\n
build URI::MailTo.build(args)\n== Description\n\nCreates a new URI::MailTo object from components, with syntax checking.\n\nComponents can be provided as an Array or Hash. If an Array is used,\nthe components must be supplied as [to, headers].\n\nIf a Hash is used, the keys are the component names preceded by colons.\n\nThe headers can be supplied as a pre-encoded string, such as\n"subject=subscribe&cc=address", or as an Array of Arrays like\n[['subject', 'subscribe'], ['cc', 'address']]\n\nExamples:\n\n   require 'uri'\n\n   m1 = URI::MailTo.build(['joe@example.com', 'subject=Ruby'])\n   puts m1.to_s  ->  mailto:joe@example.com?subject=Ruby\n\n   m2 = URI::MailTo.build(['john@example.com', [['Subject', 'Ruby'], ['Cc',\n   'jack@example.com']]])\n   puts m2.to_s  ->  mailto:john@example.com?Subject=Ruby&Cc=jack@example.com\n\n   m3 = URI::MailTo.build({:to => 'listman@example.com', :headers =>\n   [['subject', 'subscribe']]})\n   puts m3.to_s  ->  mailto:listman@example.com?subject=subscribe\n
new URI::MailTo.new(*arg)\n== Description\n\nCreates a new URI::MailTo object from generic URL components with\nno syntax checking.\n\nThis method is usually called from URI::parse, which checks\nthe validity of each component.\n
headers= URI::MailTo.headers=(v)\nsetter for headers +v+\n
set_headers URI::MailTo.set_headers(v)\nprivate setter for headers +v+\n
set_to URI::MailTo.set_to(v)\nprivate setter for to +v+\n
to= URI::MailTo.to=(v)\nsetter for to +v+\n
to_mailtext URI::MailTo.to_mailtext()\nReturns the RFC822 e-mail text equivalent of the URL, as a String.\n\nExample:\n\n  require 'uri'\n\n  uri = URI.parse("mailto:ruby-list@ruby-lang.org?Subject=subscribe&cc=myaddr")\n  uri.to_mailtext\n => "To: ruby-list@ruby-lang.org\\nSubject: subscribe\\nCc: myaddr\\n\\n\\n"\n
to_rfc822text URI::MailTo.to_rfc822text()\n\n
to_s URI::MailTo.to_s()\nConstructs String from URI\n
new URI::Parser.new(opts = {})\n== Synopsis\n\n  URI::Parser.new([opts])\n\n== Args\n\nThe constructor accepts a hash as options for parser.\nKeys of options are pattern names of URI components\nand values of options are pattern strings.\nThe constructor generetes set of regexps for parsing URIs.\n\nYou can use the following keys:\n\n  * :ESCAPED (URI::PATTERN::ESCAPED in default)\n  * :UNRESERVED (URI::PATTERN::UNRESERVED in default)\n  * :DOMLABEL (URI::PATTERN::DOMLABEL in default)\n  * :TOPLABEL (URI::PATTERN::TOPLABEL in default)\n  * :HOSTNAME (URI::PATTERN::HOSTNAME in default)\n\n== Examples\n\n  p = URI::Parser.new(:ESCAPED => "(?:%[a-fA-F0-9]{2}|%u[a-fA-F0-9]{4})")\n  u = p.parse("http://example.jp/%uABCD") #=> #<URI::HTTP:0xb78cf4f8\n  URL:http://example.jp/%uABCD>\n  URI.parse(u.to_s) #=> raises URI::InvalidURIError\n\n  s = "http://examle.com/ABCD"\n  u1 = p.parse(s) #=> #<URI::HTTP:0xb78c3220 URL:http://example.com/ABCD>\n  u2 = URI.parse(s) #=> #<URI::HTTP:0xb78b6d54 URL:http://example.com/ABCD>\n  u1 == u2 #=> true\n  u1.eql?(u2) #=> false\n
escape URI::Parser.escape(str, unsafe = @regexp[:UNSAFE])\n== Args\n\n+str+::\n   String to make safe\n+unsafe+::\n   Regexp to apply. Defaults to self.regexp[:UNSAFE]\n\n== Description\n\nconstructs a safe String from +str+, removing unsafe characters,\nreplacing them with codes.\n
extract URI::Parser.extract(str, schemes = nil, &block)\n== Args\n\n+str+::\n   String to search\n+schemes+::\n   Patterns to apply to +str+\n\n== Description\n\nAttempts to parse and merge a set of URIs\nIf no +block+ given , then returns the result,\nelse it calls +block+ for each element in result.\n\nsee also URI::Parser.make_regexp\n
inspect URI::Parser.inspect()\n\n
join URI::Parser.join(*uris)\n== Args\n\n+uris+::\n   an Array of Strings\n\n== Description\n\nAttempts to parse and merge a set of URIs\n
make_regexp URI::Parser.make_regexp(schemes = nil)\nreturns Regexp that is default self.regexp[:ABS_URI_REF],\nunless +schemes+ is provided. Then it is a Regexp.union with\nself.pattern[:X_ABS_URI]\n
parse URI::Parser.parse(uri)\n== Args\n\n+uri+::\n   String\n\n== Description\n\nparses +uri+ and constructs either matching URI scheme object\n(FTP, HTTP, HTTPS, LDAP, LDAPS, or MailTo) or URI::Generic\n\n== Usage\n\n  p = URI::Parser.new\n  p.parse("ldap://ldap.example.com/dc=example?user=john")\n=> #<URI::LDAP:0x00000000b9e7e8\nURL:ldap://ldap.example.com/dc=example?user=john>\n
split URI::Parser.split(uri)\nReturns a split URI against regexp[:ABS_URI]\n
unescape URI::Parser.unescape(str, escaped = @regexp[:ESCAPED])\n== Args\n\n+str+::\n   String to remove escapes from\n+unsafe+::\n   Regexp to apply. Defaults to self.regexp[:ESCAPED]\n\n== Description\n\nRemoves escapes from +str+\n
build URI::LDAP.build(args)\n== Description\n\nCreate a new URI::LDAP object from components, with syntax checking.\n\nThe components accepted are host, port, dn, attributes,\nscope, filter, and extensions.\n\nThe components should be provided either as an Array, or as a Hash\nwith keys formed by preceding the component names with a colon.\n\nIf an Array is used, the components must be passed in the order\n[host, port, dn, attributes, scope, filter, extensions].\n\nExample:\n\n    newuri = URI::LDAP.build({:host => 'ldap.example.com',\n      :dn> => '/dc=example'})\n\n    newuri = URI::LDAP.build(["ldap.example.com", nil,\n      "/dc=example;dc=com", "query", nil, nil, nil])\n
new URI::LDAP.new(*arg)\n== Description\n\nCreate a new URI::LDAP object from generic URI components as per\nRFC 2396. No LDAP-specific syntax checking is performed.\n\nArguments are +scheme+, +userinfo+, +host+, +port+, +registry+, +path+,\n+opaque+, +query+ and +fragment+, in that order.\n\nExample:\n\n    uri = URI::LDAP.new("ldap", nil, "ldap.example.com", nil,\n      "/dc=example;dc=com", "query", nil, nil, nil, nil)\n\nSee also URI::Generic.new\n
attributes URI::LDAP.attributes()\nreturns attributes.\n
attributes= URI::LDAP.attributes=(val)\nsetter for attributes +val+\n
dn URI::LDAP.dn()\nreturns dn.\n
dn= URI::LDAP.dn=(val)\nsetter for dn +val+\n
extensions URI::LDAP.extensions()\nreturns extensions.\n
extensions= URI::LDAP.extensions=(val)\nsetter for extensions +val+\n
filter URI::LDAP.filter()\nreturns filter.\n
filter= URI::LDAP.filter=(val)\nsetter for filter +val+\n
hierarchical? URI::LDAP.hierarchical?()\nChecks if URI has a path\nFor URI::LDAP this will return +false+\n
scope URI::LDAP.scope()\nreturns scope.\n
scope= URI::LDAP.scope=(val)\nsetter for scope +val+\n
set_attributes URI::LDAP.set_attributes(val)\nprivate setter for attributes +val+\n
set_dn URI::LDAP.set_dn(val)\nprivate setter for dn +val+\n
set_extensions URI::LDAP.set_extensions(val)\nprivate setter for extensions +val+\n
set_filter URI::LDAP.set_filter(val)\nprivate setter for filter +val+\n
set_scope URI::LDAP.set_scope(val)\nprivate setter for scope +val+\n
elements Vector.elements(array, copy = true)\nCreates a vector from an Array.  The optional second argument specifies\nwhether the array itself or a copy is used internally.\n
new Vector.new(array)\nVector.new is private; use Vector[] or Vector.elements to create.\n
clone Vector.clone()\nReturn a copy of the vector.\n
coerce Vector.coerce(other)\nThe coerce method provides support for Ruby type coercion.\nThis coercion mechanism is used by Ruby to handle mixed-type\nnumeric operations: it is intended to find a compatible common\ntype between the two operands of the operator.\nSee also Numeric#coerce.\n
collect Vector.collect()\nLike Array#collect.\n
collect2 Vector.collect2(v)\nCollects (as in Enumerable#collect) over the elements of this vector and +v+\nin conjunction.\n
component Vector.component(i)\n\n
covector Vector.covector()\nCreates a single-row matrix from this vector.\n
each Vector.each(&block)\nIterate over the elements of this vector\n
each2 Vector.each2(v)\nIterate over the elements of this vector and +v+ in conjunction.\n
element Vector.element(i)\n\n
elements_to_f Vector.elements_to_f()\n\n
elements_to_i Vector.elements_to_i()\n\n
elements_to_r Vector.elements_to_r()\n\n
eql? Vector.eql?(other)\n\n
hash Vector.hash()\nReturn a hash-code for the vector.\n
inner_product Vector.inner_product(v)\nReturns the inner product of this vector with the other.\n  Vector[4,7].inner_product Vector[10,1]  => 47\n
inspect Vector.inspect()\nOverrides Object#inspect\n
magnitude Vector.magnitude()\nReturns the modulus (Pythagorean distance) of the vector.\n  Vector[5,8,2].r => 9.643650761\n
map Vector.map()\n\n
map2 Vector.map2(v)\nLike Vector#collect2, but returns a Vector instead of an Array.\n
norm Vector.norm()\n\n
normalize Vector.normalize()\nReturns a new vector with the same direction but with norm 1.\n  v = Vector[5,8,2].normalize\n => Vector[0.5184758473652127, 0.8295613557843402, 0.20739033894608505]\n  v.norm => 1.0\n
r Vector.r()\n\n
size Vector.size()\nReturns the number of elements in the vector.\n
to_a Vector.to_a()\nReturns the elements of the vector in an array.\n
to_s Vector.to_s()\nOverrides Object#to_s\n
get_instance WEBrick::HTTPServlet::AbstractServlet.get_instance(server, *options)\nFactory for servlet instances that will handle a request from +server+\nusing +options+ from the mount point.  By default a new servlet\ninstance is created for every call.\n
new WEBrick::HTTPServlet::AbstractServlet.new(server, *options)\nInitializes a new servlet for +server+ using +options+ which are\nstored as-is in +@options+.  +@logger+ is also provided.\n
do_GET WEBrick::HTTPServlet::AbstractServlet.do_GET(req, res)\nRaises a NotFound exception\n
do_HEAD WEBrick::HTTPServlet::AbstractServlet.do_HEAD(req, res)\nDispatches to do_GET\n
do_OPTIONS WEBrick::HTTPServlet::AbstractServlet.do_OPTIONS(req, res)\nReturns the allowed HTTP request methods\n
service WEBrick::HTTPServlet::AbstractServlet.service(req, res)\nDispatches to a +do_+ method based on +req+ if such a method is\navailable.  (+do_GET+ for a GET request).  Raises a MethodNotAllowed\nexception if the method is not implemented.\n
new WEBrick::HTTPServlet::ProcHandler.new(proc)\n\n
do_GET WEBrick::HTTPServlet::ProcHandler.do_GET(request, response)\n\n
do_POST WEBrick::HTTPServlet::ProcHandler.do_POST(request, response)\n\n
get_instance WEBrick::HTTPServlet::ProcHandler.get_instance(server, *options)\n\n
new WEBrick::HTTPServlet::ERBHandler.new(server, name)\nCreates a new ERBHandler on +server+ that will evaluate and serve the\nERB file +name+\n
do_GET WEBrick::HTTPServlet::ERBHandler.do_GET(req, res)\nHandles GET requests\n
do_POST WEBrick::HTTPServlet::ERBHandler.do_POST(req, res)\nHandles POST requests\n
new WEBrick::HTTPServlet::CGIHandler.new(server, name)\n\n
do_GET WEBrick::HTTPServlet::CGIHandler.do_GET(req, res)\n\n
do_POST WEBrick::HTTPServlet::CGIHandler.do_POST(req, res)\n\n
new WEBrick::HTTPServlet::DefaultFileHandler.new(server, local_path)\n\n
do_GET WEBrick::HTTPServlet::DefaultFileHandler.do_GET(req, res)\n\n
make_partial_content WEBrick::HTTPServlet::DefaultFileHandler.make_partial_content(req, res,\nfilename, filesize)\n\n
not_modified? WEBrick::HTTPServlet::DefaultFileHandler.not_modified?(req, res, mtime, etag)\n\n
prepare_range WEBrick::HTTPServlet::DefaultFileHandler.prepare_range(range, filesize)\n\n
add_handler WEBrick::HTTPServlet::FileHandler.add_handler(suffix, handler)\nAllow custom handling of requests for files with +suffix+ by class\n+handler+\n
new WEBrick::HTTPServlet::FileHandler.new(server, root, options={},\ndefault=Config::FileHandler)\nCreates a FileHandler servlet on +server+ that serves files starting\nat directory +root+\n\nIf +options+ is a Hash the following keys are allowed:\n\n:AcceptableLanguages:: Array of languages allowed for accept-language\n:DirectoryCallback:: Allows preprocessing of directory requests\n:FancyIndexing:: If true, show an index for directories\n:FileCallback:: Allows preprocessing of file requests\n:HandlerCallback:: Allows preprocessing of requests\n:HandlerTable:: Maps file suffixes to file handlers.\n                DefaultFileHandler is used by default but any servlet\n                can be used.\n:NondisclosureName:: Do not show files matching this array of globs\n:UserDir:: Directory inside ~user to serve content from for /~user\n           requests.  Only works if mounted on /\n\nIf +options+ is true or false then +:FancyIndexing+ is enabled or\ndisabled respectively.\n
remove_handler WEBrick::HTTPServlet::FileHandler.remove_handler(suffix)\nRemove custom handling of requests for files with +suffix+\n
do_GET WEBrick::HTTPServlet::FileHandler.do_GET(req, res)\n\n
do_OPTIONS WEBrick::HTTPServlet::FileHandler.do_OPTIONS(req, res)\n\n
do_POST WEBrick::HTTPServlet::FileHandler.do_POST(req, res)\n\n
service WEBrick::HTTPServlet::FileHandler.service(req, res)\n\n
cancel WEBrick::Utils::TimeoutHandler.cancel(id)\nCancels the timeout handler +id+\n
new WEBrick::Utils::TimeoutHandler.new()\n\n
register WEBrick::Utils::TimeoutHandler.register(seconds, exception)\nRegisters a new timeout handler\n\n+time+:: Timeout in seconds\n+exception+:: Exception to raise when timeout elapsed\n
cancel WEBrick::Utils::TimeoutHandler.cancel(thread, id)\nCancels the timeout handler +id+\n
interrupt WEBrick::Utils::TimeoutHandler.interrupt(thread, id, exception)\nInterrupts the timeout handler +id+ and raises +exception+\n
register WEBrick::Utils::TimeoutHandler.register(thread, time, exception)\nRegisters a new timeout handler\n\n+time+:: Timeout in seconds\n+exception+:: Exception to raise when timeout elapsed\n
new WEBrick::HTTPRequest.new(config)\n\n
body WEBrick::HTTPRequest.body(&block)\n\n
content_length WEBrick::HTTPRequest.content_length()\nThe content-length header\n
content_type WEBrick::HTTPRequest.content_type()\nThe content-type header\n
continue WEBrick::HTTPRequest.continue()\nGenerate HTTP/1.1 100 continue response if the client expects it,\notherwise does nothing.\n
each WEBrick::HTTPRequest.each()\nIterates over the request headers\n
fixup WEBrick::HTTPRequest.fixup()\n\n
host WEBrick::HTTPRequest.host()\nThe host this request is for\n
keep_alive? WEBrick::HTTPRequest.keep_alive?()\nShould the connection this request was made on be kept alive?\n
meta_vars WEBrick::HTTPRequest.meta_vars()\nThis method provides the metavariables defined by the revision 3\nof "The WWW Common Gateway Interface Version 1.1"\nhttp://Web.Golux.Com/coar/cgi/\n
orig_meta_vars WEBrick::HTTPRequest.orig_meta_vars()\n\n
orig_parse WEBrick::HTTPRequest.orig_parse(socket=nil)\n\n
orig_parse_uri WEBrick::HTTPRequest.orig_parse_uri(str, scheme="http")\n\n
parse WEBrick::HTTPRequest.parse(socket=nil)\n\n
port WEBrick::HTTPRequest.port()\nThe port this request is for\n
query WEBrick::HTTPRequest.query()\nRequest query as a Hash\n
remote_ip WEBrick::HTTPRequest.remote_ip()\nThe client's IP address\n
server_name WEBrick::HTTPRequest.server_name()\nThe server name this request is for\n
ssl? WEBrick::HTTPRequest.ssl?()\nIs this an SSL request?\n
convert WEBrick::HTTPVersion.convert(version)\n\n
new WEBrick::HTTPVersion.new(version)\n\n
to_s WEBrick::HTTPVersion.to_s()\n\n
new WEBrick::HTTPResponse.new(config)\nCreates a new HTTP response object\n
chunked= WEBrick::HTTPResponse.chunked=(val)\nEnables chunked transfer encoding.\n
chunked? WEBrick::HTTPResponse.chunked?()\nWill this response body be returned using chunked transfer-encoding?\n
content_length WEBrick::HTTPResponse.content_length()\nThe content-length header\n
content_length= WEBrick::HTTPResponse.content_length=(len)\nSets the content-length header to +len+\n
content_type WEBrick::HTTPResponse.content_type()\nThe content-type header\n
content_type= WEBrick::HTTPResponse.content_type=(type)\nSets the content-type header to +type+\n
each WEBrick::HTTPResponse.each()\nIterates over each header in the resopnse\n
keep_alive? WEBrick::HTTPResponse.keep_alive?()\nWill this response's connection be kept alive?\n
send_body WEBrick::HTTPResponse.send_body(socket)\nSends the body on +socket+\n
send_header WEBrick::HTTPResponse.send_header(socket)\nSends the headers on +socket+\n
send_response WEBrick::HTTPResponse.send_response(socket)\nSends the response on +socket+\n
set_error WEBrick::HTTPResponse.set_error(ex, backtrace=false)\nCreates an error page for exception +ex+ with an optional +backtrace+\n
set_redirect WEBrick::HTTPResponse.set_redirect(status, url)\nRedirects to +url+ with a WEBrick::HTTPStatus::Redirect +status+.\n\nExample:\n\n  res.set_redirect WEBrick::HTTPStatus::TemporaryRedirect\n
setup_header WEBrick::HTTPResponse.setup_header()\nSets up the headers for sending\n
status= WEBrick::HTTPResponse.status=(status)\nSets the response's status to the +status+ code\n
status_line WEBrick::HTTPResponse.status_line()\nThe response's HTTP status line\n
code WEBrick::HTTPStatus::Status.code()\nReturns the HTTP status code\n
reason_phrase WEBrick::HTTPStatus::Status.reason_phrase()\nReturns the HTTP status description\n
to_i WEBrick::HTTPStatus::Status.to_i()\n\n
new WEBrick::GenericServer.new(config={}, default=Config::General)\n\n
listen WEBrick::GenericServer.listen(address, port)\n\n
run WEBrick::GenericServer.run(sock)\n\n
setup_ssl_context WEBrick::GenericServer.setup_ssl_context(config)\n\n
shutdown WEBrick::GenericServer.shutdown()\n\n
ssl_context WEBrick::GenericServer.ssl_context()\n\n
start WEBrick::GenericServer.start(&block)\n\n
stop WEBrick::GenericServer.stop()\n\n
new WEBrick::HTTPUtils::FormData.new(*args)\n\n
append_data WEBrick::HTTPUtils::FormData.append_data(data)\n\n
each_data WEBrick::HTTPUtils::FormData.each_data()\n\n
list WEBrick::HTTPUtils::FormData.list()\n\n
to_ary WEBrick::HTTPUtils::FormData.to_ary()\n\n
to_s WEBrick::HTTPUtils::FormData.to_s()\n\n
new WEBrick::BasicLog.new(log_file=nil, level=nil)\nInitializes a new logger for +log_file+ that outputs messages at +level+\nor higher.  +log_file+ can be a filename, an IO-like object that\nresponds to #<< or nil which outputs to $stderr.\n\nIf no level is given INFO is chosen by default\n
close WEBrick::BasicLog.close()\nCloses the logger (also closes the log device associated to the logger)\n
debug WEBrick::BasicLog.debug(msg)\nShortcut for logging a DEBUG message\n
debug? WEBrick::BasicLog.debug?()\nWill the logger output DEBUG messages?\n
error WEBrick::BasicLog.error(msg)\nShortcut for logging an ERROR message\n
error? WEBrick::BasicLog.error?()\nWill the logger output ERROR messages?\n
fatal WEBrick::BasicLog.fatal(msg)\nShortcut for logging a FATAL message\n
fatal? WEBrick::BasicLog.fatal?()\nWill the logger output FATAL messages?\n
info WEBrick::BasicLog.info(msg)\nShortcut for logging an INFO message\n
info? WEBrick::BasicLog.info?()\nWill the logger output INFO messages?\n
log WEBrick::BasicLog.log(level, data)\nLogs +data+ at +level+ if the given level is above the current log\nlevel.\n
warn WEBrick::BasicLog.warn(msg)\nShortcut for logging a WARN message\n
warn? WEBrick::BasicLog.warn?()\nWill the logger output WARN messages?\n
new WEBrick::Log.new(log_file=nil, level=nil)\nSame as BasicLog#initialize\n\nYou can set the timestamp format through #time_format\n
log WEBrick::Log.log(level, data)\nSame as BasicLog#log\n
new WEBrick::Cookie.new(name, value)\nattr_accessor :comment_url, :discard, :port\n
parse WEBrick::Cookie.parse(str)\nCookie::parse()\n  It parses Cookie field sent from the user agent.\n
parse_set_cookie WEBrick::Cookie.parse_set_cookie(str)\n\n
parse_set_cookies WEBrick::Cookie.parse_set_cookies(str)\n\n
expires WEBrick::Cookie.expires()\n\n
expires= WEBrick::Cookie.expires=(t)\n\n
to_s WEBrick::Cookie.to_s()\n\n
new WEBrick::HTTPAuth::Htdigest.new(path)\nOpen a digest password database at +path+\n
delete_passwd WEBrick::HTTPAuth::Htdigest.delete_passwd(realm, user)\nRemoves a password from the database for +user+ in +realm+.\n
each WEBrick::HTTPAuth::Htdigest.each()\nIterate passwords in the database.\n
flush WEBrick::HTTPAuth::Htdigest.flush(output=nil)\nFlush the password database.  If +output+ is given the database will\nbe written there instead of to the original path.\n
get_passwd WEBrick::HTTPAuth::Htdigest.get_passwd(realm, user, reload_db)\nRetrieves a password from the database for +user+ in +realm+.  If\n+reload_db+ is true the database will be reloaded first.\n
reload WEBrick::HTTPAuth::Htdigest.reload()\nReloads passwords from the database\n
set_passwd WEBrick::HTTPAuth::Htdigest.set_passwd(realm, user, pass)\nSets a password in the database for +user+ in +realm+ to +pass+.\n
new WEBrick::HTTPAuth::Htpasswd.new(path)\nOpen a password database at +path+\n
delete_passwd WEBrick::HTTPAuth::Htpasswd.delete_passwd(realm, user)\nRemoves a password from the database for +user+ in +realm+.\n
each WEBrick::HTTPAuth::Htpasswd.each()\nIterate passwords in the database.\n
flush WEBrick::HTTPAuth::Htpasswd.flush(output=nil)\nFlush the password database.  If +output+ is given the database will\nbe written there instead of to the original path.\n
get_passwd WEBrick::HTTPAuth::Htpasswd.get_passwd(realm, user, reload_db)\nRetrieves a password from the database for +user+ in +realm+.  If\n+reload_db+ is true the database will be reloaded first.\n
reload WEBrick::HTTPAuth::Htpasswd.reload()\nReload passwords from the database\n
set_passwd WEBrick::HTTPAuth::Htpasswd.set_passwd(realm, user, pass)\nSets a password in the database for +user+ in +realm+ to +pass+.\n
new WEBrick::HTTPAuth::Htgroup.new(path)\nOpen a group database at +path+\n
add WEBrick::HTTPAuth::Htgroup.add(group, members)\nAdd an Array of +members+ to +group+\n
flush WEBrick::HTTPAuth::Htgroup.flush(output=nil)\nFlush the group database.  If +output+ is given the database will be\nwritten there instead of to the original path.\n
members WEBrick::HTTPAuth::Htgroup.members(group)\nRetrieve the list of members from +group+\n
reload WEBrick::HTTPAuth::Htgroup.reload()\nReload groups from the database\n
make_passwd WEBrick::HTTPAuth::DigestAuth.make_passwd(realm, user, pass)\nUsed by UserDB to create a digest password entry\n
new WEBrick::HTTPAuth::DigestAuth.new(config, default=Config::DigestAuth)\nCreates a new DigestAuth instance.  Be sure to use the same DigestAuth\ninstance for multiple requests as it saves state between requests in\norder to perform authentication.\n\nSee WEBrick::Config::DigestAuth for default configuration entries\n\nYou must supply the following configuration entries:\n\n:Realm:: The name of the realm being protected.\n:UserDB:: A database of usernames and passwords.\n          A WEBrick::HTTPAuth::Htdigest instance should be used.\n
authenticate WEBrick::HTTPAuth::DigestAuth.authenticate(req, res)\nAuthenticates a +req+ and returns a 401 Unauthorized using +res+ if\nthe authentication was not correct.\n
challenge WEBrick::HTTPAuth::DigestAuth.challenge(req, res, stale=false)\nReturns a challenge response which asks for for authentication\ninformation\n
make_passwd WEBrick::HTTPAuth::BasicAuth.make_passwd(realm, user, pass)\nUsed by UserDB to create a basic password entry\n
new WEBrick::HTTPAuth::BasicAuth.new(config, default=Config::BasicAuth)\nCreates a new BasicAuth instance.\n\nSee WEBrick::Config::BasicAuth for default configuration entries\n\nYou must supply the following configuration entries:\n\n:Realm:: The name of the realm being protected.\n:UserDB:: A database of usernames and passwords.\n          A WEBrick::HTTPAuth::Htpasswd instance should be used.\n
authenticate WEBrick::HTTPAuth::BasicAuth.authenticate(req, res)\nAuthenticates a +req+ and returns a 401 Unauthorized using +res+ if\nthe authentication was not correct.\n
challenge WEBrick::HTTPAuth::BasicAuth.challenge(req, res)\nReturns a challenge response which asks for for authentication\ninformation\n
new WEBrick::CGI.new(*args)\n\n
service WEBrick::CGI.service(req, res)\n\n
start WEBrick::CGI.start(env=ENV, stdin=$stdin, stdout=$stdout)\n\n
new WEBrick::CGI::Socket.new(config, env, stdin, stdout)\n\n
addr WEBrick::CGI::Socket.addr()\n\n
cert WEBrick::CGI::Socket.cert()\n\n
cipher WEBrick::CGI::Socket.cipher()\n\n
each WEBrick::CGI::Socket.each()\n\n
eof? WEBrick::CGI::Socket.eof?()\n\n
gets WEBrick::CGI::Socket.gets(eol=LF, size=nil)\n\n
peer_cert WEBrick::CGI::Socket.peer_cert()\n\n
peer_cert_chain WEBrick::CGI::Socket.peer_cert_chain()\n\n
peeraddr WEBrick::CGI::Socket.peeraddr()\n\n
read WEBrick::CGI::Socket.read(size=nil)\n\n
new WEBrick::HTTPProxyServer.new(config={}, default=Config::HTTP)\nProxy server configurations.  The proxy server handles the following\nconfiguration items in addition to those supported by HTTPServer:\n\n:ProxyAuthProc:: Called with a request and response to authorize a\n                 request\n:ProxyVia:: Appended to the via header\n:ProxyURI:: The proxy server's URI\n:ProxyContentHandler:: Called with a request and resopnse and allows\n                       modification of the response\n:ProxyTimeout:: Sets the proxy timeouts to 30 seconds for open and 60\n                seconds for read operations\n
do_CONNECT WEBrick::HTTPProxyServer.do_CONNECT(req, res)\n\n
do_GET WEBrick::HTTPProxyServer.do_GET(req, res)\n\n
do_HEAD WEBrick::HTTPProxyServer.do_HEAD(req, res)\n\n
do_OPTIONS WEBrick::HTTPProxyServer.do_OPTIONS(req, res)\n\n
do_POST WEBrick::HTTPProxyServer.do_POST(req, res)\n\n
proxy_auth WEBrick::HTTPProxyServer.proxy_auth(req, res)\n\n
proxy_service WEBrick::HTTPProxyServer.proxy_service(req, res)\n\n
proxy_uri WEBrick::HTTPProxyServer.proxy_uri(req, res)\n\n
service WEBrick::HTTPProxyServer.service(req, res)\n\n
new WEBrick::HTTPServer.new(config={}, default=Config::HTTP)\nCreates a new HTTP server according to +config+\n\nAn HTTP server uses the following attributes:\n\n:AccessLog:: An array of access logs.  See WEBrick::AccessLog\n:BindAddress:: Local address for the server to bind to\n:DocumentRoot:: Root path to serve files from\n:DocumentRootOptions:: Options for the default HTTPServlet::FileHandler\n:HTTPVersion:: The HTTP version of this server\n:Port:: Port to listen on\n:RequestCallback:: Called with a request and response before each\n                   request is serviced.\n:RequestTimeout:: Maximum time to wait between requests\n:ServerAlias:: Array of alternate names for this server for virtual\n               hosting\n:ServerName:: Name for this server for virtual hosting\n
access_log WEBrick::HTTPServer.access_log(config, req, res)\n\n
do_OPTIONS WEBrick::HTTPServer.do_OPTIONS(req, res)\n\n
lookup_server WEBrick::HTTPServer.lookup_server(req)\nFinds the appropriate virtual host to handle +req+\n
mount WEBrick::HTTPServer.mount(dir, servlet, *options)\nMounts +servlet+ on +dir+ passing +options+ to the servlet at creation\ntime\n
mount_proc WEBrick::HTTPServer.mount_proc(dir, proc=nil, &block)\nMounts +proc+ or +block+ on +dir+ and calls it with a\nWEBrick::HTTPRequest and WEBrick::HTTPResponse\n
run WEBrick::HTTPServer.run(sock)\nProcesses requests on +sock+\n
search_servlet WEBrick::HTTPServer.search_servlet(path)\nFinds a servlet for +path+\n
service WEBrick::HTTPServer.service(req, res)\nServices +req+ and fills in +res+\n
umount WEBrick::HTTPServer.umount(dir)\n\n
unmount WEBrick::HTTPServer.unmount(dir)\nUnmounts +dir+\n
virtual_host WEBrick::HTTPServer.virtual_host(server)\nAdds +server+ as a virtual host.\n
new WEBrick::HTTPServer::MountTable.new()\n\n
delete WEBrick::HTTPServer::MountTable.delete(dir)\n\n
scan WEBrick::HTTPServer::MountTable.scan(path)\n\n
start WEBrick::SimpleServer.start()\n\n
start WEBrick::Daemon.start()\nPerforms the standard operations for daemonizing a process.  Runs a\nblock, if given.\n
new ERB.new(str, safe_level=nil, trim_mode=nil, eoutvar='_erbout')\nConstructs a new ERB object with the template specified in _str_.\n\nAn ERB object works by building a chunk of Ruby code that will output\nthe completed template when run. If _safe_level_ is set to a non-nil value,\nERB code will be run in a separate thread with <b>$SAFE</b> set to the\nprovided level.\n\nIf _trim_mode_ is passed a String containing one or more of the following\nmodifiers, ERB will adjust its code generation as listed:\n\n    %  enables Ruby code processing for lines beginning with %\n    <> omit newline for lines starting with <% and ending in %>\n    >  omit newline for lines ending in %>\n\n_eoutvar_ can be used to set the name of the variable ERB will build up\nits output in.  This is useful when you need to run multiple ERB\ntemplates through the same binding and/or when you want to control where\noutput ends up.  Pass the name of the variable to be used inside a String.\n\n=== Example\n\n require "erb"\n build data class\n class Listings\n   PRODUCT = { :name => "Chicken Fried Steak",\n               :desc => "A well messages pattie, breaded and fried.",\n               :cost => 9.95 }\n\n   attr_reader :product, :price\n\n   def initialize( product = "", price = "" )\n     @product = product\n     @price = price\n   end\n\n   def build\n     b = binding\n create and run templates, filling member data variables\n     ERB.new(<<-'END_PRODUCT'.gsub(/^\s+/, ""), 0, "", "@product").result b\n       <%= PRODUCT[:name] %>\n       <%= PRODUCT[:desc] %>\n     END_PRODUCT\n     ERB.new(<<-'END_PRICE'.gsub(/^\s+/, ""), 0, "", "@price").result b\n       <%= PRODUCT[:name] %> -- <%= PRODUCT[:cost] %>\n       <%= PRODUCT[:desc] %>\n     END_PRICE\n   end\n end\n setup template data\n listings = Listings.new\n listings.build\n\n puts listings.product + "\\n" + listings.price\n\n_Generates_\n\n Chicken Fried Steak\n A well messages pattie, breaded and fried.\n\n Chicken Fried Steak -- 9.95\n A well messages pattie, breaded and fried.\n
version ERB.version()\nReturns revision information for the erb.rb module.\n
def_class ERB.def_class(superklass=Object, methodname='result')\nDefine unnamed class which has _methodname_ as instance method, and return it.\n\nexample:\n  class MyClass_\n    def initialize(arg1, arg2)\n      @arg1 = arg1;  @arg2 = arg2\n    end\n  end\n  filename = 'example.rhtml'  # @arg1 and @arg2 are used in example.rhtml\n  erb = ERB.new(File.read(filename))\n  erb.filename = filename\n  MyClass = erb.def_class(MyClass_, 'render()')\n  print MyClass.new('foo', 123).render()\n
def_method ERB.def_method(mod, methodname, fname='(ERB)')\nDefine _methodname_ as instance method of _mod_ from compiled ruby source.\n\nexample:\n  filename = 'example.rhtml'   # 'arg1' and 'arg2' are used in example.rhtml\n  erb = ERB.new(File.read(filename))\n  erb.def_method(MyClass, 'render(arg1, arg2)', filename)\n  print MyClass.new.render('foo', 123)\n
def_module ERB.def_module(methodname='erb')\nCreate unnamed module, define _methodname_ as instance method of it, and\nreturn it.\n\nexample:\n  filename = 'example.rhtml'   # 'arg1' and 'arg2' are used in example.rhtml\n  erb = ERB.new(File.read(filename))\n  erb.filename = filename\n  MyModule = erb.def_module('render(arg1, arg2)')\n  class MyClass\n    include MyModule\n  end\n
result ERB.result(b=TOPLEVEL_BINDING)\nExecutes the generated ERB code to produce a completed template, returning\nthe results of that code.  (See ERB#new for details on how this process can\nbe affected by _safe_level_.)\n\n_b_ accepts a Binding or Proc object which is used to set the context of\ncode evaluation.\n
run ERB.run(b=TOPLEVEL_BINDING)\nGenerate results and print them. (see ERB#result)\n
set_eoutvar ERB.set_eoutvar(compiler, eoutvar = '_erbout')\nCan be used to set _eoutvar_ as described in ERB#new.  It's probably easier\nto just use the constructor though, since calling this method requires the\nsetup of an ERB _compiler_ object.\n
new Benchmark::Tms.new(utime = 0.0, stime = 0.0, cutime = 0.0, cstime = 0.0,\nreal = 0.0, label = nil)\nReturns an initialized Tms object which has\n_utime_ as the user CPU time, _stime_ as the system CPU time,\n_cutime_ as the children's user CPU time, _cstime_ as the children's\nsystem CPU time, _real_ as the elapsed real time and _label_ as the label.\n
add Benchmark::Tms.add()\nReturns a new Tms object whose times are the sum of the times for this\nTms object, plus the time required to execute the code block (_blk_).\n
add! Benchmark::Tms.add!(&blk)\nAn in-place version of #add.\n
format Benchmark::Tms.format(format = nil, *args)\nReturns the contents of this Tms object as\na formatted string, according to a format string\nlike that passed to Kernel.format. In addition, #format\naccepts the following extensions:\n\n<tt>%u</tt>::     Replaced by the user CPU time, as reported by Tms#utime.\n<tt>%y</tt>::     Replaced by the system CPU time, as reported by #stime\n(Mnemonic: y of "s*y*stem")\n<tt>%U</tt>::     Replaced by the children's user CPU time, as reported\nby Tms#cutime\n<tt>%Y</tt>::     Replaced by the children's system CPU time, as reported\nby Tms#cstime\n<tt>%t</tt>::     Replaced by the total CPU time, as reported by Tms#total\n<tt>%r</tt>::     Replaced by the elapsed real time, as reported by Tms#real\n<tt>%n</tt>::     Replaced by the label string, as reported by Tms#label\n(Mnemonic: n of "*n*ame")\n\nIf _format_ is not given, FORMAT is used as default value, detailing the\nuser, system and real elapsed time.\n
memberwise Benchmark::Tms.memberwise(op, x)\nReturns a new Tms object obtained by memberwise operation +op+\nof the individual times for this Tms object with those of the other\nTms object.\n\n+op+ can be a mathematical operation such as <tt>+</tt>, <tt>-</tt>,\n<tt>*</tt>, <tt>/</tt>\n
to_a Benchmark::Tms.to_a()\nReturns a new 6-element array, consisting of the\nlabel, user CPU time, system CPU time, children's\nuser CPU time, children's system CPU time and elapsed\nreal time.\n
to_s Benchmark::Tms.to_s()\nSame as #format.\n
new REXML::Instruction.new(target, content=nil)\nConstructs a new Instruction\n@param target can be one of a number of things.  If String, then\nthe target of this instruction is set to this.  If an Instruction,\nthen the Instruction is shallowly cloned (target and content are\ncopied).  If a Source, then the source is scanned and parsed for\nan Instruction declaration.\n@param content Must be either a String, or a Parent.  Can only\nbe a Parent if the target argument is a Source.  Otherwise, this\nString is set as the content of this instruction.\n
clone REXML::Instruction.clone()\n\n
inspect REXML::Instruction.inspect()\n\n
node_type REXML::Instruction.node_type()\n\n
write REXML::Instruction.write(writer, indent=-1, transitive=false, ie_hack=false)\n== DEPRECATED\nSee the rexml/formatters package\n
default REXML::XMLDecl.default()\nOnly use this if you do not want the XML declaration to be written;\nthis object is ignored by the XML writer.  Otherwise, instantiate your\nown XMLDecl and add it to the document.\n\nNote that XML 1.1 documents *must* include an XML declaration\n
new REXML::XMLDecl.new(version=DEFAULT_VERSION, encoding=nil, standalone=nil)\n\n
clone REXML::XMLDecl.clone()\n\n
dowrite REXML::XMLDecl.dowrite()\n\n
encoding= REXML::XMLDecl.encoding=( enc )\n\n
inspect REXML::XMLDecl.inspect()\n\n
node_type REXML::XMLDecl.node_type()\n\n
nowrite REXML::XMLDecl.nowrite()\n\n
old_enc= REXML::XMLDecl.old_enc=( enc )\n\n
write REXML::XMLDecl.write(writer, indent=-1, transitive=false, ie_hack=false)\nindent::\n  Ignored.  There must be no whitespace before an XML declaration\ntransitive::\n  Ignored\nie_hack::\n  Ignored\n
xmldecl REXML::XMLDecl.xmldecl(version, encoding, standalone)\n\n
new REXML::Parsers::LightParser.new(stream)\n\n
add_listener REXML::Parsers::LightParser.add_listener( listener )\n\n
parse REXML::Parsers::LightParser.parse()\n\n
rewind REXML::Parsers::LightParser.rewind()\n\n
new REXML::Parsers::UltraLightParser.new(stream)\n\n
add_listener REXML::Parsers::UltraLightParser.add_listener( listener )\n\n
parse REXML::Parsers::UltraLightParser.parse()\n\n
rewind REXML::Parsers::UltraLightParser.rewind()\n\n
new REXML::Parsers::TreeParser.new( source, build_context = Document.new )\n\n
add_listener REXML::Parsers::TreeParser.add_listener( listener )\n\n
parse REXML::Parsers::TreeParser.parse()\n\n
abbreviate REXML::Parsers::XPathParser.abbreviate( path )\n\n
expand REXML::Parsers::XPathParser.expand( path )\n\n
namespaces= REXML::Parsers::XPathParser.namespaces=( namespaces )\n\n
parse REXML::Parsers::XPathParser.parse(path)\n\n
predicate REXML::Parsers::XPathParser.predicate(path)\n\n
predicate_to_string REXML::Parsers::XPathParser.predicate_to_string( path, &block )\n\n
new REXML::Parsers::StreamParser.new(source, listener)\n\n
add_listener REXML::Parsers::StreamParser.add_listener( listener )\n\n
parse REXML::Parsers::StreamParser.parse()\n\n
new REXML::Parsers::BaseParser.new( source )\n\n
add_listener REXML::Parsers::BaseParser.add_listener( listener )\n\n
empty? REXML::Parsers::BaseParser.empty?()\nReturns true if there are no more events\n
entity REXML::Parsers::BaseParser.entity( reference, entities )\n\n
has_next? REXML::Parsers::BaseParser.has_next?()\nReturns true if there are more events.  Synonymous with !empty?\n
normalize REXML::Parsers::BaseParser.normalize( input, entities=nil, entity_filter=nil )\nEscapes all possible entities\n
peek REXML::Parsers::BaseParser.peek(depth=0)\nPeek at the +depth+ event in the stack.  The first element on the stack\nis at depth 0.  If +depth+ is -1, will parse to the end of the input\nstream and return the last event, which is always :end_document.\nBe aware that this causes the stream to be parsed up to the +depth+\nevent, so you can effectively pre-parse the entire document (pull the\nentire thing into memory) using this method.\n
position REXML::Parsers::BaseParser.position()\n\n
pull REXML::Parsers::BaseParser.pull()\nReturns the next event.  This is a +PullEvent+ object.\n
stream= REXML::Parsers::BaseParser.stream=( source )\n\n
unnormalize REXML::Parsers::BaseParser.unnormalize( string, entities=nil, filter=nil )\nUnescapes all possible entities\n
unshift REXML::Parsers::BaseParser.unshift(token)\nPush an event back on the head of the stream.  This method\nhas (theoretically) infinite depth.\n
new REXML::Parsers::PullParser.new(stream)\n\n
add_listener REXML::Parsers::PullParser.add_listener( listener )\n\n
each REXML::Parsers::PullParser.each()\n\n
peek REXML::Parsers::PullParser.peek(depth=0)\n\n
pull REXML::Parsers::PullParser.pull()\n\n
unshift REXML::Parsers::PullParser.unshift(token)\n\n
new REXML::Parsers::PullEvent.new(arg)\nThe type of this event.  Will be one of :tag_start, :tag_end, :text,\n:processing_instruction, :comment, :doctype, :attlistdecl, :entitydecl,\n:notationdecl, :entity, :cdata, :xmldecl, or :error.\n
attlistdecl? REXML::Parsers::PullEvent.attlistdecl?()\nContent: [ String text ]\n
cdata? REXML::Parsers::PullEvent.cdata?()\nContent: [ String text ]\n
comment? REXML::Parsers::PullEvent.comment?()\nContent: [ String text ]\n
doctype? REXML::Parsers::PullEvent.doctype?()\nContent: [ String name, String pub_sys, String long_name, String uri ]\n
elementdecl? REXML::Parsers::PullEvent.elementdecl?()\nContent: [ String text ]\n
end_element? REXML::Parsers::PullEvent.end_element?()\nContent: [ String tag_name ]\n
entity? REXML::Parsers::PullEvent.entity?()\nContent: [ String text ]\n
entitydecl? REXML::Parsers::PullEvent.entitydecl?()\nDue to the wonders of DTDs, an entity declaration can be just about\nanything.  There's no way to normalize it; you'll have to interpret the\ncontent yourself.  However, the following is true:\n\n* If the entity declaration is an internal entity:\n  [ String name, String value ]\nContent: [ String text ]\n
error? REXML::Parsers::PullEvent.error?()\n\n
event_type REXML::Parsers::PullEvent.event_type()\n\n
inspect REXML::Parsers::PullEvent.inspect()\n\n
instruction? REXML::Parsers::PullEvent.instruction?()\nContent: [ String text ]\n
notationdecl? REXML::Parsers::PullEvent.notationdecl?()\nContent: [ String text ]\n
start_element? REXML::Parsers::PullEvent.start_element?()\nContent: [ String tag_name, Hash attributes ]\n
text? REXML::Parsers::PullEvent.text?()\nContent: [ String raw_text, String unnormalized_text ]\n
xmldecl? REXML::Parsers::PullEvent.xmldecl?()\nContent: [ String version, String encoding, String standalone ]\n
new REXML::Parsers::SAX2Parser.new(source)\n\n
add_listener REXML::Parsers::SAX2Parser.add_listener( listener )\n\n
deafen REXML::Parsers::SAX2Parser.deafen( listener=nil, &blok )\n\n
listen REXML::Parsers::SAX2Parser.listen( *args, &blok )\nListen arguments:\n\nSymbol, Array, Block\n        Listen to Symbol events on Array elements\nSymbol, Block\n  Listen to Symbol events\nArray, Listener\n        Listen to all events on Array elements\nArray, Block\n        Listen to :start_element events on Array elements\nListener\n        Listen to All events\n\nSymbol can be one of: :start_element, :end_element,\n:start_prefix_mapping, :end_prefix_mapping, :characters,\n:processing_instruction, :doctype, :attlistdecl, :elementdecl,\n:entitydecl, :notationdecl, :cdata, :xmldecl, :comment\n\nThere is an additional symbol that can be listened for: :progress.\nThis will be called for every event generated, passing in the current\nstream position.\n\nArray contains regular expressions or strings which will be matched\nagainst fully qualified element names.\n\nListener must implement the methods in SAX2Listener\n\nBlock will be passed the same arguments as a SAX2Listener method would\nbe, where the method name is the same as the matched Symbol.\nSee the SAX2Listener for more information.\n
parse REXML::Parsers::SAX2Parser.parse()\n\n
source REXML::Parsers::SAX2Parser.source()\n\n
new REXML::Element.new( arg = UNDEFINED, parent=nil, context=nil )\nConstructor\narg::\n  if not supplied, will be set to the default value.\n  If a String, the name of this object will be set to the argument.\n  If an Element, the object will be shallowly cloned; name,\n  attributes, and namespaces will be copied.  Children will +not+ be\n  copied.\nparent::\n  if supplied, must be a Parent, and will be used as\n  the parent of this object.\ncontext::\n  If supplied, must be a hash containing context items.  Context items\n  include:\n* <tt>:respect_whitespace</tt> the value of this is :+all+ or an array of\n  strings being the names of the elements to respect\n  whitespace for.  Defaults to :+all+.\n* <tt>:compress_whitespace</tt> the value can be :+all+ or an array of\n  strings being the names of the elements to ignore whitespace on.\n  Overrides :+respect_whitespace+.\n* <tt>:ignore_whitespace_nodes</tt> the value can be :+all+ or an array\n  of strings being the names of the elements in which to ignore\n  whitespace-only nodes.  If this is set, Text nodes which contain only\n  whitespace will not be added to the document tree.\n* <tt>:raw</tt> can be :+all+, or an array of strings being the names of\n  the elements to process in raw mode.  In raw mode, special\n  characters in text is not converted to or from entities.\n
add_attribute REXML::Element.add_attribute( key, value=nil )\nAdds an attribute to this element, overwriting any existing attribute\nby the same name.\nkey::\n  can be either an Attribute or a String.  If an Attribute,\n  the attribute is added to the list of Element attributes.  If String,\n  the argument is used as the name of the new attribute, and the value\n  parameter must be supplied.\nvalue::\n  Required if +key+ is a String, and ignored if the first argument is\n  an Attribute.  This is a String, and is used as the value\n  of the new Attribute.  This should be the unnormalized value of the\n  attribute (without entities).\nReturns:: the Attribute added\n e = Element.new 'e'\n e.add_attribute( 'a', 'b' )               #-> <e a='b'/>\n e.add_attribute( 'x:a', 'c' )             #-> <e a='b' x:a='c'/>\n e.add_attribute Attribute.new('b', 'd')   #-> <e a='b' x:a='c' b='d'/>\n
add_attributes REXML::Element.add_attributes(hash)\nAdd multiple attributes to this element.\nhash:: is either a hash, or array of arrays\n el.add_attributes( {"name1"=>"value1", "name2"=>"value2"} )\n el.add_attributes( [ ["name1","value1"], ["name2"=>"value2"] ] )\n
add_element REXML::Element.add_element(element, attrs=nil)\nAdds a child to this element, optionally setting attributes in\nthe element.\nelement::\n  optional.  If Element, the element is added.\n  Otherwise, a new Element is constructed with the argument (see\n  Element.initialize).\nattrs::\n  If supplied, must be a Hash containing String name,value\n  pairs, which will be used to set the attributes of the new Element.\nReturns:: the Element that was added\n el = doc.add_element 'my-tag'\n el = doc.add_element 'my-tag', {'attr1'=>'val1', 'attr2'=>'val2'}\n el = Element.new 'my-tag'\n doc.add_element el\n
add_namespace REXML::Element.add_namespace( prefix, uri=nil )\nAdds a namespace to this element.\nprefix::\n  the prefix string, or the namespace URI if +uri+ is not\n  supplied\nuri::\n  the namespace URI.  May be nil, in which +prefix+ is used as\n  the URI\nEvaluates to: this Element\n a = Element.new("a")\n a.add_namespace("xmlns:foo", "bar" )\n a.add_namespace("foo", "bar")  # shorthand for previous line\n a.add_namespace("twiddle")\n puts a   #-> <a xmlns:foo='bar' xmlns='twiddle'/>\n
add_text REXML::Element.add_text( text )\nA helper method to add a Text child.  Actual Text instances can\nbe added with regular Parent methods, such as add() and <<()\ntext::\n  if a String, a new Text instance is created and added\n  to the parent.  If Text, the object is added directly.\nReturns:: this Element\n e = Element.new('a')          #-> <e/>\n e.add_text 'foo'              #-> <e>foo</e>\n e.add_text Text.new(' bar')    #-> <e>foo bar</e>\nNote that at the end of this example, the branch has <b>3</b> nodes; the 'e'\nelement and <b>2</b> Text node children.\n
attribute REXML::Element.attribute( name, namespace=nil )\nAttributes                                    #\n
cdatas REXML::Element.cdatas()\nGet an array of all CData children.\nIMMUTABLE\n
clone REXML::Element.clone()\nCreates a shallow copy of self.\n  d = Document.new "<a><b/><b/><c><d/></c></a>"\n  new_a = d.root.clone\n  puts new_a  # => "<a/>"\n
comments REXML::Element.comments()\nGet an array of all Comment children.\nIMMUTABLE\n
delete_attribute REXML::Element.delete_attribute(key)\nRemoves an attribute\nkey::\n  either an Attribute or a String.  In either case, the\n  attribute is found by matching the attribute name to the argument,\n  and then removed.  If no attribute is found, no action is taken.\nReturns::\n  the attribute removed, or nil if this Element did not contain\n  a matching attribute\n e = Element.new('E')\n e.add_attribute( 'name', 'Sean' )             #-> <E name='Sean'/>\n r = e.add_attribute( 'sur:name', 'Russell' )  #-> <E name='Sean'\n sur:name='Russell'/>\n e.delete_attribute( 'name' )                  #-> <E sur:name='Russell'/>\n e.delete_attribute( r )                       #-> <E/>\n
delete_element REXML::Element.delete_element(element)\nDeletes a child element.\nelement::\n  Must be an +Element+, +String+, or +Integer+.  If Element,\n  the element is removed.  If String, the element is found (via XPath)\n  and removed.  <em>This means that any parent can remove any\n  descendant.<em>  If Integer, the Element indexed by that number will be\n  removed.\nReturns:: the element that was removed.\n doc.delete_element "/a/b/c[@id='4']"\n doc.delete_element doc.elements["//k"]\n doc.delete_element 1\n
delete_namespace REXML::Element.delete_namespace(namespace="xmlns")\nRemoves a namespace from this node.  This only works if the namespace is\nactually declared in this node.  If no argument is passed, deletes the\ndefault namespace.\n\nEvaluates to: this element\n doc = Document.new "<a xmlns:foo='bar' xmlns='twiddle'/>"\n doc.root.delete_namespace\n puts doc     # -> <a xmlns:foo='bar'/>\n doc.root.delete_namespace 'foo'\n puts doc     # -> <a/>\n
document REXML::Element.document()\nEvaluates to the document to which this element belongs, or nil if this\nelement doesn't belong to a document.\n
each_element REXML::Element.each_element( xpath=nil )\nSynonym for Element.elements.each\n
each_element_with_attribute REXML::Element.each_element_with_attribute( key, value=nil, max=0, name=nil )\nIterates through the child elements, yielding for each Element that\nhas a particular attribute set.\nkey::\n  the name of the attribute to search for\nvalue::\n  the value of the attribute\nmax::\n  (optional) causes this method to return after yielding\n  for this number of matching children\nname::\n  (optional) if supplied, this is an XPath that filters\n  the children to check.\n\n doc = Document.new "<a><b @id='1'/><c @id='2'/><d @id='1'/><e/></a>"\n Yields b, c, d\n doc.root.each_element_with_attribute( 'id' ) {|e| p e}\n Yields b, d\n doc.root.each_element_with_attribute( 'id', '1' ) {|e| p e}\n Yields b\n doc.root.each_element_with_attribute( 'id', '1', 1 ) {|e| p e}\n Yields d\n doc.root.each_element_with_attribute( 'id', '1', 0, 'd' ) {|e| p e}\n
each_element_with_text REXML::Element.each_element_with_text( text=nil, max=0, name=nil )\nIterates through the children, yielding for each Element that\nhas a particular text set.\ntext::\n  the text to search for.  If nil, or not supplied, will iterate\n  over all +Element+ children that contain at least one +Text+ node.\nmax::\n  (optional) causes this method to return after yielding\n  for this number of matching children\nname::\n  (optional) if supplied, this is an XPath that filters\n  the children to check.\n\n doc = Document.new '<a><b>b</b><c>b</c><d>d</d><e/></a>'\n Yields b, c, d\n doc.each_element_with_text {|e|p e}\n Yields b, c\n doc.each_element_with_text('b'){|e|p e}\n Yields b\n doc.each_element_with_text('b', 1){|e|p e}\n Yields d\n doc.each_element_with_text(nil, 0, 'd'){|e|p e}\n
get_elements REXML::Element.get_elements( xpath )\nSynonym for Element.to_a\nThis is a little slower than calling elements.each directly.\nxpath:: any XPath by which to search for elements in the tree\nReturns:: an array of Elements that match the supplied path\n
get_text REXML::Element.get_text(path = nil)\nReturns the first child Text node, if any, or +nil+ otherwise.\nThis method returns the actual +Text+ node, rather than the String content.\n doc = Document.new "<p>some text <b>this is bold!</b> more text</p>"\n The element 'p' has two text elements, "some text " and " more text".\n doc.root.get_text.value            #-> "some text "\n
has_attributes? REXML::Element.has_attributes?()\nEvaluates to +true+ if this element has any attributes set, false\notherwise.\n
has_elements? REXML::Element.has_elements?()\nEvaluates to +true+ if this element has at least one child Element\n doc = Document.new "<a><b/><c>Text</c></a>"\n doc.root.has_elements               # -> true\n doc.elements["/a/b"].has_elements   # -> false\n doc.elements["/a/c"].has_elements   # -> false\n
has_text? REXML::Element.has_text?()\nEvaluates to +true+ if this element has at least one Text child\n
ignore_whitespace_nodes REXML::Element.ignore_whitespace_nodes()\n\n
inspect REXML::Element.inspect()\n\n
instructions REXML::Element.instructions()\nGet an array of all Instruction children.\nIMMUTABLE\n
namespace REXML::Element.namespace(prefix=nil)\nEvalutas to the URI for a prefix, or the empty string if no such\nnamespace is declared for this element. Evaluates recursively for\nancestors.  Returns the default namespace, if there is one.\nprefix::\n  the prefix to search for.  If not supplied, returns the default\n  namespace if one exists\nReturns::\n  the namespace URI as a String, or nil if no such namespace\n  exists.  If the namespace is undefined, returns an empty string\n doc = Document.new("<a xmlns='1' xmlns:y='2'><b/><c xmlns:z='3'/></a>")\n b = doc.elements['//b']\n b.namespace           # -> '1'\n b.namespace("y")      # -> '2'\n
namespaces REXML::Element.namespaces()\n\n
next_element REXML::Element.next_element()\nReturns the next sibling that is an element, or nil if there is\nno Element sibling after this one\n doc = Document.new '<a><b/>text<c/></a>'\n doc.root.elements['b'].next_element          #-> <c/>\n doc.root.elements['c'].next_element          #-> nil\n
node_type REXML::Element.node_type()\n\n
prefixes REXML::Element.prefixes()\nEvaluates to an +Array+ containing the prefixes (names) of all defined\nnamespaces at this context node.\n doc = Document.new("<a xmlns:x='1' xmlns:y='2'><b/><c xmlns:z='3'/></a>")\n doc.elements['//b'].prefixes # -> ['x', 'y']\n
previous_element REXML::Element.previous_element()\nReturns the previous sibling that is an element, or nil if there is\nno Element sibling prior to this one\n doc = Document.new '<a><b/>text<c/></a>'\n doc.root.elements['c'].previous_element          #-> <b/>\n doc.root.elements['b'].previous_element          #-> nil\n
raw REXML::Element.raw()\nEvaluates to +true+ if raw mode is set for this element.  This\nis the case if the context has :+raw+ set to :+all+ or\nan array containing the name of this element.\n\nThe evaluation is tested against +expanded_name+, and so is namespace\nsensitive.\n
root REXML::Element.root()\n\n
root_node REXML::Element.root_node()\nEvaluates to the root node of the document that this element\nbelongs to. If this element doesn't belong to a document, but does\nbelong to another Element, the parent's root will be returned, until the\nearliest ancestor is found.\n\nNote that this is not the same as the document element.\nIn the following example, <a> is the document element, and the root\nnode is the parent node of the document element.  You may ask yourself\nwhy the root node is useful: consider the doctype and XML declaration,\nand any processing instructions before the document element... they\nare children of the root node, or siblings of the document element.\nThe only time this isn't true is when an Element is created that is\nnot part of any Document.  In this case, the ancestor that has no\nparent acts as the root node.\n d = Document.new '<a><b><c/></b></a>'\n a = d[1] ; c = a[1][1]\n d.root_node == d   # TRUE\n a.root_node        # namely, d\n c.root_node        # again, d\n
text REXML::Element.text( path = nil )\nA convenience method which returns the String value of the _first_\nchild text element, if one exists, and +nil+ otherwise.\n\n<em>Note that an element may have multiple Text elements, perhaps\nseparated by other children</em>.  Be aware that this method only returns\nthe first Text node.\n\nThis method returns the +value+ of the first text child node, which\nignores the +raw+ setting, so always returns normalized text. See\nthe Text::value documentation.\n\n doc = Document.new "<p>some text <b>this is bold!</b> more text</p>"\n The element 'p' has two text elements, "some text " and " more text".\n doc.root.text              #-> "some text "\n
text= REXML::Element.text=( text )\nSets the first Text child of this object.  See text() for a\ndiscussion about Text children.\n\nIf a Text child already exists, the child is replaced by this\ncontent.  This means that Text content can be deleted by calling\nthis method with a nil argument.  In this case, the next Text\nchild becomes the first Text child.  In no case is the order of\nany siblings disturbed.\ntext::\n  If a String, a new Text child is created and added to\n  this Element as the first Text child.  If Text, the text is set\n  as the first Child element.  If nil, then any existing first Text\n  child is removed.\nReturns:: this Element.\n doc = Document.new '<a><b/></a>'\n doc.root.text = 'Sean'      #-> '<a><b/>Sean</a>'\n doc.root.text = 'Elliott'   #-> '<a><b/>Elliott</a>'\n doc.root.add_element 'c'    #-> '<a><b/>Elliott<c/></a>'\n doc.root.text = 'Russell'   #-> '<a><b/>Russell<c/></a>'\n doc.root.text = nil         #-> '<a><b/><c/></a>'\n
texts REXML::Element.texts()\nGet an array of all Text children.\nIMMUTABLE\n
whitespace REXML::Element.whitespace()\nEvaluates to +true+ if whitespace is respected for this element.  This\nis the case if:\n1. Neither :+respect_whitespace+ nor :+compress_whitespace+ has any value\n2. The context has :+respect_whitespace+ set to :+all+ or\n   an array containing the name of this element, and\n   :+compress_whitespace+ isn't set to :+all+ or an array containing the\n   name of this element.\nThe evaluation is tested against +expanded_name+, and so is namespace\nsensitive.\n
write REXML::Element.write(output=$stdout, indent=-1, transitive=false,\nie_hack=false)\n== DEPRECATED\nSee REXML::Formatters\n\nWrites out this element, and recursively, all children.\noutput::\n    output an object which supports '<< string'; this is where the\n  document will be written.\nindent::\n  An integer.  If -1, no indenting will be used; otherwise, the\n  indentation will be this number of spaces, and children will be\n  indented an additional amount.  Defaults to -1\ntransitive::\n  If transitive is true and indent is >= 0, then the output will be\n  pretty-printed in such a way that the added whitespace does not affect\n  the parse tree of the document\nie_hack::\n  Internet Explorer is the worst piece of crap to have ever been\n  written, with the possible exception of Windows itself.  Since IE is\n  unable to parse proper XML, we have to provide a hack to generate XML\n  that IE's limited abilities can handle.  This hack inserts a space\n  before the /> on empty tags.  Defaults to false\n\n out = ''\n doc.write( out )     #-> doc is written to the string 'out'\n doc.write( $stdout ) #-> doc written to the console\n
xpath REXML::Element.xpath()\n\n
new REXML::Elements.new(parent)\nConstructor\nparent:: the parent Element\n
add REXML::Elements.add(element=nil)\nAdds an element\nelement::\n  if supplied, is either an Element, String, or\n  Source (see Element.initialize).  If not supplied or nil, a\n  new, default Element will be constructed\nReturns:: the added Element\n a = Element.new('a')\n a.elements.add(Element.new('b'))  #-> <a><b/></a>\n a.elements.add('c')               #-> <a><b/><c/></a>\n
collect REXML::Elements.collect( xpath=nil, &block )\n\n
delete REXML::Elements.delete(element)\nDeletes a child Element\nelement::\n  Either an Element, which is removed directly; an\n  xpath, where the first matching child is removed; or an Integer,\n  where the n'th Element is removed.\nReturns:: the removed child\n doc = Document.new '<a><b/><c/><c id="1"/></a>'\n b = doc.root.elements[1]\n doc.root.elements.delete b           #-> <a><c/><c id="1"/></a>\n doc.elements.delete("a/c[@id='1']")  #-> <a><c/></a>\n doc.root.elements.delete 1           #-> <a/>\n
delete_all REXML::Elements.delete_all( xpath )\nRemoves multiple elements.  Filters for Element children, regardless of\nXPath matching.\nxpath:: all elements matching this String path are removed.\nReturns:: an Array of Elements that have been removed\n doc = Document.new '<a><c/><c/><c/><c/></a>'\n deleted = doc.elements.delete_all 'a/c' #-> [<c/>, <c/>, <c/>, <c/>]\n
each REXML::Elements.each( xpath=nil, &block)\nIterates through all of the child Elements, optionally filtering\nthem by a given XPath\nxpath::\n  optional.  If supplied, this is a String XPath, and is used to\n  filter the children, so that only matching children are yielded.  Note\n  that XPaths are automatically filtered for Elements, so that\n  non-Element children will not be yielded\n doc = Document.new '<a><b/><c/><d/>sean<b/><c/><d/></a>'\n doc.root.each {|e|p e}       #-> Yields b, c, d, b, c, d elements\n doc.root.each('b') {|e|p e}  #-> Yields b, b elements\n doc.root.each('child::node()')  {|e|p e}\n-> Yields <b/>, <c/>, <d/>, <b/>, <c/>, <d/>\n XPath.each(doc.root, 'child::node()', &block)\n-> Yields <b/>, <c/>, <d/>, sean, <b/>, <c/>, <d/>\n
empty? REXML::Elements.empty?()\nReturns +true+ if there are no +Element+ children, +false+ otherwise\n
index REXML::Elements.index(element)\nReturns the index of the supplied child (starting at 1), or -1 if\nthe element is not a child\nelement:: an +Element+ child\n
inject REXML::Elements.inject( xpath=nil, initial=nil, &block )\n\n
size REXML::Elements.size()\nReturns the number of +Element+ children of the parent object.\n doc = Document.new '<a>sean<b/>elliott<b/>russell<b/></a>'\n doc.root.size            #-> 6, 3 element and 3 text nodes\n doc.root.elements.size   #-> 3\n
to_a REXML::Elements.to_a( xpath=nil )\nReturns an Array of Element children.  An XPath may be supplied to\nfilter the children.  Only Element children are returned, even if the\nsupplied XPath matches non-Element children.\n doc = Document.new '<a>sean<b/>elliott<c/></a>'\n doc.root.elements.to_a                  #-> [ <b/>, <c/> ]\n doc.root.elements.to_a("child::node()") #-> [ <b/>, <c/> ]\n XPath.match(doc.root, "child::node()")  #-> [ sean, <b/>, elliott, <c/> ]\n
new REXML::Attributes.new(element)\nConstructor\nelement:: the Element of which this is an Attribute\n
add REXML::Attributes.add( attribute )\nAdds an attribute, overriding any existing attribute by the\nsame name.  Namespaces are significant.\nattribute:: An Attribute\n
delete REXML::Attributes.delete( attribute )\nRemoves an attribute\nattribute::\n  either a String, which is the name of the attribute to remove --\n  namespaces are significant here -- or the attribute to remove.\nReturns:: the owning element\n doc = Document.new "<a y:foo='0' x:foo='1' foo='3' z:foo='4'/>"\n doc.root.attributes.delete 'foo'   #-> <a y:foo='0' x:foo='1' z:foo='4'/>"\n doc.root.attributes.delete 'x:foo' #-> <a y:foo='0' z:foo='4'/>"\n attr = doc.root.attributes.get_attribute('y:foo')\n doc.root.attributes.delete attr    #-> <a z:foo='4'/>"\n
delete_all REXML::Attributes.delete_all( name )\nDeletes all attributes matching a name.  Namespaces are significant.\nname::\n  A String; all attributes that match this path will be removed\nReturns:: an Array of the Attributes that were removed\n
each REXML::Attributes.each()\nIterates over each attribute of an Element, yielding the expanded name\nand value as a pair of Strings.\n\n doc = Document.new '<a x="1" y="2"/>'\n doc.root.attributes.each {|name, value| p name+" => "+value }\n
each_attribute REXML::Attributes.each_attribute()\nIterates over the attributes of an Element.  Yields actual Attribute\nnodes, not String values.\n\n doc = Document.new '<a x="1" y="2"/>'\n doc.root.attributes.each_attribute {|attr|\n   p attr.expanded_name+" => "+attr.value\n }\n
get_attribute REXML::Attributes.get_attribute( name )\nFetches an attribute\nname::\n  the name by which to search for the attribute.  Can be a\n  <tt>prefix:name</tt> namespace name.\nReturns:: The first matching attribute, or nil if there was none.  This\nvalue is an Attribute node, not the String value of the attribute.\n doc = Document.new '<a x:foo="1" foo="2" bar="3"/>'\n doc.root.attributes.get_attribute("foo").value    #-> "2"\n doc.root.attributes.get_attribute("x:foo").value  #-> "1"\n
get_attribute_ns REXML::Attributes.get_attribute_ns(namespace, name)\nThe +get_attribute_ns+ method retrieves a method by its namespace\nand name. Thus it is possible to reliably identify an attribute\neven if an XML processor has changed the prefix.\n\nMethod contributed by Henrik Martensson\n
length REXML::Attributes.length()\nReturns the number of attributes the owning Element contains.\n doc = Document "<a x='1' y='2' foo:x='3'/>"\n doc.root.attributes.length        #-> 3\n
namespaces REXML::Attributes.namespaces()\n\n
prefixes REXML::Attributes.prefixes()\nReturns an array of Strings containing all of the prefixes declared\nby this set of # attributes.  The array does not include the default\nnamespace declaration, if one exists.\n doc = Document.new("<a xmlns='foo' xmlns:x='bar' xmlns:y='twee' "+\n       "z='glorp' p:k='gru'/>")\n prefixes = doc.root.attributes.prefixes    #-> ['x', 'y']\n
size REXML::Attributes.size()\n\n
to_a REXML::Attributes.to_a()\n\n
new REXML::Attribute.new( first, second=nil, parent=nil )\nConstructor.\nFIXME: The parser doesn't catch illegal characters in attributes\n\nfirst::\n  Either: an Attribute, which this new attribute will become a\n  clone of; or a String, which is the name of this attribute\nsecond::\n  If +first+ is an Attribute, then this may be an Element, or nil.\n  If nil, then the Element parent of this attribute is the parent\n  of the +first+ Attribute.  If the first argument is a String,\n  then this must also be a String, and is the content of the attribute.\n  If this is the content, it must be fully normalized (contain no\n  illegal characters).\nparent::\n  Ignored unless +first+ is a String; otherwise, may be the Element\n  parent of this attribute, or nil.\n\n Attribute.new( attribute_to_clone )\n Attribute.new( attribute_to_clone, parent_element )\n Attribute.new( "attr", "attr_value" )\n Attribute.new( "attr", "attr_value", parent_element )\n
clone REXML::Attribute.clone()\nReturns a copy of this attribute\n
doctype REXML::Attribute.doctype()\n\n
element= REXML::Attribute.element=( element )\nSets the element of which this object is an attribute.  Normally, this\nis not directly called.\n\nReturns this attribute\n
hash REXML::Attribute.hash()\nCreates (and returns) a hash from both the name and value\n
inspect REXML::Attribute.inspect()\n\n
namespace REXML::Attribute.namespace(arg=nil)\nReturns the namespace URL, if defined, or nil otherwise\n\n e = Element.new("el")\n e.add_attributes({"xmlns:ns", "http://url"})\n e.namespace( "ns" )              # -> "http://url"\n
node_type REXML::Attribute.node_type()\n\n
prefix REXML::Attribute.prefix()\nReturns the namespace of the attribute.\n\n e = Element.new( "elns:myelement" )\n e.add_attribute( "nsa:a", "aval" )\n e.add_attribute( "b", "bval" )\n e.attributes.get_attribute( "a" ).prefix   # -> "nsa"\n e.attributes.get_attribute( "b" ).prefix   # -> "elns"\n a = Attribute.new( "x", "y" )\n a.prefix                                   # -> ""\n
remove REXML::Attribute.remove()\nRemoves this Attribute from the tree, and returns true if successfull\n\nThis method is usually not called directly.\n
to_s REXML::Attribute.to_s()\nReturns the attribute value, with entities replaced\n
to_string REXML::Attribute.to_string()\nReturns this attribute out as XML source, expanding the name\n\n a = Attribute.new( "x", "y" )\n a.to_string     # -> "x='y'"\n b = Attribute.new( "ns:x", "y" )\n b.to_string     # -> "ns:x='y'"\n
value REXML::Attribute.value()\nReturns the UNNORMALIZED value of this attribute.  That is, entities\nhave been expanded to their values\n
write REXML::Attribute.write( output, indent=-1 )\nWrites this attribute (EG, puts 'key="value"' to the output)\n
xpath REXML::Attribute.xpath()\n\n
new REXML::Formatters::Pretty.new( indentation=2, ie_hack=false )\nCreate a new pretty printer.\n\noutput::\n  An object implementing '<<(String)', to which the output will be written.\nindentation::\n  An integer greater than 0.  The indentation of each level will be\n  this number of spaces.  If this is < 1, the behavior of this object\n  is undefined.  Defaults to 2.\nie_hack::\n  If true, the printer will insert whitespace before closing empty\n  tags, thereby allowing Internet Explorer's feeble XML parser to\n  function. Defaults to false.\n
write_cdata REXML::Formatters::Pretty.write_cdata( node, output)\n\n
write_comment REXML::Formatters::Pretty.write_comment( node, output)\n\n
write_document REXML::Formatters::Pretty.write_document( node, output )\n\n
write_element REXML::Formatters::Pretty.write_element(node, output)\n\n
write_text REXML::Formatters::Pretty.write_text( node, output )\n\n
new REXML::Formatters::Transitive.new( indentation=2, ie_hack=false )\n\n
write_element REXML::Formatters::Transitive.write_element( node, output )\n\n
write_text REXML::Formatters::Transitive.write_text( node, output )\n\n
new REXML::Formatters::Default.new( ie_hack=false )\nPrints out the XML document with no formatting -- except if id_hack is\nset.\n\nie_hack::\n  If set to true, then inserts whitespace before the close of an empty\n  tag, so that IE's bad XML parser doesn't choke.\n
write REXML::Formatters::Default.write( node, output )\nWrites the node to some output.\n\nnode::\n  The node to write\noutput::\n  A class implementing <TT>&lt;&lt;</TT>.  Pass in an Output object to\n  change the output encoding.\n
write_cdata REXML::Formatters::Default.write_cdata( node, output )\n\n
write_comment REXML::Formatters::Default.write_comment( node, output )\n\n
write_document REXML::Formatters::Default.write_document( node, output )\n\n
write_element REXML::Formatters::Default.write_element( node, output )\n\n
write_instruction REXML::Formatters::Default.write_instruction( node, output )\n\n
write_text REXML::Formatters::Default.write_text( node, output )\n\n
new REXML::SyncEnumerator.new(*enums)\nCreates a new SyncEnumerator which enumerates rows of given\nEnumerable objects.\n
each REXML::SyncEnumerator.each()\nEnumerates rows of the Enumerable objects.\n
length REXML::SyncEnumerator.length()\nReturns the number of enumerated Enumerable objects, i.e. the size\nof each row.\n
size REXML::SyncEnumerator.size()\nReturns the number of enumerated Enumerable objects, i.e. the size\nof each row.\n
new REXML::Validation::ValidationException.new(msg)\n\n
new REXML::Validation::RelaxNG.new(source)\nFIXME: Namespaces\n
receive REXML::Validation::RelaxNG.receive(event)\n\n
new REXML::Validation::State.new( context )\n\n
add_event_to_arry REXML::Validation::State.add_event_to_arry( arry, evt )\n\n
expand_ref_in REXML::Validation::State.expand_ref_in( arry, ind )\n\n
expected REXML::Validation::State.expected()\n\n
generate_event REXML::Validation::State.generate_event( event )\n\n
inspect REXML::Validation::State.inspect()\n\n
next REXML::Validation::State.next( event )\n\n
previous= REXML::Validation::State.previous=( previous )\n\n
reset REXML::Validation::State.reset()\n\n
to_s REXML::Validation::State.to_s()\n\n
matches? REXML::Validation::Sequence.matches?(event)\n\n
expected REXML::Validation::Optional.expected()\n\n
matches? REXML::Validation::Optional.matches?(event)\n\n
next REXML::Validation::Optional.next( event )\n\n
expected REXML::Validation::ZeroOrMore.expected()\n\n
next REXML::Validation::ZeroOrMore.next( event )\n\n
new REXML::Validation::OneOrMore.new(context)\n\n
expected REXML::Validation::OneOrMore.expected()\n\n
matches? REXML::Validation::OneOrMore.matches?( event )\n\n
next REXML::Validation::OneOrMore.next( event )\n\n
reset REXML::Validation::OneOrMore.reset()\n\n
new REXML::Validation::Choice.new(context)\n\n
add_event_to_arry REXML::Validation::Choice.add_event_to_arry( arry, evt )\n\n
expected REXML::Validation::Choice.expected()\n\n
inspect REXML::Validation::Choice.inspect()\n\n
matches? REXML::Validation::Choice.matches?( event )\n\n
next REXML::Validation::Choice.next( event )\n\n
reset REXML::Validation::Choice.reset()\n\n
new REXML::Validation::Interleave.new(context)\n\n
expected REXML::Validation::Interleave.expected()\n\n
inspect REXML::Validation::Interleave.inspect()\n\n
matches? REXML::Validation::Interleave.matches?( event )\n\n
next REXML::Validation::Interleave.next( event )\n\n
next_current REXML::Validation::Interleave.next_current( event )\n\n
reset REXML::Validation::Interleave.reset()\n\n
new REXML::Validation::Ref.new(value)\n\n
inspect REXML::Validation::Ref.inspect()\n\n
to_s REXML::Validation::Ref.to_s()\n\n
new REXML::Validation::Event.new(event_type, event_arg=nil )\n\n
done? REXML::Validation::Event.done?()\n\n
inspect REXML::Validation::Event.inspect()\n\n
matches? REXML::Validation::Event.matches?( event )\n\n
single? REXML::Validation::Event.single?()\n\n
to_s REXML::Validation::Event.to_s()\n\n
new REXML::Output.new(real_IO, encd="iso-8859-1")\n\n
to_s REXML::Output.to_s()\n\n
new REXML::Comment.new( first, second = nil )\nConstructor.  The first argument can be one of three types:\n@param first If String, the contents of this comment are set to the\nargument.  If Comment, the argument is duplicated.  If\nSource, the argument is scanned for a comment.\n@param second If the first argument is a Source, this argument\nshould be nil, not supplied, or a Parent to be set as the parent\nof this object\n
clone REXML::Comment.clone()\n\n
node_type REXML::Comment.node_type()\n\n
write REXML::Comment.write( output, indent=-1, transitive=false, ie_hack=false )\n== DEPRECATED\nSee REXML::Formatters\n\noutput::\n   Where to write the string\nindent::\n   An integer.    If -1, no indenting will be used; otherwise, the\n   indentation will be this number of spaces, and children will be\n   indented an additional amount.\ntransitive::\n   Ignored by this class. The contents of comments are never modified.\nie_hack::\n   Needed for conformity to the child API, but not used by this class.\n
new REXML::ParseException.new( message, source=nil, parser=nil, exception=nil )\n\n
context REXML::ParseException.context()\n\n
line REXML::ParseException.line()\n\n
position REXML::ParseException.position()\n\n
to_s REXML::ParseException.to_s()\n\n
new REXML::CData.new( first, whitespace=true, parent=nil )\n  Constructor.  CData is data between <![CDATA[ ... ]]>\n\n_Examples_\n CData.new( source )\n CData.new( "Here is some CDATA" )\n CData.new( "Some unprocessed data", respect_whitespace_TF, parent_element )\n
clone REXML::CData.clone()\nMake a copy of this object\n\n_Examples_\n c = CData.new( "Some text" )\n d = c.clone\n d.to_s        # -> "Some text"\n
to_s REXML::CData.to_s()\nReturns the content of this CData object\n\n_Examples_\n c = CData.new( "Some text" )\n c.to_s        # -> "Some text"\n
value REXML::CData.value()\n\n
write REXML::CData.write( output=$stdout, indent=-1, transitive=false,\nie_hack=false )\n== DEPRECATED\nSee the rexml/formatters package\n\nGenerates XML output of this object\n\noutput::\n  Where to write the string.  Defaults to $stdout\nindent::\n  The amount to indent this node by\ntransitive::\n  Ignored\nie_hack::\n  Ignored\n\n_Examples_\n c = CData.new( " Some text " )\n c.write( $stdout )     #->  <![CDATA[ Some text ]]>\n
create_from REXML::SourceFactory.create_from(arg)\nGenerates a Source object\n@param arg Either a String, or an IO\n@return a Source, or nil if a bad argument was given\n
new REXML::Source.new(arg, encoding=nil)\nConstructor\n@param arg must be a String, and should be a valid XML document\n@param encoding if non-null, sets the encoding of the source to this\nvalue, overriding all encoding detection\n
consume REXML::Source.consume( pattern )\n\n
current_line REXML::Source.current_line()\n@return the current line in the source\n
empty? REXML::Source.empty?()\n@return true if the Source is exhausted\n
encoding= REXML::Source.encoding=(enc)\nInherited from Encoding\nOverridden to support optimized en/decoding\n
match REXML::Source.match(pattern, cons=false)\n\n
match_to REXML::Source.match_to( char, pattern )\n\n
match_to_consume REXML::Source.match_to_consume( char, pattern )\n\n
position REXML::Source.position()\n\n
read REXML::Source.read()\n\n
scan REXML::Source.scan(pattern, cons=false)\nScans the source for a given pattern.  Note, that this is not your\nusual scan() method.  For one thing, the pattern argument has some\nrequirements; for another, the source can be consumed.  You can easily\nconfuse this method.  Originally, the patterns were easier\nto construct and this method more robust, because this method\ngenerated search regexes on the fly; however, this was\ncomputationally expensive and slowed down the entire REXML package\nconsiderably, since this is by far the most commonly called method.\n@param pattern must be a Regexp, and must be in the form of\n/^\s*(#{your pattern, with no groups})(.*)/.  The first group\nwill be returned; the second group is used if the consume flag is\nset.\n@param consume if true, the pattern returned will be consumed, leaving\neverything after it in the Source.\n@return the pattern, if found, or nil if the Source is empty or the\npattern is not found.\n
new REXML::IOSource.new(arg, block_size=500, encoding=nil)\nblock_size has been deprecated\n
consume REXML::IOSource.consume( pattern )\n\n
current_line REXML::IOSource.current_line()\n@return the current line in the source\n
empty? REXML::IOSource.empty?()\n\n
match REXML::IOSource.match( pattern, cons=false )\n\n
position REXML::IOSource.position()\n\n
read REXML::IOSource.read()\n\n
scan REXML::IOSource.scan(pattern, cons=false)\n\n
each REXML::XPath.each(element, path=nil, namespaces=nil, variables={})\nIterates over nodes that match the given path, calling the supplied\nblock with the match.\nelement::\n  The context element\npath::\n  The xpath to search for.  If not supplied or nil, defaults to '*'\nnamespaces::\n  If supplied, a Hash which defines a namespace mapping\nvariables::\n  If supplied, a Hash which maps $variables in the query\n  to values. This can be used to avoid XPath injection attacks\n  or to automatically handle escaping string values.\n\n XPath.each( node ) { |el| ... }\n XPath.each( node, '/*[@attr='v']' ) { |el| ... }\n XPath.each( node, 'ancestor::x' ) { |el| ... }\n XPath.each( node, '/book/publisher/text()=$publisher', {},\n {"publisher"=>"O'Reilly"}) \\n   {|el| ... }\n
first REXML::XPath.first(element, path=nil, namespaces=nil, variables={})\nFinds and returns the first node that matches the supplied xpath.\nelement::\n  The context element\npath::\n  The xpath to search for.  If not supplied or nil, returns the first\n  node matching '*'.\nnamespaces::\n  If supplied, a Hash which defines a namespace mapping.\nvariables::\n  If supplied, a Hash which maps $variables in the query\n  to values. This can be used to avoid XPath injection attacks\n  or to automatically handle escaping string values.\n\n XPath.first( node )\n XPath.first( doc, "//b"} )\n XPath.first( node, "a/x:b", { "x"=>"http://doofus" } )\n XPath.first( node, '/book/publisher/text()=$publisher', {},\n {"publisher"=>"O'Reilly"})\n
match REXML::XPath.match(element, path=nil, namespaces=nil, variables={})\nReturns an array of nodes matching a given XPath.\n
attribute REXML::QuickPath.attribute( name )\n\n
axe REXML::QuickPath.axe( elements, axe_name, rest )\n\n
each REXML::QuickPath.each(element, path, namespaces=EMPTY_HASH, &block)\n\n
filter REXML::QuickPath.filter(elements, path)\nGiven an array of nodes it filters the array based on the path. The\nresult is that when this method returns, the array will contain elements\nwhich match the path\n
first REXML::QuickPath.first(element, path, namespaces=EMPTY_HASH)\n\n
function REXML::QuickPath.function( elements, fname, rest )\n\n
match REXML::QuickPath.match(element, path, namespaces=EMPTY_HASH)\n\n
method_missing REXML::QuickPath.method_missing( id, *args )\n\n
name REXML::QuickPath.name()\n\n
parse_args REXML::QuickPath.parse_args( element, string )\n\n
predicate REXML::QuickPath.predicate( elements, path )\nA predicate filters a node-set with respect to an axis to produce a\nnew node-set. For each node in the node-set to be filtered, the\nPredicateExpr is evaluated with that node as the context node, with\nthe number of nodes in the node-set as the context size, and with the\nproximity position of the node in the node-set with respect to the\naxis as the context position; if PredicateExpr evaluates to true for\nthat node, the node is included in the new node-set; otherwise, it is\nnot included.\n\nA PredicateExpr is evaluated by evaluating the Expr and converting\nthe result to a boolean. If the result is a number, the result will\nbe converted to true if the number is equal to the context position\nand will be converted to false otherwise; if the result is not a\nnumber, then the result will be converted as if by a call to the\nboolean function. Thus a location path para[3] is equivalent to\npara[position()=3].\n
new REXML::AttlistDecl.new(source)\nCreate an AttlistDecl, pulling the information from a Source.  Notice\nthat this isn't very convenient; to create an AttlistDecl, you basically\nhave to format it yourself, and then have the initializer parse it.\nSorry, but for the forseeable future, DTD support in REXML is pretty\nweak on convenience.  Have I mentioned how much I hate DTDs?\n
each REXML::AttlistDecl.each(&block)\nIterate over the key/value pairs:\n attlist_decl.each { |attribute_name, attribute_value| ... }\n
include? REXML::AttlistDecl.include?(key)\nWhether an attlist declaration includes the given attribute definition\n if attlist_decl.include? "xmlns:foobar"\n
node_type REXML::AttlistDecl.node_type()\n\n
write REXML::AttlistDecl.write(out, indent=-1)\nWrite out exactly what we got in.\n
new REXML::Child.new( parent = nil )\nConstructor.  Any inheritors of this class should call super to make\nsure this method is called.\nparent::\n  if supplied, the parent of this child will be set to the\n  supplied value, and self will be added to the parent\n
bytes REXML::Child.bytes()\nThis doesn't yet handle encodings\n
document REXML::Child.document()\nReturns:: the document this child belongs to, or nil if this child\nbelongs to no document\n
next_sibling= REXML::Child.next_sibling=( other )\nSets the next sibling of this child.  This can be used to insert a child\nafter some other child.\n a = Element.new("a")\n b = a.add_element("b")\n c = Element.new("c")\n b.next_sibling = c\n => <a><b/><c/></a>\n
parent= REXML::Child.parent=( other )\nSets the parent of this child to the supplied argument.\n\nother::\n  Must be a Parent object.  If this object is the same object as the\n  existing parent of this child, no action is taken. Otherwise, this\n  child is removed from the current parent (if one exists), and is added\n  to the new parent.\nReturns:: The parent added\n
previous_sibling= REXML::Child.previous_sibling=(other)\nSets the previous sibling of this child.  This can be used to insert a\nchild before some other child.\n a = Element.new("a")\n b = a.add_element("b")\n c = Element.new("c")\n b.previous_sibling = c\n => <a><b/><c/></a>\n
remove REXML::Child.remove()\nRemoves this child from the parent.\n\nReturns:: self\n
replace_with REXML::Child.replace_with( child )\nReplaces this object with another object.  Basically, calls\nParent.replace_child\n\nReturns:: self\n
new REXML::Parent.new(parent=nil)\nConstructor\n@param parent if supplied, will be set as the parent of this object\n
add REXML::Parent.add( object )\n\n
children REXML::Parent.children()\n\n
deep_clone REXML::Parent.deep_clone()\nDeeply clones this object.  This creates a complete duplicate of this\nParent, including all descendants.\n
delete REXML::Parent.delete( object )\n\n
delete_at REXML::Parent.delete_at( index )\n\n
delete_if REXML::Parent.delete_if( &block )\n\n
each REXML::Parent.each(&block)\n\n
each_child REXML::Parent.each_child(&block)\n\n
each_index REXML::Parent.each_index( &block )\n\n
index REXML::Parent.index( child )\nFetches the index of a given child\n@param child the child to get the index of\n@return the index of the child, or nil if the object is not a child\nof this parent.\n
insert_after REXML::Parent.insert_after( child1, child2 )\nInserts an child after another child\n@param child1 this is either an xpath or an Element.  If an Element,\nchild2 will be inserted after child1 in the child list of the parent.\nIf an xpath, child2 will be inserted after the first child to match\nthe xpath.\n@param child2 the child to insert\n@return the parent (self)\n
insert_before REXML::Parent.insert_before( child1, child2 )\nInserts an child before another child\n@param child1 this is either an xpath or an Element.  If an Element,\nchild2 will be inserted before child1 in the child list of the parent.\nIf an xpath, child2 will be inserted before the first child to match\nthe xpath.\n@param child2 the child to insert\n@return the parent (self)\n
length REXML::Parent.length()\n\n
parent? REXML::Parent.parent?()\n\n
push REXML::Parent.push( object )\n\n
replace_child REXML::Parent.replace_child( to_replace, replacement )\nReplaces one child with another, making sure the nodelist is correct\n@param to_replace the child to replace (must be a Child)\n@param replacement the child to insert into the nodelist (must be a\nChild)\n
size REXML::Parent.size()\n@return the number of children of this parent\n
to_a REXML::Parent.to_a()\n\n
unshift REXML::Parent.unshift( object )\n\n
new REXML::DTD::EntityDecl.new(src)\n<!ENTITY name SYSTEM "...">\n<!ENTITY name "...">\n
parse_source REXML::DTD::EntityDecl.parse_source(source, listener)\n\n
to_s REXML::DTD::EntityDecl.to_s()\n\n
write REXML::DTD::EntityDecl.write( output, indent )\n\n
new REXML::DTD::ElementDecl.new(match)\n\s*((((["']).*?\5)|[^\/'">]*)*?)(\/)?>/um, true)\n
parse REXML::DTD::Parser.parse( input )\n\n
parse_helper REXML::DTD::Parser.parse_helper( input )\nTakes a String and parses it out\n
new REXML::DTD::NotationDecl.new(src)\n\n
parse_source REXML::DTD::NotationDecl.parse_source(source, listener)\n\n
to_s REXML::DTD::NotationDecl.to_s()\n\n
write REXML::DTD::NotationDecl.write( output, indent )\n\n
new REXML::DocType.new( first, parent=nil )\nConstructor\n\n  dt = DocType.new( 'foo', '-//I/Hate/External/IDs' )\n <!DOCTYPE foo '-//I/Hate/External/IDs'>\n  dt = DocType.new( doctype_to_clone )\n Incomplete.  Shallow clone of doctype\n\n+Note+ that the constructor:\n\n Doctype.new( Source.new( "<!DOCTYPE foo 'bar'>" ) )\n\nis _deprecated_.  Do not use it.  It will probably disappear.\n
add REXML::DocType.add(child)\n\n
attribute_of REXML::DocType.attribute_of(element, attribute)\n\n
attributes_of REXML::DocType.attributes_of(element)\n\n
clone REXML::DocType.clone()\n\n
context REXML::DocType.context()\n\n
entity REXML::DocType.entity( name )\n\n
node_type REXML::DocType.node_type()\n\n
notation REXML::DocType.notation(name)\nRetrieves a named notation. Only notations declared in the internal\nDTD subset can be retrieved.\n\nMethod contributed by Henrik Martensson\n
notations REXML::DocType.notations()\nThis method returns a list of notations that have been declared in the\n_internal_ DTD subset. Notations in the external DTD subset are not\nlisted.\n\nMethod contributed by Henrik Martensson\n
public REXML::DocType.public()\nThis method retrieves the public identifier identifying the document's\nDTD.\n\nMethod contributed by Henrik Martensson\n
system REXML::DocType.system()\nThis method retrieves the system identifier identifying the document's DTD\n\nMethod contributed by Henrik Martensson\n
write REXML::DocType.write( output, indent=0, transitive=false, ie_hack=false )\noutput::\n  Where to write the string\nindent::\n  An integer.  If -1, no indentation will be used; otherwise, the\n  indentation will be this number of spaces, and children will be\n  indented an additional amount.\ntransitive::\n  Ignored\nie_hack::\n  Ignored\n
new REXML::Declaration.new(src)\n\n
to_s REXML::Declaration.to_s()\n\n
write REXML::Declaration.write( output, indent )\n== DEPRECATED\nSee REXML::Formatters\n
new REXML::ElementDecl.new( src )\n\n
new REXML::ExternalEntity.new( src )\n\n
to_s REXML::ExternalEntity.to_s()\n\n
write REXML::ExternalEntity.write( output, indent )\n\n
new REXML::NotationDecl.new(name, middle, pub, sys)\n\n
name REXML::NotationDecl.name()\nThis method retrieves the name of the notation.\n\nMethod contributed by Henrik Martensson\n
to_s REXML::NotationDecl.to_s()\n\n
write REXML::NotationDecl.write( output, indent=-1 )\n\n
new REXML::UndefinedNamespaceException.new( prefix, source, parser )\n\n
matches? REXML::Entity.matches?(string)\nEvaluates whether the given string matchs an entity definition,\nreturning true if so, and false otherwise.\n
new REXML::Entity.new(stream, value=nil, parent=nil, reference=false)\nCreate a new entity.  Simple entities can be constructed by passing a\nname, value to the constructor; this creates a generic, plain entity\nreference. For anything more complicated, you have to pass a Source to\nthe constructor with the entity definition, or use the accessor methods.\n+WARNING+: There is no validation of entity state except when the entity\nis read from a stream.  If you start poking around with the accessors,\nyou can easily create a non-conformant Entity.  The best thing to do is\ndump the stupid DTDs and use XMLSchema instead.\n\n e = Entity.new( 'amp', '&' )\n
normalized REXML::Entity.normalized()\nReturns the value of this entity unprocessed -- raw.  This is the\nnormalized value; that is, with all %ent; and &ent; entities intact\n
to_s REXML::Entity.to_s()\nReturns this entity as a string.  See write().\n
unnormalized REXML::Entity.unnormalized()\nEvaluates to the unnormalized value of this entity; that is, replacing\nall entities -- both %ent; and &ent; entities.  This differs from\n+value()+ in that +value+ only replaces %ent; entities.\n
value REXML::Entity.value()\nReturns the value of this entity.  At the moment, only internal entities\nare processed.  If the value contains internal references (IE,\n%blah;), those are replaced with their values.  IE, if the doctype\ncontains:\n <!ENTITY % foo "bar">\n <!ENTITY yada "nanoo %foo; nanoo>\nthen:\n doctype.entity('yada').value   #-> "nanoo bar nanoo"\n
write REXML::Entity.write(out, indent=-1)\nWrite out a fully formed, correct entity definition (assuming the Entity\nobject itself is valid.)\n\nout::\n  An object implementing <TT>&lt;&lt;<TT> to which the entity will be\n  output\nindent::\n  *DEPRECATED* and ignored\n
entity_expansion_limit REXML::Document.entity_expansion_limit()\nGet the entity expansion limit. By default the limit is set to 10000.\n
entity_expansion_limit= REXML::Document.entity_expansion_limit=( val )\nSet the entity expansion limit. By default the limit is set to 10000.\n
entity_expansion_text_limit REXML::Document.entity_expansion_text_limit()\nGet the entity expansion limit. By default the limit is set to 10240.\n\nDeprecated. Use REXML.entity_expansion_text_limit instead.\n
entity_expansion_text_limit= REXML::Document.entity_expansion_text_limit=( val )\nSet the entity expansion limit. By default the limit is set to 10240.\n\nDeprecated. Use REXML.entity_expansion_text_limit= instead.\n
new REXML::Document.new( source = nil, context = {} )\nConstructor\n@param source if supplied, must be a Document, String, or IO.\nDocuments have their context and Element attributes cloned.\nStrings are expected to be valid XML documents.  IOs are expected\nto be sources of valid XML documents.\n@param context if supplied, contains the context of the document;\nthis should be a Hash.\n
parse_stream REXML::Document.parse_stream( source, listener )\n\n
add REXML::Document.add( child )\nWe override this, because XMLDecls and DocTypes must go at the start\nof the document\n
add_element REXML::Document.add_element(arg=nil, arg2=nil)\n\n
clone REXML::Document.clone()\nShould be obvious\n
doctype REXML::Document.doctype()\n@return the DocType child of the document, if one exists,\nand nil otherwise.\n
encoding REXML::Document.encoding()\n@return the XMLDecl encoding of this document as an\nEncoding object.\nIf no XMLDecl has been set, returns the default encoding.\n
expanded_name REXML::Document.expanded_name()\nAccording to the XML spec, a root node has no expanded name\n
name REXML::Document.name()\n\n
node_type REXML::Document.node_type()\n\n
record_entity_expansion REXML::Document.record_entity_expansion()\n\n
root REXML::Document.root()\n@return the root Element of the document, or nil if this document\nhas no children.\n
stand_alone? REXML::Document.stand_alone?()\n@return the XMLDecl standalone value of this document as a String.\nIf no XMLDecl has been set, returns the default setting.\n
version REXML::Document.version()\n@return the XMLDecl version of this document as a String.\nIf no XMLDecl has been set, returns the default version.\n
write REXML::Document.write( output=$stdout, indent=-1, transitive=false,\nie_hack=false )\nWrite the XML tree out, optionally with indent.  This writes out the\nentire XML document, including XML declarations, doctype declarations,\nand processing instructions (if any are given).\n\nA controversial point is whether Document should always write the XML\ndeclaration (<?xml version='1.0'?>) whether or not one is given by the\nuser (or source document).  REXML does not write one if one was not\nspecified, because it adds unnecessary bandwidth to applications such\nas XML-RPC.\n\nSee also the classes in the rexml/formatters package for the proper way\nto change the default formatting of XML output\n\n_Examples_\n  Document.new("<a><b/></a>").serialize\n\n  output_string = ""\n  tr = Transitive.new( output_string )\n  Document.new("<a><b/></a>").serialize( tr )\n\noutput::\n    output an object which supports '<< string'; this is where the\n  document will be written.\nindent::\n  An integer.  If -1, no indenting will be used; otherwise, the\n  indentation will be twice this number of spaces, and children will be\n  indented an additional amount.  For a value of 3, every item will be\n  indented 3 more levels, or 6 more spaces (2 * 3). Defaults to -1\ntransitive::\n  If transitive is true and indent is >= 0, then the output will be\n  pretty-printed in such a way that the added whitespace does not affect\n  the absolute *value* of the document -- that is, it leaves the value\n  and number of Text nodes in the document unchanged.\nie_hack::\n  Internet Explorer is the worst piece of crap to have ever been\n  written, with the possible exception of Windows itself.  Since IE is\n  unable to parse proper XML, we have to provide a hack to generate XML\n  that IE's limited abilities can handle.  This hack inserts a space\n  before the /> on empty tags.  Defaults to false\n
xml_decl REXML::Document.xml_decl()\n@return the XMLDecl of this document; if no XMLDecl has been\nset, the default declaration is returned.\n
new REXML::XPathParser.new( )\n\n
first REXML::XPathParser.first( path_stack, node )\nPerforms a depth-first (document order) XPath search, and returns the\nfirst match.  This is the fastest, lightest way to return a single result.\n\nFIXME: This method is incomplete!\n
get_first REXML::XPathParser.get_first(path, nodeset)\n\n
match REXML::XPathParser.match( path_stack, nodeset )\n\n
namespaces= REXML::XPathParser.namespaces=( namespaces={} )\n\n
parse REXML::XPathParser.parse(path, nodeset)\n\n
predicate REXML::XPathParser.predicate(path, nodeset)\n\n
variables= REXML::XPathParser.variables=( vars={} )\n\n
check REXML::Text.check(string, pattern, doctype)\ncheck for illegal characters\n
expand REXML::Text.expand(ref, doctype, filter)\n\n
new REXML::Text.new(arg, respect_whitespace=false, parent=nil, raw=nil,\nentity_filter=nil, illegal=NEEDS_A_SECOND_CHECK )\nConstructor\n+arg+ if a String, the content is set to the String.  If a Text,\nthe object is shallowly cloned.\n\n+respect_whitespace+ (boolean, false) if true, whitespace is\nrespected\n\n+parent+ (nil) if this is a Parent object, the parent\nwill be set to this.\n\n+raw+ (nil) This argument can be given three values.\nIf true, then the value of used to construct this object is expected to\ncontain no unescaped XML markup, and REXML will not change the text. If\nthis value is false, the string may contain any characters, and REXML will\nescape any and all defined entities whose values are contained in the\ntext.  If this value is nil (the default), then the raw value of the\nparent will be used as the raw value for this node.  If there is no raw\nvalue for the parent, and no value is supplied, the default is false.\nUse this field if you have entities defined for some text, and you don't\nwant REXML to escape that text in output.\n  Text.new( "<&", false, nil, false ) #-> "&lt;&amp;"\n  Text.new( "&lt;&amp;", false, nil, false ) #-> "&amp;lt;&amp;amp;"\n  Text.new( "<&", false, nil, true )  #-> Parse exception\n  Text.new( "&lt;&amp;", false, nil, true )  #-> "&lt;&amp;"\n Assume that the entity "s" is defined to be "sean"\n and that the entity    "r" is defined to be "russell"\n  Text.new( "sean russell" )          #-> "&s; &r;"\n  Text.new( "sean russell", false, nil, true ) #-> "sean russell"\n\n+entity_filter+ (nil) This can be an array of entities to match in the\nsupplied text.  This argument is only useful if +raw+ is set to false.\n  Text.new( "sean russell", false, nil, false, ["s"] ) #-> "&s; russell"\n  Text.new( "sean russell", false, nil, true, ["s"] ) #-> "sean russell"\nIn the last example, the +entity_filter+ argument is ignored.\n\n+illegal+ INTERNAL USE ONLY\n
normalize REXML::Text.normalize( input, doctype=nil, entity_filter=nil )\nEscapes all possible entities\n
read_with_substitution REXML::Text.read_with_substitution( input, illegal=nil )\nReads text, substituting entities\n
unnormalize REXML::Text.unnormalize( string, doctype=nil, filter=nil, illegal=nil )\nUnescapes all possible entities\n
clone REXML::Text.clone()\n\n
doctype REXML::Text.doctype()\n\n
empty? REXML::Text.empty?()\n\n
indent_text REXML::Text.indent_text(string, level=1, style="\t", indentfirstline=true)\n\n
inspect REXML::Text.inspect()\n\n
node_type REXML::Text.node_type()\n\n
parent= REXML::Text.parent=(parent)\n\n
to_s REXML::Text.to_s()\nReturns the string value of this text node.  This string is always\nescaped, meaning that it is a valid XML text node string, and all\nentities that can be escaped, have been inserted.  This method respects\nthe entity filter set in the constructor.\n Assume that the entity "s" is defined to be "sean", and that the\n entity "r" is defined to be "russell"\n  t = Text.new( "< & sean russell", false, nil, false, ['s'] )\n  t.to_s   #-> "&lt; &amp; &s; russell"\n  t = Text.new( "< & &s; russell", false, nil, false )\n  t.to_s   #-> "&lt; &amp; &s; russell"\n  u = Text.new( "sean russell", false, nil, true )\n  u.to_s   #-> "sean russell"\n
value REXML::Text.value()\nReturns the string value of this text.  This is the text without\nentities, as it might be used programmatically, or printed to the\nconsole.  This ignores the 'raw' attribute setting, and any\nentity_filter.\n Assume that the entity "s" is defined to be "sean", and that the\n entity "r" is defined to be "russell"\n  t = Text.new( "< & sean russell", false, nil, false, ['s'] )\n  t.value   #-> "< & sean russell"\n  t = Text.new( "< & &s; russell", false, nil, false )\n  t.value   #-> "< & sean russell"\n  u = Text.new( "sean russell", false, nil, true )\n  u.value   #-> "sean russell"\n
value= REXML::Text.value=( val )\nSets the contents of this text node.  This expects the text to be\nunnormalized.  It returns self.\n\n  e = Element.new( "a" )\n  e.add_text( "foo" )   # <a>foo</a>\n  e[0].value = "bar"    # <a>bar</a>\n  e[0].value = "<a>"    # <a>&lt;a&gt;</a>\n
wrap REXML::Text.wrap(string, width, addnewline=false)\n\n
write REXML::Text.write( writer, indent=-1, transitive=false, ie_hack=false )\n== DEPRECATED\nSee REXML::Formatters\n
write_with_substitution REXML::Text.write_with_substitution(out, input)\nWrites out text, substituting special characters beforehand.\n+out+ A String, IO, or any other object supporting <<( String )\n+input+ the text to substitute and the write out\n\n  z=utf8.unpack("U*")\n  ascOut=""\n  z.each{|r|\n    if r <  0x100\n      ascOut.concat(r.chr)\n    else\n      ascOut.concat(sprintf("&#x%x;", r))\n    end\n  }\n  puts ascOut\n
xpath REXML::Text.xpath()\nFIXME\nThis probably won't work properly\n
new REXML::Light::Node.new(node=nil)\nCreate a new element.\n
children REXML::Light::Node.children()\n\n
each REXML::Light::Node.each( &block )\n\n
has_name? REXML::Light::Node.has_name?( name, namespace = '' )\n\n
local_name REXML::Light::Node.local_name()\n\n
local_name= REXML::Light::Node.local_name=( name_str )\n\n
name REXML::Light::Node.name()\n\n
name= REXML::Light::Node.name=( name_str, ns=nil )\n\n
namespace REXML::Light::Node.namespace( prefix=prefix() )\n\n
namespace= REXML::Light::Node.namespace=( namespace )\n\n
node_type REXML::Light::Node.node_type()\n\n
parent REXML::Light::Node.parent()\n\n
parent= REXML::Light::Node.parent=( node )\n\n
prefix REXML::Light::Node.prefix( namespace=nil )\n\n
root REXML::Light::Node.root()\n\n
size REXML::Light::Node.size()\n\n
text= REXML::Light::Node.text=( foo )\n\n
to_s REXML::Light::Node.to_s()\n\n
_load BigDecimal._load(p1)\nInternal method used to provide marshalling support. See the Marshal module.\n
double_fig BigDecimal.double_fig()\nThe BigDecimal.double_fig class method returns the number of digits a\nFloat number is allowed to have. The result depends upon the CPU and OS\nin use.\n
limit BigDecimal.limit(p1 = v1)\nLimit the number of significant digits in newly created BigDecimal\nnumbers to the specified value. Rounding is performed as necessary,\nas specified by BigDecimal.mode.\n\nA limit of 0, the default, means no upper limit.\n\nThe limit specified by this method takes less priority over any limit\nspecified to instance methods such as ceil, floor, truncate, or round.\n
mode BigDecimal.mode(p1, p2 = v2)\nControls handling of arithmetic exceptions and rounding. If no value\nis supplied, the current value is returned.\n\nSix values of the mode parameter control the handling of arithmetic\nexceptions:\n\nBigDecimal::EXCEPTION_NaN\nBigDecimal::EXCEPTION_INFINITY\nBigDecimal::EXCEPTION_UNDERFLOW\nBigDecimal::EXCEPTION_OVERFLOW\nBigDecimal::EXCEPTION_ZERODIVIDE\nBigDecimal::EXCEPTION_ALL\n\nFor each mode parameter above, if the value set is false, computation\ncontinues after an arithmetic exception of the appropriate type.\nWhen computation continues, results are as follows:\n\nEXCEPTION_NaN:: NaN\nEXCEPTION_INFINITY:: +infinity or -infinity\nEXCEPTION_UNDERFLOW:: 0\nEXCEPTION_OVERFLOW:: +infinity or -infinity\nEXCEPTION_ZERODIVIDE:: +infinity or -infinity\n\nOne value of the mode parameter controls the rounding of numeric values:\nBigDecimal::ROUND_MODE. The values it can take are:\n\nROUND_UP, :up:: round away from zero\nROUND_DOWN, :down, :truncate:: round towards zero (truncate)\nROUND_HALF_UP, :half_up, :default:: round towards the nearest neighbor, unless\nboth neighbors are equidistant, in which case round away from zero. (default)\nROUND_HALF_DOWN, :half_down:: round towards the nearest neighbor, unless\nboth neighbors are equidistant, in which case round towards zero.\nROUND_HALF_EVEN, :half_even, :banker:: round towards the nearest neighbor,\nunless both neighbors are equidistant, in which case round towards the even\nneighbor (Banker's rounding)\nROUND_CEILING, :ceiling, :ceil:: round towards positive infinity (ceil)\nROUND_FLOOR, :floor:: round towards negative infinity (floor)\n
new BigDecimal.new(p1, p2 = v2)\nCreate a new BigDecimal object.\n\ninitial:: The initial value, as an Integer, a Float, a Rational,\n          a BigDecimal, or a String.\n          If it is a String, spaces are ignored and unrecognized characters\n          terminate the value.\n\ndigits:: The number of significant digits, as a Fixnum. If omitted or 0,\n         the number of significant digits is determined from the initial\n         value.\n\nThe actual number of significant digits used in computation is usually\nlarger than the specified number.\n
save_exception_mode BigDecimal.save_exception_mode()\n\n
save_limit BigDecimal.save_limit()\n\n
save_rounding_mode BigDecimal.save_rounding_mode()\n\n
ver BigDecimal.ver()\nReturns the BigDecimal version number.\n\nRuby 1.8.0 returns 1.0.0.\nRuby 1.8.1 thru 1.8.3 return 1.0.1.\n
_dump BigDecimal._dump(p1 = v1)\n\n
abs BigDecimal.abs()\nReturns the absolute value.\n\nBigDecimal('5').abs -> 5\n\nBigDecimal('-3').abs -> 3\n
add BigDecimal.add(p1, p2)\n\n
ceil BigDecimal.ceil(p1 = v1)\nReturn the smallest integer greater than or equal to the value, as a\nBigDecimal.\n\nBigDecimal('3.14159').ceil -> 4\n\nBigDecimal('-9.1').ceil -> -9\n\nIf n is specified and positive, the fractional part of the result has no\nmore than that many digits.\n\nIf n is specified and negative, at least that\nmany digits to the left of the decimal point will be 0 in the result.\n\nBigDecimal('3.14159').ceil(3) -> 3.142\n\nBigDecimal('13345.234').ceil(-2) -> 13400.0\n
coerce BigDecimal.coerce(p1)\nThe coerce method provides support for Ruby type coercion. It is not\nenabled by default.\n\nThis means that binary operations like + * / or - can often be performed\non a BigDecimal and an object of another type, if the other object can\nbe coerced into a BigDecimal value.\n\ne.g.\na = BigDecimal.new("1.0")\nb = a / 2.0  -> 0.5\n\nNote that coercing a String to a BigDecimal is not supported by default;\nit requires a special compile-time option when building Ruby.\n
div BigDecimal.div(p1, p2 = v2)\n\n
divmod BigDecimal.divmod(p1)\nDivides by the specified value, and returns the quotient and modulus\nas BigDecimal numbers. The quotient is rounded towards negative infinity.\n\nFor example:\n\nrequire 'bigdecimal'\n\na = BigDecimal.new("42")\nb = BigDecimal.new("9")\n\nq,m = a.divmod(b)\n\nc = q * b + m\n\na == c  -> true\n\nThe quotient q is (a/b).floor, and the modulus is the amount that must be\nadded to q * b to get a.\n
eql? BigDecimal.eql?(p1)\nTests for value equality; returns true if the values are equal.\n\nThe == and === operators and the eql? method have the same implementation\nfor BigDecimal.\n\nValues may be coerced to perform the comparison:\n\nBigDecimal.new('1.0') == 1.0  -> true\n
exponent BigDecimal.exponent()\nReturns the exponent of the BigDecimal number, as an Integer.\n\nIf the number can be represented as 0.xxxxxx*10**n where xxxxxx is a string\nof digits with no leading zeros, then n is the exponent.\n
finite? BigDecimal.finite?()\nReturns True if the value is finite (not NaN or infinite)\n
fix BigDecimal.fix()\nReturn the integer part of the number.\n
floor BigDecimal.floor(p1 = v1)\nReturn the largest integer less than or equal to the value, as a BigDecimal.\n\nBigDecimal('3.14159').floor -> 3\n\nBigDecimal('-9.1').floor -> -10\n\nIf n is specified and positive, the fractional part of the result has no\nmore than that many digits.\n\nIf n is specified and negative, at least that\nmany digits to the left of the decimal point will be 0 in the result.\n\nBigDecimal('3.14159').floor(3) -> 3.141\n\nBigDecimal('13345.234').floor(-2) -> 13300.0\n
frac BigDecimal.frac()\nReturn the fractional part of the number.\n
hash BigDecimal.hash()\n\n
infinite? BigDecimal.infinite?()\nReturns nil, -1, or +1 depending on whether the value is finite,\n-infinity, or +infinity.\n
inspect BigDecimal.inspect()\nReturns debugging information about the value as a string of comma-separated\nvalues in angle brackets with a leading #:\n\nBigDecimal.new("1234.5678").inspect ->\n"#<BigDecimal:b7ea1130,'0.12345678E4',8(12)>"\n\nThe first part is the address, the second is the value as a string, and\nthe final part ss(mm) is the current number of significant digits and the\nmaximum number of significant digits, respectively.\n
modulo BigDecimal.modulo(p1)\nReturns the modulus from dividing by b. See divmod.\n
mult BigDecimal.mult(p1, p2)\n\n
nan? BigDecimal.nan?()\nReturns True if the value is Not a Number\n
nonzero? BigDecimal.nonzero?()\nReturns self if the value is non-zero, nil otherwise.\n
power BigDecimal.power(p1, p2 = v2)\nReturns the value raised to the power of n. Note that n must be an Integer.\n\nAlso available as the operator **\n
precs BigDecimal.precs()\nReturns an Array of two Integer values.\n\nThe first value is the current number of significant digits in the\nBigDecimal. The second value is the maximum number of significant digits\nfor the BigDecimal.\n
quo BigDecimal.quo(p1)\nDivide by the specified value.\n\ne.g.\n  c = a.div(b,n)\n\ndigits:: If specified and less than the number of significant digits of\nthe result, the result is rounded to that number of digits, according to\nBigDecimal.mode.\n\nIf digits is 0, the result is the same as the / operator. If not, the\nresult is an integer BigDecimal, by analogy with Float#div.\n\nThe alias quo is provided since div(value, 0) is the same as computing\nthe quotient; see divmod.\n
remainder BigDecimal.remainder(p1)\nReturns the remainder from dividing by the value.\n\nx.remainder(y) means x-y*(x/y).truncate\n
round BigDecimal.round(p1 = v1, p2 = v2)\nRound to the nearest 1 (by default), returning the result as a BigDecimal.\n\nBigDecimal('3.14159').round -> 3\n\nBigDecimal('8.7').round -> 9\n\nIf n is specified and positive, the fractional part of the result has no\nmore than that many digits.\n\nIf n is specified and negative, at least that many digits to the left of the\ndecimal point will be 0 in the result.\n\nBigDecimal('3.14159').round(3) -> 3.142\n\nBigDecimal('13345.234').round(-2) -> 13300.0\n\nThe value of the optional mode argument can be used to determine how\nrounding is performed; see BigDecimal.mode.\n
sign BigDecimal.sign()\nReturns the sign of the value.\n\nReturns a positive value if > 0, a negative value if < 0, and a\nzero if == 0.\n\nThe specific value returned indicates the type and sign of the BigDecimal,\nas follows:\n\nBigDecimal::SIGN_NaN:: value is Not a Number\nBigDecimal::SIGN_POSITIVE_ZERO:: value is +0\nBigDecimal::SIGN_NEGATIVE_ZERO:: value is -0\nBigDecimal::SIGN_POSITIVE_INFINITE:: value is +infinity\nBigDecimal::SIGN_NEGATIVE_INFINITE:: value is -infinity\nBigDecimal::SIGN_POSITIVE_FINITE:: value is positive\nBigDecimal::SIGN_NEGATIVE_FINITE:: value is negative\n
split BigDecimal.split()\nSplits a BigDecimal number into four parts, returned as an array of values.\n\nThe first value represents the sign of the BigDecimal, and is -1 or 1, or 0\nif the BigDecimal is Not a Number.\n\nThe second value is a string representing the significant digits of the\nBigDecimal, with no leading zeros.\n\nThe third value is the base used for arithmetic (currently always 10) as an\nInteger.\n\nThe fourth value is an Integer exponent.\n\nIf the BigDecimal can be represented as 0.xxxxxx*10**n, then xxxxxx is the\nstring of significant digits with no leading zeros, and n is the exponent.\n\nFrom these values, you can translate a BigDecimal to a float as follows:\n\n  sign, significant_digits, base, exponent = a.split\n  f = sign * "0.#{significant_digits}".to_f * (base ** exponent)\n\n(Note that the to_f method is provided as a more convenient way to translate\na BigDecimal to a Float.)\n
sqrt BigDecimal.sqrt(p1)\nReturns the square root of the value.\n\nIf n is specified, returns at least that many significant digits.\n
sub BigDecimal.sub(p1, p2)\n\n
to_d BigDecimal.to_d()\nReturns self.\n
to_digits BigDecimal.to_digits()\nConverts a BigDecimal to a String of the form "nnnnnn.mmm".\nThis method is deprecated; use BigDecimal#to_s("F") instead.\n\n    require 'bigdecimal'\n    require 'bigdecimal/util'\n\n    d = BigDecimal.new("3.14")\n    d.to_digits\n => "3.14"\n
to_f BigDecimal.to_f()\nReturns a new Float object having approximately the same value as the\nBigDecimal number. Normal accuracy limits and built-in errors of binary\nFloat arithmetic apply.\n
to_i BigDecimal.to_i()\nReturns the value as an integer (Fixnum or Bignum).\n\nIf the BigNumber is infinity or NaN, raises FloatDomainError.\n
to_int BigDecimal.to_int()\nReturns the value as an integer (Fixnum or Bignum).\n\nIf the BigNumber is infinity or NaN, raises FloatDomainError.\n
to_r BigDecimal.to_r()\nConverts a BigDecimal to a Rational.\n
to_s BigDecimal.to_s(p1 = v1)\nConverts the value to a string.\n\nThe default format looks like  0.xxxxEnn.\n\nThe optional parameter s consists of either an integer; or an optional '+'\nor ' ', followed by an optional number, followed by an optional 'E' or 'F'.\n\nIf there is a '+' at the start of s, positive values are returned with\na leading '+'.\n\nA space at the start of s returns positive values with a leading space.\n\nIf s contains a number, a space is inserted after each group of that many\nfractional digits.\n\nIf s ends with an 'E', engineering notation (0.xxxxEnn) is used.\n\nIf s ends with an 'F', conventional floating point notation is used.\n\nExamples:\n\nBigDecimal.new('-123.45678901234567890').to_s('5F') -> '-123.45678 90123\n45678 9'\n\nBigDecimal.new('123.45678901234567890').to_s('+8F') -> '+123.45678901 23456789'\n\nBigDecimal.new('123.45678901234567890').to_s(' F') -> ' 123.4567890123456789'\n
truncate BigDecimal.truncate(p1 = v1)\nTruncate to the nearest 1, returning the result as a BigDecimal.\n\nBigDecimal('3.14159').truncate -> 3\n\nBigDecimal('8.7').truncate -> 8\n\nIf n is specified and positive, the fractional part of the result has no\nmore than that many digits.\n\nIf n is specified and negative, at least that many digits to the left of the\ndecimal point will be 0 in the result.\n\nBigDecimal('3.14159').truncate(3) -> 3.141\n\nBigDecimal('13345.234').truncate(-2) -> 13300.0\n
zero? BigDecimal.zero?()\nReturns True if the value is zero.\n
new Curses::Window.new(p1, p2, p3, p4)\nContruct a new Curses::Window with constraints of\n+height+ lines, +width+ columns, begin at +top+ line, and begin +left+\nmost column.\n\nA new window using full screen is called as\n     Curses::Window.new(0,0,0,0)\n
addch Curses::Window.addch(p1)\nAdd a character +ch+, with attributes, to the window, then advance the cursor.\n\nsee also the system manual for curs_addch(3)\n
addstr Curses::Window.addstr(p1)\nadd a string of characters +str+, to the window and advance cursor\n
attroff Curses::Window.attroff(p1)\nTurns on the named attributes +attrs+ without affecting any others.\n\nSee also Curses::Window.attrset\n
attron Curses::Window.attron(p1)\nTurns off the named attributes +attrs+\nwithout turning any other attributes on or off.\n\nSee also Curses::Window.attrset\n
attrset Curses::Window.attrset(p1)\nSets the current attributes of the given window to +attrs+.\n\nThe following video attributes, defined in <curses.h>, can\nbe passed to the routines Curses::Window.attron, Curses::Window.attroff,\nand Curses::Window.attrset, or OR'd with the characters passed to addch.\n  A_NORMAL        Normal display (no highlight)\n  A_STANDOUT      Best highlighting mode of the terminal.\n  A_UNDERLINE     Underlining\n  A_REVERSE       Reverse video\n  A_BLINK         Blinking\n  A_DIM           Half bright\n  A_BOLD          Extra bright or bold\n  A_PROTECT       Protected mode\n  A_INVIS         Invisible or blank mode\n  A_ALTCHARSET    Alternate character set\n  A_CHARTEXT      Bit-mask to extract a character\n  COLOR_PAIR(n)   Color-pair number n\n\nTODO: provide some examples here.\n\nsee also system manual curs_attr(3)\n
begx Curses::Window.begx()\nA getter for the beginning column (X coord) of the window\n
begy Curses::Window.begy()\nA getter for the beginning line (Y coord) of the window\n
bkgd Curses::Window.bkgd(p1)\nSet the background of the current window\nand apply character Integer +ch+ to every character.\n\nsee also Curses.bkgd\n
bkgdset Curses::Window.bkgdset(p1)\nManipulate the background of the current window\nwith character Integer +ch+\n\nsee also Curses.bkgdset\n
box Curses::Window.box(p1, p2, p3 = v3)\nset the characters to frame the window in.\nThe vertical +vert+ and horizontal +hor+ character.\n\n     win = Curses::Window.new(5,5,5,5)\n     win.box(?|, ?-)\n
clear Curses::Window.clear()\nClear the window.\n
close Curses::Window.close()\nDeletes the window, and frees the memory\n
clrtoeol Curses::Window.clrtoeol()\nClear the window to the end of line, that the cursor is currently on.\n
color_set Curses::Window.color_set(p1)\nSets the current color of the given window to the\nforeground/background combination described by the Fixnum +col+.\n
curx Curses::Window.curx()\nA getter for the current column (X coord) of the window\n
cury Curses::Window.cury()\nA getter for the current line (Y coord) of the window\n
delch Curses::Window.delch()\nDelete the character under the cursor\n
deleteln Curses::Window.deleteln()\nDelete the line under the cursor.\n
getbkgd Curses::Window.getbkgd()\nReturns an Interer (+ch+) for the character property in the current window.\n
getch Curses::Window.getch()\nRead and returns a character from the window.\n\nSee Curses::Key to all the function KEY_* available\n
getstr Curses::Window.getstr()\nThis is equivalent to a series f Curses::Window.getch calls\n
idlok Curses::Window.idlok(p1)\nIf +bool+ is +true+ curses considers using the hardware insert/delete\nline feature of terminals so equipped.\n\nIf +bool+ is +false+, disables use of line insertion and deletion.\nThis option should be enabled only if the application needs insert/delete\nline, for example, for a screen editor.\n\nIt is disabled by default because insert/delete line tends to be visually\nannoying when used in applications where it is not really needed.\nIf insert/delete line cannot be used, curses redraws the changed portions\nof all lines.\n
inch Curses::Window.inch()\nReturns the character at the current position of the window.\n
insch Curses::Window.insch(p1)\nInsert a character +ch+, before the cursor, in the current window\n
insertln Curses::Window.insertln()\nInserts a line above the cursor, and the bottom line is lost\n
keypad Curses::Window.keypad(p1)\nEnables the keypad of the user's terminal.\n\nIf enabled (+bool+ is +true+), the user can press a function key\n(such as an arrow key) and wgetch returns a single value representing\nthe function key, as in KEY_LEFT.  If disabled (+bool+ is +false+),\ncurses does not treat function keys specially and the program has to\ninterpret the escape sequences itself.  If the keypad in the terminal\ncan be turned on (made to transmit) and off (made to work locally),\nturning on this option causes the terminal keypad to be turned on when\nCurses::Window.getch is called.\n\nThe default value for keypad is false.\n
keypad= Curses::Window.keypad=(p1)\nEnables the keypad of the user's terminal.\n\nIf enabled (+bool+ is +true+), the user can press a function key\n(such as an arrow key) and wgetch returns a single value representing\nthe function key, as in KEY_LEFT.  If disabled (+bool+ is +false+),\ncurses does not treat function keys specially and the program has to\ninterpret the escape sequences itself.  If the keypad in the terminal\ncan be turned on (made to transmit) and off (made to work locally),\nturning on this option causes the terminal keypad to be turned on when\nCurses::Window.getch is called.\n\nThe default value for keypad is false.\n
maxx Curses::Window.maxx()\nA getter for the maximum columns for the window\n
maxy Curses::Window.maxy()\nA getter for the maximum lines for the window\n
move Curses::Window.move(p1, p2)\nMoves the window so that the upper left-hand corner is at position (+y+, +x+)\n
nodelay= Curses::Window.nodelay=(p1)\nCauses Curses::Window.getch to be a non-blocking call.  If no input is ready,\ngetch returns ERR.\n\nIf disabled (+bool+ is +false+), Curses::Window.getch waits until a key\nis pressed.\n
noutrefresh Curses::Window.noutrefresh()\nRefreshes the windows and lines.\n\nCurses::Window.noutrefresh allows multiple updates with\nmore efficiency than Curses::Window.refresh alone.\n
refresh Curses::Window.refresh()\nRefreshes the windows and lines.\n
resize Curses::Window.resize(p1, p2)\nResize the current window to Fixnum +lines+ and Fixnum +cols+\n
scrl Curses::Window.scrl(p1)\nScrolls the current window Fixnum +num+ lines.\nThe current cursor position is not changed.\n\nFor positive +num+, it scrolls up.\n\nFor negative +num+, it scrolls down.\n
scroll Curses::Window.scroll()\nScrolls the current window up one line.\n
scrollok Curses::Window.scrollok(p1)\nControls what happens when the cursor of a window\nis moved off the edge of the window or scrolling region,\neither as a result of a newline action on the bottom line,\nor typing the last character of the last line.\n\nIf disabled, (+bool+ is false), the cursor is left on the bottom line.\n\nIf enabled, (+bool+ is true), the window is scrolled up one line\n(Note that to get the physical scrolling effect on the terminal,\nit is also necessary to call Curses::Window.idlok)\n
setpos Curses::Window.setpos(p1, p2)\nA setter for the position of the cursor\nin the current window,\nusing coordinates +x+ and +y+\n
setscrreg Curses::Window.setscrreg(p1, p2)\nSet a software scrolling region in a window.\n+top+ and +bottom+ are lines numbers of the margin.\n\nIf this option and Curses::Window.scrollok are enabled, an attempt to move\noff the bottom margin line causes all lines in the scrolling region to\nscroll one line in the direction of the first line.  Only the text of the\nwindow is scrolled.\n
standend Curses::Window.standend()\nEnables the Normal display (no highlight)\n\nThis is equivalent to Curses::Window.attron(A_NORMAL)\n\nsee also Curses::Window.attrset\n
standout Curses::Window.standout()\nEnables the best highlighting mode of the terminal.\n\nThis is equivalent to Curses::Window.attron(A_STANDOUT)\n\nsee also Curses::Window.attrset\n
subwin Curses::Window.subwin(p1, p2, p3, p4)\nContruct a new subwindow with constraints of\n+height+ lines, +width+ columns, begin at +top+ line, and begin +left+\nmost column.\n
timeout= Curses::Window.timeout=(p1)\nSets block and non-blocking reads for the window.\n- If delay is negative, blocking read is used (i.e., waits indefinitely\nfor input).\n- If delay is zero, then non-blocking read is used (i.e., read returns ERR\nif no input is waiting).\n- If delay is positive, then read blocks for delay milliseconds, and returns\nERR if there is still no input.\n
_strptime DateTime._strptime(*args)\nParses the given representation of date and time with the given\ntemplate, and returns a hash of parsed elements.\n\n See also strptime(3) and strftime.\n
civil DateTime.civil(p1 = v1, p2 = v2, p3 = v3, p4 = v4, p5 = v5, p6 = v6, p7 =\nv7, p8 = v8)\nCreates a date-time object denoting the given calendar date.\n\nFor example:\n\n   DateTime.new(2001,2,3)    #=> #<DateTime: 2001-02-03T00:00:00+00:00 ...>\n   DateTime.new(2001,2,3,4,5,6,'+7')\n=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>\n   DateTime.new(2001,-11,-26,-20,-55,-54,'+7')\n=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>\n
commercial DateTime.commercial(p1 = v1, p2 = v2, p3 = v3, p4 = v4, p5 = v5, p6 = v6,\np7 = v7, p8 = v8)\nCreates a date-time object denoting the given week date.\n\nFor example:\n\n   DateTime.commercial(2001) #=> #<DateTime: 2001-01-01T00:00:00+00:00 ...>\n   DateTime.commercial(2002) #=> #<DateTime: 2001-12-31T00:00:00+00:00 ...>\n   DateTime.commercial(2001,5,6,4,5,6,'+7')\n=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>\n
httpdate DateTime.httpdate(p1 = v1, p2 = v2)\nCreates a new Date object by parsing from a string according to\nsome RFC 2616 format.\n\nFor example:\n\n   DateTime.httpdate('Sat, 03 Feb 2001 04:05:06 GMT')\n=> #<DateTime: 2001-02-03T04:05:06+00:00 ...>\n
iso8601 DateTime.iso8601(p1 = v1, p2 = v2)\nCreates a new Date object by parsing from a string according to\nsome typical ISO 8601 formats.\n\nFor example:\n\n   DateTime.iso8601('2001-02-03T04:05:06+07:00')\n=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>\n   DateTime.iso8601('20010203T040506+0700')\n=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>\n   DateTime.iso8601('2001-W05-6T04:05:06+07:00')\n=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>\n
jd DateTime.jd(p1 = v1, p2 = v2, p3 = v3, p4 = v4, p5 = v5, p6 = v6)\nCreates a datetime object denoting the given chronological Julian\nday number.\n\nFor example:\n\n   DateTime.jd(2451944)      #=> #<DateTime: 2001-02-03T00:00:00+00:00 ...>\n   DateTime.jd(2451945)      #=> #<DateTime: 2001-02-04T00:00:00+00:00 ...>\n   DateTime.jd(Rational('0.5'))\n=> #<DateTime: -4712-01-01T12:00:00+00:00 ...>\n
jisx0301 DateTime.jisx0301(p1 = v1, p2 = v2)\nCreates a new Date object by parsing from a string according to\nsome typical JIS X 0301 formats.\n\nFor example:\n\n   DateTime.jisx0301('H13.02.03T04:05:06+07:00')\n=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>\n
json_create DateTime.json_create(object)\nDeserializes JSON string by converting year <tt>y</tt>, month <tt>m</tt>,\nday <tt>d</tt>, hour <tt>H</tt>, minute <tt>M</tt>, second <tt>S</tt>,\noffset <tt>of</tt> and Day of Calendar Reform <tt>sg</tt> to DateTime.\n
new DateTime.new(p1 = v1, p2 = v2, p3 = v3, p4 = v4, p5 = v5, p6 = v6, p7 = v7,\np8 = v8)\nCreates a date-time object denoting the given calendar date.\n\nFor example:\n\n   DateTime.new(2001,2,3)    #=> #<DateTime: 2001-02-03T00:00:00+00:00 ...>\n   DateTime.new(2001,2,3,4,5,6,'+7')\n=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>\n   DateTime.new(2001,-11,-26,-20,-55,-54,'+7')\n=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>\n
now DateTime.now(p1 = v1)\nCreates a date-time object denoting the present time.\n\nFor example:\n\n   DateTime.now              #=> #<DateTime: 2011-06-11T21:20:44+09:00 ...>\n
ordinal DateTime.ordinal(p1 = v1, p2 = v2, p3 = v3, p4 = v4, p5 = v5, p6 = v6, p7 = v7)\nCreates a date-time object denoting the given ordinal date.\n\nFor example:\n\n   DateTime.ordinal(2001,34) #=> #<DateTime: 2001-02-03T00:00:00+00:00 ...>\n   DateTime.ordinal(2001,34,4,5,6,'+7')\n=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>\n   DateTime.ordinal(2001,-332,-20,-55,-54,'+7')\n=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>\n
parse DateTime.parse(p1 = v1, p2 = v2, p3 = v3)\nParses the given representation of date and time, and creates a\ndate object.\n\nIf the optional second argument is true and the detected year is in\nthe range "00" to "99", makes it full.\n\nFor example:\n\n   DateTime.parse('2001-02-03T04:05:06+07:00')\n=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>\n   DateTime.parse('20010203T040506+0700')\n=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>\n   DateTime.parse('3rd Feb 2001 04:05:06 PM')\n=> #<DateTime: 2001-02-03T16:05:06+00:00 ...>\n
rfc2822 DateTime.rfc2822(p1 = v1, p2 = v2)\nCreates a new Date object by parsing from a string according to\nsome typical RFC 2822 formats.\n\nFor example:\n\n    DateTime.rfc2822('Sat, 3 Feb 2001 04:05:06 +0700')\n=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>\n
rfc3339 DateTime.rfc3339(p1 = v1, p2 = v2)\nCreates a new Date object by parsing from a string according to\nsome typical RFC 3339 formats.\n\nFor example:\n\n   DateTime.rfc3339('2001-02-03T04:05:06+07:00')\n=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>\n
rfc822 DateTime.rfc822(p1 = v1, p2 = v2)\nCreates a new Date object by parsing from a string according to\nsome typical RFC 2822 formats.\n\nFor example:\n\n    DateTime.rfc2822('Sat, 3 Feb 2001 04:05:06 +0700')\n=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>\n
strptime DateTime.strptime(p1 = v1, p2 = v2, p3 = v3)\nParses the given representation of date and time with the given\ntemplate, and creates a date object.\n\nFor example:\n\n   DateTime.strptime('2001-02-03T04:05:06+07:00', '%Y-%m-%dT%H:%M:%S%z')\n=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>\n   DateTime.strptime('03-02-2001 04:05:06 PM', '%d-%m-%Y %I:%M:%S %p')\n=> #<DateTime: 2001-02-03T16:05:06+00:00 ...>\n   DateTime.strptime('2001-W05-6T04:05:06+07:00', '%G-W%V-%uT%H:%M:%S%z')\n=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>\n   DateTime.strptime('2001 04 6 04 05 06 +7', '%Y %U %w %H %M %S %z')\n=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>\n   DateTime.strptime('2001 05 6 04 05 06 +7', '%Y %W %u %H %M %S %z')\n=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>\n   DateTime.strptime('-1', '%s')\n=> #<DateTime: 1969-12-31T23:59:59+00:00 ...>\n   DateTime.strptime('-1000', '%Q')\n=> #<DateTime: 1969-12-31T23:59:59+00:00 ...>\n   DateTime.strptime('sat3feb014pm+7', '%a%d%b%y%H%p%z')\n=> #<DateTime: 2001-02-03T16:00:00+07:00 ...>\n\nSee also strptime(3) and strftime.\n
xmlschema DateTime.xmlschema(p1 = v1, p2 = v2)\nCreates a new Date object by parsing from a string according to\nsome typical XML Schema formats.\n\nFor example:\n\n   DateTime.xmlschema('2001-02-03T04:05:06+07:00')\n=> #<DateTime: 2001-02-03T04:05:06+07:00 ...>\n
as_json DateTime.as_json(*)\nReturns a hash, that will be turned into a JSON object and represent this\nobject.\n
iso8601 DateTime.iso8601(p1 = v1)\nThis method is equivalent to strftime('%FT%T').  The optional\nargument n is length of fractional seconds.\n\nFor example:\n\n   DateTime.parse('2001-02-03T04:05:06.123456789+07:00').iso8601(9)\n=> "2001-02-03T04:05:06.123456789+07:00"\n
jisx0301 DateTime.jisx0301(p1 = v1)\nReturns a string in a JIS X 0301 format.  The optional argument n\nis length of fractional seconds.\n\nFor example:\n\n   DateTime.parse('2001-02-03T04:05:06.123456789+07:00').jisx0301(9)\n=> "H13.02.03T04:05:06.123456789+07:00"\n
rfc3339 DateTime.rfc3339(*args)\nThis method is equivalent to strftime('%FT%T').  The optional\nargument n is length of fractional seconds.\n\nFor example:\n\n   DateTime.parse('2001-02-03T04:05:06.123456789+07:00').rfc3339(9)\n=> "2001-02-03T04:05:06.123456789+07:00"\n
strftime DateTime.strftime(*args)\n Formats date according to the directives in the given format\n string.\n The directives begins with a percent (%) character.\n Any text not listed as a directive will be passed through to the\n output string.\n\n The directive consists of a percent (%) character,\n zero or more flags, optional minimum field width,\n optional modifier and a conversion specifier\n as follows.\n\n   %<flags><width><modifier><conversion>\n\n Flags:\n   -  don't pad a numerical output.\n   _  use spaces for padding.\n   0  use zeros for padding.\n   ^  upcase the result string.\n  change case.\n   :  use colons for %z.\n\n The minimum field width specifies the minimum width.\n\n The modifier is "E" and "O".\n They are ignored.\n\n Format directives:\n\n   Date (Year, Month, Day):\n     %Y - Year with century (can be negative, 4 digits at least)\n             -0001, 0000, 1995, 2009, 14292, etc.\n     %C - year / 100 (round down.  20 in 2009)\n     %y - year % 100 (00..99)\n\n     %m - Month of the year, zero-padded (01..12)\n             %_m  blank-padded ( 1..12)\n             %-m  no-padded (1..12)\n     %B - The full month name (``January'')\n             %^B  uppercased (``JANUARY'')\n     %b - The abbreviated month name (``Jan'')\n             %^b  uppercased (``JAN'')\n     %h - Equivalent to %b\n\n     %d - Day of the month, zero-padded (01..31)\n             %-d  no-padded (1..31)\n     %e - Day of the month, blank-padded ( 1..31)\n\n     %j - Day of the year (001..366)\n\n   Time (Hour, Minute, Second, Subsecond):\n     %H - Hour of the day, 24-hour clock, zero-padded (00..23)\n     %k - Hour of the day, 24-hour clock, blank-padded ( 0..23)\n     %I - Hour of the day, 12-hour clock, zero-padded (01..12)\n     %l - Hour of the day, 12-hour clock, blank-padded ( 1..12)\n     %P - Meridian indicator, lowercase (``am'' or ``pm'')\n     %p - Meridian indicator, uppercase (``AM'' or ``PM'')\n\n     %M - Minute of the hour (00..59)\n\n     %S - Second of the minute (00..59)\n\n     %L - Millisecond of the second (000..999)\n     %N - Fractional seconds digits, default is 9 digits (nanosecond)\n             %3N  millisecond (3 digits)\n             %6N  microsecond (6 digits)\n             %9N  nanosecond (9 digits)\n             %12N picosecond (12 digits)\n\n   Time zone:\n     %z - Time zone as hour and minute offset from UTC (e.g. +0900)\n             %:z - hour and minute offset from UTC with a colon (e.g. +09:00)\n             %::z - hour, minute and second offset from UTC (e.g. +09:00:00)\n             %:::z - hour, minute and second offset from UTC\n                                               (e.g. +09, +09:30, +09:30:30)\n     %Z - Time zone abbreviation name\n\n   Weekday:\n     %A - The full weekday name (``Sunday'')\n             %^A  uppercased (``SUNDAY'')\n     %a - The abbreviated name (``Sun'')\n             %^a  uppercased (``SUN'')\n     %u - Day of the week (Monday is 1, 1..7)\n     %w - Day of the week (Sunday is 0, 0..6)\n\n   ISO 8601 week-based year and week number:\n   The week 1 of YYYY starts with a Monday and includes YYYY-01-04.\n   The days in the year before the first week are in the last week of\n   the previous year.\n     %G - The week-based year\n     %g - The last 2 digits of the week-based year (00..99)\n     %V - Week number of the week-based year (01..53)\n\n   Week number:\n   The week 1 of YYYY starts with a Sunday or Monday (according to %U\n   or %W).  The days in the year before the first week are in week 0.\n     %U - Week number of the year.  The week starts with Sunday.  (00..53)\n     %W - Week number of the year.  The week starts with Monday.  (00..53)\n\n   Seconds since the Unix Epoch:\n     %s - Number of seconds since 1970-01-01 00:00:00 UTC.\n     %Q - Number of milliseconds since 1970-01-01 00:00:00 UTC.\n\n   Literal string:\n     %n - Newline character (\\n)\n     %t - Tab character (\t)\n     %% - Literal ``%'' character\n\n   Combination:\n     %c - date and time (%a %b %e %T %Y)\n     %D - Date (%m/%d/%y)\n     %F - The ISO 8601 date format (%Y-%m-%d)\n     %v - VMS date (%e-%b-%Y)\n     %x - Same as %D\n     %X - Same as %T\n     %r - 12-hour time (%I:%M:%S %p)\n     %R - 24-hour time (%H:%M)\n     %T - 24-hour time (%H:%M:%S)\n     %+ - date(1) (%a %b %e %H:%M:%S %Z %Y)\n\n This method is similar to strftime() function defined in ISO C and POSIX.\n Several directives (%a, %A, %b, %B, %c, %p, %r, %x, %X, %E*, %O* and %Z)\n are locale dependent in the function.\n However this method is locale independent.\n So, the result may differ even if a same format string is used in other\n systems such as C.\n It is good practice to avoid %x and %X because there are corresponding\n locale independent representations, %D and %T.\n\n Examples:\n\n   d = DateTime.new(2007,11,19,8,37,48,"-06:00")\n=> #<DateTime: 2007-11-19T08:37:48-0600 ...>\n   d.strftime("Printed on %m/%d/%Y")   #=> "Printed on 11/19/2007"\n   d.strftime("at %I:%M%p")            #=> "at 08:37AM"\n\n Various ISO 8601 formats:\n   %Y%m%d           => 20071119                  Calendar date (basic)\n   %F               => 2007-11-19                Calendar date (extended)\n   %Y-%m            => 2007-11                   Calendar date, reduced\n   accuracy, specific month\n   %Y               => 2007                      Calendar date, reduced\n   accuracy, specific year\n   %C               => 20                        Calendar date, reduced\n   accuracy, specific century\n   %Y%j             => 2007323                   Ordinal date (basic)\n   %Y-%j            => 2007-323                  Ordinal date (extended)\n   %GW%V%u          => 2007W471                  Week date (basic)\n   %G-W%V-%u        => 2007-W47-1                Week date (extended)\n   %GW%V            => 2007W47                   Week date, reduced accuracy,\n   specific week (basic)\n   %G-W%V           => 2007-W47                  Week date, reduced accuracy,\n   specific week (extended)\n   %H%M%S           => 083748                    Local time (basic)\n   %T               => 08:37:48                  Local time (extended)\n   %H%M             => 0837                      Local time, reduced accuracy,\n   specific minute (basic)\n   %H:%M            => 08:37                     Local time, reduced accuracy,\n   specific minute (extended)\n   %H               => 08                        Local time, reduced accuracy,\n   specific hour\n   %H%M%S,%L        => 083748,000                Local time with decimal\n   fraction, comma as decimal sign (basic)\n   %T,%L            => 08:37:48,000              Local time with decimal\n   fraction, comma as decimal sign (extended)\n   %H%M%S.%L        => 083748.000                Local time with decimal\n   fraction, full stop as decimal sign (basic)\n   %T.%L            => 08:37:48.000              Local time with decimal\n   fraction, full stop as decimal sign (extended)\n   %H%M%S%z         => 083748-0600               Local time and the difference\n   from UTC (basic)\n   %T%:z            => 08:37:48-06:00            Local time and the difference\n   from UTC (extended)\n   %Y%m%dT%H%M%S%z  => 20071119T083748-0600      Date and time of day for\n   calendar date (basic)\n   %FT%T%:z         => 2007-11-19T08:37:48-06:00 Date and time of day for\n   calendar date (extended)\n   %Y%jT%H%M%S%z    => 2007323T083748-0600       Date and time of day for\n   ordinal date (basic)\n   %Y-%jT%T%:z      => 2007-323T08:37:48-06:00   Date and time of day for\n   ordinal date (extended)\n   %GW%V%uT%H%M%S%z => 2007W471T083748-0600      Date and time of day for\n   week date (basic)\n   %G-W%V-%uT%T%:z  => 2007-W47-1T08:37:48-06:00 Date and time of day for\n   week date (extended)\n   %Y%m%dT%H%M      => 20071119T0837             Calendar date and local time\n   (basic)\n   %FT%R            => 2007-11-19T08:37          Calendar date and local time\n   (extended)\n   %Y%jT%H%MZ       => 2007323T0837Z             Ordinal date and UTC of day\n   (basic)\n   %Y-%jT%RZ        => 2007-323T08:37Z           Ordinal date and UTC of day\n   (extended)\n   %GW%V%uT%H%M%z   => 2007W471T0837-0600        Week date and local time\n   and difference from UTC (basic)\n   %G-W%V-%uT%R%:z  => 2007-W47-1T08:37-06:00    Week date and local time\n   and difference from UTC (extended)\n\nSee also strftime(3) and strptime.\n
to_date DateTime.to_date()\nReturns a Date object which denotes self.\n
to_datetime DateTime.to_datetime()\nReturns self.\n
to_json DateTime.to_json(*args)\nStores class name (DateTime) with Julian year <tt>y</tt>, month <tt>m</tt>,\nday <tt>d</tt>, hour <tt>H</tt>, minute <tt>M</tt>, second <tt>S</tt>,\noffset <tt>of</tt> and Day of Calendar Reform <tt>sg</tt> as JSON string\n
to_s DateTime.to_s()\nReturns a string in an ISO 8601 format (This method doesn't use the\nexpanded representations).\n\nFor example:\n\n    DateTime.new(2001,2,3,4,5,6,'-7').to_s\n=> "2001-02-03T04:05:06-07:00"\n
to_time DateTime.to_time()\nReturns a Time object which denotes self.\n
xmlschema DateTime.xmlschema(p1 = v1)\nThis method is equivalent to strftime('%FT%T').  The optional\nargument n is length of fractional seconds.\n\nFor example:\n\n   DateTime.parse('2001-02-03T04:05:06.123456789+07:00').iso8601(9)\n=> "2001-02-03T04:05:06.123456789+07:00"\n
new DBM.new(p1, p2 = v2, p3 = v3)\nOpen a dbm database with the specified name, which can include a directory\npath. Any file extensions needed will be supplied automatically by the dbm\nlibrary. For example, Berkeley DB appends '.db', and GNU gdbm uses two\nphysical files with extensions '.dir' and '.pag'.\n\nThe mode should be an integer, as for Unix chmod.\n\nFlags should be one of READER, WRITER, WRCREAT or NEWDB.\n
open DBM.open(*args)\nOpen a dbm database and yields it if a block is given. See also\n`DBM.new`.\n
clear DBM.clear()\nDeletes all data from the database.\n
close DBM.close()\nCloses the database.\n
closed? DBM.closed?()\nReturns true if the database is closed, false otherwise.\n
delete DBM.delete(p1)\nDeletes an entry from the database.\n
delete_if DBM.delete_if()\nDeletes all entries for which the code block returns true.\nReturns self.\n
each DBM.each()\nCalls the block once for each [key, value] pair in the database.\nReturns self.\n
each_key DBM.each_key()\nCalls the block once for each key string in the database. Returns self.\n
each_pair DBM.each_pair()\nCalls the block once for each [key, value] pair in the database.\nReturns self.\n
each_value DBM.each_value()\nCalls the block once for each value string in the database. Returns self.\n
empty? DBM.empty?()\nReturns true if the database is empty, false otherwise.\n
fetch DBM.fetch(p1, p2 = v2)\nReturn a value from the database by locating the key string\nprovided.  If the key is not found, returns +ifnone+. If +ifnone+\nis not given, raises IndexError.\n
has_key? DBM.has_key?(p1)\nReturns true if the database contains the specified key, false otherwise.\n
has_value? DBM.has_value?(p1)\nReturns true if the database contains the specified string value, false\notherwise.\n
include? DBM.include?(p1)\nReturns true if the database contains the specified key, false otherwise.\n
invert DBM.invert()\nReturns a Hash (not a DBM database) created by using each value in the\ndatabase as a key, with the corresponding key as its value.\n
key DBM.key(p1)\nReturns the key for the specified value.\n
key? DBM.key?(p1)\nReturns true if the database contains the specified key, false otherwise.\n
keys DBM.keys()\nReturns an array of all the string keys in the database.\n
length DBM.length()\nReturns the number of entries in the database.\n
member? DBM.member?(p1)\nReturns true if the database contains the specified key, false otherwise.\n
reject DBM.reject()\nConverts the contents of the database to an in-memory Hash, then calls\nHash#reject with the specified code block, returning a new Hash.\n
reject! DBM.reject!()\nDeletes all entries for which the code block returns true.\nReturns self.\n
replace DBM.replace(p1)\nReplaces the contents of the database with the contents of the specified\nobject. Takes any object which implements the each_pair method, including\nHash and DBM objects.\n
select DBM.select()\nReturns a new array consisting of the [key, value] pairs for which the code\nblock returns true.\n
shift DBM.shift()\nRemoves a [key, value] pair from the database, and returns it.\nIf the database is empty, returns nil.\nThe order in which values are removed/returned is not guaranteed.\n
size DBM.size()\nReturns the number of entries in the database.\n
store DBM.store(p1, p2)\nStores the specified string value in the database, indexed via the\nstring key provided.\n
to_a DBM.to_a()\nConverts the contents of the database to an array of [key, value] arrays,\nand returns it.\n
to_hash DBM.to_hash()\nConverts the contents of the database to an in-memory Hash object, and\nreturns it.\n
update DBM.update(p1)\nUpdates the database with multiple values from the specified object.\nTakes any object which implements the each_pair method, including\nHash and DBM objects.\n
value? DBM.value?(p1)\nReturns true if the database contains the specified string value, false\notherwise.\n
values DBM.values()\nReturns an array of all the string values in the database.\n
values_at DBM.values_at(*args)\nReturns an array containing the values associated with the given keys.\n
base64digest Digest::Class.base64digest(str, *args)\nReturns the base64 encoded hash value of a given _string_.  The\nreturn value is properly padded with '=' and contains no line\nfeeds.\n
digest Digest::Class.digest(*args)\nReturns the hash value of a given _string_.  This is equivalent to\nDigest::Class.new(*parameters).digest(string), where extra\n_parameters_, if any, are passed through to the constructor and the\n_string_ is passed to #digest().\n
file Digest::Class.file(name)\ncreates a digest object and reads a given file, _name_.\n\n  p Digest::SHA256.file("X11R6.8.2-src.tar.bz2").hexdigest\n => "f02e3c85572dc9ad7cb77c2a638e3be24cc1b5bea9fdbb0b0299c9668475c534"\n
hexdigest Digest::Class.hexdigest(*args)\nReturns the hex-encoded hash value of a given _string_.  This is\nalmost equivalent to\nDigest.hexencode(Digest::Class.new(*parameters).digest(string)).\n
new Digest::HMAC.new(key, digester)\nCreates a Digest::HMAC instance.\n
block_length Digest::HMAC.block_length()\nReturns the block length in bytes of the hmac.\n
digest_length Digest::HMAC.digest_length()\nReturns the length in bytes of the hash value of the digest.\n
inspect Digest::HMAC.inspect()\nCreates a printable version of the hmac object.\n
reset Digest::HMAC.reset()\nResets the hmac to the initial state and returns self.\n
update Digest::HMAC.update(text)\nUpdates the hmac using a given +string+ and returns self.\n
last_error DL::CFunc.last_error()\nReturns the last error for the current executing thread\n
new DL::CFunc.new(p1, p2 = v2, p3 = v3, p4 = v4)\nCreate a new function that points to +address+ with an optional return type\nof +type+, a name of +name+ and a calltype of +calltype+.\n
win32_last_error DL::CFunc.win32_last_error()\nReturns the last win32 error for the current executing thread\n
call DL::CFunc.call(p1)\nCalls the function pointer passing in +ary+ as values to the underlying\nC function.  The return value depends on the ctype.\n
calltype DL::CFunc.calltype()\nGet the call type of this function.\n
calltype= DL::CFunc.calltype=(p1)\nSet the call type for this function.\n
ctype DL::CFunc.ctype()\nGet the C function return value type.  See DL for a list of constants\ncorresponding to this method's return value.\n
ctype= DL::CFunc.ctype=(p1)\nSet the C function return value type to +type+.\n
inspect DL::CFunc.inspect()\nReturns a string formatted with an easily readable representation of the\ninternal state of the DL::CFunc\n
name DL::CFunc.name()\nGet the name of this function\n
ptr DL::CFunc.ptr()\nGet the underlying function pointer as a DL::CPtr object.\n
ptr= DL::CFunc.ptr=(p1)\nSet the underlying function pointer to a DL::CPtr named +pointer+.\n
to_i DL::CFunc.to_i()\nReturns the memory location of this function pointer as an integer.\n
to_s DL::CFunc.to_s()\nReturns a string formatted with an easily readable representation of the\ninternal state of the DL::CFunc\n
malloc DL::CPtr.malloc(p1, p2 = v2)\nAllocate +size+ bytes of memory and associate it with an optional\n+freefunc+ that will be called when the pointer is garbage collected.\n+freefunc+ must be an address pointing to a function or an instance of\nDL::CFunc\n
new DL::CPtr.new(p1, p2 = v2, p3 = v3)\nCreate a new pointer to +address+ with an optional +size+ and +freefunc+.\n+freefunc+ will be called when the instance is garbage collected.\n
to_ptr DL::CPtr.to_ptr(p1)\nGet the underlying pointer for ruby object +val+ and return it as a\nDL::CPtr object.\n
eql? DL::CPtr.eql?(p1)\nReturns true if +other+ wraps the same pointer, otherwise returns\nfalse.\n
free DL::CPtr.free()\nGet the free function for this pointer.  Returns  DL::CFunc or nil.\n
free= DL::CPtr.free=(p1)\nSet the free function for this pointer to the DL::CFunc in +function+.\n
inspect DL::CPtr.inspect()\nReturns a string formatted with an easily readable representation of the\ninternal state of the DL::CPtr\n
null? DL::CPtr.null?()\nReturns true if this is a null pointer.\n
ptr DL::CPtr.ptr()\nReturns a DL::CPtr that is a dereferenced pointer for this DL::CPtr.\nAnalogous to the star operator in C.\n
ref DL::CPtr.ref()\nReturns a DL::CPtr that is a reference pointer for this DL::CPtr.\nAnalogous to the ampersand operator in C.\n
size DL::CPtr.size()\nGet the size of this pointer.\n
size= DL::CPtr.size=(p1)\nSet the size of this pointer to +size+\n
to_i DL::CPtr.to_i()\nReturns the integer memory location of this DL::CPtr.\n
to_int DL::CPtr.to_int()\nReturns the integer memory location of this DL::CPtr.\n
to_s DL::CPtr.to_s(p1 = v1)\nReturns the pointer contents as a string.  When called with no arguments,\nthis method will return the contents until the first NULL byte.  When\ncalled with +len+, a string of +len+ bytes will be returned.\n
to_str DL::CPtr.to_str(p1 = v1)\nReturns the pointer contents as a string.  When called with no arguments,\nthis method will return the contents with the length of this pointer's\n+size+. When called with +len+, a string of +len+ bytes will be returned.\n
to_value DL::CPtr.to_value()\nCast this CPtr to a ruby object.\n
new DL::Handle.new(p1 = v1, p2 = v2)\nCreate a new handler that opens library named +lib+ with +flags+.  If no\nlibrary is specified, RTLD_DEFAULT is used.\n
sym DL::Handle.sym(p1)\nDocument-method: []\n\nGet the address as an Integer for the function named +name+.\n
close DL::Handle.close()\nClose this DL::Handle.  Calling close more than once will raise a\nDL::DLError exception.\n
close_enabled? DL::Handle.close_enabled?()\nReturns +true+ if dlclose() will be called when this DL::Handle is\ngarbage collected.\n
disable_close DL::Handle.disable_close()\nDisable a call to dlclose() when this DL::Handle is garbage collected.\n
enable_close DL::Handle.enable_close()\nEnable a call to dlclose() when this DL::Handle is garbage collected.\n
sym DL::Handle.sym(p1)\nDocument-method: []\n\nGet the address as an Integer for the function named +name+.\n
to_i DL::Handle.to_i()\nReturns the memory address for this handle.\n
new DL::CompositeHandler.new(handlers)\n\n
handlers DL::CompositeHandler.handlers()\n\n
sym DL::CompositeHandler.sym(symbol)\n\n
entity_class DL::CStruct.entity_class()\n\n
entity_class DL::CUnion.entity_class()\n\n
malloc DL::CStructEntity.malloc(types, func = nil)\n\n
new DL::CStructEntity.new(addr, types, func = nil)\n\n
size DL::CStructEntity.size(types)\n\n
assign_names DL::CStructEntity.assign_names(members)\n\n
set_ctypes DL::CStructEntity.set_ctypes(types)\n\n
to_s DL::CStructEntity.to_s()\n\n
malloc DL::CUnionEntity.malloc(types, func=nil)\n\n
size DL::CUnionEntity.size(types)\n\n
set_ctypes DL::CUnionEntity.set_ctypes(types)\n\n
new DL::Packer.new(types)\n\n
pack DL::Packer.pack(ary)\n\n
size DL::Packer.size()\n\n
unpack DL::Packer.unpack(ary)\n\n
new DL::Function.new(cfunc, argtypes, abi = nil, &block)\n\n
bind DL::Function.bind(&block)\n\n
bind_at_call DL::Function.bind_at_call(&block)\n\n
bound? DL::Function.bound?()\n\n
call DL::Function.call(*args, &block)\n\n
name DL::Function.name()\n\n
to_i DL::Function.to_i()\n\n
unbind DL::Function.unbind()\n\n
unbind_at_call DL::Function.unbind_at_call()\n\n
wrap_result DL::Function.wrap_result(r)\n\n
bind_at_call DL::TempFunction.bind_at_call(&block)\n\n
unbind_at_call DL::TempFunction.unbind_at_call()\n\n
new DL::CarriedFunction.new(cfunc, argtypes, n)\n\n
bind_at_call DL::CarriedFunction.bind_at_call(&block)\n\n
create_carrier DL::CarriedFunction.create_carrier(data)\n\n
new DL::Stack.new(types)\n\n
pack DL::Stack.pack(ary)\n\n
size DL::Stack.size()\n\n
types DL::Stack.types()\n\n
unpack DL::Stack.unpack(ary)\n\n
new Win32API.new(dllname, func, import, export = "0", calltype = :stdcall)\n\n
Call Win32API.Call(*args)\n\n
call Win32API.call(*args)\n\n
create Win32::Registry.create(hkey, subkey, desired = KEY_ALL_ACCESS, opt =\nREG_OPTION_RESERVED)\n--- Registry.create(key, subkey, desired = KEY_ALL_ACCESS, opt =\nREG_OPTION_RESERVED)\n\n--- Registry.create(key, subkey, desired = KEY_ALL_ACCESS, opt =\nREG_OPTION_RESERVED) { |reg| ... }\n\nCreate or open the registry key subkey under key.\nYou can use predefined key HKEY_* (see Constants)\n\nIf subkey is already exists, key is opened and Registry#created?\nmethod will return false.\n\nIf block is given, the key is closed automatically.\n
expand_environ Win32::Registry.expand_environ(str)\nReplace %\w+% into the environment value of what is contained between the %'s\nThis method is used for REG_EXPAND_SZ.\n\nFor detail, see\nexpandEnvironmentStrings[http://msdn.microsoft.com/library/en-us/sysinfo/base/expandenvironmentstrings.asp]\n\Win32 \API.\n
new Win32::Registry.new(hkey, parent, keyname, disposition)\ninitialize\n
open Win32::Registry.open(hkey, subkey, desired = KEY_READ, opt =\nREG_OPTION_RESERVED)\n--- Registry.open(key, subkey, desired = KEY_READ, opt = REG_OPTION_RESERVED)\n\n--- Registry.open(key, subkey, desired = KEY_READ, opt = REG_OPTION_RESERVED)\n{ |reg| ... }\n\nOpen the registry key subkey under key.\nkey is Win32::Registry object of parent key.\nYou can use predefined key HKEY_* (see Constants)\ndesired and opt is access mask and key option.\nFor detail, see the\nMSDN[http://msdn.microsoft.com/library/en-us/sysinfo/base/regopenkeyex.asp].\nIf block is given, the key is closed automatically.\n
time2wtime Win32::Registry.time2wtime(time)\nConvert Time object or Integer object into 64-bit FILETIME.\n
type2name Win32::Registry.type2name(type)\nConvert registry type value to readable string.\n
wtime2time Win32::Registry.wtime2time(wtime)\nConvert 64-bit FILETIME integer into Time object.\n
_dump Win32::Registry._dump(depth)\nmarshalling is not allowed\n
close Win32::Registry.close()\nClose key.\n\nAfter close, most method raise an error.\n
create Win32::Registry.create(subkey, desired = KEY_ALL_ACCESS, opt =\nREG_OPTION_RESERVED, &blk)\nSame as Win32::Registry.create (self, subkey, desired, opt)\n
created? Win32::Registry.created?()\nReturns if key is created ((*newly*)).\n(see Registry.create) -- basically you call create\nthen when you call created? on the instance returned\nit will tell if it was successful or not\n
delete Win32::Registry.delete(name)\n\n
delete_key Win32::Registry.delete_key(name, recursive = false)\nDelete a subkey named name and all its values.\n\nIf recursive is false, the subkey must not have subkeys.\nOtherwise, this method deletes all subkeys and values recursively.\n
delete_value Win32::Registry.delete_value(name)\nDelete a registry value named name.\nWe can not delete the `default' value.\n
each Win32::Registry.each()\n\n
each_key Win32::Registry.each_key()\nEnumerate subkeys.\n\nsubkey is String which contains name of subkey.\nwtime is last write time as FILETIME (64-bit integer).\n(see Registry.wtime2time)\n
each_value Win32::Registry.each_value()\nEnumerate values.\n
flush Win32::Registry.flush()\nWrite all the attributes into the registry file.\n
info Win32::Registry.info()\nReturns key information as Array of:\n:num_keys\n  The number of subkeys.\n:max_key_length\n  Maximum length of name of subkeys.\n:num_values\n  The number of values.\n:max_value_name_length\n  Maximum length of name of values.\n:max_value_length\n  Maximum length of value of values.\n:descriptor_length\n  Length of security descriptor.\n:wtime\n  Last write time as FILETIME(64-bit integer)\n\nFor detail, see\nRegQueryInfoKey[http://msdn.microsoft.com/library/en-us/sysinfo/base/regqueryinfokey.asp]\nWin32 API.\n
inspect Win32::Registry.inspect()\n\n
keys Win32::Registry.keys()\nreturn keys as an array\n
name Win32::Registry.name()\nFull path of key such as 'HKEY_CURRENT_USER\SOFTWARE\foo\bar'.\n
open Win32::Registry.open(subkey, desired = KEY_READ, opt = REG_OPTION_RESERVED,\n&blk)\nSame as Win32::Registry.open (self, subkey, desired, opt)\n
open? Win32::Registry.open?()\nReturns if key is not closed.\n
read Win32::Registry.read(name, *rtype)\nRead a registry value named name and return array of\n[ type, data ].\nWhen name is nil, the `default' value is read.\ntype is value type. (see Win32::Registry::Constants module)\ndata is value data, its class is:\n:REG_SZ, REG_EXPAND_SZ\n   String\n:REG_MULTI_SZ\n   Array of String\n:REG_DWORD, REG_DWORD_BIG_ENDIAN, REG_QWORD\n   Integer\n:REG_BINARY\n   String (contains binary data)\n\nWhen rtype is specified, the value type must be included by\nrtype array, or TypeError is raised.\n
read_bin Win32::Registry.read_bin(name)\nRead a REG_SZ(read_s), REG_DWORD(read_i), or REG_BINARY(read_bin)\nregistry value named name.\n\nIf the values type does not match, TypeError is raised.\n
read_i Win32::Registry.read_i(name)\nRead a REG_SZ(read_s), REG_DWORD(read_i), or REG_BINARY(read_bin)\nregistry value named name.\n\nIf the values type does not match, TypeError is raised.\n
read_s Win32::Registry.read_s(name)\nRead a REG_SZ(read_s), REG_DWORD(read_i), or REG_BINARY(read_bin)\nregistry value named name.\n\nIf the values type does not match, TypeError is raised.\n
read_s_expand Win32::Registry.read_s_expand(name)\nRead a REG_SZ or REG_EXPAND_SZ registry value named name.\n\nIf the value type is REG_EXPAND_SZ, environment variables are replaced.\nUnless the value type is REG_SZ or REG_EXPAND_SZ, TypeError is raised.\n
write Win32::Registry.write(name, type, data)\nWrite data to a registry value named name.\nWhen name is nil, write to the `default' value.\n\ntype is type value. (see Registry::Constants module)\nClass of data must be same as which #read\nmethod returns.\n
write_bin Win32::Registry.write_bin(name, value)\nWrite value to a registry value named name.\n\nThe value type is REG_SZ(write_s), REG_DWORD(write_i), or\nREG_BINARY(write_bin).\n
write_i Win32::Registry.write_i(name, value)\nWrite value to a registry value named name.\n\nThe value type is REG_SZ(write_s), REG_DWORD(write_i), or\nREG_BINARY(write_bin).\n
write_s Win32::Registry.write_s(name, value)\nWrite value to a registry value named name.\n\nThe value type is REG_SZ(write_s), REG_DWORD(write_i), or\nREG_BINARY(write_bin).\n
new Win32::Registry::Error.new(code)\n\n
new Win32::Registry::PredefinedKey.new(hkey, keyname)\n\n
class Win32::Registry::PredefinedKey.class()\nFake #class method for Registry#open, Registry#create\n
close Win32::Registry::PredefinedKey.close()\nPredefined keys cannot be closed\n
lower Win32::SSPI::SecurityHandle.lower()\n\n
to_p Win32::SSPI::SecurityHandle.to_p()\n\n
upper Win32::SSPI::SecurityHandle.upper()\n\n
to_p Win32::SSPI::TimeStamp.to_p()\n\n
new Win32::SSPI::SecurityBuffer.new(buffer = nil)\n\n
bufferSize Win32::SSPI::SecurityBuffer.bufferSize()\n\n
bufferType Win32::SSPI::SecurityBuffer.bufferType()\n\n
to_p Win32::SSPI::SecurityBuffer.to_p()\n\n
token Win32::SSPI::SecurityBuffer.token()\n\n
new Win32::SSPI::Identity.new(user = nil, domain = nil, password = nil)\n\n
to_p Win32::SSPI::Identity.to_p()\n\n
new Win32::SSPI::SSPIResult.new(value)\n\n
ok? Win32::SSPI::SSPIResult.ok?()\n\n
to_s Win32::SSPI::SSPIResult.to_s()\n\n
new Win32::SSPI::NegotiateAuth.new(user = nil, domain = nil)\nCreates a new instance ready for authentication as the given user in the\ngiven domain.\nDefaults to current user and domain as defined by ENV["USERDOMAIN"] and\nENV["USERNAME"] if\nno arguments are supplied.\n
proxy_auth_get Win32::SSPI::NegotiateAuth.proxy_auth_get(http, path, user = nil, domain = nil)\nGiven a connection and a request path, performs authentication as the current\nuser and returns\nthe response from a GET request. The connnection should be a Net::HTTP object,\nand it should\nhave been constructed using the Net::HTTP.Proxy method, but anything that\nresponds to "get" will work.\nIf a user and domain are given, will authenticate as the given user.\nReturns the response received from the get method (usually Net::HTTPResponse)\n
complete_authentication Win32::SSPI::NegotiateAuth.complete_authentication(token)\nTakes a token and gets the next token in the Negotiate authentication\nchain. Token can be Base64 encoded or not.\nThe token can include the "Negotiate" header and it will be stripped.\nDoes not indicate if SEC_I_CONTINUE or SEC_E_OK was returned.\nToken returned is Base64 encoded w/ all new lines removed.\n
get_initial_token Win32::SSPI::NegotiateAuth.get_initial_token()\nGets the initial Negotiate token. Returns it as a base64 encoded string\nsuitable for use in HTTP. Can\nbe easily decoded, however.\n
new Fiddle::Closure.new(p1, p2, p3 = v3)\nConstruct a new Closure object.\n\n* +ret+ is the C type to be returned\n* +args+ are passed the callback\n* +abi+ is the abi of the closure\n\nIf there is an error in preparing the ffi_cif or ffi_prep_closure,\nthen a RuntimeError will be raised.\n
to_i Fiddle::Closure.to_i()\nReturns the memory address for this closure\n
new Fiddle::Function.new(p1, p2, p3, p4 = v4)\nConstructs a Function object.\n* +ptr+ is a referenced function, of a DL::Handle\n* +args+ is an Array of arguments, passed to the +ptr+ function\n* +ret_type+ is the return type of the function\n* +abi+ is the ABI of the function\n
call Fiddle::Function.call(*args)\nCalls the constructed Function, with +args+\n\nFor an example see Fiddle::Function\n
new Fiddle::Closure::BlockCaller.new(ctype, args, abi = Fiddle::Function::DEFAULT,\n&block)\n== Description\n\nConstruct a new BlockCaller object.\n\n* +ctype+ is the C type to be returned\n* +args+ are passed the callback\n* +abi+ is the abi of the closure\n\nIf there is an error in preparing the +ffi_cif+ or +ffi_prep_closure+,\nthen a RuntimeError will be raised.\n\n== Example\n\n  include Fiddle\n\n  cb = Closure::BlockCaller.new(TYPE_INT, [TYPE_INT]) do |one|\n    one\n  end\n\n  func = Function.new(cb, [TYPE_INT], TYPE_INT)\n
call Fiddle::Closure::BlockCaller.call(*args)\nCalls the constructed BlockCaller, with +args+\n\nFor an example see Fiddle::Closure::BlockCaller.new\n
malloc Fiddle::Pointer.malloc(p1, p2 = v2)\nAllocate +size+ bytes of memory and associate it with an optional\n+freefunc+ that will be called when the pointer is garbage collected.\n+freefunc+ must be an address pointing to a function or an instance of\nDL::CFunc\n
new Fiddle::Pointer.new(p1, p2 = v2, p3 = v3)\nCreate a new pointer to +address+ with an optional +size+ and +freefunc+.\n+freefunc+ will be called when the instance is garbage collected.\n
to_ptr Fiddle::Pointer.to_ptr(p1)\nGet the underlying pointer for ruby object +val+ and return it as a\nDL::CPtr object.\n
eql? Fiddle::Pointer.eql?(p1)\nReturns true if +other+ wraps the same pointer, otherwise returns\nfalse.\n
free Fiddle::Pointer.free()\nGet the free function for this pointer.  Returns  DL::CFunc or nil.\n
free= Fiddle::Pointer.free=(p1)\nSet the free function for this pointer to the DL::CFunc in +function+.\n
inspect Fiddle::Pointer.inspect()\nReturns a string formatted with an easily readable representation of the\ninternal state of the DL::CPtr\n
null? Fiddle::Pointer.null?()\nReturns true if this is a null pointer.\n
ptr Fiddle::Pointer.ptr()\nReturns a DL::CPtr that is a dereferenced pointer for this DL::CPtr.\nAnalogous to the star operator in C.\n
ref Fiddle::Pointer.ref()\nReturns a DL::CPtr that is a reference pointer for this DL::CPtr.\nAnalogous to the ampersand operator in C.\n
size Fiddle::Pointer.size()\nGet the size of this pointer.\n
size= Fiddle::Pointer.size=(p1)\nSet the size of this pointer to +size+\n
to_i Fiddle::Pointer.to_i()\nReturns the integer memory location of this DL::CPtr.\n
to_int Fiddle::Pointer.to_int()\nReturns the integer memory location of this DL::CPtr.\n
to_s Fiddle::Pointer.to_s(p1 = v1)\nReturns the pointer contents as a string.  When called with no arguments,\nthis method will return the contents until the first NULL byte.  When\ncalled with +len+, a string of +len+ bytes will be returned.\n
to_str Fiddle::Pointer.to_str(p1 = v1)\nReturns the pointer contents as a string.  When called with no arguments,\nthis method will return the contents with the length of this pointer's\n+size+. When called with +len+, a string of +len+ bytes will be returned.\n
to_value Fiddle::Pointer.to_value()\nCast this CPtr to a ruby object.\n
new GDBM.new(p1, p2 = v2, p3 = v3)\nCreates a new GDBM instance by opening a gdbm file named _filename_.\nIf the file does not exist, a new file with file mode _mode_ will be\ncreated. _flags_ may be one of the following:\n* *READER*  - open as a reader\n* *WRITER*  - open as a writer\n* *WRCREAT* - open as a writer; if the database does not exist, create a\nnew one\n* *NEWDB*   - open as a writer; overwrite any existing databases\n\nThe values *WRITER*, *WRCREAT* and *NEWDB* may be combined with the following\nvalues by bitwise or:\n* *SYNC*    - cause all database operations to be synchronized to the disk\n* *NOLOCK*  - do not lock the database file\n\nIf no _flags_ are specified, the GDBM object will try to open the database\nfile as a writer and will create it if it does not already exist\n(cf. flag <tt>WRCREAT</tt>). If this fails (for instance, if another process\nhas already opened the database as a reader), it will try to open the\ndatabase file as a reader (cf. flag <tt>READER</tt>).\n
open GDBM.open(*args)\nIf called without a block, this is synonymous to GDBM::new.\nIf a block is given, the new GDBM instance will be passed to the block\nas a parameter, and the corresponding database file will be closed\nafter the execution of the block code has been finished.\n\nExample for an open call with a block:\n\n  require 'gdbm'\n  GDBM.open("fruitstore.db") do |gdbm|\n    gdbm.each_pair do |key, value|\n      print "#{key}: #{value}\\n"\n    end\n  end\n
cachesize= GDBM.cachesize=(p1)\nSets the size of the internal bucket cache to _size_.\n
clear GDBM.clear()\nRemoves all the key-value pairs within _gdbm_.\n
close GDBM.close()\nCloses the associated database file.\n
closed? GDBM.closed?()\nReturns true if the associated database file has been closed.\n
delete GDBM.delete(p1)\nRemoves the key-value-pair with the specified _key_ from this database and\nreturns the corresponding _value_. Returns nil if the database is empty.\n
delete_if GDBM.delete_if()\nDeletes every key-value pair from _gdbm_ for which _block_ evaluates to true.\n
each GDBM.each()\nExecutes _block_ for each key in the database, passing the _key_ and the\ncorrespoding _value_ as a parameter.\n
each_key GDBM.each_key()\nExecutes _block_ for each key in the database, passing the\n_key_ as a parameter.\n
each_pair GDBM.each_pair()\nExecutes _block_ for each key in the database, passing the _key_ and the\ncorrespoding _value_ as a parameter.\n
each_value GDBM.each_value()\nExecutes _block_ for each key in the database, passing the corresponding\n_value_ as a parameter.\n
empty? GDBM.empty?()\nReturns true if the database is empty.\n
fastmode= GDBM.fastmode=(p1)\nTurns the database's fast mode on or off. If fast mode is turned on, gdbm\ndoes not wait for writes to be flushed to the disk before continuing.\n\nThis option is obsolete for gdbm >= 1.8 since fast mode is turned on by\ndefault. See also: #syncmode=\n
fetch GDBM.fetch(p1, p2 = v2)\nRetrieves the _value_ corresponding to _key_. If there is no value\nassociated with _key_, _default_ will be returned instead.\n
has_key? GDBM.has_key?(p1)\nReturns true if the given key _k_ exists within the database.\nReturns false otherwise.\n
has_value? GDBM.has_value?(p1)\nReturns true if the given value _v_ exists within the database.\nReturns false otherwise.\n
include? GDBM.include?(p1)\nReturns true if the given key _k_ exists within the database.\nReturns false otherwise.\n
invert GDBM.invert()\nReturns a hash created by using _gdbm_'s values as keys, and the keys\nas values.\n
key GDBM.key(p1)\nReturns the _key_ for a given _value_. If several keys may map to the\nsame value, the key that is found first will be returned.\n
key? GDBM.key?(p1)\nReturns true if the given key _k_ exists within the database.\nReturns false otherwise.\n
keys GDBM.keys()\nReturns an array of all keys of this database.\n
length GDBM.length()\nReturns the number of key-value pairs in this database.\n
member? GDBM.member?(p1)\nReturns true if the given key _k_ exists within the database.\nReturns false otherwise.\n
reject GDBM.reject()\nReturns a hash copy of _gdbm_ where all key-value pairs from _gdbm_ for\nwhich _block_ evaluates to true are removed. See also: #delete_if\n
reject! GDBM.reject!()\nDeletes every key-value pair from _gdbm_ for which _block_ evaluates to true.\n
reorganize GDBM.reorganize()\nReorganizes the database file. This operation removes reserved space of\nelements that have already been deleted. It is only useful after a lot of\ndeletions in the database.\n
replace GDBM.replace(p1)\nReplaces the content of _gdbm_ with the key-value pairs of _other_.\n_other_ must have an each_pair method.\n
select GDBM.select()\nReturns a new array of all key-value pairs of the database for which _block_\nevaluates to true.\n
shift GDBM.shift()\nRemoves a key-value-pair from this database and returns it as a\ntwo-item array [ _key_, _value_ ]. Returns nil if the database is empty.\n
size GDBM.size()\nReturns the number of key-value pairs in this database.\n
store GDBM.store(p1, p2)\nAssociates the value _value_ with the specified _key_.\n
sync GDBM.sync()\nUnless the _gdbm_ object has been opened with the *SYNC* flag, it is not\nguarenteed that database modification operations are immediately applied to\nthe database file. This method ensures that all recent modifications\nto the database are written to the file. Blocks until all writing operations\nto the disk have been finished.\n
syncmode= GDBM.syncmode=(p1)\nTurns the database's synchronization mode on or off. If the synchronization\nmode is turned on, the database's in-memory state will be synchronized to\ndisk after every database modification operation. If the synchronization\nmode is turned off, GDBM does not wait for writes to be flushed to the disk\nbefore continuing.\n\nThis option is only available for gdbm >= 1.8 where syncmode is turned off\nby default. See also: #fastmode=\n
to_a GDBM.to_a()\nReturns an array of all key-value pairs contained in the database.\n
to_hash GDBM.to_hash()\nReturns a hash of all key-value pairs contained in the database.\n
update GDBM.update(p1)\nAdds the key-value pairs of _other_ to _gdbm_, overwriting entries with\nduplicate keys with those from _other_. _other_ must have an each_pair\nmethod.\n
value? GDBM.value?(p1)\nReturns true if the given value _v_ exists within the database.\nReturns false otherwise.\n
values GDBM.values()\nReturns an array of all values of this database.\n
values_at GDBM.values_at(*args)\nReturns an array of the values associated with each specified _key_.\n
charset_map Iconv.charset_map()\nReturns the map from canonical name to system dependent name.\n
conv Iconv.conv(p1, p2, p3)\nShorthand for\n  Iconv.iconv(to, from, str).join\nSee Iconv.iconv.\n
ctlmethods Iconv.ctlmethods()\nReturns available iconvctl() method list.\n
iconv Iconv.iconv(*args)\nShorthand for\n  Iconv.open(to, from) { |cd|\n    (strs + [nil]).collect { |s| cd.iconv(s) }\n  }\n\n=== Parameters\n\n<tt>to, from</tt>:: see Iconv.new\n<tt>strs</tt>:: strings to be converted\n\n=== Exceptions\n\nExceptions thrown by Iconv.new, Iconv.open and Iconv#iconv.\n
list Iconv.list()\nIterates each alias sets.\n
new Iconv.new(p1, p2, p3 = v3)\nCreates new code converter from a coding-system designated with +from+\nto another one designated with +to+.\n\n=== Parameters\n\n+to+::   encoding name for destination\n+from+:: encoding name for source\n+options+:: options for converter\n\n=== Exceptions\n\nTypeError::       if +to+ or +from+ aren't String\nInvalidEncoding:: if designated converter couldn't find out\nSystemCallError:: if <tt>iconv_open(3)</tt> fails\n
open Iconv.open(p1, p2, p3 = v3)\nEquivalent to Iconv.new except that when it is called with a block, it\nyields with the new instance and closes it, and returns the result which\nreturned from the block.\n
close Iconv.close()\nFinishes conversion.\n\nAfter calling this, calling Iconv#iconv will cause an exception, but\nmultiple calls of #close are guaranteed to end successfully.\n\nReturns a string containing the byte sequence to change the output buffer to\nits initial shift state.\n
conv Iconv.conv(*args)\nEquivalent to\n\n  iconv(nil, str..., nil).join\n
discard_ilseq= Iconv.discard_ilseq=(p1)\nSets discard_ilseq flag.\n
discard_ilseq? Iconv.discard_ilseq?()\nReturns discard_ilseq flag.\n
iconv Iconv.iconv(p1, p2 = v2, p3 = v3)\nConverts string and returns the result.\n* If +str+ is a String, converts <tt>str[start, length]</tt> and returns\nthe converted string.\n* If +str+ is +nil+, places converter itself into initial shift state and\n  just returns a string containing the byte sequence to change the output\n  buffer to its initial shift state.\n* Otherwise, raises an exception.\n\n=== Parameters\n\nstr::    string to be converted, or nil\nstart::  starting offset\nlength:: conversion length; nil or -1 means whole the string from start\n\n=== Exceptions\n\n* IconvIllegalSequence\n* IconvInvalidCharacter\n* IconvOutOfRange\n\n=== Examples\n\nSee the Iconv documentation.\n
transliterate= Iconv.transliterate=(p1)\nSets transliterate flag.\n
transliterate? Iconv.transliterate?()\nReturns transliterate flag.\n
trivial? Iconv.trivial?()\nReturns trivial flag.\n
new OpenSSL::X509::ExtensionFactory.new(p1 = v1, p2 = v2, p3 = v3, p4 = v4)\n\n
config= OpenSSL::X509::ExtensionFactory.config=(p1)\n\n
create_ext OpenSSL::X509::ExtensionFactory.create_ext(p1, p2, p3 = v3)\nArray to X509_EXTENSION\nStructure:\n["ln", "value", bool_critical] or\n["sn", "value", bool_critical] or\n["ln", "critical,value"] or the same for sn\n["ln", "value"] => not critical\n
create_ext_from_array OpenSSL::X509::ExtensionFactory.create_ext_from_array(ary)\n\n
create_ext_from_hash OpenSSL::X509::ExtensionFactory.create_ext_from_hash(hash)\n\n
create_ext_from_string OpenSSL::X509::ExtensionFactory.create_ext_from_string(str)\n\n
create_extension OpenSSL::X509::ExtensionFactory.create_extension(*arg)\n\n
crl= OpenSSL::X509::ExtensionFactory.crl=(p1)\n\n
issuer_certificate= OpenSSL::X509::ExtensionFactory.issuer_certificate=(p1)\n\n
subject_certificate= OpenSSL::X509::ExtensionFactory.subject_certificate=(p1)\n\n
subject_request= OpenSSL::X509::ExtensionFactory.subject_request=(p1)\n\n
new OpenSSL::X509::Extension.new(p1, p2 = v2, p3 = v3)\nCreates an X509 extension.\n\nThe extension may be created from +asn1+ data or from an extension +name+\nand +value+.  The +name+ may be either an OID or an extension name.  If\n+critical+ is true the extension is marked critical.\n
critical= OpenSSL::X509::Extension.critical=(p1)\n\n
critical? OpenSSL::X509::Extension.critical?()\n\n
oid OpenSSL::X509::Extension.oid()\n\n
oid= OpenSSL::X509::Extension.oid=(p1)\n\n
to_a OpenSSL::X509::Extension.to_a()\n\n
to_der OpenSSL::X509::Extension.to_der()\n\n
to_h OpenSSL::X509::Extension.to_h()\n\n
to_s OpenSSL::X509::Extension.to_s()\n\n
value OpenSSL::X509::Extension.value()\n\n
value= OpenSSL::X509::Extension.value=(p1)\n\n
new OpenSSL::X509::Name.new(p1 = v1, p2 = v2)\n\n
parse OpenSSL::X509::Name.parse(str, template=OBJECT_TYPE_TEMPLATE)\n\n
parse_openssl OpenSSL::X509::Name.parse_openssl(str, template=OBJECT_TYPE_TEMPLATE)\n\n
parse_rfc2253 OpenSSL::X509::Name.parse_rfc2253(str, template=OBJECT_TYPE_TEMPLATE)\n\n
add_entry OpenSSL::X509::Name.add_entry(p1, p2, p3 = v3)\n\n
cmp OpenSSL::X509::Name.cmp(p1)\nCompares this Name with +other+ and returns 0 if they are the same and -1 or\n+1 if they are greater or less than each other respectively.\n
eql? OpenSSL::X509::Name.eql?(p1)\n\n
hash OpenSSL::X509::Name.hash()\nThe hash value returned is suitable for use as a certificate's filename in\na CA path.\n
hash_old OpenSSL::X509::Name.hash_old()\nhash_old returns MD5 based hash used in OpenSSL 0.9.X.\n
to_a OpenSSL::X509::Name.to_a()\n\n
to_der OpenSSL::X509::Name.to_der()\n\n
to_s OpenSSL::X509::Name.to_s(p1 = v1)\n\n
cleanup OpenSSL::X509::StoreContext.cleanup()\n\n
ciphers OpenSSL::Cipher.ciphers()\nReturns the names of all available ciphers in an array.\n
new OpenSSL::Cipher.new(p1)\nThe string must contain a valid cipher name like "AES-128-CBC" or "3DES".\n\nA list of cipher names is available by calling OpenSSL::Cipher.ciphers.\n
decrypt OpenSSL::Cipher.decrypt(*args)\nInitializes the Cipher for decryption.\n\nMake sure to call Cipher#encrypt or Cipher#decrypt before using any of the\nfollowing methods:\n* [key=, iv=, random_key, random_iv, pkcs5_keyivgen]\n\nInternally calls EVP_CipherInit_ex(ctx, NULL, NULL, NULL, NULL, 0).\n
encrypt OpenSSL::Cipher.encrypt(*args)\nInitializes the Cipher for encryption.\n\nMake sure to call Cipher#encrypt or Cipher#decrypt before using any of the\nfollowing methods:\n* [key=, iv=, random_key, random_iv, pkcs5_keyivgen]\n\nInternally calls EVP_CipherInit_ex(ctx, NULL, NULL, NULL, NULL, 1).\n
final OpenSSL::Cipher.final()\nReturns the remaining data held in the cipher object.  Further calls to\nCipher#update or Cipher#final will return garbage.\n\nSee EVP_CipherFinal_ex for further information.\n
iv= OpenSSL::Cipher.iv=(p1)\nSets the cipher IV. Please note that since you should never be using ECB\nmode, an IV is always explicitly required and should be set prior to\nencryption. The IV itself can be safely transmitted in public, but it\nshould be unpredictable to prevent certain kinds of attacks. You may use\nCipher#random_iv to create a secure random IV.\n\nOnly call this method after calling Cipher#encrypt or Cipher#decrypt.\n\nIf not explicitly set, the OpenSSL default of an all-zeroes ("\\0") IV is\nused.\n
key= OpenSSL::Cipher.key=(p1)\nSets the cipher key. To generate a key, you should either use a secure\nrandom byte string or, if the key is to be derived from a password, you\nshould rely on PBKDF2 functionality provided by OpenSSL::PKCS5. To\ngenerate a secure random-based key, Cipher#random_key may be used.\n\nOnly call this method after calling Cipher#encrypt or Cipher#decrypt.\n
key_len= OpenSSL::Cipher.key_len=(p1)\nSets the key length of the cipher.  If the cipher is a fixed length cipher\nthen attempting to set the key length to any value other than the fixed\nvalue is an error.\n\nUnder normal circumstances you do not need to call this method (and probably\nshouldn't).\n\nSee EVP_CIPHER_CTX_set_key_length for further information.\n
name OpenSSL::Cipher.name()\nReturns the name of the cipher which may differ slightly from the original\nname provided.\n
padding= OpenSSL::Cipher.padding=(p1)\nEnables or disables padding. By default encryption operations are padded\nusing standard block padding and the\npadding is checked and removed when decrypting. If the pad parameter is zero\nthen no padding is performed, the\ntotal amount of data encrypted or decrypted must then be a multiple of the\nblock size or an error will occur.\n\nSee EVP_CIPHER_CTX_set_padding for further information.\n
pkcs5_keyivgen OpenSSL::Cipher.pkcs5_keyivgen(p1, p2 = v2, p3 = v3, p4 = v4)\nGenerates and sets the key/IV based on a password.\n\nWARNING: This method is only PKCS5 v1.5 compliant when using RC2, RC4-40,\nor DES with MD5 or SHA1. Using anything else (like AES) will generate the\nkey/iv using an OpenSSL specific method. This method is deprecated and\nshould no longer be used. Use a PKCS5 v2 key generation method from\nOpenSSL::PKCS5 instead.\n\n=== Parameters\n+salt+ must be an 8 byte string if provided.\n+iterations+ is a integer with a default of 2048.\n+digest+ is a Digest object that defaults to 'MD5'\n\nA minimum of 1000 iterations is recommended.\n
random_iv OpenSSL::Cipher.random_iv()\nGenerate, set, and return a random iv.\nYou must call cipher.encrypt or cipher.decrypt before calling this method.\n
random_key OpenSSL::Cipher.random_key()\nGenerate, set, and return a random key.\nYou must call cipher.encrypt or cipher.decrypt before calling this method.\n
reset OpenSSL::Cipher.reset()\nFully resets the internal state of the Cipher. By using this, the same\nCipher instance may be used several times for en- or decryption tasks.\n\nInternally calls EVP_CipherInit_ex(ctx, NULL, NULL, NULL, NULL, -1).\n
update OpenSSL::Cipher.update(p1, p2 = v2)\nEncrypts data in a streaming fashion. Hand consecutive blocks of data\nto the +update+ method in order to encrypt it. Returns the encrypted\ndata chunk. When done, the output of Cipher#final should be additionally\nadded to the result.\n\n=== Parameters\n+data+ is a nonempty string.\n+buffer+ is an optional string to store the result.\n
new OpenSSL::Config.new(filename = nil)\n\n
parse OpenSSL::Config.parse(str)\n\n
parse_config OpenSSL::Config.parse_config(io)\n\n
add_value OpenSSL::Config.add_value(section, key, value)\n\n
data OpenSSL::Config.data()\n\n
each OpenSSL::Config.each()\n\n
get_value OpenSSL::Config.get_value(section, key)\n\n
inspect OpenSSL::Config.inspect()\n\n
section OpenSSL::Config.section(name)\n\n
sections OpenSSL::Config.sections()\n\n
to_s OpenSSL::Config.to_s()\n\n
value OpenSSL::Config.value(arg1, arg2 = nil)\n\n
generate_prime OpenSSL::BN.generate_prime(p1, p2 = v2, p3 = v3, p4 = v4)\n=== Parameters\n* +bits+ - integer\n* +safe+ - boolean\n* +add+ - BN\n* +rem+ - BN\n
new OpenSSL::BN.new(p1, p2 = v2)\n\n
bit_set? OpenSSL::BN.bit_set?(p1)\n\n
coerce OpenSSL::BN.coerce(p1)\n\n
copy OpenSSL::BN.copy(p1)\n\n
eql? OpenSSL::BN.eql?(p1)\n\n
prime? OpenSSL::BN.prime?(p1 = v1)\n=== Parameters\n* +checks+ - integer\n
prime_fasttest? OpenSSL::BN.prime_fasttest?(p1 = v1, p2 = v2)\n=== Parameters\n* +checks+ - integer\n* +trial_div+ - boolean\n
to_bn OpenSSL::BN.to_bn()\n\n
to_i OpenSSL::BN.to_i()\n\n
to_int OpenSSL::BN.to_int()\n\n
to_s OpenSSL::BN.to_s(p1 = v1)\n=== Parameters\n* +base+ - integer\n* * Valid values:\n* * * 0 - MPI\n* * * 2 - binary\n* * * 10 - the default\n* * * 16 - hex\n
digest OpenSSL::Digest.digest(name, data)\nReturn the +data+ hash computed with +name+ Digest. +name+ is either the\nlong name or short name of a supported digest algorithm.\n\n=== Examples\n\n  OpenSSL::Digest.digest("SHA256, "abc")\n\nwhich is equivalent to:\n\n  OpenSSL::Digest::SHA256.digest("abc")\n
new OpenSSL::Digest.new(p1, p2 = v2)\nCreates a Digest instance based on +string+, which is either the ln\n(long name) or sn (short name) of a supported digest algorithm.\nIf +data+ (a +String+) is given, it is used as the initial input to the\nDigest instance, i.e.\n  digest = OpenSSL::Digest.new('sha256', 'digestdata')\nis equal to\n  digest = OpenSSL::Digest.new('sha256')\n  digest.update('digestdata')\n\n=== Example\n  digest = OpenSSL::Digest.new('sha1')\n
block_length OpenSSL::Digest.block_length()\nReturns the block length of the digest algorithm, i.e. the length in bytes\nof an individual block. Most modern algorithms partition a message to be\ndigested into a sequence of fix-sized blocks that are processed\nconsecutively.\n\n=== Example\n  digest = OpenSSL::Digest::SHA1.new\n  puts digest.block_length # => 64\n
digest_length OpenSSL::Digest.digest_length()\nReturns the output size of the digest, i.e. the length in bytes of the\nfinal message digest result.\n\n=== Example\n  digest = OpenSSL::Digest::SHA1.new\n  puts digest.digest_length # => 20\n
name OpenSSL::Digest.name()\nReturns the sn of this Digest instance.\n\n=== Example\n  digest = OpenSSL::Digest::SHA512.new\n  puts digest.name # => SHA512\n
reset OpenSSL::Digest.reset()\nResets the Digest in the sense that any Digest#update that has been\nperformed is abandoned and the Digest is set to its initial state again.\n
update OpenSSL::Digest.update(p1)\nNot every message digest can be computed in one single pass. If a message\ndigest is to be computed from several subsequent sources, then each may\nbe passed individually to the Digest instance.\n\n=== Example\n  digest = OpenSSL::Digest::SHA256.new\n  digest.update('First input')\n  digest << 'Second input' # equivalent to digest.update('Second input')\n  result = digest.digest\n
new OpenSSL::Digest::Digest.new(*args)\n\n
new OpenSSL::SSL::SSLContext.new(p1 = v1)\nYou can get a list of valid methods with OpenSSL::SSL::SSLContext::METHODS\n
ciphers OpenSSL::SSL::SSLContext.ciphers()\nThe list of ciphers configured for this context.\n
ciphers= OpenSSL::SSL::SSLContext.ciphers=(p1)\nSets the list of available ciphers for this context.  Note in a server\ncontext some ciphers require the appropriate certificates.  For example, an\nRSA cipher can only be chosen when an RSA certificate is available.\n\nSee also OpenSSL::Cipher and OpenSSL::Cipher::ciphers\n
flush_sessions OpenSSL::SSL::SSLContext.flush_sessions(p1 = v1)\nRemoves sessions in the internal cache that have expired at +time+.\n
session_add OpenSSL::SSL::SSLContext.session_add(p1)\nAdds +session+ to the session cache\n
session_cache_mode OpenSSL::SSL::SSLContext.session_cache_mode()\nThe current session cache mode.\n
session_cache_mode= OpenSSL::SSL::SSLContext.session_cache_mode=(p1)\nSets the SSL session cache mode.  Bitwise-or together the desired\nSESSION_CACHE_* constants to set.  See SSL_CTX_set_session_cache_mode(3) for\ndetails.\n
session_cache_size OpenSSL::SSL::SSLContext.session_cache_size()\nReturns the current session cache size.  Zero is used to represent an\nunlimited cache size.\n
session_cache_size= OpenSSL::SSL::SSLContext.session_cache_size=(p1)\nSets the session cache size.  Returns the previously valid session cache\nsize.  Zero is used to represent an unlimited session cache size.\n
session_cache_stats OpenSSL::SSL::SSLContext.session_cache_stats()\nReturns a Hash containing the following keys:\n\n:accept:: Number of started SSL/TLS handshakes in server mode\n:accept_good:: Number of established SSL/TLS sessions in server mode\n:accept_renegotiate:: Number of start renegotiations in server mode\n:cache_full:: Number of sessions that were removed due to cache overflow\n:cache_hits:: Number of successfully reused connections\n:cache_misses:: Number of sessions proposed by clients that were not found\n                in the cache\n:cache_num:: Number of sessions in the internal session cache\n:cb_hits:: Number of sessions retrieved from the external cache in server\n           mode\n:connect:: Number of started SSL/TLS handshakes in client mode\n:connect_good:: Number of established SSL/TLS sessions in client mode\n:connect_renegotiate:: Number of start renegotiations in client mode\n:timeouts:: Number of sessions proposed by clients that were found in the\n            cache but had expired due to timeouts\n
session_remove OpenSSL::SSL::SSLContext.session_remove(p1)\nRemoves +session+ from the session cache\n
set_params OpenSSL::SSL::SSLContext.set_params(params={})\n\n
setup OpenSSL::SSL::SSLContext.setup()\nThis method is called automatically when a new SSLSocket is created.\nNormally you do not need to call this method (unless you are writing an\nextension in C).\n
ssl_version= OpenSSL::SSL::SSLContext.ssl_version=(p1)\nYou can get a list of valid versions with OpenSSL::SSL::SSLContext::METHODS\n
new OpenSSL::SSL::SSLSocket.new(p1, p2 = v2)\nCreates a new SSL socket from +io+ which must be a real ruby object (not an\nIO-like object that responds to read/write.\n\nIf +ctx+ is provided the SSL Sockets initial params will be taken from\nthe context.\n\nThe OpenSSL::Buffering module provides additional IO methods.\n\nThis method will freeze the SSLContext if one is provided;\nhowever, session management is still allowed in the frozen SSLContext.\n
accept OpenSSL::SSL::SSLSocket.accept()\nWaits for a SSL/TLS client to initiate a handshake.  The handshake may be\nstarted after unencrypted data has been sent over the socket.\n
accept_nonblock OpenSSL::SSL::SSLSocket.accept_nonblock()\nInitiates the SSL/TLS handshake as a server in non-blocking manner.\n emulates blocking accept\n  begin\n    ssl.accept_nonblock\n  rescue IO::WaitReadable\n    IO.select([s2])\n    retry\n  rescue IO::WaitWritable\n    IO.select(nil, [s2])\n    retry\n  end\n
cert OpenSSL::SSL::SSLSocket.cert()\nThe X509 certificate for this socket endpoint.\n
cipher OpenSSL::SSL::SSLSocket.cipher()\nThe cipher being used for the current connection\n
client_ca OpenSSL::SSL::SSLSocket.client_ca()\nReturns the list of client CAs. Please note that in contrast to\nSSLContext#client_ca= no array of X509::Certificate is returned but\nX509::Name instances of the CA's subject distinguished name.\n\nIn server mode, returns the list set by SSLContext#client_ca=.\nIn client mode, returns the list of client CAs sent from the server.\n
connect OpenSSL::SSL::SSLSocket.connect()\nInitiates an SSL/TLS handshake with a server.  The handshake may be started\nafter unencrypted data has been sent over the socket.\n
connect_nonblock OpenSSL::SSL::SSLSocket.connect_nonblock()\nInitiates the SSL/TLS handshake as a client in non-blocking manner.\n emulates blocking connect\n  begin\n    ssl.connect_nonblock\n  rescue IO::WaitReadable\n    IO.select([s2])\n    retry\n  rescue IO::WaitWritable\n    IO.select(nil, [s2])\n    retry\n  end\n
peer_cert OpenSSL::SSL::SSLSocket.peer_cert()\nThe X509 certificate for this socket's peer.\n
peer_cert_chain OpenSSL::SSL::SSLSocket.peer_cert_chain()\nThe X509 certificate chain for this socket's peer.\n
pending OpenSSL::SSL::SSLSocket.pending()\nThe number of bytes that are immediately available for reading\n
post_connection_check OpenSSL::SSL::SSLSocket.post_connection_check(hostname)\n\n
session OpenSSL::SSL::SSLSocket.session()\n\n
session= OpenSSL::SSL::SSLSocket.session=(p1)\nSets the Session to be used when the connection is established.\n
session_reused? OpenSSL::SSL::SSLSocket.session_reused?()\nReturns true if a reused session was negotiated during the handshake.\n
state OpenSSL::SSL::SSLSocket.state()\nA description of the current connection state.\n
sysclose OpenSSL::SSL::SSLSocket.sysclose()\nShuts down the SSL connection and prepares it for another connection.\n
sysread OpenSSL::SSL::SSLSocket.sysread(*args)\nReads +length+ bytes from the SSL connection.  If a pre-allocated +buffer+\nis provided the data will be written into it.\n
syswrite OpenSSL::SSL::SSLSocket.syswrite(p1)\nWrites +string+ to the SSL connection.\n
verify_result OpenSSL::SSL::SSLSocket.verify_result()\nReturns the result of the peer certificates verification.  See verify(1)\nfor error values and descriptions.\n\nIf no peer certificate was presented X509_V_OK is returned.\n
new OpenSSL::SSL::SSLServer.new(svr, ctx)\n\n
accept OpenSSL::SSL::SSLServer.accept()\n\n
close OpenSSL::SSL::SSLServer.close()\n\n
listen OpenSSL::SSL::SSLServer.listen(backlog=5)\n\n
shutdown OpenSSL::SSL::SSLServer.shutdown(how=Socket::SHUT_RDWR)\n\n
to_io OpenSSL::SSL::SSLServer.to_io()\n\n
new OpenSSL::ASN1::ASN1Data.new(p1, p2, p3)\n+value+: Please have a look at Constructive and Primitive to see how Ruby\ntypes are mapped to ASN.1 types and vice versa.\n\n+tag+: A +Number+ indicating the tag number.\n\n+tag_class+: A +Symbol+ indicating the tag class. Please cf. ASN1 for\npossible values.\n\n== Example\n  asn1_int = OpenSSL::ASN1Data.new(42, 2, :UNIVERSAL) # => Same as\n  OpenSSL::ASN1::Integer.new(42)\n  tagged_int = OpenSSL::ASN1Data.new(42, 0, :CONTEXT_SPECIFIC) # implicitly\n  0-tagged INTEGER\n
to_der OpenSSL::ASN1::ASN1Data.to_der()\nEncodes this ASN1Data into a DER-encoded String value. The result is\nDER-encoded except for the possibility of infinite length encodings.\nInfinite length encodings are not allowed in strict DER, so strictly\nspeaking the result of such an encoding would be a BER-encoding.\n
new OpenSSL::ASN1::Primitive.new(p1, p2 = v2, p3 = v3, p4 = v4)\n+value+: is mandatory.\n\n+tag+: optional, may be specified for tagged values. If no +tag+ is\nspecified, the UNIVERSAL tag corresponding to the Primitive sub-class\nis used by default.\n\n+tagging+: may be used as an encoding hint to encode a value either\nexplicitly or implicitly, see ASN1 for possible values.\n\n+tag_class+: if +tag+ and +tagging+ are +nil+ then this is set to\n+:UNIVERSAL+ by default. If either +tag+ or +tagging+ are set then\n+:CONTEXT_SPECIFIC+ is used as the default. For possible values please\ncf. ASN1.\n\n== Example\n  int = OpenSSL::ASN1::Integer.new(42)\n  zero_tagged_int = OpenSSL::ASN1::Integer.new(42, 0, :IMPLICIT)\n  private_explicit_zero_tagged_int = OpenSSL::ASN1::Integer.new(42, 0,\n  :EXPLICIT, :PRIVATE)\n
to_der OpenSSL::ASN1::Primitive.to_der()\nSee ASN1Data#to_der for details. *\n
new OpenSSL::ASN1::Constructive.new(p1, p2 = v2, p3 = v3, p4 = v4)\n+value+: is mandatory.\n\n+tag+: optional, may be specified for tagged values. If no +tag+ is\nspecified, the UNIVERSAL tag corresponding to the Primitive sub-class\nis used by default.\n\n+tagging+: may be used as an encoding hint to encode a value either\nexplicitly or implicitly, see ASN1 for possible values.\n\n+tag_class+: if +tag+ and +tagging+ are +nil+ then this is set to\n+:UNIVERSAL+ by default. If either +tag+ or +tagging+ are set then\n+:CONTEXT_SPECIFIC+ is used as the default. For possible values please\ncf. ASN1.\n\n== Example\n  int = OpenSSL::ASN1::Integer.new(42)\n  zero_tagged_int = OpenSSL::ASN1::Integer.new(42, 0, :IMPLICIT)\n  private_explicit_zero_tagged_int = OpenSSL::ASN1::Integer.new(42, 0,\n  :EXPLICIT, :PRIVATE)\n
each OpenSSL::ASN1::Constructive.each()\nCalls <i>block</i> once for each element in +self+, passing that element\nas parameter +asn1+. If no block is given, an enumerator is returned\ninstead.\n\n== Example\n  asn1_ary.each do |asn1|\n    puts asn1\n  end\n
to_der OpenSSL::ASN1::Constructive.to_der()\nSee ASN1Data#to_der for details.\n
by_id OpenSSL::Engine.by_id(p1)\n\n
cleanup OpenSSL::Engine.cleanup()\n\n
engines OpenSSL::Engine.engines()\n\n
load OpenSSL::Engine.load(p1 = v1)\n\n
cipher OpenSSL::Engine.cipher(p1)\n\n
cmds OpenSSL::Engine.cmds()\n\n
ctrl_cmd OpenSSL::Engine.ctrl_cmd(p1, p2 = v2)\n\n
digest OpenSSL::Engine.digest(p1)\n\n
finish OpenSSL::Engine.finish()\n\n
id OpenSSL::Engine.id()\n\n
inspect OpenSSL::Engine.inspect()\n\n
load_private_key OpenSSL::Engine.load_private_key(p1 = v1, p2 = v2)\n\n
load_public_key OpenSSL::Engine.load_public_key(p1 = v1, p2 = v2)\n\n
name OpenSSL::Engine.name()\n\n
set_default OpenSSL::Engine.set_default(p1)\n\n
digest OpenSSL::HMAC.digest(p1, p2, p3)\n\n
hexdigest OpenSSL::HMAC.hexdigest(p1, p2, p3)\n\n
new OpenSSL::HMAC.new(p1, p2)\n\n
digest OpenSSL::HMAC.digest()\n\n
hexdigest OpenSSL::HMAC.hexdigest()\n\n
inspect OpenSSL::HMAC.inspect()\n\n
reset OpenSSL::HMAC.reset()\n\n
to_s OpenSSL::HMAC.to_s()\n\n
update OpenSSL::HMAC.update(p1)\n\n
new OpenSSL::Netscape::SPKI.new(p1 = v1)\n\n
challenge OpenSSL::Netscape::SPKI.challenge()\n\n
challenge= OpenSSL::Netscape::SPKI.challenge=(p1)\n\n
public_key OpenSSL::Netscape::SPKI.public_key()\n\n
public_key= OpenSSL::Netscape::SPKI.public_key=(p1)\n\n
sign OpenSSL::Netscape::SPKI.sign(p1, p2)\n\n
to_der OpenSSL::Netscape::SPKI.to_der()\n\n
to_pem OpenSSL::Netscape::SPKI.to_pem()\n\n
to_s OpenSSL::Netscape::SPKI.to_s()\n\n
to_text OpenSSL::Netscape::SPKI.to_text()\n\n
verify OpenSSL::Netscape::SPKI.verify(p1)\nChecks that cert signature is made with PRIVversion of this PUBLIC 'key'\n
new OpenSSL::OCSP::Request.new(p1 = v1)\n\n
add_certid OpenSSL::OCSP::Request.add_certid(p1)\n\n
add_nonce OpenSSL::OCSP::Request.add_nonce(p1 = v1)\n\n
certid OpenSSL::OCSP::Request.certid()\n\n
check_nonce OpenSSL::OCSP::Request.check_nonce(p1)\nCheck nonce validity in a request and response.\nReturn value reflects result:\n 1: nonces present and equal.\n 2: nonces both absent.\n 3: nonce present in response only.\n 0: nonces both present and not equal.\n-1: nonce in request only.\n\n For most responders clients can check return > 0.\n If responder doesn't handle nonces return != 0 may be\n necessary. return == 0 is always an error.\n
sign OpenSSL::OCSP::Request.sign(p1, p2, p3 = v3, p4 = v4)\n\n
to_der OpenSSL::OCSP::Request.to_der()\n\n
verify OpenSSL::OCSP::Request.verify(p1, p2, p3 = v3)\n\n
create OpenSSL::OCSP::Response.create(p1, p2)\nOCSP::Response\n
new OpenSSL::OCSP::Response.new(p1 = v1)\n\n
basic OpenSSL::OCSP::Response.basic()\n\n
status OpenSSL::OCSP::Response.status()\n\n
status_string OpenSSL::OCSP::Response.status_string()\n\n
to_der OpenSSL::OCSP::Response.to_der()\n\n
new OpenSSL::OCSP::BasicResponse.new(*args)\n\n
add_nonce OpenSSL::OCSP::BasicResponse.add_nonce(p1 = v1)\n\n
add_status OpenSSL::OCSP::BasicResponse.add_status(p1, p2, p3, p4, p5, p6, p7)\n\n
copy_nonce OpenSSL::OCSP::BasicResponse.copy_nonce(p1)\n\n
sign OpenSSL::OCSP::BasicResponse.sign(p1, p2, p3 = v3, p4 = v4)\n\n
status OpenSSL::OCSP::BasicResponse.status()\n\n
verify OpenSSL::OCSP::BasicResponse.verify(p1, p2, p3 = v3)\n\n
new OpenSSL::OCSP::CertificateId.new(p1, p2, p3 = v3)\n\n
cmp OpenSSL::OCSP::CertificateId.cmp(p1)\n\n
cmp_issuer OpenSSL::OCSP::CertificateId.cmp_issuer(p1)\n\n
serial OpenSSL::OCSP::CertificateId.serial()\n\n
create OpenSSL::PKCS12.create(p1, p2, p3, p4, p5 = v5, p6 = v6, p7 = v7, p8 = v8,\np9 = v9, p10 = v10)\n=== Parameters\n* +pass+ - string\n* +name+ - A string describing the key.\n* +key+ - Any PKey.\n* +cert+ - A X509::Certificate.\n* * The public_key portion of the certificate must contain a valid public key.\n* * The not_before and not_after fields must be filled in.\n* +ca+ - An optional array of X509::Certificate's.\n* +key_pbe+ - string\n* +cert_pbe+ - string\n* +key_iter+ - integer\n* +mac_iter+ - integer\n* +keytype+ - An integer representing an MSIE specific extension.\n\nAny optional arguments may be supplied as nil to preserve the OpenSSL defaults.\n\nSee the OpenSSL documentation for PKCS12_create().\n
new OpenSSL::PKCS12.new(p1 = v1, p2 = v2)\n=== Parameters\n* +str+ - Must be a DER encoded PKCS12 string.\n* +pass+ - string\n
to_der OpenSSL::PKCS12.to_der()\n\n
encrypt OpenSSL::PKCS7.encrypt(p1, p2, p3 = v3, p4 = v4)\n\n
new OpenSSL::PKCS7.new(p1 = v1)\nMany methods in this class aren't documented.\n
read_smime OpenSSL::PKCS7.read_smime(p1)\n\n
sign OpenSSL::PKCS7.sign(p1, p2, p3, p4 = v4, p5 = v5)\n\n
write_smime OpenSSL::PKCS7.write_smime(p1, p2 = v2, p3 = v3)\n\n
add_certificate OpenSSL::PKCS7.add_certificate(p1)\n\n
add_crl OpenSSL::PKCS7.add_crl(p1)\n\n
add_data OpenSSL::PKCS7.add_data(p1)\n\n
add_recipient OpenSSL::PKCS7.add_recipient(p1)\n\n
add_signer OpenSSL::PKCS7.add_signer(p1)\n\n
certificates OpenSSL::PKCS7.certificates()\n\n
certificates= OpenSSL::PKCS7.certificates=(p1)\n\n
cipher= OpenSSL::PKCS7.cipher=(p1)\n\n
crls OpenSSL::PKCS7.crls()\n\n
crls= OpenSSL::PKCS7.crls=(p1)\n\n
data= OpenSSL::PKCS7.data=(p1)\n\n
decrypt OpenSSL::PKCS7.decrypt(p1, p2, p3 = v3)\n\n
detached OpenSSL::PKCS7.detached()\n\n
detached= OpenSSL::PKCS7.detached=(p1)\n\n
detached? OpenSSL::PKCS7.detached?()\n\n
recipients OpenSSL::PKCS7.recipients()\n\n
signers OpenSSL::PKCS7.signers()\n\n
to_der OpenSSL::PKCS7.to_der()\n\n
to_pem OpenSSL::PKCS7.to_pem()\n\n
to_s OpenSSL::PKCS7.to_s()\n\n
type OpenSSL::PKCS7.type()\n\n
type= OpenSSL::PKCS7.type=(p1)\n\n
verify OpenSSL::PKCS7.verify(p1, p2, p3 = v3, p4 = v4)\n\n
new OpenSSL::PKCS7::SignerInfo.new(p1, p2, p3)\n\n
issuer OpenSSL::PKCS7::SignerInfo.issuer()\n\n
name OpenSSL::PKCS7::SignerInfo.name()\n\n
serial OpenSSL::PKCS7::SignerInfo.serial()\n\n
signed_time OpenSSL::PKCS7::SignerInfo.signed_time()\n\n
new OpenSSL::PKCS7::RecipientInfo.new(p1)\n\n
enc_key OpenSSL::PKCS7::RecipientInfo.enc_key()\n\n
issuer OpenSSL::PKCS7::RecipientInfo.issuer()\n\n
serial OpenSSL::PKCS7::RecipientInfo.serial()\n\n
new OpenSSL::PKey::PKey.new()\nBecause PKey is an abstract class, actually calling this method explicitly\nwill raise a +NotImplementedError+.\n
sign OpenSSL::PKey::PKey.sign(p1, p2)\nTo sign the +String+ +data+, +digest+, an instance of OpenSSL::Digest, must\nbe provided. The return value is again a +String+ containing the signature.\nA PKeyError is raised should errors occur.\nAny previous state of the +Digest+ instance is irrelevant to the signature\noutcome, the digest instance is reset to its initial state during the\noperation.\n\n== Example\n  data = 'Sign me!'\n  digest = OpenSSL::Digest::SHA256.new\n  pkey = OpenSSL::PKey::RSA.new(2048)\n  signature = pkey.sign(digest, data)\n
verify OpenSSL::PKey::PKey.verify(p1, p2, p3)\nTo verify the +String+ +signature+, +digest+, an instance of\nOpenSSL::Digest, must be provided to re-compute the message digest of the\noriginal +data+, also a +String+. The return value is +true+ if the\nsignature is valid, +false+ otherwise. A PKeyError is raised should errors\noccur.\nAny previous state of the +Digest+ instance is irrelevant to the validation\noutcome, the digest instance is reset to its initial state during the\noperation.\n\n== Example\n  data = 'Sign me!'\n  digest = OpenSSL::Digest::SHA256.new\n  pkey = OpenSSL::PKey::RSA.new(2048)\n  signature = pkey.sign(digest, data)\n  pub_key = pkey.public_key\n  puts pub_key.verify(digest, signature, data) # => true\n
generate OpenSSL::PKey::DH.generate(p1, p2 = v2)\nCreates a new DH instance from scratch by generating the private and public\ncomponents alike.\n\n=== Parameters\n* +size+ is an integer representing the desired key size. Keys smaller than\n1024 bits should be considered insecure.\n* +generator+ is a small number > 1, typically 2 or 5.\n
new OpenSSL::PKey::DH.new(p1 = v1, p2 = v2)\nEither generates a DH instance from scratch or by reading already existing\nDH parameters from +string+. Note that when reading a DH instance from\ndata that was encoded from a DH instance by using DH#to_pem or DH#to_der\nthe result will *not* contain a public/private key pair yet. This needs to\nbe generated using DH#generate_key! first.\n\n=== Parameters\n* +size+ is an integer representing the desired key size. Keys smaller than\n1024 bits should be considered insecure.\n* +generator+ is a small number > 1, typically 2 or 5.\n* +string+ contains the DER or PEM encoded key.\n\n=== Examples\n DH.new # -> dh\n DH.new(1024) # -> dh\n DH.new(1024, 5) # -> dh\nReading DH parameters\n dh = DH.new(File.read('parameters.pem')) # -> dh, but no public/private\n key yet\n dh.generate_key! # -> dh with public and private key\n
compute_key OpenSSL::PKey::DH.compute_key(p1)\nReturns a String containing a shared secret computed from the other party's\npublic value.\nSee DH_compute_key() for further information.\n\n=== Parameters\n* +pub_bn+ is a OpenSSL::BN, *not* the DH instance returned by\nDH#public_key as that contains the DH parameters only.\n
export OpenSSL::PKey::DH.export()\nEncodes this DH to its PEM encoding. Note that any existing per-session\npublic/private keys will *not* get encoded, just the Diffie-Hellman\nparameters will be encoded.\n
generate_key! OpenSSL::PKey::DH.generate_key!()\nGenerates a private and public key unless a private key already exists.\nIf this DH instance was generated from public DH parameters (e.g. by\nencoding the result of DH#public_key), then this method needs to be\ncalled first in order to generate the per-session keys before performing\nthe actual key exchange.\n\n=== Example\n  dh = OpenSSL::PKey::DH.new(2048)\n  public_key = dh.public_key #contains no private/public key yet\n  public_key.generate_key!\n  puts public_key.private? # => true\n
params OpenSSL::PKey::DH.params()\nStores all parameters of key to the hash\nINSECURE: PRIVATE INFORMATIONS CAN LEAK OUT!!!\nDon't use :-)) (I's up to you)\n
params_ok? OpenSSL::PKey::DH.params_ok?()\nValidates the Diffie-Hellman parameters associated with this instance.\nIt checks whether a safe prime and a suitable generator are used. If this\nis not the case, +false+ is returned.\n
private? OpenSSL::PKey::DH.private?()\nIndicates whether this DH instance has a private key associated with it or\nnot. The private key may be retrieved with DH#priv_key.\n
public? OpenSSL::PKey::DH.public?()\nIndicates whether this DH instance has a public key associated with it or\nnot. The public key may be retrieved with DH#pub_key.\n
public_key OpenSSL::PKey::DH.public_key()\nReturns a new DH instance that carries just the public information, i.e.\nthe prime +p+ and the generator +g+, but no public/private key yet. Such\na pair may be generated using DH#generate_key!. The "public key" needed\nfor a key exchange with DH#compute_key is considered as per-session\ninformation and may be retrieved with DH#pub_key once a key pair has\nbeen generated.\nIf the current instance already contains private information (and thus a\nvalid public/private key pair), this information will no longer be present\nin the new instance generated by DH#public_key. This feature is helpful for\npublishing the Diffie-Hellman parameters without leaking any of the private\nper-session information.\n\n=== Example\n dh = OpenSSL::PKey::DH.new(2048) # has public and private key set\n public_key = dh.public_key # contains only prime and generator\n parameters = public_key.to_der # it's safe to publish this\n
to_der OpenSSL::PKey::DH.to_der()\nEncodes this DH to its DER encoding. Note that any existing per-session\npublic/private keys will *not* get encoded, just the Diffie-Hellman\nparameters will be encoded.\n
to_pem OpenSSL::PKey::DH.to_pem()\n\n
to_s OpenSSL::PKey::DH.to_s()\n\n
to_text OpenSSL::PKey::DH.to_text()\nPrints all parameters of key to buffer\nINSECURE: PRIVATE INFORMATIONS CAN LEAK OUT!!!\nDon't use :-)) (I's up to you)\n
generate OpenSSL::PKey::DSA.generate(p1)\nCreates a new DSA instance by generating a private/public key pair\nfrom scratch.\n\n=== Parameters\n* +size+ is an integer representing the desired key size.\n
new OpenSSL::PKey::DSA.new(p1 = v1, p2 = v2)\nCreates a new DSA instance by reading an existing key from +string+.\n\n=== Parameters\n* +size+ is an integer representing the desired key size.\n* +string+ contains a DER or PEM encoded key.\n* +pass+ is a string that contains an optional password.\n\n=== Examples\n DSA.new -> dsa\n DSA.new(1024) -> dsa\n DSA.new(File.read('dsa.pem')) -> dsa\n DSA.new(File.read('dsa.pem'), 'mypassword') -> dsa\n
export OpenSSL::PKey::DSA.export(p1 = v1, p2 = v2)\nEncodes this DSA to its PEM encoding.\n\n=== Parameters\n* +cipher+ is an OpenSSL::Cipher.\n* +password+ is a string containing your password.\n\n=== Examples\n DSA.to_pem -> aString\n DSA.to_pem(cipher, 'mypassword') -> aString\n
params OpenSSL::PKey::DSA.params()\nStores all parameters of key to the hash\nINSECURE: PRIVATE INFORMATIONS CAN LEAK OUT!!!\nDon't use :-)) (I's up to you)\n
private? OpenSSL::PKey::DSA.private?()\nIndicates whether this DSA instance has a private key associated with it or\nnot. The private key may be retrieved with DSA#private_key.\n
public? OpenSSL::PKey::DSA.public?()\nIndicates whether this DSA instance has a public key associated with it or\nnot. The public key may be retrieved with DSA#public_key.\n
public_key OpenSSL::PKey::DSA.public_key()\nReturns a new DSA instance that carries just the public key information.\nIf the current instance has also private key information, this will no\nlonger be present in the new instance. This feature is helpful for\npublishing the public key information without leaking any of the private\ninformation.\n\n=== Example\n dsa = OpenSSL::PKey::DSA.new(2048) # has public and private information\n pub_key = dsa.public_key # has only the public part available\n pub_key_der = pub_key.to_der # it's safe to publish this\n
syssign OpenSSL::PKey::DSA.syssign(p1)\nComputes and returns the DSA signature of +string+, where +string+ is\nexpected to be an already-computed message digest of the original input\ndata. The signature is issued using the private key of this DSA instance.\n\n=== Parameters\n* +string+ is a message digest of the original input data to be signed\n\n=== Example\n dsa = OpenSSL::PKey::DSA.new(2048)\n doc = "Sign me"\n digest = OpenSSL::Digest::SHA1.digest(doc)\n sig = dsa.syssign(digest)\n
sysverify OpenSSL::PKey::DSA.sysverify(p1, p2)\nVerifies whether the signature is valid given the message digest input. It\ndoes so by validating +sig+ using the public key of this DSA instance.\n\n=== Parameters\n* +digest+ is a message digest of the original input data to be signed\n* +sig+ is a DSA signature value\n\n=== Example\n dsa = OpenSSL::PKey::DSA.new(2048)\n doc = "Sign me"\n digest = OpenSSL::Digest::SHA1.digest(doc)\n sig = dsa.syssign(digest)\n puts dsa.sysverify(digest, sig) # => true\n
to_der OpenSSL::PKey::DSA.to_der()\nEncodes this DSA to its DER encoding.\n
to_pem OpenSSL::PKey::DSA.to_pem(p1 = v1, p2 = v2)\n\n
to_s OpenSSL::PKey::DSA.to_s(p1 = v1, p2 = v2)\n\n
to_text OpenSSL::PKey::DSA.to_text()\nPrints all parameters of key to buffer\nINSECURE: PRIVATE INFORMATIONS CAN LEAK OUT!!!\nDon't use :-)) (I's up to you)\n
builtin_curves OpenSSL::PKey::EC.builtin_curves()\nSee the OpenSSL documentation for EC_builtin_curves()\n
new OpenSSL::PKey::EC.new(p1 = v1, p2 = v2)\nSee the OpenSSL documentation for:\n   EC_KEY_*\n
check_key OpenSSL::PKey::EC.check_key()\nRaises an exception if the key is invalid.\n\nSee the OpenSSL documentation for EC_KEY_check_key()\n
dh_compute_key OpenSSL::PKey::EC.dh_compute_key(p1)\nSee the OpenSSL documentation for ECDH_compute_key()\n
dsa_sign_asn1 OpenSSL::PKey::EC.dsa_sign_asn1(p1)\nSee the OpenSSL documentation for ECDSA_sign()\n
dsa_verify_asn1 OpenSSL::PKey::EC.dsa_verify_asn1(p1, p2)\nSee the OpenSSL documentation for ECDSA_verify()\n
generate_key OpenSSL::PKey::EC.generate_key()\nSee the OpenSSL documentation for EC_KEY_generate_key()\n
group OpenSSL::PKey::EC.group()\nReturns a constant `OpenSSL::EC::Group` that is tied to the key.\nModifying the returned group can make the key invalid.\n
group= OpenSSL::PKey::EC.group=(p1)\nReturns the same object passed, not the group object associated with the key.\nIf you wish to access the group object tied to the key call key.group\nafter setting\nthe group.\n\nSetting the group will immediately destroy any previously assigned group\nobject.\nThe group is internally copied by OpenSSL.  Modifying the original group after\nassignment will not effect the internal key structure.\n(your changes may be lost).  BE CAREFUL.\n\nEC_KEY_set_group calls EC_GROUP_free(key->group) then EC_GROUP_dup(),\nnot EC_GROUP_copy.\nThis documentation is accurate for OpenSSL 0.9.8b.\n
private_key OpenSSL::PKey::EC.private_key()\nSee the OpenSSL documentation for EC_KEY_get0_private_key()\n
private_key= OpenSSL::PKey::EC.private_key=(p1)\nSee the OpenSSL documentation for EC_KEY_set_private_key()\n
private_key? OpenSSL::PKey::EC.private_key?()\nBoth public_key? and private_key? may return false at the same time unlike\nother PKey classes.\n
public_key OpenSSL::PKey::EC.public_key()\nSee the OpenSSL documentation for EC_KEY_get0_public_key()\n
public_key= OpenSSL::PKey::EC.public_key=(p1)\nSee the OpenSSL documentation for EC_KEY_set_public_key()\n
public_key? OpenSSL::PKey::EC.public_key?()\nBoth public_key? and private_key? may return false at the same time unlike\nother PKey classes.\n
to_der OpenSSL::PKey::EC.to_der()\nSee the OpenSSL documentation for i2d_ECPrivateKey_bio()\n
to_pem OpenSSL::PKey::EC.to_pem(p1 = v1, p2 = v2)\nOutputs the EC key in PEM encoding.  If +cipher+ and +pass_phrase+ are\ngiven they will be used to encrypt the key.  +cipher+ must be an\nOpenSSL::Cipher::Cipher instance. Note that encryption will only be\neffective for a private key, public keys will always be encoded in plain\ntext.\n
to_text OpenSSL::PKey::EC.to_text()\nSee the OpenSSL documentation for EC_KEY_print()\n
new OpenSSL::PKey::EC::Group.new(p1, p2 = v2, p3 = v3, p4 = v4)\nSee the OpenSSL documentation for EC_GROUP_*\n
asn1_flag OpenSSL::PKey::EC::Group.asn1_flag()\nSee the OpenSSL documentation for EC_GROUP_get_asn1_flag()\n
asn1_flag= OpenSSL::PKey::EC::Group.asn1_flag=(p1)\nSee the OpenSSL documentation for EC_GROUP_set_asn1_flag()\n
cofactor OpenSSL::PKey::EC::Group.cofactor()\nSee the OpenSSL documentation for EC_GROUP_get_cofactor()\n
curve_name OpenSSL::PKey::EC::Group.curve_name()\nSee the OpenSSL documentation for EC_GROUP_get_curve_name()\n
degree OpenSSL::PKey::EC::Group.degree()\nSee the OpenSSL documentation for EC_GROUP_get_degree()\n
eql? OpenSSL::PKey::EC::Group.eql?(p1)\n\n
generator OpenSSL::PKey::EC::Group.generator()\nSee the OpenSSL documentation for EC_GROUP_get0_generator()\n
order OpenSSL::PKey::EC::Group.order()\nSee the OpenSSL documentation for EC_GROUP_get_order()\n
point_conversion_form OpenSSL::PKey::EC::Group.point_conversion_form()\nSee the OpenSSL documentation for EC_GROUP_get_point_conversion_form()\n
point_conversion_form= OpenSSL::PKey::EC::Group.point_conversion_form=(p1)\nSee the OpenSSL documentation for EC_GROUP_set_point_conversion_form()\n
seed OpenSSL::PKey::EC::Group.seed()\nSee the OpenSSL documentation for EC_GROUP_get0_seed()\n
seed= OpenSSL::PKey::EC::Group.seed=(p1)\nSee the OpenSSL documentation for EC_GROUP_set_seed()\n
set_generator OpenSSL::PKey::EC::Group.set_generator(p1, p2, p3)\nSee the OpenSSL documentation for EC_GROUP_set_generator()\n
to_der OpenSSL::PKey::EC::Group.to_der()\nSee the OpenSSL documentation for i2d_ECPKParameters_bio()\n
to_pem OpenSSL::PKey::EC::Group.to_pem()\nSee the OpenSSL documentation for PEM_write_bio_ECPKParameters()\n
to_text OpenSSL::PKey::EC::Group.to_text()\nSee the OpenSSL documentation for ECPKParameters_print()\n
new OpenSSL::PKey::EC::Point.new(p1, p2 = v2)\nSee the OpenSSL documentation for EC_POINT_*\n
eql? OpenSSL::PKey::EC::Point.eql?(p1)\n\n
infinity? OpenSSL::PKey::EC::Point.infinity?()\n\n
invert! OpenSSL::PKey::EC::Point.invert!()\n\n
make_affine! OpenSSL::PKey::EC::Point.make_affine!()\n\n
on_curve? OpenSSL::PKey::EC::Point.on_curve?()\n\n
set_to_infinity! OpenSSL::PKey::EC::Point.set_to_infinity!()\n\n
to_bn OpenSSL::PKey::EC::Point.to_bn()\nSee the OpenSSL documentation for EC_POINT_point2bn()\n
generate OpenSSL::PKey::RSA.generate(p1, p2 = v2)\nGenerates an RSA keypair.  +size+ is an integer representing the desired key\nsize.  Keys smaller than 1024 should be considered insecure.  +exponent+ is\nan odd number normally 3, 17, or 65537.\n
new OpenSSL::PKey::RSA.new(p1 = v1, p2 = v2)\nGenerates or loads an RSA keypair.  If an integer +key_size+ is given it\nrepresents the desired key size.  Keys less than 1024 bits should be\nconsidered insecure.\n\nA key can instead be loaded from an +encoded_key+ which must be PEM or DER\nencoded.  A +pass_phrase+ can be used to decrypt the key.  If none is given\nOpenSSL will prompt for the pass phrase.\n\n= Examples\n\n  OpenSSL::PKey::RSA.new 2048\n  OpenSSL::PKey::RSA.new File.read 'rsa.pem'\n  OpenSSL::PKey::RSA.new File.read('rsa.pem'), 'my pass phrase'\n
blinding_off! OpenSSL::PKey::RSA.blinding_off!()\n\n
blinding_on! OpenSSL::PKey::RSA.blinding_on!()\n\n
export OpenSSL::PKey::RSA.export(p1 = v1, p2 = v2)\nOutputs this keypair in PEM encoding.  If +cipher+ and +pass_phrase+ are\ngiven they will be used to encrypt the key.  +cipher+ must be an\nOpenSSL::Cipher::Cipher instance.\n
params OpenSSL::PKey::RSA.params()\nTHIS METHOD IS INSECURE, PRIVATE INFORMATION CAN LEAK OUT!!!\n\nStores all parameters of key to the hash.  The hash has keys 'n', 'e', 'd',\n'p', 'q', 'dmp1', 'dmq1', 'iqmp'.\n\nDon't use :-)) (It's up to you)\n
private? OpenSSL::PKey::RSA.private?()\nDoes this keypair contain a private key?\n
private_decrypt OpenSSL::PKey::RSA.private_decrypt(p1, p2 = v2)\nDecrypt +string+, which has been encrypted with the public key, with the\nprivate key.  +padding+ defaults to PKCS1_PADDING.\n
private_encrypt OpenSSL::PKey::RSA.private_encrypt(p1, p2 = v2)\nEncrypt +string+ with the private key.  +padding+ defaults to PKCS1_PADDING.\nThe encrypted string output can be decrypted using #public_decrypt.\n
public? OpenSSL::PKey::RSA.public?()\nThe return value is always true since every private key is also a public\nkey.\n
public_decrypt OpenSSL::PKey::RSA.public_decrypt(p1, p2 = v2)\nDecrypt +string+, which has been encrypted with the private key, with the\npublic key.  +padding+ defaults to PKCS1_PADDING.\n
public_encrypt OpenSSL::PKey::RSA.public_encrypt(p1, p2 = v2)\nEncrypt +string+ with the public key.  +padding+ defaults to PKCS1_PADDING.\nThe encrypted string output can be decrypted using #private_decrypt.\n
public_key OpenSSL::PKey::RSA.public_key()\nMakes new RSA instance containing the public key from the private key.\n
to_der OpenSSL::PKey::RSA.to_der()\nOutputs this keypair in DER encoding.\n
to_pem OpenSSL::PKey::RSA.to_pem(p1 = v1, p2 = v2)\n\n
to_s OpenSSL::PKey::RSA.to_s(p1 = v1, p2 = v2)\n\n
to_text OpenSSL::PKey::RSA.to_text()\nTHIS METHOD IS INSECURE, PRIVATE INFORMATION CAN LEAK OUT!!!\n\nDumps all parameters of a keypair to a String\n\nDon't use :-)) (It's up to you)\n
new OpenSSL::SSL::Session.new(p1)\n=== Parameters\n+SSLSocket+ is an OpenSSL::SSL::SSLSocket\n+string+ must be a DER or PEM encoded Session.\n
id OpenSSL::SSL::Session.id()\nReturns the Session ID.\n
time OpenSSL::SSL::Session.time()\nGets start time of the session.\n
time= OpenSSL::SSL::Session.time=(p1)\nSets start time of the session. Time resolution is in seconds.\n
timeout OpenSSL::SSL::Session.timeout()\nGets how long until the session expires in seconds.\n
timeout= OpenSSL::SSL::Session.timeout=(p1)\nSets how long until the session expires in seconds.\n
to_der OpenSSL::SSL::Session.to_der()\nReturns an ASN1 encoded String that contains the Session object.\n
to_pem OpenSSL::SSL::Session.to_pem()\nReturns a PEM encoded String that contains the Session object.\n
to_text OpenSSL::SSL::Session.to_text()\nShows everything in the Session object.\n
new OpenSSL::X509::Attribute.new(p1, p2 = v2)\n\n
oid OpenSSL::X509::Attribute.oid()\n\n
oid= OpenSSL::X509::Attribute.oid=(p1)\n\n
to_der OpenSSL::X509::Attribute.to_der()\n\n
value OpenSSL::X509::Attribute.value()\n\n
value= OpenSSL::X509::Attribute.value=(p1)\n\n
new OpenSSL::X509::CRL.new(p1 = v1)\n\n
add_extension OpenSSL::X509::CRL.add_extension(p1)\n\n
add_revoked OpenSSL::X509::CRL.add_revoked(p1)\n\n
extensions OpenSSL::X509::CRL.extensions()\nGets X509v3 extensions as array of X509Ext objects\n
extensions= OpenSSL::X509::CRL.extensions=(p1)\nSets X509_EXTENSIONs\n
issuer OpenSSL::X509::CRL.issuer()\n\n
issuer= OpenSSL::X509::CRL.issuer=(p1)\n\n
last_update OpenSSL::X509::CRL.last_update()\n\n
last_update= OpenSSL::X509::CRL.last_update=(p1)\n\n
next_update OpenSSL::X509::CRL.next_update()\n\n
next_update= OpenSSL::X509::CRL.next_update=(p1)\n\n
revoked OpenSSL::X509::CRL.revoked()\n\n
revoked= OpenSSL::X509::CRL.revoked=(p1)\n\n
sign OpenSSL::X509::CRL.sign(p1, p2)\n\n
signature_algorithm OpenSSL::X509::CRL.signature_algorithm()\n\n
to_der OpenSSL::X509::CRL.to_der()\n\n
to_pem OpenSSL::X509::CRL.to_pem()\n\n
to_s OpenSSL::X509::CRL.to_s()\n\n
to_text OpenSSL::X509::CRL.to_text()\n\n
verify OpenSSL::X509::CRL.verify(p1)\n\n
version OpenSSL::X509::CRL.version()\n\n
version= OpenSSL::X509::CRL.version=(p1)\n\n
new OpenSSL::X509::Request.new(p1 = v1)\n\n
add_attribute OpenSSL::X509::Request.add_attribute(p1)\n\n
attributes OpenSSL::X509::Request.attributes()\n\n
attributes= OpenSSL::X509::Request.attributes=(p1)\n\n
public_key OpenSSL::X509::Request.public_key()\n\n
public_key= OpenSSL::X509::Request.public_key=(p1)\n\n
sign OpenSSL::X509::Request.sign(p1, p2)\n\n
signature_algorithm OpenSSL::X509::Request.signature_algorithm()\n\n
subject OpenSSL::X509::Request.subject()\n\n
subject= OpenSSL::X509::Request.subject=(p1)\n\n
to_der OpenSSL::X509::Request.to_der()\n\n
to_pem OpenSSL::X509::Request.to_pem()\n\n
to_s OpenSSL::X509::Request.to_s()\n\n
to_text OpenSSL::X509::Request.to_text()\n\n
verify OpenSSL::X509::Request.verify(p1)\nChecks that cert signature is made with PRIVversion of this PUBLIC 'key'\n
version OpenSSL::X509::Request.version()\n\n
version= OpenSSL::X509::Request.version=(p1)\n\n
new OpenSSL::X509::Revoked.new(*args)\n\n
add_extension OpenSSL::X509::Revoked.add_extension(p1)\n\n
extensions OpenSSL::X509::Revoked.extensions()\nGets X509v3 extensions as array of X509Ext objects\n
extensions= OpenSSL::X509::Revoked.extensions=(p1)\nSets X509_EXTENSIONs\n
serial OpenSSL::X509::Revoked.serial()\n\n
serial= OpenSSL::X509::Revoked.serial=(p1)\n\n
time OpenSSL::X509::Revoked.time()\n\n
time= OpenSSL::X509::Revoked.time=(p1)\n\n
new OpenSSL::X509::Store.new(*args)\n\n
add_cert OpenSSL::X509::Store.add_cert(p1)\n\n
add_crl OpenSSL::X509::Store.add_crl(p1)\n\n
add_file OpenSSL::X509::Store.add_file(p1)\n\n
add_path OpenSSL::X509::Store.add_path(p1)\n\n
flags= OpenSSL::X509::Store.flags=(p1)\n\n
purpose= OpenSSL::X509::Store.purpose=(p1)\n\n
set_default_paths OpenSSL::X509::Store.set_default_paths()\n\n
time= OpenSSL::X509::Store.time=(p1)\n\n
trust= OpenSSL::X509::Store.trust=(p1)\n\n
verify OpenSSL::X509::Store.verify(p1, p2 = v2)\n\n
verify_callback= OpenSSL::X509::Store.verify_callback=(p1)\nGeneral callback for OpenSSL verify\n
getwd Pathname.getwd()\nSee <tt>Dir.getwd</tt>.  Returns the current working directory as a Pathname.\n
glob Pathname.glob(p1, p2 = v2)\nSee <tt>Dir.glob</tt>.  Returns or yields Pathname objects.\n
new Pathname.new(p1)\nCreate a Pathname object from the given String (or String-like object).\nIf +path+ contains a NUL character (<tt>\0</tt>), an ArgumentError is raised.\n
pwd Pathname.pwd()\nSee <tt>Dir.getwd</tt>.  Returns the current working directory as a Pathname.\n
absolute? Pathname.absolute?()\nPredicate method for testing whether a path is absolute.\nIt returns +true+ if the pathname begins with a slash.\n
ascend Pathname.ascend()\nIterates over and yields a new Pathname object\nfor each element in the given path in ascending order.\n\n Pathname.new('/path/to/some/file.rb').ascend {|v| p v}\n<Pathname:/path/to/some/file.rb>\n<Pathname:/path/to/some>\n<Pathname:/path/to>\n<Pathname:/path>\n<Pathname:/>\n\n Pathname.new('path/to/some/file.rb').ascend {|v| p v}\n<Pathname:path/to/some/file.rb>\n<Pathname:path/to/some>\n<Pathname:path/to>\n<Pathname:path>\n\nIt doesn't access actual filesystem.\n\nThis method is available since 1.8.5.\n
atime Pathname.atime()\nSee <tt>File.atime</tt>.  Returns last access time.\n
basename Pathname.basename(p1 = v1)\nSee <tt>File.basename</tt>.  Returns the last component of the path.\n
binread Pathname.binread(p1 = v1, p2 = v2)\nSee <tt>IO.binread</tt>.  Returns all the bytes from the file, or the first +N+\nif specified.\n
blockdev? Pathname.blockdev?()\nSee <tt>FileTest.blockdev?</tt>.\n
chardev? Pathname.chardev?()\nSee <tt>FileTest.chardev?</tt>.\n
children Pathname.children(with_directory=true)\nReturns the children of the directory (files and subdirectories, not\nrecursive) as an array of Pathname objects.  By default, the returned\npathnames will have enough information to access the files.  If you set\n+with_directory+ to +false+, then the returned pathnames will contain the\nfilename only.\n\nFor example:\n  pn = Pathname("/usr/lib/ruby/1.8")\n  pn.children\n -> [ Pathname:/usr/lib/ruby/1.8/English.rb,\n             Pathname:/usr/lib/ruby/1.8/Env.rb,\n             Pathname:/usr/lib/ruby/1.8/abbrev.rb, ... ]\n  pn.children(false)\n -> [ Pathname:English.rb, Pathname:Env.rb, Pathname:abbrev.rb, ... ]\n\nNote that the results never contain the entries <tt>.</tt> and <tt>..</tt> in\nthe directory because they are not children.\n\nThis method has existed since 1.8.1.\n
chmod Pathname.chmod(p1)\nSee <tt>File.chmod</tt>.  Changes permissions.\n
chown Pathname.chown(p1, p2)\nSee <tt>File.chown</tt>.  Change owner and group of file.\n
cleanpath Pathname.cleanpath(consider_symlink=false)\nReturns clean pathname of +self+ with consecutive slashes and useless dots\nremoved.  The filesystem is not accessed.\n\nIf +consider_symlink+ is +true+, then a more conservative algorithm is used\nto avoid breaking symbolic linkages.  This may retain more <tt>..</tt>\nentries than absolutely necessary, but without accessing the filesystem,\nthis can't be avoided.  See #realpath.\n
ctime Pathname.ctime()\nSee <tt>File.ctime</tt>.  Returns last (directory entry, not file) change time.\n
delete Pathname.delete()\nRemoves a file or directory, using <tt>File.unlink</tt> or\n<tt>Dir.unlink</tt> as necessary.\n
descend Pathname.descend()\nIterates over and yields a new Pathname object\nfor each element in the given path in descending order.\n\n Pathname.new('/path/to/some/file.rb').descend {|v| p v}\n<Pathname:/>\n<Pathname:/path>\n<Pathname:/path/to>\n<Pathname:/path/to/some>\n<Pathname:/path/to/some/file.rb>\n\n Pathname.new('path/to/some/file.rb').descend {|v| p v}\n<Pathname:path>\n<Pathname:path/to>\n<Pathname:path/to/some>\n<Pathname:path/to/some/file.rb>\n\nIt doesn't access actual filesystem.\n\nThis method is available since 1.8.5.\n
directory? Pathname.directory?()\nSee <tt>FileTest.directory?</tt>.\n
dirname Pathname.dirname()\nSee <tt>File.dirname</tt>.  Returns all but the last component of the path.\n
each_child Pathname.each_child(with_directory=true, &b)\nIterates over the children of the directory\n(files and subdirectories, not recursive).\nIt yields Pathname object for each child.\nBy default, the yielded pathnames will have enough information to access\nthe files.\nIf you set +with_directory+ to +false+, then the returned pathnames will\ncontain the filename only.\n\n  Pathname("/usr/local").each_child {|f| p f }\n=> #<Pathname:/usr/local/share>\n   #<Pathname:/usr/local/bin>\n   #<Pathname:/usr/local/games>\n   #<Pathname:/usr/local/lib>\n   #<Pathname:/usr/local/include>\n   #<Pathname:/usr/local/sbin>\n   #<Pathname:/usr/local/src>\n   #<Pathname:/usr/local/man>\n\n  Pathname("/usr/local").each_child(false) {|f| p f }\n=> #<Pathname:share>\n   #<Pathname:bin>\n   #<Pathname:games>\n   #<Pathname:lib>\n   #<Pathname:include>\n   #<Pathname:sbin>\n   #<Pathname:src>\n   #<Pathname:man>\n
each_entry Pathname.each_entry()\nIterates over the entries (files and subdirectories) in the directory.  It\nyields a Pathname object for each entry.\n\nThis method has available since 1.8.1.\n
each_filename Pathname.each_filename()\nIterates over each component of the path.\n\n  Pathname.new("/usr/bin/ruby").each_filename {|filename| ... }\n yields "usr", "bin", and "ruby".\n
each_line Pathname.each_line(p1 = v1, p2 = v2, p3 = v3)\neach_line iterates over the line in the file.  It yields a String object\nfor each line.\n\nThis method is availabel since 1.8.1.\n
entries Pathname.entries()\nReturn the entries (files and subdirectories) in the directory, each as a\nPathname object.\n\nThe result may contain the current directory #<Pathname:.> and the parent\ndirectory #<Pathname:..>.\n
eql? Pathname.eql?(p1)\nCompare this pathname with +other+.  The comparison is string-based.\nBe aware that two different paths (<tt>foo.txt</tt> and <tt>./foo.txt</tt>)\ncan refer to the same file.\n
executable? Pathname.executable?()\nSee <tt>FileTest.executable?</tt>.\n
executable_real? Pathname.executable_real?()\nSee <tt>FileTest.executable_real?</tt>.\n
exist? Pathname.exist?()\nSee <tt>FileTest.exist?</tt>.\n
expand_path Pathname.expand_path(p1 = v1)\nSee <tt>File.expand_path</tt>.\n
extname Pathname.extname()\nSee <tt>File.extname</tt>.  Returns the file's extension.\n
file? Pathname.file?()\nSee <tt>FileTest.file?</tt>.\n
find Pathname.find()\nPathname#find is an iterator to traverse a directory tree in a depth first\nmanner.  It yields a Pathname for each file under "this" directory.\n\nSince it is implemented by <tt>find.rb</tt>, <tt>Find.prune</tt> can be used\nto control the traversal.\n\nIf +self+ is <tt>.</tt>, yielded pathnames begin with a filename in the\ncurrent directory, not <tt>./</tt>.\n
fnmatch Pathname.fnmatch(p1, p2 = v2)\nSee <tt>File.fnmatch</tt>.  Return +true+ if the receiver matches the given\npattern.\n
fnmatch? Pathname.fnmatch?(p1, p2 = v2)\nSee <tt>File.fnmatch</tt>.  Return +true+ if the receiver matches the given\npattern.\n
freeze Pathname.freeze()\n\n
ftype Pathname.ftype()\nSee <tt>File.ftype</tt>.  Returns "type" of file ("file", "directory",\netc).\n
grpowned? Pathname.grpowned?()\nSee <tt>FileTest.grpowned?</tt>.\n
join Pathname.join(*args)\nPathname#join joins pathnames.\n\n<tt>path0.join(path1, ..., pathN)</tt> is the same as\n<tt>path0 + path1 + ... + pathN</tt>.\n
lchmod Pathname.lchmod(p1)\nSee <tt>File.lchmod</tt>.\n
lchown Pathname.lchown(p1, p2)\nSee <tt>File.lchown</tt>.\n
lstat Pathname.lstat()\nSee <tt>File.lstat</tt>.\n
make_link Pathname.make_link(p1)\nSee <tt>File.link</tt>.  Creates a hard link at _pathname_.\n
make_symlink Pathname.make_symlink(p1)\nSee <tt>File.symlink</tt>.  Creates a symbolic link.\n
mkdir Pathname.mkdir(p1 = v1)\nSee <tt>Dir.mkdir</tt>.  Create the referenced directory.\n
mkpath Pathname.mkpath()\nSee <tt>FileUtils.mkpath</tt>.  Creates a full path, including any\nintermediate directories that don't yet exist.\n
mountpoint? Pathname.mountpoint?()\nmountpoint? returns +true+ if <tt>self</tt> points to a mountpoint.\n
mtime Pathname.mtime()\nSee <tt>File.mtime</tt>.  Returns last modification time.\n
open Pathname.open(p1 = v1, p2 = v2, p3 = v3)\nSee <tt>File.open</tt>.  Opens the file for reading or writing.\n
opendir Pathname.opendir()\nSee <tt>Dir.open</tt>.\n
owned? Pathname.owned?()\nSee <tt>FileTest.owned?</tt>.\n
parent Pathname.parent()\nparent returns the parent directory.\n\nThis is same as <tt>self + '..'</tt>.\n
pipe? Pathname.pipe?()\nSee <tt>FileTest.pipe?</tt>.\n
read Pathname.read(p1 = v1, p2 = v2, p3 = v3)\nSee <tt>IO.read</tt>.  Returns all data from the file, or the first +N+ bytes\nif specified.\n
readable? Pathname.readable?()\nSee <tt>FileTest.readable?</tt>.\n
readable_real? Pathname.readable_real?()\nSee <tt>FileTest.readable_real?</tt>.\n
readlines Pathname.readlines(p1 = v1, p2 = v2, p3 = v3)\nSee <tt>IO.readlines</tt>.  Returns all the lines from the file.\n
readlink Pathname.readlink()\nSee <tt>File.readlink</tt>.  Read symbolic link.\n
realdirpath Pathname.realdirpath(p1 = v1)\nReturns the real (absolute) pathname of +self+ in the actual filesystem.\nThe real pathname doesn't contain symlinks or useless dots.\n\nThe last component of the real pathname can be nonexistent.\n
realpath Pathname.realpath(p1 = v1)\nReturns the real (absolute) pathname of +self+ in the actual\nfilesystem not containing symlinks or useless dots.\n\nAll components of the pathname must exist when this method is\ncalled.\n
relative? Pathname.relative?()\nThe opposite of #absolute?\n
relative_path_from Pathname.relative_path_from(base_directory)\nrelative_path_from returns a relative path from the argument to the\nreceiver.  If +self+ is absolute, the argument must be absolute too.  If\n+self+ is relative, the argument must be relative too.\nrelative_path_from doesn't access the filesystem.  It assumes no symlinks.\n\nArgumentError is raised when it cannot find a relative path.\n\nThis method has existed since 1.8.1.\n
rename Pathname.rename(p1)\nSee <tt>File.rename</tt>.  Rename the file.\n
rmdir Pathname.rmdir()\nSee <tt>Dir.rmdir</tt>.  Remove the referenced directory.\n
rmtree Pathname.rmtree()\nSee <tt>FileUtils.rm_r</tt>.  Deletes a directory and all beneath it.\n
root? Pathname.root?()\nroot? is a predicate for root directories.  I.e. it returns +true+ if the\npathname consists of consecutive slashes.\n\nIt doesn't access actual filesystem.  So it may return +false+ for some\npathnames which points to roots such as <tt>/usr/..</tt>.\n
setgid? Pathname.setgid?()\nSee <tt>FileTest.setgid?</tt>.\n
setuid? Pathname.setuid?()\nSee <tt>FileTest.setuid?</tt>.\n
size Pathname.size()\nSee <tt>FileTest.size</tt>.\n
size? Pathname.size?()\nSee <tt>FileTest.size?</tt>.\n
socket? Pathname.socket?()\nSee <tt>FileTest.socket?</tt>.\n
split Pathname.split()\nSee <tt>File.split</tt>.  Returns the #dirname and the #basename in an Array.\n
stat Pathname.stat()\nSee <tt>File.stat</tt>.  Returns a <tt>File::Stat</tt> object.\n
sticky? Pathname.sticky?()\nSee <tt>FileTest.sticky?</tt>.\n
sub Pathname.sub(*args)\nReturn a pathname which is substituted by String#sub.\n
sub_ext Pathname.sub_ext(p1)\nReturn a pathname which the extension of the basename is substituted by\n<i>repl</i>.\n\nIf self has no extension part, <i>repl</i> is appended.\n
symlink? Pathname.symlink?()\nSee <tt>FileTest.symlink?</tt>.\n
sysopen Pathname.sysopen(p1 = v1, p2 = v2)\nSee <tt>IO.sysopen</tt>.\n
taint Pathname.taint()\n\n
to_path Pathname.to_path()\nReturn the path as a String.\n\nto_path is implemented so Pathname objects are usable with File.open, etc.\n
to_s Pathname.to_s()\nReturn the path as a String.\n\nto_path is implemented so Pathname objects are usable with File.open, etc.\n
truncate Pathname.truncate(p1)\nSee <tt>File.truncate</tt>.  Truncate the file to +length+ bytes.\n
unlink Pathname.unlink()\nRemoves a file or directory, using <tt>File.unlink</tt> or\n<tt>Dir.unlink</tt> as necessary.\n
untaint Pathname.untaint()\n\n
utime Pathname.utime(p1, p2)\nSee <tt>File.utime</tt>.  Update the access and modification times.\n
world_readable? Pathname.world_readable?()\nSee <tt>FileTest.world_readable?</tt>.\n
world_writable? Pathname.world_writable?()\nSee <tt>FileTest.world_writable?</tt>.\n
writable? Pathname.writable?()\nSee <tt>FileTest.writable?</tt>.\n
writable_real? Pathname.writable_real?()\nSee <tt>FileTest.writable_real?</tt>.\n
zero? Pathname.zero?()\nSee <tt>FileTest.zero?</tt>.\n
alias Psych::Handler.alias(anchor)\nCalled when an alias is found to +anchor+.  +anchor+ will be the name\nof the anchor found.\n\n=== Example\n\nHere we have an example of an array that references itself in YAML:\n\n  --- &ponies\n  - first element\n  - *ponies\n\n&ponies is the achor, *ponies is the alias.  In this case, alias is\ncalled with "ponies".\n
empty Psych::Handler.empty()\nCalled when an empty event happens. (Which, as far as I can tell, is\nnever).\n
end_document Psych::Handler.end_document(implicit)\nCalled with the document ends.  +implicit+ is a boolean value indicating\nwhether or not the document has an implicit ending.\n\n=== Example\n\nGiven the following YAML:\n\n  ---\n    hello world\n\n+implicit+ will be true.  Given this YAML:\n\n  ---\n    hello world\n  ...\n\n+implicit+ will be false.\n
end_mapping Psych::Handler.end_mapping()\nCalled when a map ends\n
end_sequence Psych::Handler.end_sequence()\nCalled when a sequence ends.\n
end_stream Psych::Handler.end_stream()\nCalled when the YAML stream ends\n
scalar Psych::Handler.scalar(value, anchor, tag, plain, quoted, style)\nCalled when a scalar +value+ is found.  The scalar may have an\n+anchor+, a +tag+, be implicitly +plain+ or implicitly +quoted+\n\n+value+ is the string value of the scalar\n+anchor+ is an associated anchor or nil\n+tag+ is an associated tag or nil\n+plain+ is a boolean value\n+quoted+ is a boolean value\n+style+ is an integer idicating the string style\n\nSee the constants in Psych::Nodes::Scalar for the possible values of\n+style+\n\n=== Example\n\nHere is a YAML document that exercises most of the possible ways this\nmethod can be called:\n\n  ---\n  - !str "foo"\n  - &anchor fun\n  - many\n    lines\n  - |\n    many\n    newlines\n\nThe above YAML document contains a list with four strings.  Here are\nthe parameters sent to this method in the same order:\n value               anchor    tag     plain   quoted  style\n  ["foo",               nil,      "!str", false,  false,  3    ]\n  ["fun",               "anchor", nil,    true,   false,  1    ]\n  ["many lines",        nil,      nil,    true,   false,  1    ]\n  ["many\\nnewlines\\n",  nil,      nil,    false,  true,   4    ]\n
start_document Psych::Handler.start_document(version, tag_directives, implicit)\nCalled when the document starts with the declared +version+,\n+tag_directives+, if the document is +implicit+.\n\n+version+ will be an array of integers indicating the YAML version being\ndealt with, +tag_directives+ is a list of tuples indicating the prefix\nand suffix of each tag, and +implicit+ is a boolean indicating whether\nthe document is started implicitly.\n\n=== Example\n\nGiven the following YAML:\n\n  %YAML 1.1\n  %TAG ! tag:tenderlovemaking.com,2009:\n  --- !squee\n\nThe parameters for start_document must be this:\n\n  version         # => [1, 1]\n  tag_directives  # => [["!", "tag:tenderlovemaking.com,2009:"]]\n  implicit        # => false\n
start_mapping Psych::Handler.start_mapping(anchor, tag, implicit, style)\nCalled when a map starts.\n\n+anchor+ is the anchor associated with the map or +nil+.\n+tag+ is the tag associated with the map or +nil+.\n+implicit+ is a boolean indicating whether or not the map was implicitly\nstarted.\n+style+ is an integer indicating the mapping style.\n\nSee the constants in Psych::Nodes::Mapping for the possible values of\n+style+.\n\n=== Example\n\nHere is a YAML document that exercises most of the possible ways this\nmethod can be called:\n\n  ---\n  k: !!map { hello: world }\n  v: &pewpew\n    hello: world\n\nThe above YAML document consists of three maps, an outer map that contains\ntwo inner maps.  Below is a matrix of the parameters sent in order to\nrepresent these three maps:\n anchor    tag                       implicit  style\n  [nil,       nil,                      true,     1     ]\n  [nil,       "tag:yaml.org,2002:map",  false,    2     ]\n  ["pewpew",  nil,                      true,     1     ]\n
start_sequence Psych::Handler.start_sequence(anchor, tag, implicit, style)\nCalled when a sequence is started.\n\n+anchor+ is the anchor associated with the sequence or nil.\n+tag+ is the tag associated with the sequence or nil.\n+implicit+ a boolean indicating whether or not the sequence was implicitly\nstarted.\n+style+ is an integer indicating the list style.\n\nSee the constants in Psych::Nodes::Sequence for the possible values of\n+style+.\n\n=== Example\n\nHere is a YAML document that exercises most of the possible ways this\nmethod can be called:\n\n  ---\n  - !!seq [\n    a\n  ]\n  - &pewpew\n    - b\n\nThe above YAML document consists of three lists, an outer list that\ncontains two inner lists.  Here is a matrix of the parameters sent\nto represent these lists:\n anchor    tag                       implicit  style\n  [nil,       nil,                      true,     1     ]\n  [nil,       "tag:yaml.org,2002:seq",  false,    2     ]\n  ["pewpew",  nil,                      true,     1     ]\n
start_stream Psych::Handler.start_stream(encoding)\nCalled with +encoding+ when the YAML stream starts.  This method is\ncalled once per stream.  A stream may contain multiple documents.\n\nSee the constants in Psych::Parser for the possible values of +encoding+.\n
streaming? Psych::Handler.streaming?()\nIs this handler a streaming handler?\n
new Psych::Emitter.new(p1, p2 = v2)\nCreate a new Psych::Emitter that writes to +io+.\n
alias Psych::Emitter.alias(p1)\nEmit an alias with +anchor+.\n\nSee Psych::Handler#alias\n
canonical Psych::Emitter.canonical()\nGet the output style, canonical or not.\n
canonical= Psych::Emitter.canonical=(p1)\nSet the output style to canonical, or not.\n
end_document Psych::Emitter.end_document(p1)\nEnd a document emission with an +implicit+ ending.\n\nSee Psych::Handler#end_document\n
end_mapping Psych::Emitter.end_mapping()\nEmit the end of a mapping.\n\nSee Psych::Handler#end_mapping\n
end_sequence Psych::Emitter.end_sequence()\nEnd sequence emission.\n\nSee Psych::Handler#end_sequence\n
end_stream Psych::Emitter.end_stream()\nEnd a stream emission\n\nSee Psych::Handler#end_stream\n
indentation Psych::Emitter.indentation()\nGet the indentation level.\n
indentation= Psych::Emitter.indentation=(p1)\nSet the indentation level to +level+.  The level must be less than 10 and\ngreater than 1.\n
line_width Psych::Emitter.line_width()\nGet the preferred line width.\n
line_width= Psych::Emitter.line_width=(p1)\nSet the preferred line with to +width+.\n
scalar Psych::Emitter.scalar(p1, p2, p3, p4, p5, p6)\nEmit a scalar with +value+, +anchor+, +tag+, and a +plain+ or +quoted+\nstring type with +style+.\n\nSee Psych::Handler#scalar\n
start_document Psych::Emitter.start_document(p1, p2, p3)\nStart a document emission with YAML +version+, +tags+, and an +implicit+\nstart.\n\nSee Psych::Handler#start_document\n
start_mapping Psych::Emitter.start_mapping(p1, p2, p3, p4)\nStart emitting a YAML map with +anchor+, +tag+, an +implicit+ start\nand end, and +style+.\n\nSee Psych::Handler#start_mapping\n
start_sequence Psych::Emitter.start_sequence(p1, p2, p3, p4)\nStart emitting a sequence with +anchor+, a +tag+, +implicit+ sequence\nstart and end, along with +style+.\n\nSee Psych::Handler#start_sequence\n
start_stream Psych::Emitter.start_stream(p1)\nStart a stream emission with +encoding+\n\nSee Psych::Handler#start_stream\n
new Psych::Coder.new(tag)\n\n
add Psych::Coder.add(k, v)\n\n
map Psych::Coder.map(tag = @tag, style = @style)\nEmit a map.  The coder will be yielded to the block.\n
map= Psych::Coder.map=(map)\nEmit a map with +value+\n
represent_map Psych::Coder.represent_map(tag, map)\nEmit a sequence with +map+ and +tag+\n
represent_object Psych::Coder.represent_object(tag, obj)\nEmit an arbitrary object +obj+ and +tag+\n
represent_scalar Psych::Coder.represent_scalar(tag, value)\nEmit a scalar with +value+ and +tag+\n
represent_seq Psych::Coder.represent_seq(tag, list)\nEmit a sequence with +list+ and +tag+\n
scalar Psych::Coder.scalar(*args)\n\n
scalar= Psych::Coder.scalar=(value)\nEmit a scalar with +value+\n
seq= Psych::Coder.seq=(list)\nEmit a sequence of +list+\n
new Psych::Nodes::Stream.new(encoding = UTF8)\nCreate a new Psych::Nodes::Stream node with an +encoding+ that\ndefaults to Psych::Nodes::Stream::UTF8.\n\nSee also Psych::Handler#start_stream\n
new Psych::Nodes::Scalar.new(value, anchor = nil, tag = nil, plain = true,\nquoted = false, style = ANY)\nCreate a new Psych::Nodes::Scalar object.\n\n+value+ is the string value of the scalar\n+anchor+ is an associated anchor or nil\n+tag+ is an associated tag or nil\n+plain+ is a boolean value\n+quoted+ is a boolean value\n+style+ is an integer idicating the string style\n\n== See Also\n\nSee also Psych::Handler#scalar\n
new Psych::Nodes::Node.new()\nCreate a new Psych::Nodes::Node\n
each Psych::Nodes::Node.each(&block)\nIterate over each node in the tree. Yields each node to +block+ depth\nfirst.\n
to_ruby Psych::Nodes::Node.to_ruby()\nConvert this node to Ruby.\n\nSee also Psych::Visitors::ToRuby\n
to_yaml Psych::Nodes::Node.to_yaml(io = nil, options = {})\n\n
transform Psych::Nodes::Node.transform()\n\n
yaml Psych::Nodes::Node.yaml(io = nil, options = {})\nConvert this node to YAML.\n\nSee also Psych::Visitors::Emitter\n
new Psych::Nodes::Mapping.new(anchor = nil, tag = nil, implicit = true, style\n= BLOCK)\nCreate a new Psych::Nodes::Mapping object.\n\n+anchor+ is the anchor associated with the map or +nil+.\n+tag+ is the tag associated with the map or +nil+.\n+implicit+ is a boolean indicating whether or not the map was implicitly\nstarted.\n+style+ is an integer indicating the mapping style.\n\n== See Also\nSee also Psych::Handler#start_mapping\n
new Psych::Nodes::Sequence.new(anchor = nil, tag = nil, implicit = true, style\n= BLOCK)\nCreate a new object representing a YAML sequence.\n\n+anchor+ is the anchor associated with the sequence or nil.\n+tag+ is the tag associated with the sequence or nil.\n+implicit+ a boolean indicating whether or not the sequence was\nimplicitly started.\n+style+ is an integer indicating the list style.\n\nSee Psych::Handler#start_sequence\n
new Psych::Nodes::Alias.new(anchor)\nCreate a new Alias that points to an +anchor+\n
new Psych::Nodes::Document.new(version = [], tag_directives = [], implicit = false)\nCreate a new Psych::Nodes::Document object.\n\n+version+ is a list indicating the YAML version.\n+tags_directives+ is a list of tag directive declarations\n+implicit+ is a flag indicating whether the document will be implicitly\nstarted.\n\n== Example:\nThis creates a YAML document object that represents a YAML 1.1 document\nwith one tag directive, and has an implicit start:\n\n  Psych::Nodes::Document.new(\n    [1,1],\n    [["!", "tag:tenderlovemaking.com,2009:"]],\n    true\n  )\n\n== See Also\nSee also Psych::Handler#start_document\n
root Psych::Nodes::Document.root()\nReturns the root node.  A Document may only have one root node:\nhttp://yaml.org/spec/1.1/#id898031\n
new Psych::Handler::DumperOptions.new()\n\n
new Psych::ScalarScanner.new()\nCreate a new scanner\n
parse_time Psych::ScalarScanner.parse_time(string)\nParse and return a Time from +string+\n
tokenize Psych::ScalarScanner.tokenize(string)\nTokenize +string+ returning the ruby object\n
new Psych::Visitors::DepthFirst.new(block)\n\n
new Psych::Visitors::YAMLTree.new(options = {})\n\n
accept Psych::Visitors::YAMLTree.accept(target)\n\n
finish Psych::Visitors::YAMLTree.finish()\n\n
push Psych::Visitors::YAMLTree.push(object)\n\n
start Psych::Visitors::YAMLTree.start(encoding = Nodes::Stream::UTF8)\n\n
tree Psych::Visitors::YAMLTree.tree()\n\n
visit_Array Psych::Visitors::YAMLTree.visit_Array(o)\n\n
visit_BigDecimal Psych::Visitors::YAMLTree.visit_BigDecimal(o)\n\n
visit_Class Psych::Visitors::YAMLTree.visit_Class(o)\n\n
visit_Complex Psych::Visitors::YAMLTree.visit_Complex(o)\n\n
visit_Date Psych::Visitors::YAMLTree.visit_Date(o)\n\n
visit_DateTime Psych::Visitors::YAMLTree.visit_DateTime(o)\n\n
visit_Exception Psych::Visitors::YAMLTree.visit_Exception(o)\n\n
visit_FalseClass Psych::Visitors::YAMLTree.visit_FalseClass(o)\n\n
visit_Float Psych::Visitors::YAMLTree.visit_Float(o)\n\n
visit_Hash Psych::Visitors::YAMLTree.visit_Hash(o)\n\n
visit_Integer Psych::Visitors::YAMLTree.visit_Integer(o)\n\n
visit_Module Psych::Visitors::YAMLTree.visit_Module(o)\n\n
visit_NilClass Psych::Visitors::YAMLTree.visit_NilClass(o)\n\n
visit_Object Psych::Visitors::YAMLTree.visit_Object(o)\n\n
visit_Psych_Omap Psych::Visitors::YAMLTree.visit_Psych_Omap(o)\n\n
visit_Psych_Set Psych::Visitors::YAMLTree.visit_Psych_Set(o)\n\n
visit_Range Psych::Visitors::YAMLTree.visit_Range(o)\n\n
visit_Rational Psych::Visitors::YAMLTree.visit_Rational(o)\n\n
visit_Regexp Psych::Visitors::YAMLTree.visit_Regexp(o)\n\n
visit_String Psych::Visitors::YAMLTree.visit_String(o)\n\n
visit_Struct Psych::Visitors::YAMLTree.visit_Struct(o)\n\n
visit_Symbol Psych::Visitors::YAMLTree.visit_Symbol(o)\n\n
visit_Time Psych::Visitors::YAMLTree.visit_Time(o)\n\n
visit_TrueClass Psych::Visitors::YAMLTree.visit_TrueClass(o)\n\n
new Psych::Visitors::ToRuby.new(ss = ScalarScanner.new)\n\n
accept Psych::Visitors::ToRuby.accept(target)\n\n
visit_Psych_Nodes_Alias Psych::Visitors::ToRuby.visit_Psych_Nodes_Alias(o)\n\n
visit_Psych_Nodes_Document Psych::Visitors::ToRuby.visit_Psych_Nodes_Document(o)\n\n
visit_Psych_Nodes_Mapping Psych::Visitors::ToRuby.visit_Psych_Nodes_Mapping(o)\n\n
visit_Psych_Nodes_Scalar Psych::Visitors::ToRuby.visit_Psych_Nodes_Scalar(o)\n\n
visit_Psych_Nodes_Sequence Psych::Visitors::ToRuby.visit_Psych_Nodes_Sequence(o)\n\n
visit_Psych_Nodes_Stream Psych::Visitors::ToRuby.visit_Psych_Nodes_Stream(o)\n\n
new Psych::Visitors::Emitter.new(io, options = {})\n\n
visit_Psych_Nodes_Alias Psych::Visitors::Emitter.visit_Psych_Nodes_Alias(o)\n\n
visit_Psych_Nodes_Document Psych::Visitors::Emitter.visit_Psych_Nodes_Document(o)\n\n
visit_Psych_Nodes_Mapping Psych::Visitors::Emitter.visit_Psych_Nodes_Mapping(o)\n\n
visit_Psych_Nodes_Scalar Psych::Visitors::Emitter.visit_Psych_Nodes_Scalar(o)\n\n
visit_Psych_Nodes_Sequence Psych::Visitors::Emitter.visit_Psych_Nodes_Sequence(o)\n\n
visit_Psych_Nodes_Stream Psych::Visitors::Emitter.visit_Psych_Nodes_Stream(o)\n\n
accept Psych::Visitors::Visitor.accept(target)\n\n
new Psych::Visitors::JSONTree.new(options = {})\n\n
accept Psych::Visitors::JSONTree.accept(target)\n\n
new Psych::SyntaxError.new(file, line, col, offset, problem, context)\n\n
new Psych::TreeBuilder.new()\nCreate a new TreeBuilder instance\n
alias Psych::TreeBuilder.alias(anchor)\n\n
end_document Psych::TreeBuilder.end_document(implicit_end = !streaming?)\nHandles end_document events with +version+, +tag_directives+,\nand +implicit+ styling.\n\nSee Psych::Handler#start_document\n
end_stream Psych::TreeBuilder.end_stream()\n\n
scalar Psych::TreeBuilder.scalar(value, anchor, tag, plain, quoted, style)\n\n
start_document Psych::TreeBuilder.start_document(version, tag_directives, implicit)\nHandles start_document events with +version+, +tag_directives+,\nand +implicit+ styling.\n\nSee Psych::Handler#start_document\n
start_stream Psych::TreeBuilder.start_stream(encoding)\n\n
new Psych::Parser.new(handler = Handler.new)\nCreates a new Psych::Parser instance with +handler+.  YAML events will\nbe called on +handler+.  See Psych::Parser for more details.\n
mark Psych::Parser.mark()\nReturns a Psych::Parser::Mark object that contains line, column, and index\ninformation.\n
parse Psych::Parser.parse(p1, p2 = v2)\nParse the YAML document contained in +yaml+.  Events will be called on\nthe handler set on the parser instance.\n\nSee Psych::Parser and Psych::Parser#handler\n
status PTY::ChildExited.status()\nReturns the exit status of the child for which PTY#check\nraised this exception\n
new Ripper::Filter.new(src, filename = '-', lineno = 1)\n\n
column Ripper::Filter.column()\nThe column number of the current token.\nThis value starts from 0.\nThis method is valid only in event handlers.\n
filename Ripper::Filter.filename()\nThe file name of the input.\n
lineno Ripper::Filter.lineno()\nThe line number of the current token.\nThis value starts from 1.\nThis method is valid only in event handlers.\n
parse Ripper::Filter.parse(init = nil)\nStarts parsing.  _init_ is a data accumulator.\nIt is passed to the next event handler (as of Enumerable#inject).\n
new Ripper::TokenPattern::MatchData.new(tokens, match)\n\n
string Ripper::TokenPattern::MatchData.string(n = 0)\n\n
new SDBM.new(p1, p2 = v2)\n\n
open SDBM.open(*args)\n\n
clear SDBM.clear()\n\n
close SDBM.close()\n\n
closed? SDBM.closed?()\n\n
delete SDBM.delete(p1)\n\n
delete_if SDBM.delete_if()\n\n
each SDBM.each()\n\n
each_key SDBM.each_key()\n\n
each_pair SDBM.each_pair()\n\n
each_value SDBM.each_value()\n\n
empty? SDBM.empty?()\n\n
fetch SDBM.fetch(p1, p2 = v2)\n\n
has_key? SDBM.has_key?(p1)\n\n
has_value? SDBM.has_value?(p1)\n\n
include? SDBM.include?(p1)\n\n
index SDBM.index(p1)\n\n
invert SDBM.invert()\n\n
key SDBM.key(p1)\n\n
key? SDBM.key?(p1)\n\n
keys SDBM.keys()\n\n
length SDBM.length()\n\n
member? SDBM.member?(p1)\n\n
reject SDBM.reject()\n\n
reject! SDBM.reject!()\n\n
replace SDBM.replace(p1)\n\n
select SDBM.select()\n\n
shift SDBM.shift()\n\n
size SDBM.size()\n\n
store SDBM.store(p1, p2)\n\n
to_a SDBM.to_a()\n\n
to_hash SDBM.to_hash()\n\n
update SDBM.update(p1)\n\n
value? SDBM.value?(p1)\n\n
values SDBM.values()\n\n
values_at SDBM.values_at(*args)\n\n
int Socket::AncillaryData.int(p1, p2, p3, p4)\nCreates a new Socket::AncillaryData object which contains a int as data.\n\nThe size and endian is dependent on the host.\n\n  p Socket::AncillaryData.int(:UNIX, :SOCKET, :RIGHTS, STDERR.fileno)\n=> #<Socket::AncillaryData: UNIX SOCKET RIGHTS 2>\n
ip_pktinfo Socket::AncillaryData.ip_pktinfo(p1, p2, p3 = v3)\nReturns new ancillary data for IP_PKTINFO.\n\nIf spec_dst is not given, addr is used.\n\nIP_PKTINFO is not standard.\n\nSupported platform: GNU/Linux\n\n  addr = Addrinfo.ip("127.0.0.1")\n  ifindex = 0\n  spec_dst = Addrinfo.ip("127.0.0.1")\n  p Socket::AncillaryData.ip_pktinfo(addr, ifindex, spec_dst)\n=> #<Socket::AncillaryData: INET IP PKTINFO 127.0.0.1 ifindex:0\nspec_dst:127.0.0.1>\n
ipv6_pktinfo Socket::AncillaryData.ipv6_pktinfo(p1, p2)\nReturns new ancillary data for IPV6_PKTINFO.\n\nIPV6_PKTINFO is defined by RFC 3542.\n\n  addr = Addrinfo.ip("::1")\n  ifindex = 0\n  p Socket::AncillaryData.ipv6_pktinfo(addr, ifindex)\n=> #<Socket::AncillaryData: INET6 IPV6 PKTINFO ::1 ifindex:0>\n
new Socket::AncillaryData.new(p1, p2, p3, p4)\n_family_ should be an integer, a string or a symbol.\n- Socket::AF_INET, "AF_INET", "INET", :AF_INET, :INET\n- Socket::AF_UNIX, "AF_UNIX", "UNIX", :AF_UNIX, :UNIX\n- etc.\n\n_cmsg_level_ should be an integer, a string or a symbol.\n- Socket::SOL_SOCKET, "SOL_SOCKET", "SOCKET", :SOL_SOCKET and :SOCKET\n- Socket::IPPROTO_IP, "IP" and :IP\n- Socket::IPPROTO_IPV6, "IPV6" and :IPV6\n- Socket::IPPROTO_TCP, "TCP" and :TCP\n- etc.\n\n_cmsg_type_ should be an integer, a string or a symbol.\nIf a string/symbol is specified, it is interpreted depend on _cmsg_level_.\n- Socket::SCM_RIGHTS, "SCM_RIGHTS", "RIGHTS", :SCM_RIGHTS, :RIGHTS for\nSOL_SOCKET\n- Socket::IP_RECVTTL, "RECVTTL" and :RECVTTL for IPPROTO_IP\n- Socket::IPV6_PKTINFO, "PKTINFO" and :PKTINFO for IPPROTO_IPV6\n- etc.\n\n_cmsg_data_ should be a string.\n\n  p Socket::AncillaryData.new(:INET, :TCP, :NODELAY, "")\n=> #<Socket::AncillaryData: INET TCP NODELAY "">\n\n  p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, "")\n=> #<Socket::AncillaryData: INET6 IPV6 PKTINFO "">\n
unix_rights Socket::AncillaryData.unix_rights(*args)\nCreates a new Socket::AncillaryData object which contains file descriptors\nas data.\n\n  p Socket::AncillaryData.unix_rights(STDERR)\n=> #<Socket::AncillaryData: UNIX SOCKET RIGHTS 2>\n
cmsg_is? Socket::AncillaryData.cmsg_is?(p1, p2)\ntests the level and type of _ancillarydata_.\n\n  ancdata = Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, "")\n  ancdata.cmsg_is?(Socket::IPPROTO_IPV6, Socket::IPV6_PKTINFO) #=> true\n  ancdata.cmsg_is?(:IPV6, :PKTINFO)       #=> true\n  ancdata.cmsg_is?(:IP, :PKTINFO)         #=> false\n  ancdata.cmsg_is?(:SOCKET, :RIGHTS)      #=> false\n
data Socket::AncillaryData.data()\nreturns the cmsg data as a string.\n\n  p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, "").data\n=> ""\n
family Socket::AncillaryData.family()\nreturns the socket family as an integer.\n\n  p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, "").family\n=> 10\n
inspect Socket::AncillaryData.inspect()\nreturns a string which shows ancillarydata in human-readable form.\n\n  p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, "").inspect\n=> "#<Socket::AncillaryData: INET6 IPV6 PKTINFO \"\">"\n
int Socket::AncillaryData.int()\nReturns the data in _ancillarydata_ as an int.\n\nThe size and endian is dependent on the host.\n\n  ancdata = Socket::AncillaryData.int(:UNIX, :SOCKET, :RIGHTS, STDERR.fileno)\n  p ancdata.int #=> 2\n
ip_pktinfo Socket::AncillaryData.ip_pktinfo()\nExtracts addr, ifindex and spec_dst from IP_PKTINFO ancillary data.\n\nIP_PKTINFO is not standard.\n\nSupported platform: GNU/Linux\n\n  addr = Addrinfo.ip("127.0.0.1")\n  ifindex = 0\n  spec_dest = Addrinfo.ip("127.0.0.1")\n  ancdata = Socket::AncillaryData.ip_pktinfo(addr, ifindex, spec_dest)\n  p ancdata.ip_pktinfo\n=> [#<Addrinfo: 127.0.0.1>, 0, #<Addrinfo: 127.0.0.1>]\n
ipv6_pktinfo Socket::AncillaryData.ipv6_pktinfo()\nExtracts addr and ifindex from IPV6_PKTINFO ancillary data.\n\nIPV6_PKTINFO is defined by RFC 3542.\n\n  addr = Addrinfo.ip("::1")\n  ifindex = 0\n  ancdata = Socket::AncillaryData.ipv6_pktinfo(addr, ifindex)\n  p ancdata.ipv6_pktinfo #=> [#<Addrinfo: ::1>, 0]\n
ipv6_pktinfo_addr Socket::AncillaryData.ipv6_pktinfo_addr()\nExtracts addr from IPV6_PKTINFO ancillary data.\n\nIPV6_PKTINFO is defined by RFC 3542.\n\n  addr = Addrinfo.ip("::1")\n  ifindex = 0\n  ancdata = Socket::AncillaryData.ipv6_pktinfo(addr, ifindex)\n  p ancdata.ipv6_pktinfo_addr #=> #<Addrinfo: ::1>\n
ipv6_pktinfo_ifindex Socket::AncillaryData.ipv6_pktinfo_ifindex()\nExtracts ifindex from IPV6_PKTINFO ancillary data.\n\nIPV6_PKTINFO is defined by RFC 3542.\n\n  addr = Addrinfo.ip("::1")\n  ifindex = 0\n  ancdata = Socket::AncillaryData.ipv6_pktinfo(addr, ifindex)\n  p ancdata.ipv6_pktinfo_ifindex #=> 0\n
level Socket::AncillaryData.level()\nreturns the cmsg level as an integer.\n\n  p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, "").level\n=> 41\n
timestamp Socket::AncillaryData.timestamp()\nreturns the timestamp as a time object.\n\n_ancillarydata_ should be one of following type:\n- SOL_SOCKET/SCM_TIMESTAMP (micro second) GNU/Linux, FreeBSD, NetBSD, OpenBSD,\nSolaris, MacOS X\n- SOL_SOCKET/SCM_TIMESTAMPNS (nano second) GNU/Linux\n- SOL_SOCKET/SCM_BINTIME (2**(-64) second) FreeBSD\n\n  Addrinfo.udp("127.0.0.1", 0).bind {|s1|\n    Addrinfo.udp("127.0.0.1", 0).bind {|s2|\n      s1.setsockopt(:SOCKET, :TIMESTAMP, true)\n      s2.send "a", 0, s1.local_address\n      ctl = s1.recvmsg.last\n      p ctl    #=> #<Socket::AncillaryData: INET SOCKET TIMESTAMP 2009-02-24\n      17:35:46.775581>\n      t = ctl.timestamp\n      p t      #=> 2009-02-24 17:35:46 +0900\n      p t.usec #=> 775581\n      p t.nsec #=> 775581000\n    }\n  }\n
type Socket::AncillaryData.type()\nreturns the cmsg type as an integer.\n\n  p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, "").type\n=> 2\n
unix_rights Socket::AncillaryData.unix_rights()\nreturns the array of IO objects for SCM_RIGHTS control message in UNIX\ndomain socket.\n\nThe class of the IO objects in the array is IO or Socket.\n\nThe array is attached to _ancillarydata_ when it is instantiated.\nFor example, BasicSocket#recvmsg attach the array when\nreceives a SCM_RIGHTS control message and :scm_rights=>true option is given.\n recvmsg needs :scm_rights=>true for unix_rights\n  s1, s2 = UNIXSocket.pair\n  p s1                                         #=> #<UNIXSocket:fd 3>\n  s1.sendmsg "stdin and a socket", 0, nil,\n  Socket::AncillaryData.unix_rights(STDIN, s1)\n  _, _, _, ctl = s2.recvmsg(:scm_rights=>true)\n  p ctl                                        #=> #<Socket::AncillaryData:\n  UNIX SOCKET RIGHTS 6 7>\n  p ctl.unix_rights                            #=> [#<IO:fd 6>, #<Socket:fd 7>]\n  p File.identical?(STDIN, ctl.unix_rights[0]) #=> true\n  p File.identical?(s1, ctl.unix_rights[1])    #=> true\n If :scm_rights=>true is not given, unix_rights returns nil\n  s1, s2 = UNIXSocket.pair\n  s1.sendmsg "stdin and a socket", 0, nil,\n  Socket::AncillaryData.unix_rights(STDIN, s1)\n  _, _, _, ctl = s2.recvmsg\n  p ctl #=> #<Socket::AncillaryData: UNIX SOCKET RIGHTS 6 7>\n  p ctl.unix_rights #=> nil\n
do_not_reverse_lookup BasicSocket.do_not_reverse_lookup()\nGets the global do_not_reverse_lookup flag.\n\n  BasicSocket.do_not_reverse_lookup  #=> false\n
do_not_reverse_lookup= BasicSocket.do_not_reverse_lookup=(p1)\nSets the global do_not_reverse_lookup flag.\n\nThe flag is used for initial value of do_not_reverse_lookup for each socket.\n\n  s1 = TCPSocket.new("localhost", 80)\n  p s1.do_not_reverse_lookup                 #=> true\n  BasicSocket.do_not_reverse_lookup = false\n  s2 = TCPSocket.new("localhost", 80)\n  p s2.do_not_reverse_lookup                 #=> false\n  p s1.do_not_reverse_lookup                 #=> true\n
for_fd BasicSocket.for_fd(p1)\nReturns a socket object which contains the file descriptor, _fd_.\n If invoked by inetd, STDIN/STDOUT/STDERR is a socket.\n  STDIN_SOCK = Socket.for_fd(STDIN.fileno)\n  p STDIN_SOCK.remote_address\n
close_read BasicSocket.close_read()\nDisallows further read using shutdown system call.\n\n  s1, s2 = UNIXSocket.pair\n  s1.close_read\n  s2.puts #=> Broken pipe (Errno::EPIPE)\n
close_write BasicSocket.close_write()\nDisallows further write using shutdown system call.\n\n  UNIXSocket.pair {|s1, s2|\n    s1.print "ping"\n    s1.close_write\n    p s2.read        #=> "ping"\n    s2.print "pong"\n    s2.close\n    p s1.read        #=> "pong"\n  }\n
connect_address BasicSocket.connect_address()\nReturns an address of the socket suitable for connect in the local machine.\n\nThis method returns _self_.local_address, except following condition.\n\n- IPv4 unspecified address (0.0.0.0) is replaced by IPv4 loopback address\n(127.0.0.1).\n- IPv6 unspecified address (::) is replaced by IPv6 loopback address (::1).\n\nIf the local address is not suitable for connect, SocketError is raised.\nIPv4 and IPv6 address which port is 0 is not suitable for connect.\nUnix domain socket which has no path is not suitable for connect.\n\n  Addrinfo.tcp("0.0.0.0", 0).listen {|serv|\n    p serv.connect_address #=> #<Addrinfo: 127.0.0.1:53660 TCP>\n    serv.connect_address.connect {|c|\n      s, _ = serv.accept\n      p [c, s] #=> [#<Socket:fd 4>, #<Socket:fd 6>]\n    }\n  }\n
do_not_reverse_lookup BasicSocket.do_not_reverse_lookup()\nGets the do_not_reverse_lookup flag of _basicsocket_.\n\n  TCPSocket.open("www.ruby-lang.org", 80) {|sock|\n    p sock.do_not_reverse_lookup      #=> false\n    p sock.peeraddr                   #=> ["AF_INET", 80,\n    "carbon.ruby-lang.org", "221.186.184.68"]\n    sock.do_not_reverse_lookup = true\n    p sock.peeraddr                   #=> ["AF_INET", 80, "221.186.184.68",\n    "221.186.184.68"]\n  }\n
do_not_reverse_lookup= BasicSocket.do_not_reverse_lookup=(p1)\nSets the do_not_reverse_lookup flag of _basicsocket_.\n\n  BasicSocket.do_not_reverse_lookup = false\n  p TCPSocket.new("127.0.0.1", 80).do_not_reverse_lookup #=> false\n  BasicSocket.do_not_reverse_lookup = true\n  p TCPSocket.new("127.0.0.1", 80).do_not_reverse_lookup #=> true\n
getpeereid BasicSocket.getpeereid()\nReturns the user and group on the peer of the UNIX socket.\nThe result is a two element array which contains the effective uid and the\neffective gid.\n\n  Socket.unix_server_loop("/tmp/sock") {|s|\n    begin\n      euid, egid = s.getpeereid\n Check the connected client is myself or not.\n      next if euid != Process.uid\n do something about my resource.\n\n    ensure\n      s.close\n    end\n  }\n
getpeername BasicSocket.getpeername()\nReturns the remote address of the socket as a sockaddr string.\n\n  TCPServer.open("127.0.0.1", 1440) {|serv|\n    c = TCPSocket.new("127.0.0.1", 1440)\n    s = serv.accept\n    p s.getpeername #=>\n    "\x02\x00\x82u\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"\n  }\n\nIf Addrinfo object is preferred over the binary string,\nuse BasicSocket#remote_address.\n
getsockname BasicSocket.getsockname()\nReturns the local address of the socket as a sockaddr string.\n\n  TCPServer.open("127.0.0.1", 15120) {|serv|\n    p serv.getsockname #=>\n    "\x02\x00;\x10\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"\n  }\n\nIf Addrinfo object is preferred over the binary string,\nuse BasicSocket#local_address.\n
getsockopt BasicSocket.getsockopt(p1, p2)\nGets a socket option. These are protocol and system specific, see your\nlocal system documentation for details. The option is returned as\na Socket::Option object.\n\n=== Parameters\n* +level+ is an integer, usually one of the SOL_ constants such as\n  Socket::SOL_SOCKET, or a protocol level.\n  A string or symbol of the name, possibly without prefix, is also\n  accepted.\n* +optname+ is an integer, usually one of the SO_ constants, such\n  as Socket::SO_REUSEADDR.\n  A string or symbol of the name, possibly without prefix, is also\n  accepted.\n\n=== Examples\n\nSome socket options are integers with boolean values, in this case\ngetsockopt could be called like this:\n\n  reuseaddr = sock.getsockopt(:SOCKET, :REUSEADDR).bool\n\n  optval = sock.getsockopt(Socket::SOL_SOCKET,Socket::SO_REUSEADDR)\n  optval = optval.unpack "i"\n  reuseaddr = optval[0] == 0 ? false : true\n\nSome socket options are integers with numeric values, in this case\ngetsockopt could be called like this:\n\n  ipttl = sock.getsockopt(:IP, :TTL).int\n\n  optval = sock.getsockopt(Socket::IPPROTO_IP, Socket::IP_TTL)\n  ipttl = optval.unpack("i")[0]\n\nOption values may be structs. Decoding them can be complex as it involves\nexamining your system headers to determine the correct definition. An\nexample is a +struct linger+, which may be defined in your system headers\nas:\n  struct linger {\n    int l_onoff;\n    int l_linger;\n  };\n\nIn this case #getsockopt could be called like this:\n Socket::Option knows linger structure.\n  onoff, linger = sock.getsockopt(:SOCKET, :LINGER).linger\n\n  optval =  sock.getsockopt(Socket::SOL_SOCKET, Socket::SO_LINGER)\n  onoff, linger = optval.unpack "ii"\n  onoff = onoff == 0 ? false : true\n
local_address BasicSocket.local_address()\nReturns an Addrinfo object for local address obtained by getsockname.\n\nNote that addrinfo.protocol is filled by 0.\n\n  TCPSocket.open("www.ruby-lang.org", 80) {|s|\n    p s.local_address #=> #<Addrinfo: 192.168.0.129:36873 TCP>\n  }\n\n  TCPServer.open("127.0.0.1", 1512) {|serv|\n    p serv.local_address #=> #<Addrinfo: 127.0.0.1:1512 TCP>\n  }\n
recv BasicSocket.recv(*args)\nReceives a message.\n\n_maxlen_ is the maximum number of bytes to receive.\n\n_flags_ should be a bitwise OR of Socket::MSG_* constants.\n\n  UNIXSocket.pair {|s1, s2|\n    s1.puts "Hello World"\n    p s2.recv(4)                     #=> "Hell"\n    p s2.recv(4, Socket::MSG_PEEK)   #=> "o Wo"\n    p s2.recv(4)                     #=> "o Wo"\n    p s2.recv(10)                    #=> "rld\\n"\n  }\n
recv_nonblock BasicSocket.recv_nonblock(*args)\nReceives up to _maxlen_ bytes from +socket+ using recvfrom(2) after\nO_NONBLOCK is set for the underlying file descriptor.\n_flags_ is zero or more of the +MSG_+ options.\nThe result, _mesg_, is the data received.\n\nWhen recvfrom(2) returns 0, Socket#recv_nonblock returns\nan empty string as data.\nThe meaning depends on the socket: EOF on TCP, empty packet on UDP, etc.\n\n=== Parameters\n* +maxlen+ - the number of bytes to receive from the socket\n* +flags+ - zero or more of the +MSG_+ options\n\n=== Example\n     serv = TCPServer.new("127.0.0.1", 0)\n     af, port, host, addr = serv.addr\n     c = TCPSocket.new(addr, port)\n     s = serv.accept\n     c.send "aaa", 0\n     begin # emulate blocking recv.\n       p s.recv_nonblock(10) #=> "aaa"\n     rescue IO::WaitReadable\n       IO.select([s])\n       retry\n     end\n\nRefer to Socket#recvfrom for the exceptions that may be thrown if the call\nto _recv_nonblock_ fails.\n\nBasicSocket#recv_nonblock may raise any error corresponding to recvfrom(2)\nfailure,\nincluding Errno::EWOULDBLOCK.\n\nIf the exception is Errno::EWOULDBLOCK or Errno::AGAIN,\nit is extended by IO::WaitReadable.\nSo IO::WaitReadable can be used to rescue the exceptions for retrying\nrecv_nonblock.\n\n=== See\n* Socket#recvfrom\n
recvmsg BasicSocket.recvmsg(*args)\nrecvmsg receives a message using recvmsg(2) system call in blocking manner.\n\n_maxmesglen_ is the maximum length of mesg to receive.\n\n_flags_ is bitwise OR of MSG_* constants such as Socket::MSG_PEEK.\n\n_maxcontrollen_ is the maximum length of controls (ancillary data) to receive.\n\n_opts_ is option hash.\nCurrently :scm_rights=>bool is the only option.\n\n:scm_rights option specifies that application expects SCM_RIGHTS control\nmessage.\nIf the value is nil or false, application don't expects SCM_RIGHTS control\nmessage.\nIn this case, recvmsg closes the passed file descriptors immediately.\nThis is the default behavior.\n\nIf :scm_rights value is neither nil nor false, application expects SCM_RIGHTS\ncontrol message.\nIn this case, recvmsg creates IO objects for each file descriptors for\nSocket::AncillaryData#unix_rights method.\n\nThe return value is 4-elements array.\n\n_mesg_ is a string of the received message.\n\n_sender_addrinfo_ is a sender socket address for connection-less socket.\nIt is an Addrinfo object.\nFor connection-oriented socket such as TCP, sender_addrinfo is platform\ndependent.\n\n_rflags_ is a flags on the received message which is bitwise OR of MSG_*\nconstants such as Socket::MSG_TRUNC.\nIt will be nil if the system uses 4.3BSD style old recvmsg system call.\n\n_controls_ is ancillary data which is an array of Socket::AncillaryData\nobjects such as:\n<Socket::AncillaryData: AF_UNIX SOCKET RIGHTS 7>\n\n_maxmesglen_ and _maxcontrollen_ can be nil.\nIn that case, the buffer will be grown until the message is not truncated.\nInternally, MSG_PEEK is used and MSG_TRUNC/MSG_CTRUNC are checked.\n\nrecvmsg can be used to implement recv_io as follows:\n\n  mesg, sender_sockaddr, rflags, *controls = sock.recvmsg(:scm_rights=>true)\n  controls.each {|ancdata|\n    if ancdata.cmsg_is?(:SOCKET, :RIGHTS)\n      return ancdata.unix_rights[0]\n    end\n  }\n
recvmsg_nonblock BasicSocket.recvmsg_nonblock(*args)\nrecvmsg receives a message using recvmsg(2) system call in non-blocking manner.\n\nIt is similar to BasicSocket#recvmsg\nbut non-blocking flag is set before the system call\nand it doesn't retry the system call.\n
remote_address BasicSocket.remote_address()\nReturns an Addrinfo object for remote address obtained by getpeername.\n\nNote that addrinfo.protocol is filled by 0.\n\n  TCPSocket.open("www.ruby-lang.org", 80) {|s|\n    p s.remote_address #=> #<Addrinfo: 221.186.184.68:80 TCP>\n  }\n\n  TCPServer.open("127.0.0.1", 1728) {|serv|\n    c = TCPSocket.new("127.0.0.1", 1728)\n    s = serv.accept\n    p s.remote_address #=> #<Addrinfo: 127.0.0.1:36504 TCP>\n  }\n
send BasicSocket.send(p1, p2, p3 = v3)\nsend _mesg_ via _basicsocket_.\n\n_mesg_ should be a string.\n\n_flags_ should be a bitwise OR of Socket::MSG_* constants.\n\n_dest_sockaddr_ should be a packed sockaddr string or an addrinfo.\n\n  TCPSocket.open("localhost", 80) {|s|\n    s.send "GET / HTTP/1.0\r\\n\r\\n", 0\n    p s.read\n  }\n
sendmsg BasicSocket.sendmsg(*args)\nsendmsg sends a message using sendmsg(2) system call in blocking manner.\n\n_mesg_ is a string to send.\n\n_flags_ is bitwise OR of MSG_* constants such as Socket::MSG_OOB.\n\n_dest_sockaddr_ is a destination socket address for connection-less socket.\nIt should be a sockaddr such as a result of Socket.sockaddr_in.\nAn Addrinfo object can be used too.\n\n_controls_ is a list of ancillary data.\nThe element of _controls_ should be Socket::AncillaryData or\n3-elements array.\nThe 3-element array should contains cmsg_level, cmsg_type and data.\n\nThe return value, _numbytes_sent_ is an integer which is the number of\nbytes sent.\n\nsendmsg can be used to implement send_io as follows:\n use Socket::AncillaryData.\n  ancdata = Socket::AncillaryData.int(:UNIX, :SOCKET, :RIGHTS, io.fileno)\n  sock.sendmsg("a", 0, nil, ancdata)\n use 3-element array.\n  ancdata = [:SOCKET, :RIGHTS, [io.fileno].pack("i!")]\n  sock.sendmsg("\0", 0, nil, ancdata)\n
sendmsg_nonblock BasicSocket.sendmsg_nonblock(*args)\nsendmsg_nonblock sends a message using sendmsg(2) system call in non-blocking\nmanner.\n\nIt is similar to BasicSocket#sendmsg\nbut the non-blocking flag is set before the system call\nand it doesn't retry the system call.\n
setsockopt BasicSocket.setsockopt(p1, p2, p3)\nSets a socket option. These are protocol and system specific, see your\nlocal system documentation for details.\n\n=== Parameters\n* +level+ is an integer, usually one of the SOL_ constants such as\n  Socket::SOL_SOCKET, or a protocol level.\n  A string or symbol of the name, possibly without prefix, is also\n  accepted.\n* +optname+ is an integer, usually one of the SO_ constants, such\n  as Socket::SO_REUSEADDR.\n  A string or symbol of the name, possibly without prefix, is also\n  accepted.\n* +optval+ is the value of the option, it is passed to the underlying\n  setsockopt() as a pointer to a certain number of bytes. How this is\n  done depends on the type:\n  - Fixnum: value is assigned to an int, and a pointer to the int is\n    passed, with length of sizeof(int).\n  - true or false: 1 or 0 (respectively) is assigned to an int, and the\n    int is passed as for a Fixnum. Note that +false+ must be passed,\n    not +nil+.\n  - String: the string's data and length is passed to the socket.\n* +socketoption+ is an instance of Socket::Option\n\n=== Examples\n\nSome socket options are integers with boolean values, in this case\nsetsockopt could be called like this:\n  sock.setsockopt(:SOCKET, :REUSEADDR, true)\n  sock.setsockopt(Socket::SOL_SOCKET,Socket::SO_REUSEADDR, true)\n  sock.setsockopt(Socket::Option.bool(:INET, :SOCKET, :REUSEADDR, true))\n\nSome socket options are integers with numeric values, in this case\nsetsockopt could be called like this:\n  sock.setsockopt(:IP, :TTL, 255)\n  sock.setsockopt(Socket::IPPROTO_IP, Socket::IP_TTL, 255)\n  sock.setsockopt(Socket::Option.int(:INET, :IP, :TTL, 255))\n\nOption values may be structs. Passing them can be complex as it involves\nexamining your system headers to determine the correct definition. An\nexample is an +ip_mreq+, which may be defined in your system headers as:\n  struct ip_mreq {\n    struct  in_addr imr_multiaddr;\n    struct  in_addr imr_interface;\n  };\n\nIn this case #setsockopt could be called like this:\n  optval = IPAddr.new("224.0.0.251").hton +\n           IPAddr.new(Socket::INADDR_ANY, Socket::AF_INET).hton\n  sock.setsockopt(Socket::IPPROTO_IP, Socket::IP_ADD_MEMBERSHIP, optval)\n
shutdown BasicSocket.shutdown(p1 = v1)\nCalls shutdown(2) system call.\n\ns.shutdown(Socket::SHUT_RD) disallows further read.\n\ns.shutdown(Socket::SHUT_WR) disallows further write.\n\ns.shutdown(Socket::SHUT_RDWR) disallows further read and write.\n\n_how_ can be symbol or string:\n- :RD, :SHUT_RD, "RD" and "SHUT_RD" are accepted as Socket::SHUT_RD.\n- :WR, :SHUT_WR, "WR" and "SHUT_WR" are accepted as Socket::SHUT_WR.\n- :RDWR, :SHUT_RDWR, "RDWR" and "SHUT_RDWR" are accepted as Socket::SHUT_RDWR.\n\n  UNIXSocket.pair {|s1, s2|\n    s1.puts "ping"\n    s1.shutdown(:WR)\n    p s2.read          #=> "ping\\n"\n    s2.puts "pong"\n    s2.close\n    p s1.read          #=> "pong\\n"\n  }\n
bool Socket::Option.bool(p1, p2, p3, p4)\nCreates a new Socket::Option object which contains boolean as data.\nActually 0 or 1 as int is used.\n\n  p Socket::Option.bool(:INET, :SOCKET, :KEEPALIVE, true)\n=> #<Socket::Option: INET SOCKET KEEPALIVE 1>\n\n  p Socket::Option.bool(:INET, :SOCKET, :KEEPALIVE, false)\n=> #<Socket::Option: AF_INET SOCKET KEEPALIVE 0>\n
int Socket::Option.int(p1, p2, p3, p4)\nCreates a new Socket::Option object which contains an int as data.\n\nThe size and endian is dependent on the platform.\n\n  p Socket::Option.int(:INET, :SOCKET, :KEEPALIVE, 1)\n=> #<Socket::Option: INET SOCKET KEEPALIVE 1>\n
linger Socket::Option.linger(p1, p2)\nCreates a new Socket::Option object for SOL_SOCKET/SO_LINGER.\n\n_onoff_ should be an integer or a boolean.\n\n_secs_ should be the number of seconds.\n\n  p Socket::Option.linger(true, 10)\n=> #<Socket::Option: UNSPEC SOCKET LINGER on 10sec>\n
new Socket::Option.new(p1, p2, p3, p4)\nReturns a new Socket::Option object.\n\n  sockopt = Socket::Option.new(:INET, :SOCKET, :KEEPALIVE, [1].pack("i"))\n  p sockopt #=> #<Socket::Option: INET SOCKET KEEPALIVE 1>\n
bool Socket::Option.bool()\nReturns the data in _sockopt_ as an boolean value.\n\n  sockopt = Socket::Option.int(:INET, :SOCKET, :KEEPALIVE, 1)\n  p sockopt.bool => true\n
data Socket::Option.data()\nreturns the socket option data as a string.\n\n  p Socket::Option.new(:INET6, :IPV6, :RECVPKTINFO, [1].pack("i!")).data\n=> "\x01\x00\x00\x00"\n
family Socket::Option.family()\nreturns the socket family as an integer.\n\n  p Socket::Option.new(:INET6, :IPV6, :RECVPKTINFO, [1].pack("i!")).family\n=> 10\n
inspect Socket::Option.inspect()\nReturns a string which shows sockopt in human-readable form.\n\n  p Socket::Option.new(:INET, :SOCKET, :KEEPALIVE, [1].pack("i")).inspect\n=> "#<Socket::Option: INET SOCKET KEEPALIVE 1>"\n
int Socket::Option.int()\nReturns the data in _sockopt_ as an int.\n\nThe size and endian is dependent on the platform.\n\n  sockopt = Socket::Option.int(:INET, :SOCKET, :KEEPALIVE, 1)\n  p sockopt.int => 1\n
level Socket::Option.level()\nreturns the socket level as an integer.\n\n  p Socket::Option.new(:INET6, :IPV6, :RECVPKTINFO, [1].pack("i!")).level\n=> 41\n
linger Socket::Option.linger()\nReturns the linger data in _sockopt_ as a pair of boolean and integer.\n\n  sockopt = Socket::Option.linger(true, 10)\n  p sockopt.linger => [true, 10]\n
optname Socket::Option.optname()\nreturns the socket option name as an integer.\n\n  p Socket::Option.new(:INET6, :IPV6, :RECVPKTINFO, [1].pack("i!")).optname\n=> 2\n
to_s Socket::Option.to_s()\nreturns the socket option data as a string.\n\n  p Socket::Option.new(:INET6, :IPV6, :RECVPKTINFO, [1].pack("i!")).data\n=> "\x01\x00\x00\x00"\n
unpack Socket::Option.unpack(p1)\nCalls String#unpack on sockopt.data.\n\n  sockopt = Socket::Option.new(:INET, :SOCKET, :KEEPALIVE, [1].pack("i"))\n  p sockopt.unpack("i")      #=> [1]\n  p sockopt.data.unpack("i") #=> [1]\n
foreach Addrinfo.foreach(nodename, service, family=nil, socktype=nil, protocol=nil,\nflags=nil, &block)\niterates over the list of Addrinfo objects obtained by Addrinfo.getaddrinfo.\n\n  Addrinfo.foreach(nil, 80) {|x| p x }\n=> #<Addrinfo: 127.0.0.1:80 TCP (:80)>\n   #<Addrinfo: 127.0.0.1:80 UDP (:80)>\n   #<Addrinfo: [::1]:80 TCP (:80)>\n   #<Addrinfo: [::1]:80 UDP (:80)>\n
getaddrinfo Addrinfo.getaddrinfo(p1, p2, p3 = v3, p4 = v4, p5 = v5, p6 = v6)\nreturns a list of addrinfo objects as an array.\n\nThis method converts nodename (hostname) and service (port) to addrinfo.\nSince the conversion is not unique, the result is a list of addrinfo objects.\n\nnodename or service can be nil if no conversion intended.\n\nfamily, socktype and protocol are hint for preferred protocol.\nIf the result will be used for a socket with SOCK_STREAM,\nSOCK_STREAM should be specified as socktype.\nIf so, Addrinfo.getaddrinfo returns addrinfo list appropriate for SOCK_STREAM.\nIf they are omitted or nil is given, the result is not restricted.\n\nSimilarly, PF_INET6 as family restricts for IPv6.\n\nflags should be bitwise OR of Socket::AI_??? constants.\n\nNote that socktype should be specified whenever application knows the usage\nof the address.\nSome platform causes an error when socktype is omitted and servname is\nspecified as an integer\nbecause some port numbers, 512 for example, are ambiguous without socktype.\n\n  Addrinfo.getaddrinfo("www.kame.net", 80, nil, :STREAM)\n=> [#<Addrinfo: 203.178.141.194:80 TCP (www.kame.net:80)>,\n    #<Addrinfo: [2001:200:0:8002:203:47ff:fea5:3085]:80 TCP (www.kame.net:80)>]\n
ip Addrinfo.ip(p1)\nreturns an addrinfo object for IP address.\n\nThe port, socktype, protocol of the result is filled by zero.\nSo, it is not appropriate to create a socket.\n\n  Addrinfo.ip("localhost") #=> #<Addrinfo: 127.0.0.1 (localhost)>\n
new Addrinfo.new(p1, p2 = v2, p3 = v3, p4 = v4)\nreturns a new instance of Addrinfo.\nThe instance contains sockaddr, family, socktype, protocol.\nsockaddr means struct sockaddr which can be used for connect(2), etc.\nfamily, socktype and protocol are integers which is used for arguments\nof socket(2).\n\nsockaddr is specified as an array or a string.\nThe array should be compatible to the value of IPSocket#addr or\nUNIXSocket#addr.\nThe string should be struct sockaddr as generated by\nSocket.sockaddr_in or Socket.unpack_sockaddr_un.\n\nsockaddr examples:\n- ["AF_INET", 46102, "localhost.localdomain", "127.0.0.1"]\n- ["AF_INET6", 42304, "ip6-localhost", "::1"]\n- ["AF_UNIX", "/tmp/sock"]\n- Socket.sockaddr_in("smtp", "2001:DB8::1")\n- Socket.sockaddr_in(80, "172.18.22.42")\n- Socket.sockaddr_in(80, "www.ruby-lang.org")\n- Socket.sockaddr_un("/tmp/sock")\n\nIn an AF_INET/AF_INET6 sockaddr array, the 4th element,\nnumeric IP address, is used to construct socket address in the Addrinfo\ninstance.\nIf the 3rd element, textual host name, is non-nil, it is also recorded but\nused only for Addrinfo#inspect.\n\nfamily is specified as an integer to specify the protocol family such as\nSocket::PF_INET.\nIt can be a symbol or a string which is the constant name\nwith or without PF_ prefix such as :INET, :INET6, :UNIX, "PF_INET", etc.\nIf omitted, PF_UNSPEC is assumed.\n\nsocktype is specified as an integer to specify the socket type such as\nSocket::SOCK_STREAM.\nIt can be a symbol or a string which is the constant name\nwith or without SOCK_ prefix such as :STREAM, :DGRAM, :RAW, "SOCK_STREAM", etc.\nIf omitted, 0 is assumed.\n\nprotocol is specified as an integer to specify the protocol such as\nSocket::IPPROTO_TCP.\nIt must be an integer, unlike family and socktype.\nIf omitted, 0 is assumed.\nNote that 0 is reasonable value for most protocols, except raw socket.\n
tcp Addrinfo.tcp(p1, p2)\nreturns an addrinfo object for TCP address.\n\n  Addrinfo.tcp("localhost", "smtp") #=> #<Addrinfo: 127.0.0.1:25 TCP\n  (localhost:smtp)>\n
udp Addrinfo.udp(p1, p2)\nreturns an addrinfo object for UDP address.\n\n  Addrinfo.udp("localhost", "daytime") #=> #<Addrinfo: 127.0.0.1:13 UDP\n  (localhost:daytime)>\n
unix Addrinfo.unix(p1, p2 = v2)\nreturns an addrinfo object for UNIX socket address.\n\n_socktype_ specifies the socket type.\nIf it is omitted, :STREAM is used.\n\n  Addrinfo.unix("/tmp/sock")         #=> #<Addrinfo: /tmp/sock SOCK_STREAM>\n  Addrinfo.unix("/tmp/sock", :DGRAM) #=> #<Addrinfo: /tmp/sock SOCK_DGRAM>\n
afamily Addrinfo.afamily()\nreturns the address family as an integer.\n\n  Addrinfo.tcp("localhost", 80).afamily == Socket::AF_INET #=> true\n
bind Addrinfo.bind()\ncreates a socket bound to self.\n\nIf a block is given, it is called with the socket and the value of the block\nis returned.\nThe socket is returned otherwise.\n\n  Addrinfo.udp("0.0.0.0", 9981).bind {|s|\n    s.local_address.connect {|s| s.send "hello", 0 }\n    p s.recv(10) #=> "hello"\n  }\n
canonname Addrinfo.canonname()\nreturns the canonical name as an string.\n\nnil is returned if no canonical name.\n\nThe canonical name is set by Addrinfo.getaddrinfo when AI_CANONNAME is\nspecified.\n\n  list = Addrinfo.getaddrinfo("www.ruby-lang.org", 80, :INET, :STREAM, nil,\n  Socket::AI_CANONNAME)\n  p list[0] #=> #<Addrinfo: 221.186.184.68:80 TCP carbon.ruby-lang.org\n  (www.ruby-lang.org:80)>\n  p list[0].canonname #=> "carbon.ruby-lang.org"\n
connect Addrinfo.connect(&block)\ncreates a socket connected to the address of self.\n\nIf a block is given, it is called with the socket and the value of the block\nis returned.\nThe socket is returned otherwise.\n\n  Addrinfo.tcp("www.ruby-lang.org", 80).connect {|s|\n    s.print "GET / HTTP/1.0\r\\nHost: www.ruby-lang.org\r\\n\r\\n"\n    puts s.read\n  }\n
connect_from Addrinfo.connect_from(*local_addr_args, &block)\ncreates a socket connected to the address of self.\n\nIf one or more arguments given as _local_addr_args_,\nit is used as the local address of the socket.\n_local_addr_args_ is given for family_addrinfo to obtain actual address.\n\nIf no arguments given, the local address of the socket is not bound.\n\nIf a block is given, it is called with the socket and the value of the block\nis returned.\nThe socket is returned otherwise.\n\n  Addrinfo.tcp("www.ruby-lang.org", 80).connect_from("0.0.0.0", 4649) {|s|\n    s.print "GET / HTTP/1.0\r\\nHost: www.ruby-lang.org\r\\n\r\\n"\n    puts s.read\n  }\n Addrinfo object can be taken for the argument.\n  Addrinfo.tcp("www.ruby-lang.org", 80).connect_from(Addrinfo.tcp("0.0.0.0",\n  4649)) {|s|\n    s.print "GET / HTTP/1.0\r\\nHost: www.ruby-lang.org\r\\n\r\\n"\n    puts s.read\n  }\n
connect_to Addrinfo.connect_to(*remote_addr_args, &block)\ncreates a socket connected to _remote_addr_args_ and bound to self.\n\nIf a block is given, it is called with the socket and the value of the block\nis returned.\nThe socket is returned otherwise.\n\n  Addrinfo.tcp("0.0.0.0", 4649).connect_to("www.ruby-lang.org", 80) {|s|\n    s.print "GET / HTTP/1.0\r\\nHost: www.ruby-lang.org\r\\n\r\\n"\n    puts s.read\n  }\n
family_addrinfo Addrinfo.family_addrinfo(*args)\ncreates an Addrinfo object from the arguments.\n\nThe arguments are interpreted as similar to self.\n\n  Addrinfo.tcp("0.0.0.0", 4649).family_addrinfo("www.ruby-lang.org", 80)\n=> #<Addrinfo: 221.186.184.68:80 TCP (www.ruby-lang.org:80)>\n\n  Addrinfo.unix("/tmp/sock").family_addrinfo("/tmp/sock2")\n=> #<Addrinfo: /tmp/sock2 SOCK_STREAM>\n
getnameinfo Addrinfo.getnameinfo(p1 = v1)\nreturns nodename and service as a pair of strings.\nThis converts struct sockaddr in addrinfo to textual representation.\n\nflags should be bitwise OR of Socket::NI_??? constants.\n\n  Addrinfo.tcp("127.0.0.1", 80).getnameinfo #=> ["localhost", "www"]\n\n  Addrinfo.tcp("127.0.0.1", 80).getnameinfo(Socket::NI_NUMERICSERV)\n=> ["localhost", "80"]\n
inspect Addrinfo.inspect()\nreturns a string which shows addrinfo in human-readable form.\n\n  Addrinfo.tcp("localhost", 80).inspect #=> "#<Addrinfo: 127.0.0.1:80 TCP\n  (localhost:80)>"\n  Addrinfo.unix("/tmp/sock").inspect    #=> "#<Addrinfo: /tmp/sock\n  SOCK_STREAM>"\n
inspect_sockaddr Addrinfo.inspect_sockaddr()\nreturns a string which shows the sockaddr in _addrinfo_ with human-readable\nform.\n\n  Addrinfo.tcp("localhost", 80).inspect_sockaddr     #=> "127.0.0.1:80"\n  Addrinfo.tcp("ip6-localhost", 80).inspect_sockaddr #=> "[::1]:80"\n  Addrinfo.unix("/tmp/sock").inspect_sockaddr        #=> "/tmp/sock"\n
ip? Addrinfo.ip?()\nreturns true if addrinfo is internet (IPv4/IPv6) address.\nreturns false otherwise.\n\n  Addrinfo.tcp("127.0.0.1", 80).ip? #=> true\n  Addrinfo.tcp("::1", 80).ip?       #=> true\n  Addrinfo.unix("/tmp/sock").ip?    #=> false\n
ip_address Addrinfo.ip_address()\nReturns the IP address as a string.\n\n  Addrinfo.tcp("127.0.0.1", 80).ip_address    #=> "127.0.0.1"\n  Addrinfo.tcp("::1", 80).ip_address          #=> "::1"\n
ip_port Addrinfo.ip_port()\nReturns the port number as an integer.\n\n  Addrinfo.tcp("127.0.0.1", 80).ip_port    #=> 80\n  Addrinfo.tcp("::1", 80).ip_port          #=> 80\n
ip_unpack Addrinfo.ip_unpack()\nReturns the IP address and port number as 2-element array.\n\n  Addrinfo.tcp("127.0.0.1", 80).ip_unpack    #=> ["127.0.0.1", 80]\n  Addrinfo.tcp("::1", 80).ip_unpack          #=> ["::1", 80]\n
ipv4? Addrinfo.ipv4?()\nreturns true if addrinfo is IPv4 address.\nreturns false otherwise.\n\n  Addrinfo.tcp("127.0.0.1", 80).ipv4? #=> true\n  Addrinfo.tcp("::1", 80).ipv4?       #=> false\n  Addrinfo.unix("/tmp/sock").ipv4?    #=> false\n
ipv4_loopback? Addrinfo.ipv4_loopback?()\nReturns true for IPv4 loopback address (127.0.0.0/8).\nIt returns false otherwise.\n
ipv4_multicast? Addrinfo.ipv4_multicast?()\nReturns true for IPv4 multicast address (224.0.0.0/4).\nIt returns false otherwise.\n
ipv4_private? Addrinfo.ipv4_private?()\nReturns true for IPv4 private address (10.0.0.0/8, 172.16.0.0/12,\n192.168.0.0/16).\nIt returns false otherwise.\n
ipv6? Addrinfo.ipv6?()\nreturns true if addrinfo is IPv6 address.\nreturns false otherwise.\n\n  Addrinfo.tcp("127.0.0.1", 80).ipv6? #=> false\n  Addrinfo.tcp("::1", 80).ipv6?       #=> true\n  Addrinfo.unix("/tmp/sock").ipv6?    #=> false\n
ipv6_linklocal? Addrinfo.ipv6_linklocal?()\nReturns true for IPv6 link local address (ff80::/10).\nIt returns false otherwise.\n
ipv6_loopback? Addrinfo.ipv6_loopback?()\nReturns true for IPv6 loopback address (::1).\nIt returns false otherwise.\n
ipv6_mc_global? Addrinfo.ipv6_mc_global?()\nReturns true for IPv6 multicast global scope address.\nIt returns false otherwise.\n
ipv6_mc_linklocal? Addrinfo.ipv6_mc_linklocal?()\nReturns true for IPv6 multicast link-local scope address.\nIt returns false otherwise.\n
ipv6_mc_nodelocal? Addrinfo.ipv6_mc_nodelocal?()\nReturns true for IPv6 multicast node-local scope address.\nIt returns false otherwise.\n
ipv6_mc_orglocal? Addrinfo.ipv6_mc_orglocal?()\nReturns true for IPv6 multicast organization-local scope address.\nIt returns false otherwise.\n
ipv6_mc_sitelocal? Addrinfo.ipv6_mc_sitelocal?()\nReturns true for IPv6 multicast site-local scope address.\nIt returns false otherwise.\n
ipv6_multicast? Addrinfo.ipv6_multicast?()\nReturns true for IPv6 multicast address (ff00::/8).\nIt returns false otherwise.\n
ipv6_sitelocal? Addrinfo.ipv6_sitelocal?()\nReturns true for IPv6 site local address (ffc0::/10).\nIt returns false otherwise.\n
ipv6_to_ipv4 Addrinfo.ipv6_to_ipv4()\nReturns IPv4 address of IPv4 mapped/compatible IPv6 address.\nIt returns nil if +self+ is not IPv4 mapped/compatible IPv6 address.\n\n  Addrinfo.ip("::192.0.2.3").ipv6_to_ipv4      #=> #<Addrinfo: 192.0.2.3>\n  Addrinfo.ip("::ffff:192.0.2.3").ipv6_to_ipv4 #=> #<Addrinfo: 192.0.2.3>\n  Addrinfo.ip("::1").ipv6_to_ipv4              #=> nil\n  Addrinfo.ip("192.0.2.3").ipv6_to_ipv4        #=> nil\n  Addrinfo.unix("/tmp/sock").ipv6_to_ipv4      #=> nil\n
ipv6_unspecified? Addrinfo.ipv6_unspecified?()\nReturns true for IPv6 unspecified address (::).\nIt returns false otherwise.\n
ipv6_v4compat? Addrinfo.ipv6_v4compat?()\nReturns true for IPv4-compatible IPv6 address (::/80).\nIt returns false otherwise.\n
ipv6_v4mapped? Addrinfo.ipv6_v4mapped?()\nReturns true for IPv4-mapped IPv6 address (::ffff:0:0/80).\nIt returns false otherwise.\n
listen Addrinfo.listen(backlog=5)\ncreates a listening socket bound to self.\n
pfamily Addrinfo.pfamily()\nreturns the protocol family as an integer.\n\n  Addrinfo.tcp("localhost", 80).pfamily == Socket::PF_INET #=> true\n
protocol Addrinfo.protocol()\nreturns the socket type as an integer.\n\n  Addrinfo.tcp("localhost", 80).protocol == Socket::IPPROTO_TCP #=> true\n
socktype Addrinfo.socktype()\nreturns the socket type as an integer.\n\n  Addrinfo.tcp("localhost", 80).socktype == Socket::SOCK_STREAM #=> true\n
to_s Addrinfo.to_s()\nreturns the socket address as packed struct sockaddr string.\n\n  Addrinfo.tcp("localhost", 80).to_sockaddr\n=> "\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"\n
to_sockaddr Addrinfo.to_sockaddr()\nreturns the socket address as packed struct sockaddr string.\n\n  Addrinfo.tcp("localhost", 80).to_sockaddr\n=> "\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"\n
unix? Addrinfo.unix?()\nreturns true if addrinfo is UNIX address.\nreturns false otherwise.\n\n  Addrinfo.tcp("127.0.0.1", 80).unix? #=> false\n  Addrinfo.tcp("::1", 80).unix?       #=> false\n  Addrinfo.unix("/tmp/sock").unix?    #=> true\n
unix_path Addrinfo.unix_path()\nReturns the socket path as a string.\n\n  Addrinfo.unix("/tmp/sock").unix_path       #=> "/tmp/sock"\n
new TCPServer.new(p1 = v1, p2)\nCreates a new server socket bound to _port_.\n\nIf _hostname_ is given, the socket is bound to it.\n\n  serv = TCPServer.new("127.0.0.1", 28561)\n  s = serv.accept\n  s.puts Time.now\n  s.close\n
accept TCPServer.accept()\nTCPServer.open("127.0.0.1", 14641) {|serv|\n  s = serv.accept\n  s.puts Time.now\n  s.close\n}\n
accept_nonblock TCPServer.accept_nonblock()\nAccepts an incoming connection using accept(2) after\nO_NONBLOCK is set for the underlying file descriptor.\nIt returns an accepted TCPSocket for the incoming connection.\n\n=== Example\n     require 'socket'\n     serv = TCPServer.new(2202)\n     begin # emulate blocking accept\n       sock = serv.accept_nonblock\n     rescue IO::WaitReadable, Errno::EINTR\n       IO.select([serv])\n       retry\n     end\n sock is an accepted socket.\n\nRefer to Socket#accept for the exceptions that may be thrown if the call\nto TCPServer#accept_nonblock fails.\n\nTCPServer#accept_nonblock may raise any error corresponding to accept(2)\nfailure,\nincluding Errno::EWOULDBLOCK.\n\nIf the exception is Errno::EWOULDBLOCK, Errno::AGAIN, Errno::ECONNABORTED,\nErrno::EPROTO,\nit is extended by IO::WaitReadable.\nSo IO::WaitReadable can be used to rescue the exceptions for retrying\naccept_nonblock.\n\n=== See\n* TCPServer#accept\n* Socket#accept\n
listen TCPServer.listen(p1)\nListens for connections, using the specified +int+ as the backlog. A call\nto _listen_ only applies if the +socket+ is of type SOCK_STREAM or\nSOCK_SEQPACKET.\n\n=== Parameter\n* +backlog+ - the maximum length of the queue for pending connections.\n\n=== Example 1\n     require 'socket'\n     include Socket::Constants\n     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )\n     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )\n     socket.bind( sockaddr )\n     socket.listen( 5 )\n\n=== Example 2 (listening on an arbitrary port, unix-based systems only):\n     require 'socket'\n     include Socket::Constants\n     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )\n     socket.listen( 1 )\n\n=== Unix-based Exceptions\nOn unix based systems the above will work because a new +sockaddr+ struct\nis created on the address ADDR_ANY, for an arbitrary port number as handed\noff by the kernel. It will not work on Windows, because Windows requires that\nthe +socket+ is bound by calling _bind_ before it can _listen_.\n\nIf the _backlog_ amount exceeds the implementation-dependent maximum\nqueue length, the implementation's maximum queue length will be used.\n\nOn unix-based based systems the following system exceptions may be raised\nif the\ncall to _listen_ fails:\n* Errno::EBADF - the _socket_ argument is not a valid file descriptor\n* Errno::EDESTADDRREQ - the _socket_ is not bound to a local address, and\n  the protocol does not support listening on an unbound socket\n* Errno::EINVAL - the _socket_ is already connected\n* Errno::ENOTSOCK - the _socket_ argument does not refer to a socket\n* Errno::EOPNOTSUPP - the _socket_ protocol does not support listen\n* Errno::EACCES - the calling process does not have appropriate privileges\n* Errno::EINVAL - the _socket_ has been shut down\n* Errno::ENOBUFS - insufficient resources are available in the system to\n  complete the call\n\n=== Windows Exceptions\nOn Windows systems the following system exceptions may be raised if\nthe call to _listen_ fails:\n* Errno::ENETDOWN - the network is down\n* Errno::EADDRINUSE - the socket's local address is already in use. This\n  usually occurs during the execution of _bind_ but could be delayed\n  if the call to _bind_ was to a partially wildcard address (involving\n  ADDR_ANY) and if a specific address needs to be committed at the\n  time of the call to _listen_\n* Errno::EINPROGRESS - a Windows Sockets 1.1 call is in progress or the\n  service provider is still processing a callback function\n* Errno::EINVAL - the +socket+ has not been bound with a call to _bind_.\n* Errno::EISCONN - the +socket+ is already connected\n* Errno::EMFILE - no more socket descriptors are available\n* Errno::ENOBUFS - no buffer space is available\n* Errno::ENOTSOC - +socket+ is not a socket\n* Errno::EOPNOTSUPP - the referenced +socket+ is not a type that supports\n  the _listen_ method\n\n=== See\n* listen manual pages on unix-based systems\n* listen function in Microsoft's Winsock functions reference\n
sysaccept TCPServer.sysaccept()\nReturns a file descriptor of a accepted connection.\n\n  TCPServer.open("127.0.0.1", 28561) {|serv|\n    fd = serv.sysaccept\n    s = IO.for_fd(fd)\n    s.puts Time.now\n    s.close\n  }\n
new UNIXServer.new(p1)\nCreates a new UNIX server socket bound to _path_.\n\n  serv = UNIXServer.new("/tmp/sock")\n  s = serv.accept\n  p s.read\n
accept UNIXServer.accept()\nAccepts a new connection.\nIt returns new UNIXSocket object.\n\n  UNIXServer.open("/tmp/sock") {|serv|\n    UNIXSocket.open("/tmp/sock") {|c|\n      s = serv.accept\n      s.puts "hi"\n      s.close\n      p c.read #=> "hi\\n"\n    }\n  }\n
accept_nonblock UNIXServer.accept_nonblock()\nAccepts an incoming connection using accept(2) after\nO_NONBLOCK is set for the underlying file descriptor.\nIt returns an accepted UNIXSocket for the incoming connection.\n\n=== Example\n     require 'socket'\n     serv = UNIXServer.new("/tmp/sock")\n     begin # emulate blocking accept\n       sock = serv.accept_nonblock\n     rescue IO::WaitReadable, Errno::EINTR\n       IO.select([serv])\n       retry\n     end\n sock is an accepted socket.\n\nRefer to Socket#accept for the exceptions that may be thrown if the call\nto UNIXServer#accept_nonblock fails.\n\nUNIXServer#accept_nonblock may raise any error corresponding to accept(2)\nfailure,\nincluding Errno::EWOULDBLOCK.\n\nIf the exception is Errno::EWOULDBLOCK, Errno::AGAIN, Errno::ECONNABORTED\nor Errno::EPROTO,\nit is extended by IO::WaitReadable.\nSo IO::WaitReadable can be used to rescue the exceptions for retrying\naccept_nonblock.\n\n=== See\n* UNIXServer#accept\n* Socket#accept\n
listen UNIXServer.listen(p1)\nListens for connections, using the specified +int+ as the backlog. A call\nto _listen_ only applies if the +socket+ is of type SOCK_STREAM or\nSOCK_SEQPACKET.\n\n=== Parameter\n* +backlog+ - the maximum length of the queue for pending connections.\n\n=== Example 1\n     require 'socket'\n     include Socket::Constants\n     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )\n     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )\n     socket.bind( sockaddr )\n     socket.listen( 5 )\n\n=== Example 2 (listening on an arbitrary port, unix-based systems only):\n     require 'socket'\n     include Socket::Constants\n     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )\n     socket.listen( 1 )\n\n=== Unix-based Exceptions\nOn unix based systems the above will work because a new +sockaddr+ struct\nis created on the address ADDR_ANY, for an arbitrary port number as handed\noff by the kernel. It will not work on Windows, because Windows requires that\nthe +socket+ is bound by calling _bind_ before it can _listen_.\n\nIf the _backlog_ amount exceeds the implementation-dependent maximum\nqueue length, the implementation's maximum queue length will be used.\n\nOn unix-based based systems the following system exceptions may be raised\nif the\ncall to _listen_ fails:\n* Errno::EBADF - the _socket_ argument is not a valid file descriptor\n* Errno::EDESTADDRREQ - the _socket_ is not bound to a local address, and\n  the protocol does not support listening on an unbound socket\n* Errno::EINVAL - the _socket_ is already connected\n* Errno::ENOTSOCK - the _socket_ argument does not refer to a socket\n* Errno::EOPNOTSUPP - the _socket_ protocol does not support listen\n* Errno::EACCES - the calling process does not have appropriate privileges\n* Errno::EINVAL - the _socket_ has been shut down\n* Errno::ENOBUFS - insufficient resources are available in the system to\n  complete the call\n\n=== Windows Exceptions\nOn Windows systems the following system exceptions may be raised if\nthe call to _listen_ fails:\n* Errno::ENETDOWN - the network is down\n* Errno::EADDRINUSE - the socket's local address is already in use. This\n  usually occurs during the execution of _bind_ but could be delayed\n  if the call to _bind_ was to a partially wildcard address (involving\n  ADDR_ANY) and if a specific address needs to be committed at the\n  time of the call to _listen_\n* Errno::EINPROGRESS - a Windows Sockets 1.1 call is in progress or the\n  service provider is still processing a callback function\n* Errno::EINVAL - the +socket+ has not been bound with a call to _bind_.\n* Errno::EISCONN - the +socket+ is already connected\n* Errno::EMFILE - no more socket descriptors are available\n* Errno::ENOBUFS - no buffer space is available\n* Errno::ENOTSOC - +socket+ is not a socket\n* Errno::EOPNOTSUPP - the referenced +socket+ is not a type that supports\n  the _listen_ method\n\n=== See\n* listen manual pages on unix-based systems\n* listen function in Microsoft's Winsock functions reference\n
sysaccept UNIXServer.sysaccept()\nAccepts a new connection.\nIt returns the new file descriptor which is an integer.\n\n  UNIXServer.open("/tmp/sock") {|serv|\n    UNIXSocket.open("/tmp/sock") {|c|\n      fd = serv.sysaccept\n      s = IO.new(fd)\n      s.puts "hi"\n      s.close\n      p c.read #=> "hi\\n"\n    }\n  }\n
new UNIXSocket.new(p1)\nCreates a new UNIX client socket connected to _path_.\n\n  s = UNIXSocket.new("/tmp/sock")\n  s.send "hello", 0\n
pair UNIXSocket.pair(p1 = v1, p2 = v2)\nCreates a pair of sockets connected each other.\n\n_socktype_ should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.\n\n_protocol_ should be a protocol defined in the domain.\n0 is default protocol for the domain.\n\n  s1, s2 = UNIXSocket.pair\n  s1.send "a", 0\n  s1.send "b", 0\n  p s2.recv(10) #=> "ab"\n
socketpair UNIXSocket.socketpair(p1 = v1, p2 = v2)\nCreates a pair of sockets connected each other.\n\n_socktype_ should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.\n\n_protocol_ should be a protocol defined in the domain.\n0 is default protocol for the domain.\n\n  s1, s2 = UNIXSocket.pair\n  s1.send "a", 0\n  s1.send "b", 0\n  p s2.recv(10) #=> "ab"\n
addr UNIXSocket.addr()\nReturns the local address as an array which contains\naddress_family and unix_path.\n\nExample\n  serv = UNIXServer.new("/tmp/sock")\n  p serv.addr #=> ["AF_UNIX", "/tmp/sock"]\n
path UNIXSocket.path()\nReturns the path of the local address of unixsocket.\n\n  s = UNIXServer.new("/tmp/sock")\n  p s.path #=> "/tmp/sock"\n
peeraddr UNIXSocket.peeraddr()\nReturns the remote address as an array which contains\naddress_family and unix_path.\n\nExample\n  serv = UNIXServer.new("/tmp/sock")\n  c = UNIXSocket.new("/tmp/sock")\n  p c.peeraddr #=> ["AF_UNIX", "/tmp/sock"]\n
recv_io UNIXSocket.recv_io(p1 = v1, p2 = v2)\nUNIXServer.open("/tmp/sock") {|serv|\n  UNIXSocket.open("/tmp/sock") {|c|\n    s = serv.accept\n\n    c.send_io STDOUT\n    stdout = s.recv_io\n\n    p STDOUT.fileno #=> 1\n    p stdout.fileno #=> 7\n\n    stdout.puts "hello" # outputs "hello\\n" to standard output.\n  }\n}\n
recvfrom UNIXSocket.recvfrom(*args)\nReceives a message via _unixsocket_.\n\n_maxlen_ is the maximum number of bytes to receive.\n\n_flags_ should be a bitwise OR of Socket::MSG_* constants.\n\n  s1 = Socket.new(:UNIX, :DGRAM, 0)\n  s1_ai = Addrinfo.unix("/tmp/sock1")\n  s1.bind(s1_ai)\n\n  s2 = Socket.new(:UNIX, :DGRAM, 0)\n  s2_ai = Addrinfo.unix("/tmp/sock2")\n  s2.bind(s2_ai)\n  s3 = UNIXSocket.for_fd(s2.fileno)\n\n  s1.send "a", 0, s2_ai\n  p s3.recvfrom(10) #=> ["a", ["AF_UNIX", "/tmp/sock1"]]\n
send_io UNIXSocket.send_io(p1)\nSends _io_ as file descriptor passing.\n\n  s1, s2 = UNIXSocket.pair\n\n  s1.send_io STDOUT\n  stdout = s2.recv_io\n\n  p STDOUT.fileno #=> 1\n  p stdout.fileno #=> 6\n\n  stdout.puts "hello" # outputs "hello\\n" to standard output.\n
new Socket::UDPSource.new(remote_address, local_address, &reply_proc)\n+remote_adress+ is an Addrinfo object.\n\n+local_adress+ is an Addrinfo object.\n\n+reply_proc+ is a Proc used to send reply back to the source.\n
reply Socket::UDPSource.reply(msg)\nSends the String +msg+ to the source\n
new StringIO.new(*args)\nCreates new StringIO instance from with _string_ and _mode_.\n
open StringIO.open(*args)\nEquivalent to StringIO.new except that when it is called with a block, it\nyields with the new instance and closes it, and returns the result which\nreturned from the block.\n
binmode StringIO.binmode()\nReturns *strio* itself.  Just for compatibility to IO.\n
bytes StringIO.bytes()\nSee IO#each_byte.\n
chars StringIO.chars()\nSee IO#each_char.\n
close StringIO.close()\nCloses strio.  The *strio* is unavailable for any further data\noperations; an +IOError+ is raised if such an attempt is made.\n
close_read StringIO.close_read()\nCloses the read end of a StringIO.  Will raise an +IOError+ if the\n*strio* is not readable.\n
close_write StringIO.close_write()\nCloses the write end of a StringIO.  Will raise an  +IOError+ if the\n*strio* is not writeable.\n
closed? StringIO.closed?()\nReturns +true+ if *strio* is completely closed, +false+ otherwise.\n
closed_read? StringIO.closed_read?()\nReturns +true+ if *strio* is not readable, +false+ otherwise.\n
closed_write? StringIO.closed_write?()\nReturns +true+ if *strio* is not writable, +false+ otherwise.\n
codepoints StringIO.codepoints()\nSee IO#each_codepoint.\n
each StringIO.each(*args)\nSee IO#each.\n
each_byte StringIO.each_byte()\nSee IO#each_byte.\n
each_char StringIO.each_char()\nSee IO#each_char.\n
each_codepoint StringIO.each_codepoint()\nSee IO#each_codepoint.\n
each_line StringIO.each_line(*args)\nSee IO#each.\n
eof StringIO.eof()\nReturns true if *strio* is at end of file. The stringio must be\nopened for reading or an +IOError+ will be raised.\n
eof? StringIO.eof?()\nReturns true if *strio* is at end of file. The stringio must be\nopened for reading or an +IOError+ will be raised.\n
external_encoding StringIO.external_encoding()\nReturns the Encoding object that represents the encoding of the file.\nIf strio is write mode and no encoding is specified, returns `nil`.\n
fcntl StringIO.fcntl(*args)\nRaises NotImplementedError.\n
fileno StringIO.fileno()\nReturns +nil+.  Just for compatibility to IO.\n
flush StringIO.flush()\nReturns *strio* itself.  Just for compatibility to IO.\n
fsync StringIO.fsync()\nReturns 0.  Just for compatibility to IO.\n
getbyte StringIO.getbyte()\nSee IO#getbyte.\n
getc StringIO.getc()\nSee IO#getc.\n
gets StringIO.gets(*args)\nSee IO#gets.\n
internal_encoding StringIO.internal_encoding()\nReturns the Encoding of the internal string if conversion is\nspecified.  Otherwise returns nil.\n
isatty StringIO.isatty()\nReturns +false+.  Just for compatibility to IO.\n
length StringIO.length()\nReturns the size of the buffer string.\n
lineno StringIO.lineno()\nReturns the current line number in *strio*. The stringio must be\nopened for reading. +lineno+ counts the number of times  +gets+ is\ncalled, rather than the number of newlines  encountered. The two\nvalues will differ if +gets+ is  called with a separator other than\nnewline.  See also the  `$.` variable.\n
lineno= StringIO.lineno=(p1)\nManually sets the current line number to the given value.\n`$.` is updated only on the next read.\n
lines StringIO.lines(*args)\nSee IO#each.\n
pid StringIO.pid()\nReturns +nil+.  Just for compatibility to IO.\n
pos StringIO.pos()\nReturns the current offset (in bytes) of *strio*.\n
pos= StringIO.pos=(p1)\nSeeks to the given position (in bytes) in *strio*.\n
putc StringIO.putc(p1)\nSee IO#putc.\n
read StringIO.read(*args)\nSee IO#read.\n
readlines StringIO.readlines(*args)\nSee IO#readlines.\n
reopen StringIO.reopen(*args)\nReinitializes *strio* with the given <i>other_StrIO</i> or _string_\nand _mode_ (see StringIO#new).\n
rewind StringIO.rewind()\nPositions *strio* to the beginning of input, resetting\n+lineno+ to zero.\n
seek StringIO.seek(p1, p2 = v2)\nSeeks to a given offset _amount_ in the stream according to\nthe value of _whence_ (see IO#seek).\n
set_encoding StringIO.set_encoding(p1, p2 = v2, p3 = {})\nSpecify the encoding of the StringIO as <i>ext_enc</i>.\nUse the default external encoding if <i>ext_enc</i> is nil.\n2nd argument <i>int_enc</i> and optional hash <i>opt</i> argument\nare ignored; they are for API compatibility to IO.\n
size StringIO.size()\nReturns the size of the buffer string.\n
string StringIO.string()\nReturns underlying String object, the subject of IO.\n
string= StringIO.string=(p1)\nChanges underlying String object, the subject of IO.\n
sync StringIO.sync()\nReturns +true+ always.\n
sync= StringIO.sync=(p1)\nReturns the argument unchanged.  Just for compatibility to IO.\n
tell StringIO.tell()\nReturns the current offset (in bytes) of *strio*.\n
truncate StringIO.truncate(p1)\nTruncates the buffer string to at most _integer_ bytes. The *strio*\nmust be opened for writing.\n
tty? StringIO.tty?()\nReturns +false+.  Just for compatibility to IO.\n
ungetbyte StringIO.ungetbyte(p1)\nSee IO#ungetbyte\n
ungetc StringIO.ungetc(p1)\nPushes back one character (passed as a parameter) onto *strio*\nsuch that a subsequent buffered read will return it.  There is no\nlimitation for multiple pushbacks including pushing back behind the\nbeginning of the buffer string.\n
write StringIO.write(p1)\nAppends the given string to the underlying buffer string of *strio*.\nThe stream must be opened for writing.  If the argument is not a\nstring, it will be converted to a string using `to_s`.\nReturns the number of bytes written.  See IO#write.\n
must_C_version StringScanner.must_C_version()\nThis method is defined for backward compatibility.\n
new StringScanner.new(p1, p2 = v2)\nCreates a new StringScanner object to scan over the given +string+.\n+dup+ argument is obsolete and not used now.\n
beginning_of_line? StringScanner.beginning_of_line?()\nReturns +true+ iff the scan pointer is at the beginning of the line.\n\n  s = StringScanner.new("test\\ntest\\n")\n  s.bol?           # => true\n  s.scan(/te/)\n  s.bol?           # => false\n  s.scan(/st\\n/)\n  s.bol?           # => true\n  s.terminate\n  s.bol?           # => true\n
check StringScanner.check(p1)\nThis returns the value that #scan would return, without advancing the scan\npointer.  The match register is affected, though.\n\n  s = StringScanner.new("Fri Dec 12 1975 14:39")\n  s.check /Fri/               # -> "Fri"\n  s.pos                       # -> 0\n  s.matched                   # -> "Fri"\n  s.check /12/                # -> nil\n  s.matched                   # -> nil\n\nMnemonic: it "checks" to see whether a #scan will return a value.\n
check_until StringScanner.check_until(p1)\nThis returns the value that #scan_until would return, without advancing the\nscan pointer.  The match register is affected, though.\n\n  s = StringScanner.new("Fri Dec 12 1975 14:39")\n  s.check_until /12/          # -> "Fri Dec 12"\n  s.pos                       # -> 0\n  s.matched                   # -> 12\n\nMnemonic: it "checks" to see whether a #scan_until will return a value.\n
clear StringScanner.clear()\nEquivalent to #terminate.\nThis method is obsolete; use #terminate instead.\n
concat StringScanner.concat(p1)\nAppends +str+ to the string being scanned.\nThis method does not affect scan pointer.\n\n  s = StringScanner.new("Fri Dec 12 1975 14:39")\n  s.scan(/Fri /)\n  s << " +1000 GMT"\n  s.string            # -> "Fri Dec 12 1975 14:39 +1000 GMT"\n  s.scan(/Dec/)       # -> "Dec"\n
empty? StringScanner.empty?()\nEquivalent to #eos?.\nThis method is obsolete, use #eos? instead.\n
eos? StringScanner.eos?()\nReturns +true+ if the scan pointer is at the end of the string.\n\n  s = StringScanner.new('test string')\n  p s.eos?          # => false\n  s.scan(/test/)\n  p s.eos?          # => false\n  s.terminate\n  p s.eos?          # => true\n
exist? StringScanner.exist?(p1)\nLooks _ahead_ to see if the +pattern+ exists _anywhere_ in the string,\nwithout advancing the scan pointer.  This predicates whether a #scan_until\nwill return a value.\n\n  s = StringScanner.new('test string')\n  s.exist? /s/            # -> 3\n  s.scan /test/           # -> "test"\n  s.exist? /s/            # -> 2\n  s.exist? /e/            # -> nil\n
get_byte StringScanner.get_byte()\nScans one byte and returns it.\nThis method is not multibyte character sensitive.\nSee also: #getch.\n\n  s = StringScanner.new('ab')\n  s.get_byte         # => "a"\n  s.get_byte         # => "b"\n  s.get_byte         # => nil\n\n  $KCODE = 'EUC'\n  s = StringScanner.new("\244\242")\n  s.get_byte         # => "\244"\n  s.get_byte         # => "\242"\n  s.get_byte         # => nil\n
getbyte StringScanner.getbyte()\nEquivalent to #get_byte.\nThis method is obsolete; use #get_byte instead.\n
getch StringScanner.getch()\nScans one character and returns it.\nThis method is multibyte character sensitive.\n\n  s = StringScanner.new("ab")\n  s.getch           # => "a"\n  s.getch           # => "b"\n  s.getch           # => nil\n\n  $KCODE = 'EUC'\n  s = StringScanner.new("\244\242")\n  s.getch           # => "\244\242"   # Japanese hira-kana "A" in EUC-JP\n  s.getch           # => nil\n
inspect StringScanner.inspect()\nReturns a string that represents the StringScanner object, showing:\n- the current position\n- the size of the string\n- the characters surrounding the scan pointer\n\n  s = StringScanner.new("Fri Dec 12 1975 14:39")\n  s.inspect            # -> '#<StringScanner 0/21 @ "Fri D...">'\n  s.scan_until /12/    # -> "Fri Dec 12"\n  s.inspect            # -> '#<StringScanner 10/21 "...ec 12" @ " 1975...">'\n
match? StringScanner.match?(p1)\nTests whether the given +pattern+ is matched from the current scan pointer.\nReturns the length of the match, or +nil+.  The scan pointer is not advanced.\n\n  s = StringScanner.new('test string')\n  p s.match?(/\w+/)   # -> 4\n  p s.match?(/\w+/)   # -> 4\n  p s.match?(/\s+/)   # -> nil\n
matched StringScanner.matched()\nReturns the last matched string.\n\n  s = StringScanner.new('test string')\n  s.match?(/\w+/)     # -> 4\n  s.matched           # -> "test"\n
matched? StringScanner.matched?()\nReturns +true+ iff the last match was successful.\n\n  s = StringScanner.new('test string')\n  s.match?(/\w+/)     # => 4\n  s.matched?          # => true\n  s.match?(/\d+/)     # => nil\n  s.matched?          # => false\n
matched_size StringScanner.matched_size()\nReturns the size of the most recent match (see #matched), or +nil+ if there\nwas no recent match.\n\n  s = StringScanner.new('test string')\n  s.check /\w+/           # -> "test"\n  s.matched_size          # -> 4\n  s.check /\d+/           # -> nil\n  s.matched_size          # -> nil\n
peek StringScanner.peek(p1)\nExtracts a string corresponding to <tt>string[pos,len]</tt>, without\nadvancing the scan pointer.\n\n  s = StringScanner.new('test string')\n  s.peek(7)          # => "test st"\n  s.peek(7)          # => "test st"\n
peep StringScanner.peep(p1)\nEquivalent to #peek.\nThis method is obsolete; use #peek instead.\n
pointer StringScanner.pointer()\nReturns the byte position of the scan pointer.  In the 'reset' position, this\nvalue is zero.  In the 'terminated' position (i.e. the string is exhausted),\nthis value is the bytesize of the string.\n\nIn short, it's a 0-based index into the string.\n\n  s = StringScanner.new('test string')\n  s.pos               # -> 0\n  s.scan_until /str/  # -> "test str"\n  s.pos               # -> 8\n  s.terminate         # -> #<StringScanner fin>\n  s.pos               # -> 11\n
pointer= StringScanner.pointer=(p1)\nSet the byte position of the scan pointer.\n\n  s = StringScanner.new('test string')\n  s.pos = 7            # -> 7\n  s.rest               # -> "ring"\n
pos StringScanner.pos()\nReturns the byte position of the scan pointer.  In the 'reset' position, this\nvalue is zero.  In the 'terminated' position (i.e. the string is exhausted),\nthis value is the bytesize of the string.\n\nIn short, it's a 0-based index into the string.\n\n  s = StringScanner.new('test string')\n  s.pos               # -> 0\n  s.scan_until /str/  # -> "test str"\n  s.pos               # -> 8\n  s.terminate         # -> #<StringScanner fin>\n  s.pos               # -> 11\n
pos= StringScanner.pos=(p1)\nSet the byte position of the scan pointer.\n\n  s = StringScanner.new('test string')\n  s.pos = 7            # -> 7\n  s.rest               # -> "ring"\n
post_match StringScanner.post_match()\nReturn the <i><b>post</b>-match</i> (in the regular expression sense) of\nthe last scan.\n\n  s = StringScanner.new('test string')\n  s.scan(/\w+/)           # -> "test"\n  s.scan(/\s+/)           # -> " "\n  s.pre_match             # -> "test"\n  s.post_match            # -> "string"\n
pre_match StringScanner.pre_match()\nReturn the <i><b>pre</b>-match</i> (in the regular expression sense) of the\nlast scan.\n\n  s = StringScanner.new('test string')\n  s.scan(/\w+/)           # -> "test"\n  s.scan(/\s+/)           # -> " "\n  s.pre_match             # -> "test"\n  s.post_match            # -> "string"\n
reset StringScanner.reset()\nReset the scan pointer (index 0) and clear matching data.\n
rest StringScanner.rest()\nReturns the "rest" of the string (i.e. everything after the scan pointer).\nIf there is no more data (eos? = true), it returns <tt>""</tt>.\n
rest? StringScanner.rest?()\nReturns true iff there is more data in the string.  See #eos?.\nThis method is obsolete; use #eos? instead.\n\n  s = StringScanner.new('test string')\n  s.eos?              # These two\n  s.rest?             # are opposites.\n
rest_size StringScanner.rest_size()\n<tt>s.rest_size</tt> is equivalent to <tt>s.rest.size</tt>.\n
restsize StringScanner.restsize()\n<tt>s.restsize</tt> is equivalent to <tt>s.rest_size</tt>.\nThis method is obsolete; use #rest_size instead.\n
scan StringScanner.scan(p1)\nTries to match with +pattern+ at the current position. If there's a match,\nthe scanner advances the "scan pointer" and returns the matched string.\nOtherwise, the scanner returns +nil+.\n\n  s = StringScanner.new('test string')\n  p s.scan(/\w+/)   # -> "test"\n  p s.scan(/\w+/)   # -> nil\n  p s.scan(/\s+/)   # -> " "\n  p s.scan(/\w+/)   # -> "string"\n  p s.scan(/./)     # -> nil\n
scan_full StringScanner.scan_full(p1, p2, p3)\nTests whether the given +pattern+ is matched from the current scan pointer.\nAdvances the scan pointer if +advance_pointer_p+ is true.\nReturns the matched string if +return_string_p+ is true.\nThe match register is affected.\n\n"full" means "#scan with full parameters".\n
scan_until StringScanner.scan_until(p1)\nScans the string _until_ the +pattern+ is matched.  Returns the substring up\nto and including the end of the match, advancing the scan pointer to that\nlocation. If there is no match, +nil+ is returned.\n\n  s = StringScanner.new("Fri Dec 12 1975 14:39")\n  s.scan_until(/1/)        # -> "Fri Dec 1"\n  s.pre_match              # -> "Fri Dec "\n  s.scan_until(/XYZ/)      # -> nil\n
search_full StringScanner.search_full(p1, p2, p3)\nScans the string _until_ the +pattern+ is matched.\nAdvances the scan pointer if +advance_pointer_p+, otherwise not.\nReturns the matched string if +return_string_p+ is true, otherwise\nreturns the number of bytes advanced.\nThis method does affect the match register.\n
skip StringScanner.skip(p1)\nAttempts to skip over the given +pattern+ beginning with the scan pointer.\nIf it matches, the scan pointer is advanced to the end of the match, and the\nlength of the match is returned.  Otherwise, +nil+ is returned.\n\nIt's similar to #scan, but without returning the matched string.\n\n  s = StringScanner.new('test string')\n  p s.skip(/\w+/)   # -> 4\n  p s.skip(/\w+/)   # -> nil\n  p s.skip(/\s+/)   # -> 1\n  p s.skip(/\w+/)   # -> 6\n  p s.skip(/./)     # -> nil\n
skip_until StringScanner.skip_until(p1)\nAdvances the scan pointer until +pattern+ is matched and consumed.  Returns\nthe number of bytes advanced, or +nil+ if no match was found.\n\nLook ahead to match +pattern+, and advance the scan pointer to the _end_\nof the match.  Return the number of characters advanced, or +nil+ if the\nmatch was unsuccessful.\n\nIt's similar to #scan_until, but without returning the intervening string.\n\n  s = StringScanner.new("Fri Dec 12 1975 14:39")\n  s.skip_until /12/           # -> 10\n  s                           #\n
string StringScanner.string()\nReturns the string being scanned.\n
string= StringScanner.string=(p1)\nChanges the string being scanned to +str+ and resets the scanner.\nReturns +str+.\n
terminate StringScanner.terminate()\nSet the scan pointer to the end of the string and clear matching data.\n
unscan StringScanner.unscan()\nSet the scan pointer to the previous position.  Only one previous position is\nremembered, and it changes with each scanning operation.\n\n  s = StringScanner.new('test string')\n  s.scan(/\w+/)        # => "test"\n  s.unscan\n  s.scan(/../)         # => "te"\n  s.scan(/\d/)         # => nil\n  s.unscan             # ScanError: unscan failed: previous match record\n  not exist\n
new OLEProperty.new(obj, dispid, gettypes, settypes)\n\n
codepage WIN32OLE.codepage()\nReturns current codepage.\n   WIN32OLE.codepage # => WIN32OLE::CP_ACP\n
codepage= WIN32OLE.codepage=(p1)\nSets current codepage.\nThe WIN32OLE.codepage is initialized according to\nEncoding.default_internal.\nIf Encoding.default_internal is nil then WIN32OLE.codepage\nis initialized according to Encoding.default_external.\n\n   WIN32OLE.codepage = WIN32OLE::CP_UTF8\n   WIN32OLE.codepage = 65001\n
connect WIN32OLE.connect(p1, *args)\nReturns running OLE Automation object or WIN32OLE object from moniker.\n1st argument should be OLE program id or class id or moniker.\n\n   WIN32OLE.connect('Excel.Application') # => WIN32OLE object which represents\n   running Excel.\n
const_load WIN32OLE.const_load(p1, p2 = v2)\nDefines the constants of OLE Automation server as mod's constants.\nThe first argument is WIN32OLE object or type library name.\nIf 2nd argument is omitted, the default is WIN32OLE.\nThe first letter of Ruby's constant variable name is upper case,\nso constant variable name of WIN32OLE object is capitalized.\nFor example, the 'xlTop' constant of Excel is changed to 'XlTop'\nin WIN32OLE.\nIf the first letter of constant variabl is not [A-Z], then\nthe constant is defined as CONSTANTS hash element.\n\n   module EXCEL_CONST\n   end\n   excel = WIN32OLE.new('Excel.Application')\n   WIN32OLE.const_load(excel, EXCEL_CONST)\n   puts EXCEL_CONST::XlTop # => -4160\n   puts EXCEL_CONST::CONSTANTS['_xlDialogChartSourceData'] # => 541\n\n   WIN32OLE.const_load(excel)\n   puts WIN32OLE::XlTop # => -4160\n\n   module MSO\n   end\n   WIN32OLE.const_load('Microsoft Office 9.0 Object Library', MSO)\n   puts MSO::MsoLineSingle # => 1\n
create_guid WIN32OLE.create_guid()\nCreates GUID.\n   WIN32OLE.create_guid # => {1CB530F1-F6B1-404D-BCE6-1959BF91F4A8}\n
locale WIN32OLE.locale()\nReturns current locale id (lcid). The default locale is\nLOCALE_SYSTEM_DEFAULT.\n\n   lcid = WIN32OLE.locale\n
locale= WIN32OLE.locale=(p1)\nSets current locale id (lcid).\n\n   WIN32OLE.locale = 1033 # set locale English(U.S)\n   obj = WIN32OLE_VARIANT.new("$100,000", WIN32OLE::VARIANT::VT_CY)\n
new WIN32OLE.new(p1, p2 = v2, *args)\nReturns a new WIN32OLE object(OLE Automation object).\nThe first argument server specifies OLE Automation server.\nThe first argument should be CLSID or PROGID.\nIf second argument host specified, then returns OLE Automation\nobject on host.\n\n    WIN32OLE.new('Excel.Application') # => Excel OLE Automation WIN32OLE\n    object.\n    WIN32OLE.new('{00024500-0000-0000-C000-000000000046}') # => Excel OLE\n    Automation WIN32OLE object.\n
ole_free WIN32OLE.ole_free(p1)\nInvokes Release method of Dispatch interface of WIN32OLE object.\nYou should not use this method because this method\nexists only for debugging WIN32OLE.\nThe return value is reference counter of OLE object.\n
ole_initialize WIN32OLE.ole_initialize()\n:nodoc\n
ole_reference_count WIN32OLE.ole_reference_count(p1)\nReturns reference counter of Dispatch interface of WIN32OLE object.\nYou should not use this method because this method\nexists only for debugging WIN32OLE.\n
ole_show_help WIN32OLE.ole_show_help(p1, p2 = v2)\nDisplays helpfile. The 1st argument specifies WIN32OLE_TYPE\nobject or WIN32OLE_METHOD object or helpfile.\n\n   excel = WIN32OLE.new('Excel.Application')\n   typeobj = excel.ole_type\n   WIN32OLE.ole_show_help(typeobj)\n
ole_uninitialize WIN32OLE.ole_uninitialize()\n:nodoc\n
_getproperty WIN32OLE._getproperty(p1, p2, p3)\nRuns the early binding method to get property.\nThe 1st argument specifies dispatch ID,\nthe 2nd argument specifies the array of arguments,\nthe 3rd argument specifies the array of the type of arguments.\n\n   excel = WIN32OLE.new('Excel.Application')\n   puts excel._getproperty(558, [], []) # same effect as puts excel.visible\n
_invoke WIN32OLE._invoke(p1, p2, p3)\nRuns the early binding method.\nThe 1st argument specifies dispatch ID,\nthe 2nd argument specifies the array of arguments,\nthe 3rd argument specifies the array of the type of arguments.\n\n   excel = WIN32OLE.new('Excel.Application')\n   excel._invoke(302, [], []) #  same effect as excel.Quit\n
_setproperty WIN32OLE._setproperty(p1, p2, p3)\nRuns the early binding method to set property.\nThe 1st argument specifies dispatch ID,\nthe 2nd argument specifies the array of arguments,\nthe 3rd argument specifies the array of the type of arguments.\n\n   excel = WIN32OLE.new('Excel.Application')\n   excel._setproperty(558, [true], [WIN32OLE::VARIANT::VT_BOOL]) # same\n   effect as excel.visible = true\n
each WIN32OLE.each()\nIterates over each item of OLE collection which has IEnumVARIANT interface.\n\n   excel = WIN32OLE.new('Excel.Application')\n   book = excel.workbooks.add\n   sheets = book.worksheets(1)\n   cells = sheets.cells("A1:A5")\n   cells.each do |cell|\n     cell.value = 10\n   end\n
invoke WIN32OLE.invoke(*args)\nRuns OLE method.\nThe first argument specifies the method name of OLE Automation object.\nThe others specify argument of the <i>method</i>.\nIf you can not execute <i>method</i> directly, then use this method instead.\n\n  excel = WIN32OLE.new('Excel.Application')\n  excel.invoke('Quit')  # => same as excel.Quit\n
method_missing WIN32OLE.method_missing(*args)\nCalls WIN32OLE#invoke method.\n
ole_activex_initialize WIN32OLE.ole_activex_initialize()\nInitialize WIN32OLE object(ActiveX Control) by calling\nIPersistMemory::InitNew.\n\nBefore calling OLE method, some kind of the ActiveX controls\ncreated with MFC should be initialized by calling\nIPersistXXX::InitNew.\n\nIf and only if you received the exception "HRESULT error code:\n0x8000ffff catastrophic failure", try this method before\ninvoking any ole_method.\n\n   obj = WIN32OLE.new("ProgID_or_GUID_of_ActiveX_Control")\n   obj.ole_activex_initialize\n   obj.method(...)\n
ole_free WIN32OLE.ole_free()\ninvokes Release method of Dispatch interface of WIN32OLE object.\nUsually, you do not need to call this method because Release method\ncalled automatically when WIN32OLE object garbaged.\n
ole_func_methods WIN32OLE.ole_func_methods()\nReturns the array of WIN32OLE_METHOD object .\nThe element of the array is property (settable) of WIN32OLE object.\n\n   excel = WIN32OLE.new('Excel.Application')\n   properties = excel.ole_func_methods\n
ole_get_methods WIN32OLE.ole_get_methods()\nReturns the array of WIN32OLE_METHOD object .\nThe element of the array is property (gettable) of WIN32OLE object.\n\n   excel = WIN32OLE.new('Excel.Application')\n   properties = excel.ole_get_methods\n
ole_method WIN32OLE.ole_method(p1)\nReturns WIN32OLE_METHOD object corresponding with method\nspecified by 1st argument.\n\n   excel = WIN32OLE.new('Excel.Application')\n   method = excel.ole_method_help('Quit')\n
ole_method_help WIN32OLE.ole_method_help(p1)\n\n
ole_methods WIN32OLE.ole_methods()\nReturns the array of WIN32OLE_METHOD object.\nThe element is OLE method of WIN32OLE object.\n\n   excel = WIN32OLE.new('Excel.Application')\n   methods = excel.ole_methods\n
ole_obj_help WIN32OLE.ole_obj_help()\n\n
ole_put_methods WIN32OLE.ole_put_methods()\nReturns the array of WIN32OLE_METHOD object .\nThe element of the array is property (settable) of WIN32OLE object.\n\n   excel = WIN32OLE.new('Excel.Application')\n   properties = excel.ole_put_methods\n
ole_query_interface WIN32OLE.ole_query_interface(p1)\nReturns WIN32OLE object for a specific dispatch or dual\ninterface specified by iid.\n\n    ie = WIN32OLE.new('InternetExplorer.Application')\n    ie_web_app =\n    ie.ole_query_interface('{0002DF05-0000-0000-C000-000000000046}') # =>\n    WIN32OLE object for dispinterface IWebBrowserApp\n
ole_respond_to? WIN32OLE.ole_respond_to?(p1)\nReturns true when OLE object has OLE method, otherwise returns false.\n\n    ie = WIN32OLE.new('InternetExplorer.Application')\n    ie.ole_respond_to?("gohome") => true\n
ole_type WIN32OLE.ole_type()\nReturns WIN32OLE_TYPE object.\n\n   excel = WIN32OLE.new('Excel.Application')\n   tobj = excel.ole_type\n
ole_typelib WIN32OLE.ole_typelib()\nReturns the WIN32OLE_TYPELIB object. The object represents the\ntype library which contains the WIN32OLE object.\n\n   excel = WIN32OLE.new('Excel.Application')\n   tlib = excel.ole_typelib\n   puts tlib.name  # -> 'Microsoft Excel 9.0 Object Library'\n
setproperty WIN32OLE.setproperty(*args)\nSets property of OLE object.\nWhen you want to set property with argument, you can use this method.\n\n   excel = WIN32OLE.new('Excel.Application')\n   excel.Visible = true\n   book = excel.workbooks.add\n   sheet = book.worksheets(1)\n   sheet.setproperty('Cells', 1, 2, 10) # => The B1 cell value is 10.\n
new WIN32OLE_TYPELIB.new(*args)\nReturns a new WIN32OLE_TYPELIB object.\n\nThe first argument <i>typelib</i>  specifies OLE type library name or GUID or\nOLE library file.\nThe second argument is major version or version of the type library.\nThe third argument is minor version.\nThe second argument and third argument are optional.\nIf the first argument is type library name, then the second and third argument\nare ignored.\n\n    tlib1 = WIN32OLE_TYPELIB.new('Microsoft Excel 9.0 Object Library')\n    tlib2 = WIN32OLE_TYPELIB.new('{00020813-0000-0000-C000-000000000046}')\n    tlib3 = WIN32OLE_TYPELIB.new('{00020813-0000-0000-C000-000000000046}', 1.3)\n    tlib4 = WIN32OLE_TYPELIB.new('{00020813-0000-0000-C000-000000000046}',\n    1, 3)\n    tlib5 = WIN32OLE_TYPELIB.new("C:\\WINNT\\SYSTEM32\\SHELL32.DLL")\n    puts tlib1.name  # -> 'Microsoft Excel 9.0 Object Library'\n    puts tlib2.name  # -> 'Microsoft Excel 9.0 Object Library'\n    puts tlib3.name  # -> 'Microsoft Excel 9.0 Object Library'\n    puts tlib4.name  # -> 'Microsoft Excel 9.0 Object Library'\n    puts tlib5.name  # -> 'Microsoft Shell Controls And Automation'\n
typelibs WIN32OLE_TYPELIB.typelibs()\nReturns the array of WIN32OLE_TYPELIB object.\n\n   tlibs = WIN32OLE_TYPELIB.typelibs\n
guid WIN32OLE_TYPELIB.guid()\nReturns guid string which specifies type library.\n\n   tlib = WIN32OLE_TYPELIB.new('Microsoft Excel 9.0 Object Library')\n   guid = tlib.guid # -> '{00020813-0000-0000-C000-000000000046}'\n
inspect WIN32OLE_TYPELIB.inspect()\nReturns the type library name with class name.\n\n   tlib = WIN32OLE_TYPELIB.new('Microsoft Excel 9.0 Object Library')\n   tlib.inspect # => "<#WIN32OLE_TYPELIB:Microsoft Excel 9.0 Object Library>"\n
library_name WIN32OLE_TYPELIB.library_name()\nReturns library name.\nIf the method fails to access library name, WIN32OLERuntimeError is raised.\n\n   tlib = WIN32OLE_TYPELIB.new('Microsoft Excel 9.0 Object Library')\n   tlib.library_name # => Excel\n
major_version WIN32OLE_TYPELIB.major_version()\nReturns the type library major version.\n\n   tlib = WIN32OLE_TYPELIB.new('Microsoft Excel 9.0 Object Library')\n   puts tlib.major_version # -> 1\n
minor_version WIN32OLE_TYPELIB.minor_version()\nReturns the type library minor version.\n\n   tlib = WIN32OLE_TYPELIB.new('Microsoft Excel 9.0 Object Library')\n   puts tlib.minor_version # -> 3\n
name WIN32OLE_TYPELIB.name()\nReturns the type library name.\n\n   tlib = WIN32OLE_TYPELIB.new('Microsoft Excel 9.0 Object Library')\n   name = tlib.name # -> 'Microsoft Excel 9.0 Object Library'\n
ole_classes WIN32OLE_TYPELIB.ole_classes()\n\n
ole_types WIN32OLE_TYPELIB.ole_types()\nReturns the type library file path.\n\n   tlib = WIN32OLE_TYPELIB.new('Microsoft Excel 9.0 Object Library')\n   classes = tlib.ole_types.collect{|k| k.name} # -> ['AddIn', 'AddIns' ...]\n
path WIN32OLE_TYPELIB.path()\nReturns the type library file path.\n\n   tlib = WIN32OLE_TYPELIB.new('Microsoft Excel 9.0 Object Library')\n   puts tlib.path #-> 'C:\...\EXCEL9.OLB'\n
to_s WIN32OLE_TYPELIB.to_s()\n\n
version WIN32OLE_TYPELIB.version()\nReturns the type library version.\n\n   tlib = WIN32OLE_TYPELIB.new('Microsoft Excel 9.0 Object Library')\n   puts tlib.version #-> 1.3\n
visible? WIN32OLE_TYPELIB.visible?()\nReturns true if the type library information is not hidden.\nIf wLibFlags of TLIBATTR is 0 or LIBFLAG_FRESTRICTED or LIBFLAG_FHIDDEN,\nthe method returns false, otherwise, returns true.\nIf the method fails to access the TLIBATTR information, then\nWIN32OLERuntimeError is raised.\n\n   tlib = WIN32OLE_TYPELIB.new('Microsoft Excel 9.0 Object Library')\n   tlib.visible? # => true\n
new WIN32OLE_TYPE.new(p1, p2)\nReturns a new WIN32OLE_TYPE object.\nThe first argument <i>typelib</i> specifies OLE type library name.\nThe second argument specifies OLE class name.\n\n    WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library', 'Application')\n => WIN32OLE_TYPE object of Application class of Excel.\n
ole_classes WIN32OLE_TYPE.ole_classes(p1)\nReturns array of WIN32OLE_TYPE objects defined by the <i>typelib</i>\ntype library.\nThis method will be OBSOLETE. Use WIN32OLE_TYPELIB.new(typelib).ole_classes\ninstead.\n
progids WIN32OLE_TYPE.progids()\nReturns array of ProgID.\n
typelibs WIN32OLE_TYPE.typelibs()\nReturns array of type libraries.\nThis method will be OBSOLETE. Use WIN32OLE_TYPELIB.typelibs.collect{|t|\nt.name} instead.\n
default_event_sources WIN32OLE_TYPE.default_event_sources()\nReturns the array of WIN32OLE_TYPE object which is implemented by the\nWIN32OLE_TYPE\nobject and having IMPLTYPEFLAG_FSOURCE and IMPLTYPEFLAG_FDEFAULT.\n   tobj = WIN32OLE_TYPE.new('Microsoft Internet Controls', "InternetExplorer")\n   p tobj.default_event_sources  # => [#<WIN32OLE_TYPE:DWebBrowserEvents2>]\n
default_ole_types WIN32OLE_TYPE.default_ole_types()\nReturns the array of WIN32OLE_TYPE object which is implemented by the\nWIN32OLE_TYPE\nobject and having IMPLTYPEFLAG_FDEFAULT.\n   tobj = WIN32OLE_TYPE.new('Microsoft Internet Controls', "InternetExplorer")\n   p tobj.default_ole_types\n => [#<WIN32OLE_TYPE:IWebBrowser2>, #<WIN32OLE_TYPE:DWebBrowserEvents2>]\n
guid WIN32OLE_TYPE.guid()\nReturns GUID.\n  tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library', 'Application')\n  puts tobj.guid  # => {00024500-0000-0000-C000-000000000046}\n
helpcontext WIN32OLE_TYPE.helpcontext()\nReturns helpcontext. If helpcontext is not found, then returns nil.\n   tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library', 'Worksheet')\n   puts tobj.helpfile # => 131185\n
helpfile WIN32OLE_TYPE.helpfile()\nReturns helpfile path. If helpfile is not found, then returns nil.\n   tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library', 'Worksheet')\n   puts tobj.helpfile # => C:\...\VBAXL9.CHM\n
helpstring WIN32OLE_TYPE.helpstring()\nReturns help string.\n  tobj = WIN32OLE_TYPE.new('Microsoft Internet Controls', 'IWebBrowser')\n  puts tobj.helpstring # => Web Browser interface\n
implemented_ole_types WIN32OLE_TYPE.implemented_ole_types()\nReturns the array of WIN32OLE_TYPE object which is implemented by the\nWIN32OLE_TYPE\nobject.\n   tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library', 'Worksheet')\n   p tobj.implemented_ole_types # => [_Worksheet, DocEvents]\n
inspect WIN32OLE_TYPE.inspect()\nReturns the type name with class name.\n\n   ie = WIN32OLE.new('InternetExplorer.Application')\n   ie.ole_type.inspect => #<WIN32OLE_TYPE:IWebBrowser2>\n
major_version WIN32OLE_TYPE.major_version()\nReturns major version.\n   tobj = WIN32OLE_TYPE.new('Microsoft Word 10.0 Object Library', 'Documents')\n   puts tobj.major_version # => 8\n
minor_version WIN32OLE_TYPE.minor_version()\nReturns minor version.\n   tobj = WIN32OLE_TYPE.new('Microsoft Word 10.0 Object Library', 'Documents')\n   puts tobj.minor_version # => 2\n
name WIN32OLE_TYPE.name()\nReturns OLE type name.\n   tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library',\n   'Application')\n   puts tobj.name  # => Application\n
ole_methods WIN32OLE_TYPE.ole_methods()\nReturns array of WIN32OLE_METHOD objects which represent OLE method defined in\nOLE type library.\n  tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library', 'Worksheet')\n  methods = tobj.ole_methods.collect{|m|\n    m.name\n  }\n => ['Activate', 'Copy', 'Delete',....]\n
ole_type WIN32OLE_TYPE.ole_type()\nreturns type of OLE class.\n  tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library', 'Application')\n  puts tobj.ole_type  # => Class\n
ole_typelib WIN32OLE_TYPE.ole_typelib()\nReturns the WIN32OLE_TYPELIB object which is including the WIN32OLE_TYPE\nobject. If it is not found, then returns nil.\n   tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library', 'Worksheet')\n   puts tobj.ole_typelib # => 'Microsoft Excel 9.0 Object Library'\n
progid WIN32OLE_TYPE.progid()\nReturns ProgID if it exists. If not found, then returns nil.\n   tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library',\n   'Application')\n   puts tobj.progid  # =>   Excel.Application.9\n
source_ole_types WIN32OLE_TYPE.source_ole_types()\nReturns the array of WIN32OLE_TYPE object which is implemented by the\nWIN32OLE_TYPE\nobject and having IMPLTYPEFLAG_FSOURCE.\n   tobj = WIN32OLE_TYPE.new('Microsoft Internet Controls', "InternetExplorer")\n   p tobj.source_ole_types\n => [#<WIN32OLE_TYPE:DWebBrowserEvents2>, #<WIN32OLE_TYPE:DWebBrowserEvents>]\n
src_type WIN32OLE_TYPE.src_type()\nReturns source class when the OLE class is 'Alias'.\n   tobj =  WIN32OLE_TYPE.new('Microsoft Office 9.0 Object Library',\n   'MsoRGBType')\n   puts tobj.src_type # => I4\n
to_s WIN32OLE_TYPE.to_s()\n\n
typekind WIN32OLE_TYPE.typekind()\nReturns number which represents type.\n  tobj = WIN32OLE_TYPE.new('Microsoft Word 10.0 Object Library', 'Documents')\n  puts tobj.typekind # => 4\n
variables WIN32OLE_TYPE.variables()\nReturns array of WIN32OLE_VARIABLE objects which represent variables\ndefined in OLE class.\n   tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library',\n   'XlSheetType')\n   vars = tobj.variables\n   vars.each do |v|\n     puts "#{v.name} = #{v.value}"\n   end\n\n   The result of above sample script is follows:\n     xlChart = -4109\n     xlDialogSheet = -4116\n     xlExcel4IntlMacroSheet = 4\n     xlExcel4MacroSheet = 3\n     xlWorksheet = -4167\n
visible? WIN32OLE_TYPE.visible?()\nReturns true if the OLE class is public.\n  tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library', 'Application')\n  puts tobj.visible  # => true\n
inspect WIN32OLE_VARIABLE.inspect()\nReturns the OLE variable name and the value with class name.\n
name WIN32OLE_VARIABLE.name()\nReturns the name of variable.\n\n   tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library',\n   'XlSheetType')\n   variables = tobj.variables\n   variables.each do |variable|\n     puts "#{variable.name}"\n   end\n\n   The result of above script is following:\n     xlChart\n     xlDialogSheet\n     xlExcel4IntlMacroSheet\n     xlExcel4MacroSheet\n     xlWorksheet\n
ole_type WIN32OLE_VARIABLE.ole_type()\nReturns OLE type string.\n\n  tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library', 'XlSheetType')\n  variables = tobj.variables\n  variables.each do |variable|\n    puts "#{variable.ole_type} #{variable.name}"\n  end\n\n  The result of above script is following:\n    INT xlChart\n    INT xlDialogSheet\n    INT xlExcel4IntlMacroSheet\n    INT xlExcel4MacroSheet\n    INT xlWorksheet\n
ole_type_detail WIN32OLE_VARIABLE.ole_type_detail()\nReturns detail information of type. The information is array of type.\n\n   tobj = WIN32OLE_TYPE.new('DirectX 7 for Visual Basic Type Library',\n   'D3DCLIPSTATUS')\n   variable = tobj.variables.find {|variable| variable.name == 'lFlags'}\n   tdetail  = variable.ole_type_detail\n   p tdetail # => ["USERDEFINED", "CONST_D3DCLIPSTATUSFLAGS"]\n
to_s WIN32OLE_VARIABLE.to_s()\n\n
value WIN32OLE_VARIABLE.value()\nReturns value if value is exists. If the value does not exist,\nthis method returns nil.\n\n   tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library',\n   'XlSheetType')\n   variables = tobj.variables\n   variables.each do |variable|\n     puts "#{variable.name} #{variable.value}"\n   end\n\n   The result of above script is following:\n     xlChart = -4109\n     xlDialogSheet = -4116\n     xlExcel4IntlMacroSheet = 4\n     xlExcel4MacroSheet = 3\n     xlWorksheet = -4167\n
variable_kind WIN32OLE_VARIABLE.variable_kind()\nReturns variable kind string.\n\n   tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library',\n   'XlSheetType')\n   variables = tobj.variables\n   variables.each do |variable|\n     puts "#{variable.name} #{variable.variable_kind}"\n   end\n\n   The result of above script is following:\n     xlChart CONSTANT\n     xlDialogSheet CONSTANT\n     xlExcel4IntlMacroSheet CONSTANT\n     xlExcel4MacroSheet CONSTANT\n     xlWorksheet CONSTANT\n
varkind WIN32OLE_VARIABLE.varkind()\nReturns the number which represents variable kind.\n  tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library', 'XlSheetType')\n  variables = tobj.variables\n  variables.each do |variable|\n    puts "#{variable.name} #{variable.varkind}"\n  end\n\n  The result of above script is following:\n     xlChart 2\n     xlDialogSheet 2\n     xlExcel4IntlMacroSheet 2\n     xlExcel4MacroSheet 2\n     xlWorksheet 2\n
visible? WIN32OLE_VARIABLE.visible?()\nReturns true if the variable is public.\n\n   tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library',\n   'XlSheetType')\n   variables = tobj.variables\n   variables.each do |variable|\n     puts "#{variable.name} #{variable.visible?}"\n   end\n\n   The result of above script is following:\n     xlChart true\n     xlDialogSheet true\n     xlExcel4IntlMacroSheet true\n     xlExcel4MacroSheet true\n     xlWorksheet true\n
new WIN32OLE_METHOD.new(p1, p2)\nReturns a new WIN32OLE_METHOD object which represents the information\nabout OLE method.\nThe first argument <i>ole_type</i> specifies WIN32OLE_TYPE object.\nThe second argument <i>method</i> specifies OLE method name defined OLE class\nwhich represents WIN32OLE_TYPE object.\n\n   tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library', 'Workbook')\n   method = WIN32OLE_METHOD.new(tobj, 'SaveAs')\n
dispid WIN32OLE_METHOD.dispid()\nReturns dispatch ID.\n   tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library', 'Workbooks')\n   method = WIN32OLE_METHOD.new(tobj, 'Add')\n   puts method.dispid # => 181\n
event? WIN32OLE_METHOD.event?()\nReturns true if the method is event.\n   tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library', 'Workbook')\n   method = WIN32OLE_METHOD.new(tobj, 'SheetActivate')\n   puts method.event? # => true\n
event_interface WIN32OLE_METHOD.event_interface()\nReturns event interface name if the method is event.\n  tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library', 'Workbook')\n  method = WIN32OLE_METHOD.new(tobj, 'SheetActivate')\n  puts method.event_interface # =>  WorkbookEvents\n
helpcontext WIN32OLE_METHOD.helpcontext()\nReturns help context.\n   tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library', 'Workbooks')\n   method = WIN32OLE_METHOD.new(tobj, 'Add')\n   puts method.helpcontext # => 65717\n
helpfile WIN32OLE_METHOD.helpfile()\nReturns help file. If help file is not found, then\nthe method returns nil.\n   tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library', 'Workbooks')\n   method = WIN32OLE_METHOD.new(tobj, 'Add')\n   puts method.helpfile # => C:\...\VBAXL9.CHM\n
helpstring WIN32OLE_METHOD.helpstring()\nReturns help string of OLE method. If the help string is not found,\nthen the method returns nil.\n   tobj = WIN32OLE_TYPE.new('Microsoft Internet Controls', 'IWebBrowser')\n   method = WIN32OLE_METHOD.new(tobj, 'Navigate')\n   puts method.helpstring # => Navigates to a URL or file.\n
inspect WIN32OLE_METHOD.inspect()\nReturns the method name with class name.\n
invkind WIN32OLE_METHOD.invkind()\nReturns the method invoke kind.\n  tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library', 'Workbooks')\n  method = WIN32OLE_METHOD.new(tobj, 'Add')\n  puts method.invkind # => 1\n
invoke_kind WIN32OLE_METHOD.invoke_kind()\nReturns the method kind string. The string is "UNKNOWN" or "PROPERTY"\nor "PROPERTY" or "PROPERTYGET" or "PROPERTYPUT" or "PROPERTYPPUTREF"\nor "FUNC".\n   tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library', 'Workbooks')\n   method = WIN32OLE_METHOD.new(tobj, 'Add')\n   puts method.invoke_kind # => "FUNC"\n
name WIN32OLE_METHOD.name()\ncall-seq\n   WIN32OLE_METHOD#name\n\nReturns the name of the method.\n\n   tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library', 'Workbook')\n   method = WIN32OLE_METHOD.new(tobj, 'SaveAs')\n   puts method.name # => SaveAs\n
offset_vtbl WIN32OLE_METHOD.offset_vtbl()\nReturns the offset ov VTBL.\n   tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library', 'Workbooks')\n   method = WIN32OLE_METHOD.new(tobj, 'Add')\n   puts method.offset_vtbl # => 40\n
params WIN32OLE_METHOD.params()\nreturns array of WIN32OLE_PARAM object corresponding with method parameters.\n   tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library', 'Workbook')\n   method = WIN32OLE_METHOD.new(tobj, 'SaveAs')\n   p method.params # => [Filename, FileFormat, Password, WriteResPassword,\n                         ReadOnlyRecommended, CreateBackup, AccessMode,\n                         ConflictResolution, AddToMru, TextCodepage,\n                         TextVisualLayout]\n
return_type WIN32OLE_METHOD.return_type()\nReturns string of return value type of method.\n   tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library', 'Workbooks')\n   method = WIN32OLE_METHOD.new(tobj, 'Add')\n   puts method.return_type # => Workbook\n
return_type_detail WIN32OLE_METHOD.return_type_detail()\nReturns detail information of return value type of method.\nThe information is array.\n   tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library', 'Workbooks')\n   method = WIN32OLE_METHOD.new(tobj, 'Add')\n   p method.return_type_detail # => ["PTR", "USERDEFINED", "Workbook"]\n
return_vtype WIN32OLE_METHOD.return_vtype()\nReturns number of return value type of method.\n   tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library', 'Workbooks')\n   method = WIN32OLE_METHOD.new(tobj, 'Add')\n   puts method.return_vtype # => 26\n
size_opt_params WIN32OLE_METHOD.size_opt_params()\nReturns the size of optional parameters.\n   tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library', 'Workbook')\n   method = WIN32OLE_METHOD.new(tobj, 'SaveAs')\n   puts method.size_opt_params # => 4\n
size_params WIN32OLE_METHOD.size_params()\nReturns the size of arguments of the method.\n   tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library', 'Workbook')\n   method = WIN32OLE_METHOD.new(tobj, 'SaveAs')\n   puts method.size_params # => 11\n
to_s WIN32OLE_METHOD.to_s()\n\n
visible? WIN32OLE_METHOD.visible?()\nReturns true if the method is public.\n   tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library', 'Workbooks')\n   method = WIN32OLE_METHOD.new(tobj, 'Add')\n   puts method.visible? # => true\n
new WIN32OLE_PARAM.new(p1, p2)\n\n
default WIN32OLE_PARAM.default()\nReturns default value. If the default value does not exist,\nthis method returns nil.\n   tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library', 'Workbook')\n   method = WIN32OLE_METHOD.new(tobj, 'SaveAs')\n   method.params.each do |param|\n     if param.default\n       puts "#{param.name} (= #{param.default})"\n     else\n       puts "#{param}"\n     end\n   end\n\n   The above script result is following:\n       Filename\n       FileFormat\n       Password\n       WriteResPassword\n       ReadOnlyRecommended\n       CreateBackup\n       AccessMode (= 1)\n       ConflictResolution\n       AddToMru\n       TextCodepage\n       TextVisualLayout\n
input? WIN32OLE_PARAM.input?()\nReturns true if the parameter is input.\n   tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library', 'Workbook')\n   method = WIN32OLE_METHOD.new(tobj, 'SaveAs')\n   param1 = method.params[0]\n   puts param1.input? # => true\n
inspect WIN32OLE_PARAM.inspect()\nReturns the parameter name with class name. If the parameter has default value,\nthen returns name=value string with class name.\n
name WIN32OLE_PARAM.name()\nReturns name.\n   tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library', 'Workbook')\n   method = WIN32OLE_METHOD.new(tobj, 'SaveAs')\n   param1 = method.params[0]\n   puts param1.name # => Filename\n
ole_type WIN32OLE_PARAM.ole_type()\nReturns OLE type of WIN32OLE_PARAM object(parameter of OLE method).\n   tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library', 'Workbook')\n   method = WIN32OLE_METHOD.new(tobj, 'SaveAs')\n   param1 = method.params[0]\n   puts param1.ole_type # => VARIANT\n
ole_type_detail WIN32OLE_PARAM.ole_type_detail()\nReturns detail information of type of argument.\n   tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library',\n   'IWorksheetFunction')\n   method = WIN32OLE_METHOD.new(tobj, 'SumIf')\n   param1 = method.params[0]\n   p param1.ole_type_detail # => ["PTR", "USERDEFINED", "Range"]\n
optional? WIN32OLE_PARAM.optional?()\nReturns true if argument is optional.\n   tobj = WIN32OLE_TYPE.new('Microsoft Excel 9.0 Object Library', 'Workbook')\n   method = WIN32OLE_METHOD.new(tobj, 'SaveAs')\n   param1 = method.params[0]\n   puts "#{param1.name} #{param1.optional?}" # => Filename true\n
output? WIN32OLE_PARAM.output?()\nReturns true if argument is output.\n   tobj = WIN32OLE_TYPE.new('Microsoft Internet Controls', 'DWebBrowserEvents')\n   method = WIN32OLE_METHOD.new(tobj, 'NewWindow')\n   method.params.each do |param|\n     puts "#{param.name} #{param.output?}"\n   end\n\n   The result of above script is following:\n     URL false\n     Flags false\n     TargetFrameName false\n     PostData false\n     Headers false\n     Processed true\n
retval? WIN32OLE_PARAM.retval?()\nReturns true if argument is return value.\n   tobj = WIN32OLE_TYPE.new('DirectX 7 for Visual Basic Type Library',\n                            'DirectPlayLobbyConnection')\n   method = WIN32OLE_METHOD.new(tobj, 'GetPlayerShortName')\n   param = method.params[0]\n   puts "#{param.name} #{param.retval?}"  # => name true\n
to_s WIN32OLE_PARAM.to_s()\n\n
message_loop WIN32OLE_EVENT.message_loop()\nTranslates and dispatches Windows message.\n
new WIN32OLE_EVENT.new(*args)\nReturns OLE event object.\nThe first argument specifies WIN32OLE object.\nThe second argument specifies OLE event name.\n   ie = WIN32OLE.new('InternetExplorer.Application')\n   ev = WIN32OLE_EVENT.new(ie, 'DWebBrowserEvents')\n
handler WIN32OLE_EVENT.handler()\nreturns handler object.\n
handler= WIN32OLE_EVENT.handler=(p1)\nsets event handler object. If handler object has onXXX\nmethod according to XXX event, then onXXX method is called\nwhen XXX event occurs.\n\nIf handler object has method_missing and there is no\nmethod according to the event, then method_missing\ncalled and 1-st argument is event name.\n\nIf handler object has onXXX method and there is block\ndefined by WIN32OLE_EVENT#on_event('XXX'){},\nthen block is executed but handler object method is not called\nwhen XXX event occurs.\n\n    class Handler\n      def onStatusTextChange(text)\n        puts "StatusTextChanged"\n      end\n      def onPropertyChange(prop)\n        puts "PropertyChanged"\n      end\n      def method_missing(ev, *arg)\n        puts "other event #{ev}"\n      end\n    end\n\n    handler = Handler.new\n    ie = WIN32OLE.new('InternetExplorer.Application')\n    ev = WIN32OLE_EVENT.new(ie)\n    ev.on_event("StatusTextChange") {|*args|\n      puts "this block executed."\n      puts "handler.onStatusTextChange method is not called."\n    }\n    ev.handler = handler\n
off_event WIN32OLE_EVENT.off_event(p1 = v1)\nremoves the callback of event.\n\n  ie = WIN32OLE.new('InternetExplorer.Application')\n  ev = WIN32OLE_EVENT.new(ie)\n  ev.on_event('BeforeNavigate2') {|*args|\n    args.last[6] = true\n  }\n    ...\n  ev.off_event('BeforeNavigate2')\n    ...\n
on_event WIN32OLE_EVENT.on_event(*args)\nDefines the callback event.\nIf argument is omitted, this method defines the callback of all events.\nIf you want to modify reference argument in callback, return hash in\ncallback. If you want to return value to OLE server as result of callback\nuse `return' or :return.\n\n  ie = WIN32OLE.new('InternetExplorer.Application')\n  ev = WIN32OLE_EVENT.new(ie)\n  ev.on_event("NavigateComplete") {|url| puts url}\n  ev.on_event() {|ev, *args| puts "#{ev} fired"}\n\n  ev.on_event("BeforeNavigate2") {|*args|\n    ...\n set true to BeforeNavigate reference argument `Cancel'.\n Cancel is 7-th argument of BeforeNavigate,\n so you can use 6 as key of hash instead of 'Cancel'.\n The argument is counted from 0.\n The hash key of 0 means first argument.)\n    {:Cancel => true}  # or {'Cancel' => true} or {6 => true}\n  }\n\n  ev.on_event(...) {|*args|\n    {:return => 1, :xxx => yyy}\n  }\n
on_event_with_outargs WIN32OLE_EVENT.on_event_with_outargs(*args)\nDefines the callback of event.\nIf you want modify argument in callback,\nyou could use this method instead of WIN32OLE_EVENT#on_event.\n\n  ie = WIN32OLE.new('InternetExplorer.Application')\n  ev = WIN32OLE_EVENT.new(ie)\n  ev.on_event_with_outargs('BeforeNavigate2') {|*args|\n    args.last[6] = true\n  }\n
unadvise WIN32OLE_EVENT.unadvise()\ndisconnects OLE server. If this method called, then the WIN32OLE_EVENT object\ndoes not receive the OLE server event any more.\nThis method is trial implementation.\n\n    ie = WIN32OLE.new('InternetExplorer.Application')\n    ev = WIN32OLE_EVENT.new(ie)\n    ev.on_event() {...}\n       ...\n    ev.unadvise\n
array WIN32OLE_VARIANT.array(p1, p2)\nReturns Ruby object wrapping OLE variant whose variant type is VT_ARRAY.\nThe first argument should be Array object which specifies dimensions\nand each size of dimensions of OLE array.\nThe second argument specifies variant type of the element of OLE array.\n\nThe following create 2 dimensions OLE array. The first dimensions size\nis 3, and the second is 4.\n\n   ole_ary = WIN32OLE_VARIANT.array([3,4], VT_I4)\n   ruby_ary = ole_ary.value # => [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]\n
new WIN32OLE_VARIANT.new(*args)\nReturns Ruby object wrapping OLE variant.\nThe first argument specifies Ruby object to convert OLE variant variable.\nThe second argument specifies VARIANT type.\nIn some situation, you need the WIN32OLE_VARIANT object to pass OLE method\n\n   shell = WIN32OLE.new("Shell.Application")\n   folder = shell.NameSpace("C:\\Windows")\n   item = folder.ParseName("tmp.txt")\n You can't use Ruby String object to call FolderItem.InvokeVerb.\n Instead, you have to use WIN32OLE_VARIANT object to call the method.\n   shortcut = WIN32OLE_VARIANT.new("Create Shortcut(\&S)")\n   item.invokeVerb(shortcut)\n
value WIN32OLE_VARIANT.value()\nReturns Ruby object value from OLE variant.\n   obj = WIN32OLE_VARIANT.new(1, WIN32OLE::VARIANT::VT_BSTR)\n   obj.value # => "1" (not Fixnum object, but String object "1")\n
value= WIN32OLE_VARIANT.value=(p1)\nSets variant value to val. If the val type does not match variant value\ntype(vartype), then val is changed to match variant value type(vartype)\nbefore setting val.\nThie method is not available when vartype is VT_ARRAY(except VT_UI1|VT_ARRAY).\nIf the vartype is VT_UI1|VT_ARRAY, the val should be String object.\n\n   obj = WIN32OLE_VARIANT.new(1) # obj.vartype is WIN32OLE::VARIANT::VT_I4\n   obj.value = 3.2 # 3.2 is changed to 3 when setting value.\n   p obj.value # => 3\n
vartype WIN32OLE_VARIANT.vartype()\nReturns OLE variant type.\n   obj = WIN32OLE_VARIANT.new("string")\n   obj.vartype # => WIN32OLE::VARIANT::VT_BSTR\n
adler Zlib::ZStream.adler()\nReturns the adler-32 checksum.\n
avail_in Zlib::ZStream.avail_in()\nReturns bytes of data in the input buffer. Normally, returns 0.\n
avail_out Zlib::ZStream.avail_out()\nReturns number of bytes of free spaces in output buffer.  Because the free\nspace is allocated automatically, this method returns 0 normally.\n
avail_out= Zlib::ZStream.avail_out=(p1)\nAllocates +size+ bytes of free space in the output buffer. If there are more\nthan +size+ bytes already in the buffer, the buffer is truncated. Because\nfree space is allocated automatically, you usually don't need to use this\nmethod.\n
close Zlib::ZStream.close()\nCloses the stream. All operations on the closed stream will raise an\nexception.\n
closed? Zlib::ZStream.closed?()\nReturns true if the stream is closed.\n
data_type Zlib::ZStream.data_type()\nGuesses the type of the data which have been inputed into the stream. The\nreturned value is either <tt>BINARY</tt>, <tt>ASCII</tt>, or\n<tt>UNKNOWN</tt>.\n
end Zlib::ZStream.end()\nCloses the stream. All operations on the closed stream will raise an\nexception.\n
ended? Zlib::ZStream.ended?()\nReturns true if the stream is closed.\n
finish Zlib::ZStream.finish()\nFinishes the stream and flushes output buffer. See Zlib::Deflate#finish and\nZlib::Inflate#finish for details of this behavior.\n
finished? Zlib::ZStream.finished?()\nReturns true if the stream is finished.\n
flush_next_in Zlib::ZStream.flush_next_in()\nFlushes input buffer and returns all data in that buffer.\n
flush_next_out Zlib::ZStream.flush_next_out()\nFlushes output buffer and returns all data in that buffer.\n
reset Zlib::ZStream.reset()\nResets and initializes the stream. All data in both input and output buffer\nare discarded.\n
stream_end? Zlib::ZStream.stream_end?()\nReturns true if the stream is finished.\n
total_in Zlib::ZStream.total_in()\nReturns the total bytes of the input data to the stream.  FIXME\n
total_out Zlib::ZStream.total_out()\nReturns the total bytes of the output data from the stream.  FIXME\n
deflate Zlib::Deflate.deflate(p1, p2 = v2)\nCompresses the given +string+. Valid values of level are\n<tt>NO_COMPRESSION</tt>, <tt>BEST_SPEED</tt>,\n<tt>BEST_COMPRESSION</tt>, <tt>DEFAULT_COMPRESSION</tt>, and an\ninteger from 0 to 9 (the default is 6).\n\nThis method is almost equivalent to the following code:\n\n  def deflate(string, level)\n    z = Zlib::Deflate.new(level)\n    dst = z.deflate(string, Zlib::NO_FLUSH)\n    z.close\n    dst\n  end\n\nSee also Zlib.inflate\n
new Zlib::Deflate.new(p1 = v1, p2 = v2, p3 = v3, p4 = v4)\n== Arguments\n\n+level+::\n  An Integer compression level between\n  BEST_SPEED and BEST_COMPRESSION\n+windowBits+::\n  An Integer for the windowBits size. Should be\n  in the range 8..15, larger values of this parameter\n  result in better at the expense of memory usage.\n+memlevel+::\n  Specifies how much memory should be allocated for\n  the internal compression state.\n  Between DEF_MEM_LEVEL and MAX_MEM_LEVEL\n+strategy+::\n  A parameter to tune the compression algorithm. Use the\n  DEFAULT_STRATEGY for normal data, FILTERED for data produced by a\n  filter (or predictor), HUFFMAN_ONLY to force Huffman encoding only (no\n  string match).\n\n== Description\n\nCreates a new deflate stream for compression. See zlib.h for details of\neach argument. If an argument is nil, the default value of that argument is\nused.\n\n== examples\n\n=== basic\n\n  f = File.new("compressed.file","w+")\n=> #<File:compressed.file>\n  f << Zlib::Deflate.new().deflate(File.read("big.file"))\n=> #<File:compressed.file>\n  f.close\n=> nil\n\n=== a little more robust\n\n  compressed_file = File.open("compressed.file", "w+")\n=> #<File:compressed.file>\n  zd = Zlib::Deflate.new(Zlib::BEST_COMPRESSION, 15, Zlib::MAX_MEM_LEVEL,\n  Zlib::HUFFMAN_ONLY)\n=> #<Zlib::Deflate:0x000000008610a0>\n  compressed_file << zd.deflate(File.read("big.file"))\n=> "\xD4z\xC6\xDE\b\xA1K\x1Ej\x8A ..."\n  compressed_file.close\n=> nil\n  zd.close\n=> nil\n\n(while this example will work, for best optimization the flags need to be\nreviewed for your specific function)\n
deflate Zlib::Deflate.deflate(p1, p2 = v2)\n== Arguments\n\n+string+::\n  String\n\n+flush+::\n  Integer representing a flush code. Either NO_FLUSH,\n  SYNC_FLUSH, FULL_FLUSH, or FINISH. See zlib.h for details.\n  Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to\n  decide how much data to accumulate before producing output, in order to\n  maximize compression.\n\n== Description\n\nInputs +string+ into the deflate stream and returns the output from the\nstream.  On calling this method, both the input and the output buffers of\nthe stream are flushed.\n\nIf +string+ is nil, this method finishes the\nstream, just like Zlib::ZStream#finish.\n\n== Usage\n\n  comp = Zlib.deflate(File.read("big.file"))\nor\n  comp = Zlib.deflate(File.read("big.file"), Zlib::FULL_FLUSH)\n
flush Zlib::Deflate.flush(p1 = v1)\nThis method is equivalent to <tt>deflate('', flush)</tt>.  If flush is omitted,\n<tt>SYNC_FLUSH</tt> is used as flush.  This method is just provided\nto improve the readability of your Ruby program.\n\nPlease visit your zlib.h for a deeper detail on NO_FLUSH, SYNC_FLUSH,\nFULL_FLUSH, and FINISH\n
initialize_copy Zlib::Deflate.initialize_copy(p1)\nDuplicates the deflate stream.\n
params Zlib::Deflate.params(p1, p2)\nChanges the parameters of the deflate stream. See zlib.h for details. The\noutput from the stream by changing the params is preserved in output\nbuffer.\n\n+level+::\n  An Integer compression level between\n  BEST_SPEED and BEST_COMPRESSION\n+strategy+::\n  A parameter to tune the compression algorithm. Use the\n  DEFAULT_STRATEGY for normal data, FILTERED for data produced by a\n  filter (or predictor), HUFFMAN_ONLY to force Huffman encoding only (no\n  string match).\n
set_dictionary Zlib::Deflate.set_dictionary(p1)\nSets the preset dictionary and returns +string+. This method is available\njust only after Zlib::Deflate.new or Zlib::ZStream#reset method was called.\nSee zlib.h for details.\n\nCan raise errors of Z_STREAM_ERROR if a parameter is invalid (such as\nNULL dictionary) or the stream state is inconsistent, Z_DATA_ERROR if\nthe given dictionary doesn't match the expected one (incorrect adler32 value)\n
inflate Zlib::Inflate.inflate(p1)\nDecompresses +string+. Raises a Zlib::NeedDict exception if a preset\ndictionary is needed for decompression.\n\nThis method is almost equivalent to the following code:\n\n  def inflate(string)\n    zstream = Zlib::Inflate.new\n    buf = zstream.inflate(string)\n    zstream.finish\n    zstream.close\n    buf\n  end\n\nSee also Zlib.deflate\n
new Zlib::Inflate.new(p1 = v1)\n== Arguments\n\n+windowBits+::\n  An Integer for the windowBits size. Should be\n  in the range 8..15, larger values of this parameter\n  result in better at the expense of memory usage.\n\n== Description\n\nCreates a new inflate stream for decompression. See zlib.h for details\nof the argument.  If +window_bits+ is +nil+, the default value is used.\n\n== Example\n\n  cf = File.open("compressed.file")\n  ucf = File.open("uncompressed.file", "w+")\n  zi = Zlib::Inflate.new(Zlib::MAX_WBITS)\n\n  ucf << zi.inflate(cf.read)\n\n  ucf.close\n  zi.close\n  cf.close\n\nor\n\n  File.open("compressed.file") {|cf|\n    zi = Zlib::Inflate.new\n    File.open("uncompressed.file", "w+") {|ucf|\n      ucf << zi.inflate(cf.read)\n    }\n    zi.close\n  }\n
inflate Zlib::Inflate.inflate(p1)\nInputs +string+ into the inflate stream and returns the output from the\nstream.  Calling this method, both the input and the output buffer of the\nstream are flushed.  If string is +nil+, this method finishes the stream,\njust like Zlib::ZStream#finish.\n\nRaises a Zlib::NeedDict exception if a preset dictionary is needed to\ndecompress.  Set the dictionary by Zlib::Inflate#set_dictionary and then\ncall this method again with an empty string to flush the stream:\n\n  inflater = Zlib::Inflate.new\n\n  begin\n    out = inflater.inflate compressed\n  rescue Zlib::NeedDict\n ensure the dictionary matches the stream's required dictionary\n    raise unless inflater.adler == Zlib.adler32(dictionary)\n\n    inflater.set_dictionary dictionary\n    inflater.inflate ''\n  end\n ...\n\n  inflater.close\n\nSee also Zlib::Inflate.new\n
set_dictionary Zlib::Inflate.set_dictionary(p1)\nSets the preset dictionary and returns +string+.  This method is available just\nonly after a Zlib::NeedDict exception was raised.  See zlib.h for details.\n
sync Zlib::Inflate.sync(p1)\nInputs +string+ into the end of input buffer and skips data until a full\nflush point can be found.  If the point is found in the buffer, this method\nflushes the buffer and returns false.  Otherwise it returns +true+ and the\nfollowing data of full flush point is preserved in the buffer.\n
sync_point? Zlib::Inflate.sync_point?()\nQuoted verbatim from original documentation:\n\n  What is this?\n\n<tt>:)</tt>\n
wrap Zlib::GzipFile.wrap(*args)\nCreates a GzipFile object associated with +io+, and\nexecutes the block with the newly created GzipFile object,\njust like File.open. The GzipFile object will be closed\nautomatically after executing the block. If you want to keep\nthe associated IO object opening, you may call\n+Zlib::GzipFile#finish+ method in the block.\n
close Zlib::GzipFile.close()\nCloses the GzipFile object. This method calls close method of the\nassociated IO object. Returns the associated IO object.\n
closed? Zlib::GzipFile.closed?()\nSame as IO#closed?\n
comment Zlib::GzipFile.comment()\nReturns comments recorded in the gzip file header, or nil if the comments\nis not present.\n
crc Zlib::GzipFile.crc()\nReturns CRC value of the uncompressed data.\n
finish Zlib::GzipFile.finish()\nCloses the GzipFile object. Unlike Zlib::GzipFile#close, this method never\ncalls the close method of the associated IO object. Returns the associated IO\nobject.\n
level Zlib::GzipFile.level()\nReturns compression level.\n
mtime Zlib::GzipFile.mtime()\nReturns last modification time recorded in the gzip file header.\n
orig_name Zlib::GzipFile.orig_name()\nReturns original filename recorded in the gzip file header, or +nil+ if\noriginal filename is not present.\n
os_code Zlib::GzipFile.os_code()\nReturns OS code number recorded in the gzip file header.\n
sync Zlib::GzipFile.sync()\nSame as IO#sync\n
sync= Zlib::GzipFile.sync=(p1)\nSame as IO.  If flag is +true+, the associated IO object must respond to the\n+flush+ method.  While +sync+ mode is +true+, the compression ratio\ndecreases sharply.\n
to_io Zlib::GzipFile.to_io()\nSame as IO.\n
inspect Zlib::GzipFile::Error.inspect()\nConstructs a String of the GzipFile Error\n
new Zlib::GzipWriter.new(p1, p2 = v2, p3 = v3)\nCreates a GzipWriter object associated with +io+. +level+ and +strategy+\nshould be the same as the arguments of Zlib::Deflate.new.  The GzipWriter\nobject writes gzipped data to +io+.  At least, +io+ must respond to the\n+write+ method that behaves same as write method in IO class.\n
open Zlib::GzipWriter.open(*args)\nOpens a file specified by +filename+ for writing gzip compressed data, and\nreturns a GzipWriter object associated with that file.  Further details of\nthis method are found in Zlib::GzipWriter.new and Zlib::GzipFile.wrap.\n
comment= Zlib::GzipWriter.comment=(p1)\nSpecify the comment (+str+) in the gzip header.\n
flush Zlib::GzipWriter.flush(p1 = v1)\nFlushes all the internal buffers of the GzipWriter object.  The meaning of\n+flush+ is same as in Zlib::Deflate#deflate.  <tt>Zlib::SYNC_FLUSH</tt>\nis used if\n+flush+ is omitted.  It is no use giving flush <tt>Zlib::NO_FLUSH</tt>.\n
mtime= Zlib::GzipWriter.mtime=(p1)\nSpecify the modification time (+mtime+) in the gzip header.\nUsing a Fixnum or Integer\n
orig_name= Zlib::GzipWriter.orig_name=(p1)\nSpecify the original name (+str+) in the gzip header.\n
pos Zlib::GzipWriter.pos()\nTotal number of input bytes read so far.\n
print Zlib::GzipWriter.print(*args)\n   Same as IO.\nSame as IO.\n
printf Zlib::GzipWriter.printf(*args)\n   Same as IO.\nSame as IO.\n
putc Zlib::GzipWriter.putc(p1)\nSame as IO.\n
puts Zlib::GzipWriter.puts(*args)\n   Same as IO.\nSame as IO.\n
tell Zlib::GzipWriter.tell()\nTotal number of input bytes read so far.\n
write Zlib::GzipWriter.write(p1)\nSame as IO.\n
new Zlib::GzipReader.new(p1, p2 = {})\nCreates a GzipReader object associated with +io+. The GzipReader object reads\ngzipped data from +io+, and parses/decompresses them.  At least, +io+ must have\na +read+ method that behaves same as the +read+ method in IO class.\n\nIf the gzip file header is incorrect, raises an Zlib::GzipFile::Error\nexception.\n
open Zlib::GzipReader.open(*args)\nOpens a file specified by +filename+ as a gzipped file, and returns a\nGzipReader object associated with that file.  Further details of this method\nare in Zlib::GzipReader.new and ZLib::GzipFile.wrap.\n
bytes Zlib::GzipReader.bytes()\nSee Zlib::GzipReader documentation for a description.\n
each Zlib::GzipReader.each(*args)\nSee Zlib::GzipReader documentation for a description.\n
each_byte Zlib::GzipReader.each_byte()\nSee Zlib::GzipReader documentation for a description.\n
each_char Zlib::GzipReader.each_char()\nSee Zlib::GzipReader documentation for a description.\n
each_line Zlib::GzipReader.each_line(*args)\nSee Zlib::GzipReader documentation for a description.\n
eof Zlib::GzipReader.eof()\nReturns +true+ or +false+ whether the stream has reached the end.\n
eof? Zlib::GzipReader.eof?()\nReturns +true+ or +false+ whether the stream has reached the end.\n
getbyte Zlib::GzipReader.getbyte()\nSee Zlib::GzipReader documentation for a description.\n
getc Zlib::GzipReader.getc()\nSee Zlib::GzipReader documentation for a description.\n
gets Zlib::GzipReader.gets(*args)\nSee Zlib::GzipReader documentation for a description.\n
lineno Zlib::GzipReader.lineno()\nThe line number of the last row read from this file.\n
lineno= Zlib::GzipReader.lineno=(p1)\nSpecify line number of the last row read from this file.\n
lines Zlib::GzipReader.lines(*args)\nSee Zlib::GzipReader documentation for a description.\n
pos Zlib::GzipReader.pos()\nTotal number of output bytes output so far.\n
read Zlib::GzipReader.read(p1 = v1)\nSee Zlib::GzipReader documentation for a description.\n
readbyte Zlib::GzipReader.readbyte()\nSee Zlib::GzipReader documentation for a description.\n
readchar Zlib::GzipReader.readchar()\nSee Zlib::GzipReader documentation for a description.\n
readline Zlib::GzipReader.readline(*args)\nSee Zlib::GzipReader documentation for a description.\n
readlines Zlib::GzipReader.readlines(*args)\nSee Zlib::GzipReader documentation for a description.\n
readpartial Zlib::GzipReader.readpartial(p1, p2 = v2)\nReads at most <i>maxlen</i> bytes from the gziped stream but\nit blocks only if <em>gzipreader</em> has no data immediately available.\nIf the optional <i>outbuf</i> argument is present,\nit must reference a String, which will receive the data.\nIt raises `EOFError` on end of file.\n
rewind Zlib::GzipReader.rewind()\nResets the position of the file pointer to the point created the GzipReader\nobject.  The associated IO object needs to respond to the +seek+ method.\n
tell Zlib::GzipReader.tell()\nTotal number of output bytes output so far.\n
ungetbyte Zlib::GzipReader.ungetbyte(p1)\nSee Zlib::GzipReader documentation for a description.\n
ungetc Zlib::GzipReader.ungetc(p1)\nSee Zlib::GzipReader documentation for a description.\n
unused Zlib::GzipReader.unused()\nReturns the rest of the data which had read for parsing gzip format, or\n+nil+ if the whole gzip file is not parsed yet.\n
all_waits Object::ThWait.all_waits(*threads)\nWaits until all specified threads have terminated.  If a block is provided,\nit is executed for each thread as they terminate.\n
new Object::ThWait.new(*threads)\nCreates a ThreadsWait object, specifying the threads to wait on.\nNon-blocking.\n
all_waits Object::ThWait.all_waits()\nWaits until all of the specified threads are terminated.  If a block is\nsupplied for the method, it is executed for each thread termination.\n\nRaises exceptions in the same manner as +next_wait+.\n
empty? Object::ThWait.empty?()\nReturns +true+ if there are no threads in the pool still running.\n
finished? Object::ThWait.finished?()\nReturns +true+ if any thread has terminated and is ready to be collected.\n
join Object::ThWait.join(*threads)\nWaits for specified threads to terminate, and returns when one of\nthe threads terminated.\n
join_nowait Object::ThWait.join_nowait(*threads)\nSpecifies the threads that this object will wait for, but does not actually\nwait.\n
next_wait Object::ThWait.next_wait(nonblock = nil)\nWaits until any of the specified threads has terminated, and returns the one\nthat does.\n\nIf there is no thread to wait, raises +ErrNoWaitingThread+.  If +nonblock+\nis true, and there is no terminated thread, raises +ErrNoFinishedThread+.\n
URI Kernel.URI(uri)\nReturns +uri+ converted to a URI object.\n
open Kernel.open(*args)\nCreates an `IO` object connected to the given stream,\nfile, or subprocess.\n\nIf <i>path</i> does not start with a pipe character\n(```|`''), treat it as the name of a file to open using\nthe specified mode (defaulting to ```r`'').\n\nThe mode_enc is\neither a string or an integer.  If it is an integer, it must be\nbitwise-or of open(2) flags, such as File::RDWR or File::EXCL.\nIf it is a string, it is either "mode", "mode:ext_enc", or\n"mode:ext_enc:int_enc".\nThe mode is one of the following:\n\n r: read (default)\n w: write\n a: append\n\nThe mode can be followed by "b" (means binary-mode), or "+"\n(means both reading and writing allowed) or both.\nIf ext_enc (external encoding) is specified,\nread string will be tagged by the encoding in reading,\nand output string will be converted\nto the specified encoding in writing.\nIf ext_enc starts with 'BOM|', check whether the input has a BOM. If\nthere is a BOM, strip it and set external encoding as\nwhat the BOM tells. If there is no BOM, use ext_enc without 'BOM|'.\nIf two encoding names,\next_enc and int_enc (external encoding and internal encoding),\nare specified, the read string is converted from ext_enc\nto int_enc then tagged with the int_enc in read mode,\nand in write mode, the output string will be\nconverted from int_enc to ext_enc before writing.\n\nIf a file is being created, its initial permissions may be\nset using the integer third parameter.\n\nIf a block is specified, it will be invoked with the\n`File` object as a parameter, and the file will be\nautomatically closed when the block terminates. The call\nreturns the value of the block.\n\nIf <i>path</i> starts with a pipe character, a subprocess is\ncreated, connected to the caller by a pair of pipes. The returned\n`IO` object may be used to write to the standard input\nand read from the standard output of this subprocess. If the command\nfollowing the ```|`'' is a single minus sign, Ruby forks,\nand this subprocess is connected to the parent. In the subprocess,\nthe `open` call returns `nil`. If the command\nis not ```-`'', the subprocess runs the command. If a\nblock is associated with an `open("|-")` call, that block\nwill be run twice---once in the parent and once in the child. The\nblock parameter will be an `IO` object in the parent and\n`nil` in the child. The parent's `IO` object\nwill be connected to the child's `$stdin` and\n`$stdout`. The subprocess will be terminated at the end\nof the block.\n\n   open("testfile") do |f|\n     print f.gets\n   end\n\n<em>produces:</em>\n\n   This is line one\n\nOpen a subprocess and read its output:\n\n   cmd = open("|date")\n   print cmd.gets\n   cmd.close\n\n<em>produces:</em>\n\n   Wed Apr  9 08:56:31 CDT 2003\n\nOpen a subprocess running the same Ruby program:\n\n   f = open("|-", "w+")\n   if f == nil\n     puts "in Child"\n     exit\n   else\n     puts "Got: #{f.gets}"\n   end\n\n<em>produces:</em>\n\n   Got: in Child\n\nOpen a subprocess using a block to receive the I/O object:\n\n   open("|-") do |f|\n     if f == nil\n       puts "in Child"\n     else\n       puts "Got: #{f.gets}"\n     end\n   end\n\n<em>produces:</em>\n\n   Got: in Child\n
pp Kernel.pp(*objs)\nprints arguments in pretty form.\n\npp returns argument(s).\n
Array Kernel.Array(p1)\nReturns <i>arg</i> as an `Array`. First tries to call\n<i>arg</i>`.to_ary`, then <i>arg</i>`.to_a`.\n\n   Array(1..5)   #=> [1, 2, 3, 4, 5]\n
BigDecimal Kernel.BigDecimal(*args)\n\n
Complex Kernel.Complex(*args)\nReturns x+i*y;\n
Float Kernel.Float(p1)\nReturns <i>arg</i> converted to a float. Numeric types are converted\ndirectly, the rest are converted using <i>arg</i>.to_f. As of Ruby\n1.8, converting `nil` generates a `TypeError`.\n\n   Float(1)           #=> 1.0\n   Float("123.456")   #=> 123.456\n
Integer Kernel.Integer(p1, p2 = v2)\nConverts <i>arg</i> to a `Fixnum` or `Bignum`.\nNumeric types are converted directly (with floating point numbers\nbeing truncated).    <i>base</i> (0, or between 2 and 36) is a base for\ninteger string representation.  If <i>arg</i> is a `String`,\nwhen <i>base</i> is omitted or equals to zero, radix indicators\n(`0`, `0b`, and `0x`) are honored.\nIn any case, strings should be strictly conformed to numeric\nrepresentation. This behavior is different from that of\n`String#to_i`.  Non string values will be converted using\n`to_int`, and `to_i`.\n\n   Integer(123.999)    #=> 123\n   Integer("0x1a")     #=> 26\n   Integer(Time.new)   #=> 1204973019\n   Integer("0930", 10) #=> 930\n   Integer("111", 2)   #=> 7\n
Pathname Kernel.Pathname(p1)\ncreate a pathname object.\n\nThis method is available since 1.8.5.\n
Rational Kernel.Rational(*args)\nReturns x/y;\n
String Kernel.String(p1)\nConverts <i>arg</i> to a `String` by calling its\n`to_s` method.\n\n   String(self)        #=> "main"\n   String(self.class)  #=> "Object"\n   String(123456)      #=> "123456"\n
__callee__ Kernel.__callee__()\nReturns the name of the current method as a Symbol.\nIf called outside of a method, it returns `nil`.\n
__method__ Kernel.__method__()\nReturns the name of the current method as a Symbol.\nIf called outside of a method, it returns `nil`.\n
abort Kernel.abort(p1)\nTerminate execution immediately, effectively by calling\n`Kernel.exit(false)`. If _msg_ is given, it is written\nto STDERR prior to terminating.\n
at_exit Kernel.at_exit()\nConverts _block_ to a +Proc+ object (and therefore\nbinds it at the point of call) and registers it for execution when\nthe program exits. If multiple handlers are registered, they are\nexecuted in reverse order of registration.\n\n   def do_at_exit(str1)\n     at_exit { print str1 }\n   end\n   at_exit { puts "cruel world" }\n   do_at_exit("goodbye ")\n   exit\n\n<em>produces:</em>\n\n   goodbye cruel world\n
autoload Kernel.autoload(p1, p2)\nRegisters _filename_ to be loaded (using `Kernel::require`)\nthe first time that _module_ (which may be a `String` or\na symbol) is accessed.\n\n   autoload(:MyModule, "/usr/local/lib/modules/my_module.rb")\n
autoload? Kernel.autoload?(p1)\nReturns _filename_ to be loaded if _name_ is registered as\n+autoload+.\n\n   autoload(:B, "b")\n   autoload?(:B)            #=> "b"\n
binding Kernel.binding()\nReturns a +Binding+ object, describing the variable and\nmethod bindings at the point of call. This object can be used when\ncalling +eval+ to execute the evaluated command in this\nenvironment. See also the description of class +Binding+.\n\n   def get_binding(param)\n     return binding\n   end\n   b = get_binding("hello")\n   eval("param", b)   #=> "hello"\n
block_given? Kernel.block_given?()\nReturns `true` if `yield` would execute a\nblock in the current context. The `iterator?` form\nis mildly deprecated.\n\n   def try\n     if block_given?\n       yield\n     else\n       "no block"\n     end\n   end\n   try                  #=> "no block"\n   try { "hello" }      #=> "hello"\n   try do "hello" end   #=> "hello"\n
callcc Kernel.callcc()\nGenerates a `Continuation` object, which it passes to\nthe associated block. You need to `require\n'continuation'` before using this method. Performing a\n<em>cont</em>`.call` will cause the `callcc`\nto return (as will falling through the end of the block). The\nvalue returned by the `callcc` is the value of the\nblock, or the value passed to <em>cont</em>`.call`. See\nclass `Continuation` for more details. Also see\n`Kernel::throw` for an alternative mechanism for\nunwinding a call stack.\n
caller Kernel.caller(p1 = v1)\nReturns the current execution stack---an array containing strings in\nthe form ``<em>file:line</em>'' or ``<em>file:line: in\n`method'</em>''. The optional _start_ parameter\ndetermines the number of initial stack entries to omit from the\nresult.\n\nReturns +nil+ if _start_ is greater than the size of\ncurrent execution stack.\n\n   def a(skip)\n     caller(skip)\n   end\n   def b(skip)\n     a(skip)\n   end\n   def c(skip)\n     b(skip)\n   end\n   c(0)   #=> ["prog:2:in `a'", "prog:5:in `b'", "prog:8:in `c'", "prog:10:in\n   `<main>'"]\n   c(1)   #=> ["prog:5:in `b'", "prog:8:in `c'", "prog:11:in `<main>'"]\n   c(2)   #=> ["prog:8:in `c'", "prog:12:in `<main>'"]\n   c(3)   #=> ["prog:13:in `<main>'"]\n   c(4)   #=> []\n   c(5)   #=> nil\n
catch Kernel.catch(p1 = v1)\n+catch+ executes its block. If a +throw+ is\nexecuted, Ruby searches up its stack for a +catch+ block\nwith a tag corresponding to the +throw+'s\n_tag_. If found, that block is terminated, and\n+catch+ returns the value given to +throw+. If\n+throw+ is not called, the block terminates normally, and\nthe value of +catch+ is the value of the last expression\nevaluated. +catch+ expressions may be nested, and the\n+throw+ call need not be in lexical scope.\n\n   def routine(n)\n     puts n\n     throw :done if n <= 0\n     routine(n-1)\n   end\n\n   catch(:done) { routine(3) }\n\n<em>produces:</em>\n\n   3\n   2\n   1\n   0\n\nwhen _arg_ is given, +catch+ yields it as is, or when no\n_arg_ is given, +catch+ assigns a new unique object to\n+throw+.  this is useful for nested +catch+.  _arg_ can\nbe an arbitrary object, not only Symbol.\n
chomp Kernel.chomp(*args)\nEquivalent to `$_ = $_.chomp(<em>string</em>)`. See\n`String#chomp`.\nAvailable only when -p/-n command line option specified.\n
chop Kernel.chop()\nEquivalent to `($_.dup).chop!`, except `nil`\nis never returned. See `String#chop!`.\nAvailable only when -p/-n command line option specified.\n
eval Kernel.eval(p1, p2 = v2, p3 = v3, p4 = v4)\nEvaluates the Ruby expression(s) in <em>string</em>. If\n<em>binding</em> is given, which must be a `Binding`\nobject, the evaluation is performed in its context. If the\noptional <em>filename</em> and <em>lineno</em> parameters are\npresent, they will be used when reporting syntax errors.\n\n   def get_binding(str)\n     return binding\n   end\n   str = "hello"\n   eval "str + ' Fred'"                      #=> "hello Fred"\n   eval "str + ' Fred'", get_binding("bye")  #=> "bye Fred"\n
exec Kernel.exec(*args)\nReplaces the current process by running the given external _command_.\n_command..._ is one of following forms.\n\n  commandline                 : command line string which is passed to the\n  standard shell\n  cmdname, arg1, ...          : command name and one or more arguments\n  (no shell)\n  [cmdname, argv0], arg1, ... : command name, argv[0] and zero or more\n  arguments (no shell)\n\nIf single string is given as the command,\nit is taken as a command line that is subject to shell expansion before\nbeing executed.\n\nThe standard shell means always `"/bin/sh"` on Unix-like systems,\n`ENV["RUBYSHELL"]` or `ENV["COMSPEC"]` on Windows NT series, and\nsimilar.\n\nIf two or more +string+ given,\nthe first is taken as a command name and\nthe rest are passed as parameters to command with no shell expansion.\n\nIf a two-element array at the beginning of the command,\nthe first element is the command to be executed,\nand the second argument is used as the `argv[0]` value,\nwhich may show up in process listings.\n\nIn order to execute the command, one of the `exec(2)`\nsystem calls is used, so the running command may inherit some of the\nenvironment\nof the original program (including open file descriptors).\nThis behavior is modified by env and options.\nSee `spawn` for details.\n\nRaises SystemCallError if the command couldn't execute (typically\n`Errno::ENOENT` when it was not found).\n\n   exec "echo *"       # echoes list of files in current directory\n never get here\n\n   exec "echo", "*"    # echoes an asterisk\n never get here\n
exit Kernel.exit(p1 = v1)\nInitiates the termination of the Ruby script by raising the\n`SystemExit` exception. This exception may be caught. The\noptional parameter is used to return a status code to the invoking\nenvironment.\n+true+ and +FALSE+ of _status_ means success and failure\nrespectively.  The interpretation of other integer values are\nsystem dependent.\n\n   begin\n     exit\n     puts "never get here"\n   rescue SystemExit\n     puts "rescued a SystemExit exception"\n   end\n   puts "after begin block"\n\n<em>produces:</em>\n\n   rescued a SystemExit exception\n   after begin block\n\nJust prior to termination, Ruby executes any `at_exit` functions\n(see Kernel::at_exit) and runs any object finalizers (see\nObjectSpace::define_finalizer).\n\n   at_exit { puts "at_exit function" }\n   ObjectSpace.define_finalizer("string",  proc { puts "in finalizer" })\n   exit\n\n<em>produces:</em>\n\n   at_exit function\n   in finalizer\n
exit! Kernel.exit!(p1 = v1)\nExits the process immediately. No exit handlers are\nrun. <em>status</em> is returned to the underlying system as the\nexit status.\n\n   Process.exit!(true)\n
fail Kernel.fail(*args)\nWith no arguments, raises the exception in `$!` or raises\na `RuntimeError` if `$!` is +nil+.\nWith a single +String+ argument, raises a\n+RuntimeError+ with the string as a message. Otherwise,\nthe first parameter should be the name of an +Exception+\nclass (or an object that returns an +Exception+ object when sent\nan +exception+ message). The optional second parameter sets the\nmessage associated with the exception, and the third parameter is an\narray of callback information. Exceptions are caught by the\n+rescue+ clause of `begin...end` blocks.\n\n   raise "Failed to create socket"\n   raise ArgumentError, "No parameters", caller\n
fork Kernel.fork()\nCreates a subprocess. If a block is specified, that block is run\nin the subprocess, and the subprocess terminates with a status of\nzero. Otherwise, the +fork+ call returns twice, once in\nthe parent, returning the process ID of the child, and once in\nthe child, returning _nil_. The child process can exit using\n`Kernel.exit!` to avoid running any\n`at_exit` functions. The parent process should\nuse `Process.wait` to collect the termination statuses\nof its children or use `Process.detach` to register\ndisinterest in their status; otherwise, the operating system\nmay accumulate zombie processes.\n\nThe thread calling fork is the only thread in the created child process.\nfork doesn't copy other threads.\n\nIf fork is not usable, Process.respond_to?(:fork) returns false.\n
format Kernel.format(*args)\nReturns the string resulting from applying <i>format_string</i> to\nany additional arguments.  Within the format string, any characters\nother than format sequences are copied to the result.\n\nThe syntax of a format sequence is follows.\n\n  %[flags][width][.precision]type\n\nA format\nsequence consists of a percent sign, followed by optional flags,\nwidth, and precision indicators, then terminated with a field type\ncharacter.  The field type controls how the corresponding\n`sprintf` argument is to be interpreted, while the flags\nmodify that interpretation.\n\nThe field type characters are:\n\n    Field |  Integer Format\n    ------+--------------------------------------------------------------\n      b   | Convert argument as a binary number.\n          | Negative numbers will be displayed as a two's complement\n          | prefixed with `..1'.\n      B   | Equivalent to `b', but uses an uppercase 0B for prefix\n          | in the alternative format by #.\n      d   | Convert argument as a decimal number.\n      i   | Identical to `d'.\n      o   | Convert argument as an octal number.\n          | Negative numbers will be displayed as a two's complement\n          | prefixed with `..7'.\n      u   | Identical to `d'.\n      x   | Convert argument as a hexadecimal number.\n          | Negative numbers will be displayed as a two's complement\n          | prefixed with `..f' (representing an infinite string of\n          | leading 'ff's).\n      X   | Equivalent to `x', but uses uppercase letters.\n\n    Field |  Float Format\n    ------+--------------------------------------------------------------\n      e   | Convert floating point argument into exponential notation\n          | with one digit before the decimal point as [-]d.dddddde[+-]dd.\n          | The precision specifies the number of digits after the decimal\n          | point (defaulting to six).\n      E   | Equivalent to `e', but uses an uppercase E to indicate\n          | the exponent.\n      f   | Convert floating point argument as [-]ddd.dddddd,\n          | where the precision specifies the number of digits after\n          | the decimal point.\n      g   | Convert a floating point number using exponential form\n          | if the exponent is less than -4 or greater than or\n          | equal to the precision, or in dd.dddd form otherwise.\n          | The precision specifies the number of significant digits.\n      G   | Equivalent to `g', but use an uppercase `E' in exponent form.\n      a   | Convert floating point argument as [-]0xh.hhhhp[+-]dd,\n          | which is consisted from optional sign, "0x", fraction part\n          | as hexadecimal, "p", and exponential part as decimal.\n      A   | Equivalent to `a', but use uppercase `X' and `P'.\n\n    Field |  Other Format\n    ------+--------------------------------------------------------------\n      c   | Argument is the numeric code for a single character or\n          | a single character string itself.\n      p   | The valuing of argument.inspect.\n      s   | Argument is a string to be substituted.  If the format\n          | sequence contains a precision, at most that many characters\n          | will be copied.\n      %   | A percent sign itself will be displayed.  No argument taken.\n\nThe flags modifies the behavior of the formats.\nThe flag characters are:\n\n  Flag     | Applies to    | Meaning\n  ---------+---------------+-----------------------------------------\n  space    | bBdiouxX      | Leave a space at the start of\n           | aAeEfgG       | non-negative numbers.\n           | (numeric fmt) | For `o', `x', `X', `b' and `B', use\n           |               | a minus sign with absolute value for\n           |               | negative values.\n  ---------+---------------+-----------------------------------------\n  (digit)$ | all           | Specifies the absolute argument number\n           |               | for this field.  Absolute and relative\n           |               | argument numbers cannot be mixed in a\n           |               | sprintf string.\n  ---------+---------------+-----------------------------------------\n       | bBoxX         | Use an alternative format.\n           | aAeEfgG       | For the conversions `o', increase the precision\n           |               | until the first digit will be `0' if\n           |               | it is not formatted as complements.\n           |               | For the conversions `x', `X', `b' and `B'\n           |               | on non-zero, prefix the result with ``0x'',\n           |               | ``0X'', ``0b'' and ``0B'', respectively.\n           |               | For `a', `A', `e', `E', `f', `g', and 'G',\n           |               | force a decimal point to be added,\n           |               | even if no digits follow.\n           |               | For `g' and 'G', do not remove trailing zeros.\n  ---------+---------------+-----------------------------------------\n  +        | bBdiouxX      | Add a leading plus sign to non-negative\n           | aAeEfgG       | numbers.\n           | (numeric fmt) | For `o', `x', `X', `b' and `B', use\n           |               | a minus sign with absolute value for\n           |               | negative values.\n  ---------+---------------+-----------------------------------------\n  -        | all           | Left-justify the result of this conversion.\n  ---------+---------------+-----------------------------------------\n  0 (zero) | bBdiouxX      | Pad with zeros, not spaces.\n           | aAeEfgG       | For `o', `x', `X', `b' and `B', radix-1\n           | (numeric fmt) | is used for negative numbers formatted as\n           |               | complements.\n  ---------+---------------+-----------------------------------------\n  *        | all           | Use the next argument as the field width.\n           |               | If negative, left-justify the result. If the\n           |               | asterisk is followed by a number and a dollar\n           |               | sign, use the indicated argument as the width.\n\nExamples of flags:\n `+' and space flag specifies the sign of non-negative numbers.\n sprintf("%d", 123)  #=> "123"\n sprintf("%+d", 123) #=> "+123"\n sprintf("% d", 123) #=> " 123"\n `#' flag for `o' increases number of digits to show `0'.\n `+' and space flag changes format of negative numbers.\n sprintf("%o", 123)   #=> "173"\n sprintf("%#o", 123)  #=> "0173"\n sprintf("%+o", -123) #=> "-173"\n sprintf("%o", -123)  #=> "..7605"\n sprintf("%#o", -123) #=> "..7605"\n `#' flag for `x' add a prefix `0x' for non-zero numbers.\n `+' and space flag disables complements for negative numbers.\n sprintf("%x", 123)   #=> "7b"\n sprintf("%#x", 123)  #=> "0x7b"\n sprintf("%+x", -123) #=> "-7b"\n sprintf("%x", -123)  #=> "..f85"\n sprintf("%#x", -123) #=> "0x..f85"\n sprintf("%#x", 0)    #=> "0"\n `#' for `X' uses the prefix `0X'.\n sprintf("%X", 123)  #=> "7B"\n sprintf("%#X", 123) #=> "0X7B"\n `#' flag for `b' add a prefix `0b' for non-zero numbers.\n `+' and space flag disables complements for negative numbers.\n sprintf("%b", 123)   #=> "1111011"\n sprintf("%#b", 123)  #=> "0b1111011"\n sprintf("%+b", -123) #=> "-1111011"\n sprintf("%b", -123)  #=> "..10000101"\n sprintf("%#b", -123) #=> "0b..10000101"\n sprintf("%#b", 0)    #=> "0"\n `#' for `B' uses the prefix `0B'.\n sprintf("%B", 123)  #=> "1111011"\n sprintf("%#B", 123) #=> "0B1111011"\n `#' for `e' forces to show the decimal point.\n sprintf("%.0e", 1)  #=> "1e+00"\n sprintf("%#.0e", 1) #=> "1.e+00"\n `#' for `f' forces to show the decimal point.\n sprintf("%.0f", 1234)  #=> "1234"\n sprintf("%#.0f", 1234) #=> "1234."\n `#' for `g' forces to show the decimal point.\n It also disables stripping lowest zeros.\n sprintf("%g", 123.4)   #=> "123.4"\n sprintf("%#g", 123.4)  #=> "123.400"\n sprintf("%g", 123456)  #=> "123456"\n sprintf("%#g", 123456) #=> "123456."\n\nThe field width is an optional integer, followed optionally by a\nperiod and a precision.  The width specifies the minimum number of\ncharacters that will be written to the result for this field.\n\nExamples of width:\n padding is done by spaces,       width=20\n 0 or radix-1.             <------------------>\n sprintf("%20d", 123)   #=> "                 123"\n sprintf("%+20d", 123)  #=> "                +123"\n sprintf("%020d", 123)  #=> "00000000000000000123"\n sprintf("%+020d", 123) #=> "+0000000000000000123"\n sprintf("% 020d", 123) #=> " 0000000000000000123"\n sprintf("%-20d", 123)  #=> "123                 "\n sprintf("%-+20d", 123) #=> "+123                "\n sprintf("%- 20d", 123) #=> " 123                "\n sprintf("%020x", -123) #=> "..ffffffffffffffff85"\n\nFor\nnumeric fields, the precision controls the number of decimal places\ndisplayed.  For string fields, the precision determines the maximum\nnumber of characters to be copied from the string.  (Thus, the format\nsequence `%10.10s` will always contribute exactly ten\ncharacters to the result.)\n\nExamples of precisions:\n precision for `d', 'o', 'x' and 'b' is\n minimum number of digits               <------>\n sprintf("%20.8d", 123)  #=> "            00000123"\n sprintf("%20.8o", 123)  #=> "            00000173"\n sprintf("%20.8x", 123)  #=> "            0000007b"\n sprintf("%20.8b", 123)  #=> "            01111011"\n sprintf("%20.8d", -123) #=> "           -00000123"\n sprintf("%20.8o", -123) #=> "            ..777605"\n sprintf("%20.8x", -123) #=> "            ..ffff85"\n sprintf("%20.8b", -11)  #=> "            ..110101"\n "0x" and "0b" for `#x' and `#b' is not counted for\n precision but "0" for `#o' is counted.  <------>\n sprintf("%#20.8d", 123)  #=> "            00000123"\n sprintf("%#20.8o", 123)  #=> "            00000173"\n sprintf("%#20.8x", 123)  #=> "          0x0000007b"\n sprintf("%#20.8b", 123)  #=> "          0b01111011"\n sprintf("%#20.8d", -123) #=> "           -00000123"\n sprintf("%#20.8o", -123) #=> "            ..777605"\n sprintf("%#20.8x", -123) #=> "          0x..ffff85"\n sprintf("%#20.8b", -11)  #=> "          0b..110101"\n precision for `e' is number of\n digits after the decimal point           <------>\n sprintf("%20.8e", 1234.56789) #=> "      1.23456789e+03"\n precision for `f' is number of\n digits after the decimal point               <------>\n sprintf("%20.8f", 1234.56789) #=> "       1234.56789000"\n precision for `g' is number of\n significant digits                          <------->\n sprintf("%20.8g", 1234.56789) #=> "           1234.5679"\n                                         <------->\n sprintf("%20.8g", 123456789)  #=> "       1.2345679e+08"\n precision for `s' is\n maximum number of characters                    <------>\n sprintf("%20.8s", "string test") #=> "            string t"\n\nExamples:\n\n   sprintf("%d %04x", 123, 123)               #=> "123 007b"\n   sprintf("%08b '%4s'", 123, 123)            #=> "01111011 ' 123'"\n   sprintf("%1$*2$s %2$d %1$s", "hello", 8)   #=> "   hello 8 hello"\n   sprintf("%1$*2$s %2$d", "hello", -8)       #=> "hello    -8"\n   sprintf("%+g:% g:%-g", 1.23, 1.23, 1.23)   #=> "+1.23: 1.23:1.23"\n   sprintf("%u", -123)                        #=> "-123"\n\nFor more complex formatting, Ruby supports a reference by name.\n%<name>s style uses format style, but %{name} style doesn't.\n\nExapmles:\n  sprintf("%<foo>d : %<bar>f", { :foo => 1, :bar => 2 })\n=> 1 : 2.000000\n  sprintf("%{foo}f", { :foo => 1 })\n => "1f"\n
gem Kernel.gem(gem_name, *requirements)\nUse Kernel#gem to activate a specific version of +gem_name+.\n\n+requirements+ is a list of version requirements that the\nspecified gem must match, most commonly "= example.version.number".  See\nGem::Requirement for how to specify a version requirement.\n\nIf you will be activating the latest version of a gem, there is no need to\ncall Kernel#gem, Kernel#require will do the right thing for you.\n\nKernel#gem returns true if the gem was activated, otherwise false.  If the\ngem could not be found, didn't match the version requirements, or a\ndifferent version was already activated, an exception will be raised.\n\nKernel#gem should be called *before* any require statements (otherwise\nRubyGems may load a conflicting library version).\n\nIn older RubyGems versions, the environment variable GEM_SKIP could be\nused to skip activation of specified gems, for example to test out changes\nthat haven't been installed yet.  Now RubyGems defers to -I and the\nRUBYLIB environment variable to skip activation of a gem.\n\nExample:\n\n  GEM_SKIP=libA:libB ruby -I../libA -I../libB ./mycode.rb\n
gem_original_require Kernel.gem_original_require(p1)\nThe Kernel#require from before RubyGems was loaded.\n
gets Kernel.gets(*args)\nReturns (and assigns to `$_`) the next line from the list\nof files in +ARGV+ (or `$*`), or from standard input if\nno files are present on the command line. Returns +nil+ at end of\nfile. The optional argument specifies the record separator. The\nseparator is included with the contents of each record. A separator\nof +nil+ reads the entire contents, and a zero-length separator\nreads the input one paragraph at a time, where paragraphs are\ndivided by two consecutive newlines.  If the first argument is an\ninteger, or optional second argument is given, the returning string\nwould not be longer than the given value in bytes.  If multiple\nfilenames are present in +ARGV+, +gets(nil)+ will read the contents\none file at a time.\n\n   ARGV << "testfile"\n   print while gets\n\n<em>produces:</em>\n\n   This is line one\n   This is line two\n   This is line three\n   And so on...\n\nThe style of programming using `$_` as an implicit\nparameter is gradually losing favor in the Ruby community.\n
global_variables Kernel.global_variables()\nReturns an array of the names of global variables.\n\n   global_variables.grep /std/   #=> [:$stdin, :$stdout, :$stderr]\n
gsub Kernel.gsub(*args)\nEquivalent to `$_.gsub...`, except that `$_`\nreceives the modified result.\nAvailable only when -p/-n command line option specified.\n
iterator? Kernel.iterator?()\nReturns `true` if `yield` would execute a\nblock in the current context. The `iterator?` form\nis mildly deprecated.\n\n   def try\n     if block_given?\n       yield\n     else\n       "no block"\n     end\n   end\n   try                  #=> "no block"\n   try { "hello" }      #=> "hello"\n   try do "hello" end   #=> "hello"\n
lambda Kernel.lambda()\nEquivalent to `Proc.new`, except the resulting Proc objects\ncheck the number of parameters passed when called.\n
load Kernel.load(p1, p2 = v2)\nLoads and executes the Ruby\nprogram in the file _filename_. If the filename does not\nresolve to an absolute path, the file is searched for in the library\ndirectories listed in `$:`. If the optional _wrap_\nparameter is +true+, the loaded script will be executed\nunder an anonymous module, protecting the calling program's global\nnamespace. In no circumstance will any local variables in the loaded\nfile be propagated to the loading environment.\n
local_variables Kernel.local_variables()\nReturns the names of the current local variables.\n\n   fred = 1\n   for i in 1..10\n ...\n   end\n   local_variables   #=> [:fred, :i]\n
loop Kernel.loop()\nRepeatedly executes the block.\n\nIf no block is given, an enumerator is returned instead.\n\n   loop do\n     print "Input: "\n     line = gets\n     break if !line or line =~ /^qQ/\n ...\n   end\n\nStopIteration raised in the block breaks the loop.\n
p Kernel.p(*args)\nFor each object, directly writes _obj_.+inspect+ followed by a\nnewline to the program's standard output.\n\n   S = Struct.new(:name, :state)\n   s = S['dave', 'TX']\n   p s\n\n<em>produces:</em>\n<S name="dave", state="TX">\n
pp Kernel.pp(*objs)\nprints arguments in pretty form.\n\npp returns argument(s).\n
pretty_inspect Kernel.pretty_inspect()\nreturns a pretty printed object as a string.\n
print Kernel.print(*args)\nPrints each object in turn to `$stdout`. If the output\nfield separator (`$,`) is not +nil+, its\ncontents will appear between each field. If the output record\nseparator (`$\\`) is not +nil+, it will be\nappended to the output. If no arguments are given, prints\n`$_`. Objects that aren't strings will be converted by\ncalling their `to_s` method.\n\n   print "cat", [1,2,3], 99, "\\n"\n   $, = ", "\n   $\ = "\\n"\n   print "cat", [1,2,3], 99\n\n<em>produces:</em>\n\n   cat12399\n   cat, 1, 2, 3, 99\n
printf Kernel.printf(*args)\nEquivalent to:\n   io.write(sprintf(string, obj, ...)\nor\n   $stdout.write(sprintf(string, obj, ...)\n
proc Kernel.proc()\nEquivalent to `Proc.new`.\n
psych_y Kernel.psych_y(*objects)\n\n
putc Kernel.putc(p1)\n Equivalent to:\n\n   $stdout.putc(int)\n\nRefer to the documentation for IO#putc for important information regarding\nmulti-byte characters.\n
puts Kernel.puts(*args)\nEquivalent to\n\n    $stdout.puts(obj, ...)\n
raise Kernel.raise(*args)\nWith no arguments, raises the exception in `$!` or raises\na `RuntimeError` if `$!` is +nil+.\nWith a single +String+ argument, raises a\n+RuntimeError+ with the string as a message. Otherwise,\nthe first parameter should be the name of an +Exception+\nclass (or an object that returns an +Exception+ object when sent\nan +exception+ message). The optional second parameter sets the\nmessage associated with the exception, and the third parameter is an\narray of callback information. Exceptions are caught by the\n+rescue+ clause of `begin...end` blocks.\n\n   raise "Failed to create socket"\n   raise ArgumentError, "No parameters", caller\n
rand Kernel.rand(p1 = v1)\nIf <i>max</i> is +Range+, returns a pseudorandom number where\nrange.member(number) == true.\n\nOr else converts _max_ to an integer using max1 =\nmax`.to_i.abs`.\n\nThen if _max_ is +nil+ the result is zero, returns a pseudorandom floating\npoint number greater than or equal to 0.0 and less than 1.0.\n\nOtherwise, returns a pseudorandom integer greater than or equal to zero and\nless than max1.\n\n`Kernel::srand` may be used to ensure repeatable sequences of\nrandom numbers between different runs of the program. Ruby currently uses\na modified Mersenne Twister with a period of 2**19937-1.\n\n   srand 1234                 #=> 0\n   [ rand,  rand ]            #=> [0.191519450163469, 0.49766366626136]\n   [ rand(10), rand(1000) ]   #=> [6, 817]\n   srand 1234                 #=> 1234\n   [ rand,  rand ]            #=> [0.191519450163469, 0.49766366626136]\n
readline Kernel.readline(*args)\nEquivalent to `Kernel::gets`, except\n+readline+ raises +EOFError+ at end of file.\n
readlines Kernel.readlines(*args)\nReturns an array containing the lines returned by calling\n`Kernel.gets(<i>sep</i>)` until the end of file.\n
require_relative Kernel.require_relative(p1)\nRuby tries to load the library named _string_ relative to the requiring\nfile's path.  If the file's path cannot be determined a LoadError is raised.\nIf a file is loaded +true+ is returned and false otherwise.\n
scanf Kernel.scanf(format, &b)\nScans STDIN for data matching +format+.  See IO#scanf for details.\n\nSee Scanf for details on creating a format string.\n\nYou will need to require 'scanf' to use Kernel#scanf.\n
select Kernel.select(p1, p2 = v2, p3 = v3, p4 = v4)\nCalls select(2) system call.\nIt monitors given arrays of `IO` objects, waits one or more\nof `IO` objects ready for reading, are ready for writing,\nand have pending exceptions respectably, and returns an array that\ncontains arrays of those IO objects.  It will return `nil`\nif optional <i>timeout</i> value is given and no `IO` object\nis ready in <i>timeout</i> seconds.\n\n=== Parameters\nread_array:: an array of `IO` objects that wait until ready for read\nwrite_array:: an array of `IO` objects that wait until ready for write\nerror_array:: an array of `IO` objects that wait for exceptions\ntimeout:: a numeric value in second\n\n=== Example\n\n    rp, wp = IO.pipe\n    mesg = "ping "\n    100.times {\n      rs, ws, = IO.select([rp], [wp])\n      if r = rs[0]\n        ret = r.read(5)\n        print ret\n        case ret\n        when /ping/\n          mesg = "pong\\n"\n        when /pong/\n          mesg = "ping "\n        end\n      end\n      if w = ws[0]\n        w.write(mesg)\n      end\n    }\n\n<em>produces:</em>\n\n    ping pong\n    ping pong\n    ping pong\n    (snipped)\n    ping\n
set_trace_func Kernel.set_trace_func(p1)\nEstablishes _proc_ as the handler for tracing, or disables\ntracing if the parameter is +nil+. _proc_ takes up\nto six parameters: an event name, a filename, a line number, an\nobject id, a binding, and the name of a class. _proc_ is\ninvoked whenever an event occurs. Events are: `c-call`\n(call a C-language routine), `c-return` (return from a\nC-language routine), `call` (call a Ruby method),\n`class` (start a class or module definition),\n`end` (finish a class or module definition),\n`line` (execute code on a new line), `raise`\n(raise an exception), and `return` (return from a Ruby\nmethod). Tracing is disabled within the context of _proc_.\n\n    class Test\n    def test\n      a = 1\n      b = 2\n    end\n    end\n\n    set_trace_func proc { |event, file, line, id, binding, classname|\n       printf "%8s %s:%-2d %10s %8s\\n", event, file, line, id, classname\n    }\n    t = Test.new\n    t.test\n\n      line prog.rb:11               false\n    c-call prog.rb:11        new    Class\n    c-call prog.rb:11 initialize   Object\n  c-return prog.rb:11 initialize   Object\n  c-return prog.rb:11        new    Class\n      line prog.rb:12               false\n      call prog.rb:2        test     Test\n      line prog.rb:3        test     Test\n      line prog.rb:4        test     Test\n    return prog.rb:4        test     Test\n
sleep Kernel.sleep(*args)\nSuspends the current thread for _duration_ seconds (which may be any number,\nincluding a +Float+ with fractional seconds). Returns the actual number of\nseconds slept (rounded), which may be less than that asked for if another\nthread calls `Thread#run`. Called without an argument, sleep()\nwill sleep forever.\n\n   Time.new    #=> 2008-03-08 19:56:19 +0900\n   sleep 1.2   #=> 1\n   Time.new    #=> 2008-03-08 19:56:20 +0900\n   sleep 1.9   #=> 2\n   Time.new    #=> 2008-03-08 19:56:22 +0900\n
spawn Kernel.spawn(*args)\nspawn executes specified command and return its pid.\n\nThis method doesn't wait for end of the command.\nThe parent process should\nuse `Process.wait` to collect\nthe termination status of its child or\nuse `Process.detach` to register\ndisinterest in their status;\notherwise, the operating system may accumulate zombie processes.\n\nspawn has bunch of options to specify process attributes:\n\n  env: hash\n    name => val : set the environment variable\n    name => nil : unset the environment variable\n  command...:\n    commandline                 : command line string which is passed to\n    the standard shell\n    cmdname, arg1, ...          : command name and one or more arguments\n    (no shell)\n    [cmdname, argv0], arg1, ... : command name, argv[0] and zero or more\n    arguments (no shell)\n  options: hash\n    clearing environment variables:\n      :unsetenv_others => true   : clear environment variables except\n      specified by env\n      :unsetenv_others => false  : don't clear (default)\n    process group:\n      :pgroup => true or 0 : make a new process group\n      :pgroup => pgid      : join to specified process group\n      :pgroup => nil       : don't change the process group (default)\n    create new process group: Windows only\n      :new_pgroup => true  : the new process is the root process of a new\n      process group\n      :new_pgroup => false : don't create a new process group (default)\n    resource limit: resourcename is core, cpu, data, etc.  See\n    Process.setrlimit.\n      :rlimit_resourcename => limit\n      :rlimit_resourcename => [cur_limit, max_limit]\n    current directory:\n      :chdir => str\n    umask:\n      :umask => int\n    redirection:\n      key:\n        FD              : single file descriptor in child process\n        [FD, FD, ...]   : multiple file descriptor in child process\n      value:\n        FD                        : redirect to the file descriptor in\n        parent process\n        string                    : redirect to file with open(string,\n        "r" or "w")\n        [string]                  : redirect to file with open(string,\n        File::RDONLY)\n        [string, open_mode]       : redirect to file with open(string,\n        open_mode, 0644)\n        [string, open_mode, perm] : redirect to file with open(string,\n        open_mode, perm)\n        [:child, FD]              : redirect to the redirected file descriptor\n        :close                    : close the file descriptor in child process\n      FD is one of follows\n        :in     : the file descriptor 0 which is the standard input\n        :out    : the file descriptor 1 which is the standard output\n        :err    : the file descriptor 2 which is the standard error\n        integer : the file descriptor of specified the integer\n        io      : the file descriptor specified as io.fileno\n    file descriptor inheritance: close non-redirected non-standard fds (3,\n    4, 5, ...) or not\n      :close_others => false : inherit fds (default for system and exec)\n      :close_others => true  : don't inherit (default for spawn and IO.popen)\n\nIf a hash is given as +env+, the environment is\nupdated by +env+ before `exec(2)` in the child process.\nIf a pair in +env+ has nil as the value, the variable is deleted.\n set FOO as BAR and unset BAZ.\n  pid = spawn({"FOO"=>"BAR", "BAZ"=>nil}, command)\n\nIf a hash is given as +options+,\nit specifies\nprocess group,\ncreate new process group,\nresource limit,\ncurrent directory,\numask and\nredirects for the child process.\nAlso, it can be specified to clear environment variables.\n\nThe `:unsetenv_others` key in +options+ specifies\nto clear environment variables, other than specified by +env+.\n\n  pid = spawn(command, :unsetenv_others=>true) # no environment variable\n  pid = spawn({"FOO"=>"BAR"}, command, :unsetenv_others=>true) # FOO only\n\nThe `:pgroup` key in +options+ specifies a process group.\nThe corresponding value should be true, zero or positive integer.\ntrue and zero means the process should be a process leader of a new\nprocess group.\nOther values specifies a process group to be belongs.\n\n  pid = spawn(command, :pgroup=>true) # process leader\n  pid = spawn(command, :pgroup=>10) # belongs to the process group 10\n\nThe `:new_pgroup` key in +options+ specifies to pass\n+CREATE_NEW_PROCESS_GROUP+ flag to `CreateProcessW()` that is\nWindows API. This option is only for Windows.\ntrue means the new process is the root process of the new process group.\nThe new process has CTRL+C disabled. This flag is necessary for\n`Process.kill(:SIGINT, pid)` on the subprocess.\n:new_pgroup is false by default.\n\n  pid = spawn(command, :new_pgroup=>true)  # new process group\n  pid = spawn(command, :new_pgroup=>false) # same process group\n\nThe `:rlimit_`<em>foo</em> key specifies a resource limit.\n<em>foo</em> should be one of resource types such as `core`.\nThe corresponding value should be an integer or an array which have one or\ntwo integers: same as cur_limit and max_limit arguments for\nProcess.setrlimit.\n\n  cur, max = Process.getrlimit(:CORE)\n  pid = spawn(command, :rlimit_core=>[0,max]) # disable core temporary.\n  pid = spawn(command, :rlimit_core=>max) # enable core dump\n  pid = spawn(command, :rlimit_core=>0) # never dump core.\n\nThe `:chdir` key in +options+ specifies the current directory.\n\n  pid = spawn(command, :chdir=>"/var/tmp")\n\nThe `:umask` key in +options+ specifies the umask.\n\n  pid = spawn(command, :umask=>077)\n\nThe :in, :out, :err, a fixnum, an IO and an array key specifies a redirection.\nThe redirection maps a file descriptor in the child process.\n\nFor example, stderr can be merged into stdout as follows:\n\n  pid = spawn(command, :err=>:out)\n  pid = spawn(command, 2=>1)\n  pid = spawn(command, STDERR=>:out)\n  pid = spawn(command, STDERR=>STDOUT)\n\nThe hash keys specifies a file descriptor\nin the child process started by `spawn`.\n:err, 2 and STDERR specifies the standard error stream (stderr).\n\nThe hash values specifies a file descriptor\nin the parent process which invokes `spawn`.\n:out, 1 and STDOUT specifies the standard output stream (stdout).\n\nIn the above example,\nthe standard output in the child process is not specified.\nSo it is inherited from the parent process.\n\nThe standard input stream (stdin) can be specified by :in, 0 and STDIN.\n\nA filename can be specified as a hash value.\n\n  pid = spawn(command, :in=>"/dev/null") # read mode\n  pid = spawn(command, :out=>"/dev/null") # write mode\n  pid = spawn(command, :err=>"log") # write mode\n  pid = spawn(command, 3=>"/dev/null") # read mode\n\nFor stdout and stderr,\nit is opened in write mode.\nOtherwise read mode is used.\n\nFor specifying flags and permission of file creation explicitly,\nan array is used instead.\n\n  pid = spawn(command, :in=>["file"]) # read mode is assumed\n  pid = spawn(command, :in=>["file", "r"])\n  pid = spawn(command, :out=>["log", "w"]) # 0644 assumed\n  pid = spawn(command, :out=>["log", "w", 0600])\n  pid = spawn(command, :out=>["log", File::WRONLY|File::EXCL|File::CREAT,\n  0600])\n\nThe array specifies a filename, flags and permission.\nThe flags can be a string or an integer.\nIf the flags is omitted or nil, File::RDONLY is assumed.\nThe permission should be an integer.\nIf the permission is omitted or nil, 0644 is assumed.\n\nIf an array of IOs and integers are specified as a hash key,\nall the elements are redirected.\n stdout and stderr is redirected to log file.\n The file "log" is opened just once.\n  pid = spawn(command, [:out, :err]=>["log", "w"])\n\nAnother way to merge multiple file descriptors is [:child, fd].\n\[:child, fd] means the file descriptor in the child process.\nThis is different from fd.\nFor example, :err=>:out means redirecting child stderr to parent stdout.\nBut :err=>[:child, :out] means redirecting child stderr to child stdout.\nThey differs if stdout is redirected in the child process as follows.\n stdout and stderr is redirected to log file.\n The file "log" is opened just once.\n  pid = spawn(command, :out=>["log", "w"], :err=>[:child, :out])\n\n\[:child, :out] can be used to merge stderr into stdout in IO.popen.\nIn this case, IO.popen redirects stdout to a pipe in the child process\nand [:child, :out] refers the redirected stdout.\n\n  io = IO.popen(["sh", "-c", "echo out; echo err >&2", :err=>[:child, :out]])\n  p io.read #=> "out\\nerr\\n"\n\nspawn closes all non-standard unspecified descriptors by default.\nThe "standard" descriptors are 0, 1 and 2.\nThis behavior is specified by :close_others option.\n:close_others doesn't affect the standard descriptors which are\nclosed only if :close is specified explicitly.\n\n  pid = spawn(command, :close_others=>true)  # close 3,4,5,... (default)\n  pid = spawn(command, :close_others=>false) # don't close 3,4,5,...\n\n:close_others is true by default for spawn and IO.popen.\n\nSo IO.pipe and spawn can be used as IO.popen.\n similar to r = IO.popen(command)\n  r, w = IO.pipe\n  pid = spawn(command, :out=>w)   # r, w is closed in the child process.\n  w.close\n\n:close is specified as a hash value to close a fd individually.\n\n  f = open(foo)\n  system(command, f=>:close)        # don't inherit f.\n\nIf a file descriptor need to be inherited,\nio=>io can be used.\n valgrind has --log-fd option for log destination.\n log_w=>log_w indicates log_w.fileno inherits to child process.\n  log_r, log_w = IO.pipe\n  pid = spawn("valgrind", "--log-fd=#{log_w.fileno}", "echo", "a",\n  log_w=>log_w)\n  log_w.close\n  p log_r.read\n\nIt is also possible to exchange file descriptors.\n\n  pid = spawn(command, :out=>:err, :err=>:out)\n\nThe hash keys specify file descriptors in the child process.\nThe hash values specifies file descriptors in the parent process.\nSo the above specifies exchanging stdout and stderr.\nInternally, +spawn+ uses an extra file descriptor to resolve such cyclic\nfile descriptor mapping.\n\nSee `Kernel.exec` for the standard shell.\n
sprintf Kernel.sprintf(*args)\nReturns the string resulting from applying <i>format_string</i> to\nany additional arguments.  Within the format string, any characters\nother than format sequences are copied to the result.\n\nThe syntax of a format sequence is follows.\n\n  %[flags][width][.precision]type\n\nA format\nsequence consists of a percent sign, followed by optional flags,\nwidth, and precision indicators, then terminated with a field type\ncharacter.  The field type controls how the corresponding\n`sprintf` argument is to be interpreted, while the flags\nmodify that interpretation.\n\nThe field type characters are:\n\n    Field |  Integer Format\n    ------+--------------------------------------------------------------\n      b   | Convert argument as a binary number.\n          | Negative numbers will be displayed as a two's complement\n          | prefixed with `..1'.\n      B   | Equivalent to `b', but uses an uppercase 0B for prefix\n          | in the alternative format by #.\n      d   | Convert argument as a decimal number.\n      i   | Identical to `d'.\n      o   | Convert argument as an octal number.\n          | Negative numbers will be displayed as a two's complement\n          | prefixed with `..7'.\n      u   | Identical to `d'.\n      x   | Convert argument as a hexadecimal number.\n          | Negative numbers will be displayed as a two's complement\n          | prefixed with `..f' (representing an infinite string of\n          | leading 'ff's).\n      X   | Equivalent to `x', but uses uppercase letters.\n\n    Field |  Float Format\n    ------+--------------------------------------------------------------\n      e   | Convert floating point argument into exponential notation\n          | with one digit before the decimal point as [-]d.dddddde[+-]dd.\n          | The precision specifies the number of digits after the decimal\n          | point (defaulting to six).\n      E   | Equivalent to `e', but uses an uppercase E to indicate\n          | the exponent.\n      f   | Convert floating point argument as [-]ddd.dddddd,\n          | where the precision specifies the number of digits after\n          | the decimal point.\n      g   | Convert a floating point number using exponential form\n          | if the exponent is less than -4 or greater than or\n          | equal to the precision, or in dd.dddd form otherwise.\n          | The precision specifies the number of significant digits.\n      G   | Equivalent to `g', but use an uppercase `E' in exponent form.\n      a   | Convert floating point argument as [-]0xh.hhhhp[+-]dd,\n          | which is consisted from optional sign, "0x", fraction part\n          | as hexadecimal, "p", and exponential part as decimal.\n      A   | Equivalent to `a', but use uppercase `X' and `P'.\n\n    Field |  Other Format\n    ------+--------------------------------------------------------------\n      c   | Argument is the numeric code for a single character or\n          | a single character string itself.\n      p   | The valuing of argument.inspect.\n      s   | Argument is a string to be substituted.  If the format\n          | sequence contains a precision, at most that many characters\n          | will be copied.\n      %   | A percent sign itself will be displayed.  No argument taken.\n\nThe flags modifies the behavior of the formats.\nThe flag characters are:\n\n  Flag     | Applies to    | Meaning\n  ---------+---------------+-----------------------------------------\n  space    | bBdiouxX      | Leave a space at the start of\n           | aAeEfgG       | non-negative numbers.\n           | (numeric fmt) | For `o', `x', `X', `b' and `B', use\n           |               | a minus sign with absolute value for\n           |               | negative values.\n  ---------+---------------+-----------------------------------------\n  (digit)$ | all           | Specifies the absolute argument number\n           |               | for this field.  Absolute and relative\n           |               | argument numbers cannot be mixed in a\n           |               | sprintf string.\n  ---------+---------------+-----------------------------------------\n       | bBoxX         | Use an alternative format.\n           | aAeEfgG       | For the conversions `o', increase the precision\n           |               | until the first digit will be `0' if\n           |               | it is not formatted as complements.\n           |               | For the conversions `x', `X', `b' and `B'\n           |               | on non-zero, prefix the result with ``0x'',\n           |               | ``0X'', ``0b'' and ``0B'', respectively.\n           |               | For `a', `A', `e', `E', `f', `g', and 'G',\n           |               | force a decimal point to be added,\n           |               | even if no digits follow.\n           |               | For `g' and 'G', do not remove trailing zeros.\n  ---------+---------------+-----------------------------------------\n  +        | bBdiouxX      | Add a leading plus sign to non-negative\n           | aAeEfgG       | numbers.\n           | (numeric fmt) | For `o', `x', `X', `b' and `B', use\n           |               | a minus sign with absolute value for\n           |               | negative values.\n  ---------+---------------+-----------------------------------------\n  -        | all           | Left-justify the result of this conversion.\n  ---------+---------------+-----------------------------------------\n  0 (zero) | bBdiouxX      | Pad with zeros, not spaces.\n           | aAeEfgG       | For `o', `x', `X', `b' and `B', radix-1\n           | (numeric fmt) | is used for negative numbers formatted as\n           |               | complements.\n  ---------+---------------+-----------------------------------------\n  *        | all           | Use the next argument as the field width.\n           |               | If negative, left-justify the result. If the\n           |               | asterisk is followed by a number and a dollar\n           |               | sign, use the indicated argument as the width.\n\nExamples of flags:\n `+' and space flag specifies the sign of non-negative numbers.\n sprintf("%d", 123)  #=> "123"\n sprintf("%+d", 123) #=> "+123"\n sprintf("% d", 123) #=> " 123"\n `#' flag for `o' increases number of digits to show `0'.\n `+' and space flag changes format of negative numbers.\n sprintf("%o", 123)   #=> "173"\n sprintf("%#o", 123)  #=> "0173"\n sprintf("%+o", -123) #=> "-173"\n sprintf("%o", -123)  #=> "..7605"\n sprintf("%#o", -123) #=> "..7605"\n `#' flag for `x' add a prefix `0x' for non-zero numbers.\n `+' and space flag disables complements for negative numbers.\n sprintf("%x", 123)   #=> "7b"\n sprintf("%#x", 123)  #=> "0x7b"\n sprintf("%+x", -123) #=> "-7b"\n sprintf("%x", -123)  #=> "..f85"\n sprintf("%#x", -123) #=> "0x..f85"\n sprintf("%#x", 0)    #=> "0"\n `#' for `X' uses the prefix `0X'.\n sprintf("%X", 123)  #=> "7B"\n sprintf("%#X", 123) #=> "0X7B"\n `#' flag for `b' add a prefix `0b' for non-zero numbers.\n `+' and space flag disables complements for negative numbers.\n sprintf("%b", 123)   #=> "1111011"\n sprintf("%#b", 123)  #=> "0b1111011"\n sprintf("%+b", -123) #=> "-1111011"\n sprintf("%b", -123)  #=> "..10000101"\n sprintf("%#b", -123) #=> "0b..10000101"\n sprintf("%#b", 0)    #=> "0"\n `#' for `B' uses the prefix `0B'.\n sprintf("%B", 123)  #=> "1111011"\n sprintf("%#B", 123) #=> "0B1111011"\n `#' for `e' forces to show the decimal point.\n sprintf("%.0e", 1)  #=> "1e+00"\n sprintf("%#.0e", 1) #=> "1.e+00"\n `#' for `f' forces to show the decimal point.\n sprintf("%.0f", 1234)  #=> "1234"\n sprintf("%#.0f", 1234) #=> "1234."\n `#' for `g' forces to show the decimal point.\n It also disables stripping lowest zeros.\n sprintf("%g", 123.4)   #=> "123.4"\n sprintf("%#g", 123.4)  #=> "123.400"\n sprintf("%g", 123456)  #=> "123456"\n sprintf("%#g", 123456) #=> "123456."\n\nThe field width is an optional integer, followed optionally by a\nperiod and a precision.  The width specifies the minimum number of\ncharacters that will be written to the result for this field.\n\nExamples of width:\n padding is done by spaces,       width=20\n 0 or radix-1.             <------------------>\n sprintf("%20d", 123)   #=> "                 123"\n sprintf("%+20d", 123)  #=> "                +123"\n sprintf("%020d", 123)  #=> "00000000000000000123"\n sprintf("%+020d", 123) #=> "+0000000000000000123"\n sprintf("% 020d", 123) #=> " 0000000000000000123"\n sprintf("%-20d", 123)  #=> "123                 "\n sprintf("%-+20d", 123) #=> "+123                "\n sprintf("%- 20d", 123) #=> " 123                "\n sprintf("%020x", -123) #=> "..ffffffffffffffff85"\n\nFor\nnumeric fields, the precision controls the number of decimal places\ndisplayed.  For string fields, the precision determines the maximum\nnumber of characters to be copied from the string.  (Thus, the format\nsequence `%10.10s` will always contribute exactly ten\ncharacters to the result.)\n\nExamples of precisions:\n precision for `d', 'o', 'x' and 'b' is\n minimum number of digits               <------>\n sprintf("%20.8d", 123)  #=> "            00000123"\n sprintf("%20.8o", 123)  #=> "            00000173"\n sprintf("%20.8x", 123)  #=> "            0000007b"\n sprintf("%20.8b", 123)  #=> "            01111011"\n sprintf("%20.8d", -123) #=> "           -00000123"\n sprintf("%20.8o", -123) #=> "            ..777605"\n sprintf("%20.8x", -123) #=> "            ..ffff85"\n sprintf("%20.8b", -11)  #=> "            ..110101"\n "0x" and "0b" for `#x' and `#b' is not counted for\n precision but "0" for `#o' is counted.  <------>\n sprintf("%#20.8d", 123)  #=> "            00000123"\n sprintf("%#20.8o", 123)  #=> "            00000173"\n sprintf("%#20.8x", 123)  #=> "          0x0000007b"\n sprintf("%#20.8b", 123)  #=> "          0b01111011"\n sprintf("%#20.8d", -123) #=> "           -00000123"\n sprintf("%#20.8o", -123) #=> "            ..777605"\n sprintf("%#20.8x", -123) #=> "          0x..ffff85"\n sprintf("%#20.8b", -11)  #=> "          0b..110101"\n precision for `e' is number of\n digits after the decimal point           <------>\n sprintf("%20.8e", 1234.56789) #=> "      1.23456789e+03"\n precision for `f' is number of\n digits after the decimal point               <------>\n sprintf("%20.8f", 1234.56789) #=> "       1234.56789000"\n precision for `g' is number of\n significant digits                          <------->\n sprintf("%20.8g", 1234.56789) #=> "           1234.5679"\n                                         <------->\n sprintf("%20.8g", 123456789)  #=> "       1.2345679e+08"\n precision for `s' is\n maximum number of characters                    <------>\n sprintf("%20.8s", "string test") #=> "            string t"\n\nExamples:\n\n   sprintf("%d %04x", 123, 123)               #=> "123 007b"\n   sprintf("%08b '%4s'", 123, 123)            #=> "01111011 ' 123'"\n   sprintf("%1$*2$s %2$d %1$s", "hello", 8)   #=> "   hello 8 hello"\n   sprintf("%1$*2$s %2$d", "hello", -8)       #=> "hello    -8"\n   sprintf("%+g:% g:%-g", 1.23, 1.23, 1.23)   #=> "+1.23: 1.23:1.23"\n   sprintf("%u", -123)                        #=> "-123"\n\nFor more complex formatting, Ruby supports a reference by name.\n%<name>s style uses format style, but %{name} style doesn't.\n\nExapmles:\n  sprintf("%<foo>d : %<bar>f", { :foo => 1, :bar => 2 })\n=> 1 : 2.000000\n  sprintf("%{foo}f", { :foo => 1 })\n => "1f"\n
srand Kernel.srand(p1 = v1)\nSeeds the pseudorandom number generator to the value of\n<i>number</i>. If <i>number</i> is omitted,\nseeds the generator using a combination of the time, the\nprocess id, and a sequence number. (This is also the behavior if\n`Kernel::rand` is called without previously calling\n`srand`, but without the sequence.) By setting the seed\nto a known value, scripts can be made deterministic during testing.\nThe previous seed value is returned. Also see `Kernel::rand`.\n
sub Kernel.sub(*args)\nEquivalent to `$_.sub(<i>args</i>)`, except that\n`$_` will be updated if substitution occurs.\nAvailable only when -p/-n command line option specified.\n
syscall Kernel.syscall(*args)\n Calls the operating system function identified by _num_ and\n returns the result of the function or raises SystemCallError if\n it failed.\n\n Arguments for the function can follow _num_. They must be either\n +String+ objects or +Integer+ objects. A +String+ object is passed\n as a pointer to the byte sequence. An +Integer+ object is passed\n as an integer whose bit size is same as a pointer.\n Up to nine parameters may be passed (14 on the Atari-ST).\n\n The function identified by _num_ is system\n dependent. On some Unix systems, the numbers may be obtained from a\n header file called `syscall.h`.\n\n    syscall 4, 1, "hello\\n", 6   # '4' is write(2) on our box\n\n <em>produces:</em>\n\n    hello\n\n Calling +syscall+ on a platform which does not have any way to\n an arbitrary system function just fails with NotImplementedError.\n\nNote::\n  +syscall+ is essentially unsafe and unportable. Feel free to shoot your foot.\n  DL (Fiddle) library is preferred for safer and a bit more portable\n  programming.\n
system Kernel.system(*args)\nExecutes _command..._ in a subshell.\n_command..._ is one of following forms.\n\n  commandline                 : command line string which is passed to the\n  standard shell\n  cmdname, arg1, ...          : command name and one or more arguments\n  (no shell)\n  [cmdname, argv0], arg1, ... : command name, argv[0] and zero or more\n  arguments (no shell)\n\nsystem returns +true+ if the command gives zero exit status,\n+false+ for non zero exit status.\nReturns +nil+ if command execution fails.\nAn error status is available in `$?`.\nThe arguments are processed in the same way as\nfor `Kernel.spawn`.\n\nThe hash arguments, env and options, are same as\n`exec` and `spawn`.\nSee `Kernel.spawn` for details.\n\n   system("echo *")\n   system("echo", "*")\n\n<em>produces:</em>\n\n   config.h main.rb\n   *\n\nSee `Kernel.exec` for the standard shell.\n
test Kernel.test(*args)\n Uses the integer <i>aCmd</i> to perform various tests on\n <i>file1</i> (first table below) or on <i>file1</i> and\n <i>file2</i> (second table).\n\n File tests on a single file:\n\n   Test   Returns   Meaning\n   "A"  | Time    | Last access time for file1\n   "b"  | boolean | True if file1 is a block device\n   "c"  | boolean | True if file1 is a character device\n   "C"  | Time    | Last change time for file1\n   "d"  | boolean | True if file1 exists and is a directory\n   "e"  | boolean | True if file1 exists\n   "f"  | boolean | True if file1 exists and is a regular file\n   "g"  | boolean | True if file1 has the \CF{setgid} bit\n        |         | set (false under NT)\n   "G"  | boolean | True if file1 exists and has a group\n        |         | ownership equal to the caller's group\n   "k"  | boolean | True if file1 exists and has the sticky bit set\n   "l"  | boolean | True if file1 exists and is a symbolic link\n   "M"  | Time    | Last modification time for file1\n   "o"  | boolean | True if file1 exists and is owned by\n        |         | the caller's effective uid\n   "O"  | boolean | True if file1 exists and is owned by\n        |         | the caller's real uid\n   "p"  | boolean | True if file1 exists and is a fifo\n   "r"  | boolean | True if file1 is readable by the effective\n        |         | uid/gid of the caller\n   "R"  | boolean | True if file is readable by the real\n        |         | uid/gid of the caller\n   "s"  | int/nil | If file1 has nonzero size, return the size,\n        |         | otherwise return nil\n   "S"  | boolean | True if file1 exists and is a socket\n   "u"  | boolean | True if file1 has the setuid bit set\n   "w"  | boolean | True if file1 exists and is writable by\n        |         | the effective uid/gid\n   "W"  | boolean | True if file1 exists and is writable by\n        |         | the real uid/gid\n   "x"  | boolean | True if file1 exists and is executable by\n        |         | the effective uid/gid\n   "X"  | boolean | True if file1 exists and is executable by\n        |         | the real uid/gid\n   "z"  | boolean | True if file1 exists and has a zero length\n\nTests that take two files:\n\n   "-"  | boolean | True if file1 and file2 are identical\n   "="  | boolean | True if the modification times of file1\n        |         | and file2 are equal\n   "<"  | boolean | True if the modification time of file1\n        |         | is prior to that of file2\n   ">"  | boolean | True if the modification time of file1\n        |         | is after that of file2\n
throw Kernel.throw(p1, p2 = v2)\nTransfers control to the end of the active +catch+ block\nwaiting for _tag_. Raises +ArgumentError+ if there\nis no +catch+ block for the _tag_. The optional second\nparameter supplies a return value for the +catch+ block,\nwhich otherwise defaults to +nil+. For examples, see\n`Kernel::catch`.\n
trace_var Kernel.trace_var(p1, p2 = v2)\nControls tracing of assignments to global variables. The parameter\n+symbol_ identifies the variable (as either a string name or a\nsymbol identifier). _cmd_ (which may be a string or a\n+Proc+ object) or block is executed whenever the variable\nis assigned. The block or +Proc+ object receives the\nvariable's new value as a parameter. Also see\n`Kernel::untrace_var`.\n\n   trace_var :$_, proc {|v| puts "$_ is now '#{v}'" }\n   $_ = "hello"\n   $_ = ' there'\n\n<em>produces:</em>\n\n   $_ is now 'hello'\n   $_ is now ' there'\n
trap Kernel.trap(*args)\nSpecifies the handling of signals. The first parameter is a signal\nname (a string such as ``SIGALRM'', ``SIGUSR1'', and so on) or a\nsignal number. The characters ``SIG'' may be omitted from the\nsignal name. The command or block specifies code to be run when the\nsignal is raised.\nIf the command is the string ``IGNORE'' or ``SIG_IGN'', the signal\nwill be ignored.\nIf the command is ``DEFAULT'' or ``SIG_DFL'', the Ruby's default handler\nwill be invoked.\nIf the command is ``EXIT'', the script will be terminated by the signal.\nIf the command is ``SYSTEM_DEFAULT'', the operating system's default\nhandler will be invoked.\nOtherwise, the given command or block will be run.\nThe special signal name ``EXIT'' or signal number zero will be\ninvoked just prior to program termination.\ntrap returns the previous handler for the given signal.\n\n    Signal.trap(0, proc { puts "Terminating: #{$$}" })\n    Signal.trap("CLD")  { puts "Child died" }\n    fork && Process.wait\n\nproduces:\n    Terminating: 27461\n    Child died\n    Terminating: 27460\n
untrace_var Kernel.untrace_var(p1, p2 = v2)\nRemoves tracing for the specified command on the given global\nvariable and returns +nil+. If no command is specified,\nremoves all tracing for that variable and returns an array\ncontaining the commands actually removed.\n
warn Kernel.warn(p1)\nDisplay the given message (followed by a newline) on STDERR unless\nwarnings are disabled (for example with the `-W0` flag).\n
dump Marshal.dump(p1, p2 = v2, p3 = v3)\nSerializes obj and all descendant objects. If anIO is\nspecified, the serialized data will be written to it, otherwise the\ndata will be returned as a String. If limit is specified, the\ntraversal of subobjects will be limited to that depth. If limit is\nnegative, no checking of depth will be performed.\n\n    class Klass\n      def initialize(str)\n        @str = str\n      end\n      def say_hello\n        @str\n      end\n    end\n\n(produces no output)\n\n    o = Klass.new("hello\\n")\n    data = Marshal.dump(o)\n    obj = Marshal.load(data)\n    obj.say_hello  #=> "hello\\n"\n\nMarshal can't dump following objects:\n* anonymous Class/Module.\n* objects which related to its system (ex: Dir, File::Stat, IO, File, Socket\n  and so on)\n* an instance of MatchData, Data, Method, UnboundMethod, Proc, Thread,\n  ThreadGroup, Continuation\n* objects which defines singleton methods\n
load Marshal.load(p1, p2 = v2)\nReturns the result of converting the serialized data in source into a\nRuby object (possibly with associated subordinate objects). source\nmay be either an instance of IO or an object that responds to\nto_str. If proc is specified, it will be passed each object as it\nis deserialized.\n
restore Marshal.restore(p1, p2 = v2)\nReturns the result of converting the serialized data in source into a\nRuby object (possibly with associated subordinate objects). source\nmay be either an instance of IO or an object that responds to\nto_str. If proc is specified, it will be passed each object as it\nis deserialized.\n
all? Enumerable.all?()\nPasses each element of the collection to the given block. The method\nreturns `true` if the block never returns\n`false` or `nil`. If the block is not given,\nRuby adds an implicit block of `{|obj| obj}` (that is\n`all?` will return `true` only if none of the\ncollection members are `false` or `nil`.)\n\n   %w{ant bear cat}.all? {|word| word.length >= 3}   #=> true\n   %w{ant bear cat}.all? {|word| word.length >= 4}   #=> false\n   [ nil, true, 99 ].all?                            #=> false\n
any? Enumerable.any?()\nPasses each element of the collection to the given block. The method\nreturns `true` if the block ever returns a value other\nthan `false` or `nil`. If the block is not\ngiven, Ruby adds an implicit block of `{|obj| obj}` (that\nis `any?` will return `true` if at least one\nof the collection members is not `false` or\n`nil`.\n\n   %w{ant bear cat}.any? {|word| word.length >= 3}   #=> true\n   %w{ant bear cat}.any? {|word| word.length >= 4}   #=> true\n   [ nil, true, 99 ].any?                            #=> true\n
chunk Enumerable.chunk(p1 = v1)\nCreates an enumerator for each chunked elements.\nThe consecutive elements which have same block value are chunked.\n\nThe result enumerator yields the block value and an array of chunked elements.\nSo "each" method can be called as follows.\n\n  enum.chunk {|elt| key }.each {|key, ary| ... }\n  enum.chunk(initial_state) {|elt, state| key }.each {|key, ary| ... }\n\nFor example, consecutive even numbers and odd numbers can be\nsplitted as follows.\n\n  [3,1,4,1,5,9,2,6,5,3,5].chunk {|n|\n    n.even?\n  }.each {|even, ary|\n    p [even, ary]\n  }\n=> [false, [3, 1]]\n   [true, [4]]\n   [false, [1, 5, 9]]\n   [true, [2, 6]]\n   [false, [5, 3, 5]]\n\nThis method is especially useful for sorted series of elements.\nThe following example counts words for each initial letter.\n\n  open("/usr/share/dict/words", "r:iso-8859-1") {|f|\n    f.chunk {|line| line.ord }.each {|ch, lines| p [ch.chr, lines.length] }\n  }\n=> ["\\n", 1]\n   ["A", 1327]\n   ["B", 1372]\n   ["C", 1507]\n   ["D", 791]\n   ...\n\nThe following key values has special meaning:\n- nil and :_separator specifies that the elements are dropped.\n- :_alone specifies that the element should be chunked as a singleton.\nOther symbols which begins an underscore are reserved.\n\nnil and :_separator can be used to ignore some elements.\nFor example, the sequence of hyphens in svn log can be eliminated as follows.\n\n  sep = "-"*72 + "\\n"\n  IO.popen("svn log README") {|f|\n    f.chunk {|line|\n      line != sep || nil\n    }.each {|_, lines|\n      pp lines\n    }\n  }\n=> ["r20018 | knu | 2008-10-29 13:20:42 +0900 (Wed, 29 Oct 2008) | 2 lines\\n",\n    "\\n",\n    "* README, README.ja: Update the portability section.\\n",\n    "\\n"]\n   ["r16725 | knu | 2008-05-31 23:34:23 +0900 (Sat, 31 May 2008) | 2 lines\\n",\n    "\\n",\n    "* README, README.ja: Add a note about default C flags.\\n",\n    "\\n"]\n   ...\n\nparagraphs separated by empty lines can be parsed as follows.\n\n  File.foreach("README").chunk {|line|\n    /\A\s*\z/ !~ line || nil\n  }.each {|_, lines|\n    pp lines\n  }\n\n:_alone can be used to pass through bunch of elements.\nFor example, sort consecutive lines formed as Foo#bar and\npass other lines, chunk can be used as follows.\n\n  pat = /\A[A-Z][A-Za-z0-9_]+\#/\n  open(filename) {|f|\n    f.chunk {|line| pat =~ line ? $& : :_alone }.each {|key, lines|\n      if key != :_alone\n        print lines.sort.join('')\n      else\n        print lines.join('')\n      end\n    }\n  }\n\nIf the block needs to maintain state over multiple elements,\n_initial_state_ argument can be used.\nIf non-nil value is given,\nit is duplicated for each "each" method invocation of the enumerator.\nThe duplicated object is passed to 2nd argument of the block for "chunk"\nmethod.\n
collect Enumerable.collect()\nReturns a new array with the results of running <em>block</em> once\nfor every element in <i>enum</i>.\n\nIf no block is given, an enumerator is returned instead.\n\n   (1..4).collect {|i| i*i }   #=> [1, 4, 9, 16]\n   (1..4).collect { "cat"  }   #=> ["cat", "cat", "cat", "cat"]\n
collect_concat Enumerable.collect_concat()\nReturns a new array with the concatenated results of running\n<em>block</em> once for every element in <i>enum</i>.\n\nIf no block is given, an enumerator is returned instead.\n\n   [[1,2],[3,4]].flat_map {|i| i }   #=> [1, 2, 3, 4]\n
count Enumerable.count(p1)\nReturns the number of items in <i>enum</i>, where #size is called\nif it responds to it, otherwise the items are counted through\nenumeration.  If an argument is given, counts the number of items\nin <i>enum</i>, for which equals to <i>item</i>.  If a block is\ngiven, counts the number of elements yielding a true value.\n\n   ary = [1, 2, 4, 2]\n   ary.count             #=> 4\n   ary.count(2)          #=> 2\n   ary.count{|x|x%2==0}  #=> 3\n
cycle Enumerable.cycle(p1 = v1)\nCalls <i>block</i> for each element of <i>enum</i> repeatedly _n_\ntimes or forever if none or +nil+ is given.  If a non-positive\nnumber is given or the collection is empty, does nothing.  Returns\n+nil+ if the loop has finished without getting interrupted.\n\nEnumerable#cycle saves elements in an internal array so changes\nto <i>enum</i> after the first pass have no effect.\n\nIf no block is given, an enumerator is returned instead.\n\n   a = ["a", "b", "c"]\n   a.cycle {|x| puts x }  # print, a, b, c, a, b, c,.. forever.\n   a.cycle(2) {|x| puts x }  # print, a, b, c, a, b, c.\n
detect Enumerable.detect(p1 = v1)\nPasses each entry in <i>enum</i> to <em>block</em>. Returns the\nfirst for which <em>block</em> is not false.  If no\nobject matches, calls <i>ifnone</i> and returns its result when it\nis specified, or returns `nil` otherwise.\n\nIf no block is given, an enumerator is returned instead.\n\n   (1..10).detect  {|i| i % 5 == 0 and i % 7 == 0 }   #=> nil\n   (1..100).detect {|i| i % 5 == 0 and i % 7 == 0 }   #=> 35\n
drop Enumerable.drop(p1)\nDrops first n elements from <i>enum</i>, and returns rest elements\nin an array.\n\n   a = [1, 2, 3, 4, 5, 0]\n   a.drop(3)             #=> [4, 5, 0]\n
drop_while Enumerable.drop_while()\nDrops elements up to, but not including, the first element for\nwhich the block returns +nil+ or +false+ and returns an array\ncontaining the remaining elements.\n\nIf no block is given, an enumerator is returned instead.\n\n   a = [1, 2, 3, 4, 5, 0]\n   a.drop_while {|i| i < 3 }   #=> [3, 4, 5, 0]\n
each_cons Enumerable.each_cons(p1)\nIterates the given block for each array of consecutive <n>\nelements.  If no block is given, returns an enumerator.\n\ne.g.:\n    (1..10).each_cons(3) {|a| p a}\n outputs below\n    [1, 2, 3]\n    [2, 3, 4]\n    [3, 4, 5]\n    [4, 5, 6]\n    [5, 6, 7]\n    [6, 7, 8]\n    [7, 8, 9]\n    [8, 9, 10]\n
each_entry Enumerable.each_entry(*args)\nCalls <i>block</i> once for each element in +self+, passing that\nelement as a parameter, converting multiple values from yield to an\narray.\n\nIf no block is given, an enumerator is returned instead.\n\n   class Foo\n     include Enumerable\n     def each\n       yield 1\n       yield 1,2\n       yield\n     end\n   end\n   Foo.new.each_entry{|o| p o }\n\nproduces:\n\n   1\n   [1, 2]\n   nil\n
each_slice Enumerable.each_slice(p1)\nIterates the given block for each slice of <n> elements.  If no\nblock is given, returns an enumerator.\n\ne.g.:\n    (1..10).each_slice(3) {|a| p a}\n outputs below\n    [1, 2, 3]\n    [4, 5, 6]\n    [7, 8, 9]\n    [10]\n
each_with_index Enumerable.each_with_index(*args)\nCalls <em>block</em> with two arguments, the item and its index,\nfor each item in <i>enum</i>.  Given arguments are passed through\nto #each().\n\nIf no block is given, an enumerator is returned instead.\n\n   hash = Hash.new\n   %w(cat dog wombat).each_with_index {|item, index|\n     hash[item] = index\n   }\n   hash   #=> {"cat"=>0, "dog"=>1, "wombat"=>2}\n
each_with_object Enumerable.each_with_object(p1)\nIterates the given block for each element with an arbitrary\nobject given, and returns the initially given object.\n\nIf no block is given, returns an enumerator.\n\ne.g.:\n    evens = (1..10).each_with_object([]) {|i, a| a << i*2 }\n=> [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n
entries Enumerable.entries(*args)\nReturns an array containing the items in <i>enum</i>.\n\n   (1..7).to_a                       #=> [1, 2, 3, 4, 5, 6, 7]\n   { 'a'=>1, 'b'=>2, 'c'=>3 }.to_a   #=> [["a", 1], ["b", 2], ["c", 3]]\n
find Enumerable.find(p1 = v1)\nPasses each entry in <i>enum</i> to <em>block</em>. Returns the\nfirst for which <em>block</em> is not false.  If no\nobject matches, calls <i>ifnone</i> and returns its result when it\nis specified, or returns `nil` otherwise.\n\nIf no block is given, an enumerator is returned instead.\n\n   (1..10).detect  {|i| i % 5 == 0 and i % 7 == 0 }   #=> nil\n   (1..100).detect {|i| i % 5 == 0 and i % 7 == 0 }   #=> 35\n
find_all Enumerable.find_all()\nReturns an array containing all elements of <i>enum</i> for which\n<em>block</em> is not `false` (see also\n`Enumerable#reject`).\n\nIf no block is given, an enumerator is returned instead.\n\n   (1..10).find_all {|i|  i % 3 == 0 }   #=> [3, 6, 9]\n
find_index Enumerable.find_index(p1)\nCompares each entry in <i>enum</i> with <em>value</em> or passes\nto <em>block</em>.  Returns the index for the first for which the\nevaluated value is non-false.  If no object matches, returns\n`nil`\n\nIf neither block nor argument is given, an enumerator is returned instead.\n\n   (1..10).find_index  {|i| i % 5 == 0 and i % 7 == 0 }   #=> nil\n   (1..100).find_index {|i| i % 5 == 0 and i % 7 == 0 }   #=> 34\n   (1..100).find_index(50)                                #=> 49\n
first Enumerable.first(p1 = v1)\nReturns the first element, or the first +n+ elements, of the enumerable.\nIf the enumerable is empty, the first form returns `nil`, and the\nsecond form returns an empty array.\n\n  %w[foo bar baz].first     #=> "foo"\n  %w[foo bar baz].first(2)  #=> ["foo", "bar"]\n  %w[foo bar baz].first(10) #=> ["foo", "bar", "baz"]\n  [].first                  #=> nil\n
flat_map Enumerable.flat_map()\nReturns a new array with the concatenated results of running\n<em>block</em> once for every element in <i>enum</i>.\n\nIf no block is given, an enumerator is returned instead.\n\n   [[1,2],[3,4]].flat_map {|i| i }   #=> [1, 2, 3, 4]\n
grep Enumerable.grep(p1)\nReturns an array of every element in <i>enum</i> for which\n`Pattern === element`. If the optional <em>block</em> is\nsupplied, each matching element is passed to it, and the block's\nresult is stored in the output array.\n\n   (1..100).grep 38..44   #=> [38, 39, 40, 41, 42, 43, 44]\n   c = IO.constants\n   c.grep(/SEEK/)         #=> [:SEEK_SET, :SEEK_CUR, :SEEK_END]\n   res = c.grep(/SEEK/) {|v| IO.const_get(v) }\n   res                    #=> [0, 1, 2]\n
group_by Enumerable.group_by()\nReturns a hash, which keys are evaluated result from the\nblock, and values are arrays of elements in <i>enum</i>\ncorresponding to the key.\n\nIf no block is given, an enumerator is returned instead.\n\n   (1..6).group_by {|i| i%3}   #=> {0=>[3, 6], 1=>[1, 4], 2=>[2, 5]}\n
include? Enumerable.include?(p1)\nReturns `true` if any member of <i>enum</i> equals\n<i>obj</i>. Equality is tested using `==`.\n\n   IO.constants.include? :SEEK_SET          #=> true\n   IO.constants.include? :SEEK_NO_FURTHER   #=> false\n
inject Enumerable.inject(p1 = v1, p2 = v2)\nCombines all elements of <i>enum</i> by applying a binary\noperation, specified by a block or a symbol that names a\nmethod or operator.\n\nIf you specify a block, then for each element in <i>enum</i>\nthe block is passed an accumulator value (<i>memo</i>) and the element.\nIf you specify a symbol instead, then each element in the collection\nwill be passed to the named method of <i>memo</i>.\nIn either case, the result becomes the new value for <i>memo</i>.\nAt the end of the iteration, the final value of <i>memo</i> is the\nreturn value for the method.\n\nIf you do not explicitly specify an <i>initial</i> value for <i>memo</i>,\nthen uses the first element of collection is used as the initial value\nof <i>memo</i>.\n\nExamples:\n Sum some numbers\n   (5..10).reduce(:+)                            #=> 45\n Same using a block and inject\n   (5..10).inject {|sum, n| sum + n }            #=> 45\n Multiply some numbers\n   (5..10).reduce(1, :*)                         #=> 151200\n Same using a block\n   (5..10).inject(1) {|product, n| product * n } #=> 151200\n find the longest word\n   longest = %w{ cat sheep bear }.inject do |memo,word|\n      memo.length > word.length ? memo : word\n   end\n   longest                                       #=> "sheep"\n
map Enumerable.map()\nReturns a new array with the results of running <em>block</em> once\nfor every element in <i>enum</i>.\n\nIf no block is given, an enumerator is returned instead.\n\n   (1..4).collect {|i| i*i }   #=> [1, 4, 9, 16]\n   (1..4).collect { "cat"  }   #=> ["cat", "cat", "cat", "cat"]\n
max Enumerable.max()\nReturns the object in _enum_ with the maximum value. The\nfirst form assumes all objects implement `Comparable`;\nthe second uses the block to return <em>a <=> b</em>.\n\n   a = %w(albatross dog horse)\n   a.max                                  #=> "horse"\n   a.max {|a,b| a.length <=> b.length }   #=> "albatross"\n
max_by Enumerable.max_by()\nReturns the object in <i>enum</i> that gives the maximum\nvalue from the given block.\n\nIf no block is given, an enumerator is returned instead.\n\n   a = %w(albatross dog horse)\n   a.max_by {|x| x.length }   #=> "albatross"\n
member? Enumerable.member?(p1)\nReturns `true` if any member of <i>enum</i> equals\n<i>obj</i>. Equality is tested using `==`.\n\n   IO.constants.include? :SEEK_SET          #=> true\n   IO.constants.include? :SEEK_NO_FURTHER   #=> false\n
min Enumerable.min()\nReturns the object in <i>enum</i> with the minimum value. The\nfirst form assumes all objects implement `Comparable`;\nthe second uses the block to return <em>a <=> b</em>.\n\n   a = %w(albatross dog horse)\n   a.min                                  #=> "albatross"\n   a.min {|a,b| a.length <=> b.length }   #=> "dog"\n
min_by Enumerable.min_by()\nReturns the object in <i>enum</i> that gives the minimum\nvalue from the given block.\n\nIf no block is given, an enumerator is returned instead.\n\n   a = %w(albatross dog horse)\n   a.min_by {|x| x.length }   #=> "dog"\n
minmax Enumerable.minmax()\nReturns two elements array which contains the minimum and the\nmaximum value in the enumerable.  The first form assumes all\nobjects implement `Comparable`; the second uses the\nblock to return <em>a <=> b</em>.\n\n   a = %w(albatross dog horse)\n   a.minmax                                  #=> ["albatross", "horse"]\n   a.minmax {|a,b| a.length <=> b.length }   #=> ["dog", "albatross"]\n
minmax_by Enumerable.minmax_by()\nReturns two elements array array containing the objects in\n<i>enum</i> that gives the minimum and maximum values respectively\nfrom the given block.\n\nIf no block is given, an enumerator is returned instead.\n\n   a = %w(albatross dog horse)\n   a.minmax_by {|x| x.length }   #=> ["dog", "albatross"]\n
none? Enumerable.none?()\nPasses each element of the collection to the given block. The method\nreturns `true` if the block never returns `true`\nfor all elements. If the block is not given, `none?` will return\n`true` only if none of the collection members is true.\n\n   %w{ant bear cat}.none? {|word| word.length == 5}  #=> true\n   %w{ant bear cat}.none? {|word| word.length >= 4}  #=> false\n   [].none?                                          #=> true\n   [nil].none?                                       #=> true\n   [nil,false].none?                                 #=> true\n
one? Enumerable.one?()\nPasses each element of the collection to the given block. The method\nreturns `true` if the block returns `true`\nexactly once. If the block is not given, `one?` will return\n`true` only if exactly one of the collection members is\ntrue.\n\n   %w{ant bear cat}.one? {|word| word.length == 4}   #=> true\n   %w{ant bear cat}.one? {|word| word.length > 4}    #=> false\n   %w{ant bear cat}.one? {|word| word.length < 4}    #=> false\n   [ nil, true, 99 ].one?                            #=> false\n   [ nil, true, false ].one?                         #=> true\n
partition Enumerable.partition()\nReturns two arrays, the first containing the elements of\n<i>enum</i> for which the block evaluates to true, the second\ncontaining the rest.\n\nIf no block is given, an enumerator is returned instead.\n\n   (1..6).partition {|v| v.even? }  #=> [[2, 4, 6], [1, 3, 5]]\n
reduce Enumerable.reduce(p1 = v1, p2 = v2)\nCombines all elements of <i>enum</i> by applying a binary\noperation, specified by a block or a symbol that names a\nmethod or operator.\n\nIf you specify a block, then for each element in <i>enum</i>\nthe block is passed an accumulator value (<i>memo</i>) and the element.\nIf you specify a symbol instead, then each element in the collection\nwill be passed to the named method of <i>memo</i>.\nIn either case, the result becomes the new value for <i>memo</i>.\nAt the end of the iteration, the final value of <i>memo</i> is the\nreturn value for the method.\n\nIf you do not explicitly specify an <i>initial</i> value for <i>memo</i>,\nthen uses the first element of collection is used as the initial value\nof <i>memo</i>.\n\nExamples:\n Sum some numbers\n   (5..10).reduce(:+)                            #=> 45\n Same using a block and inject\n   (5..10).inject {|sum, n| sum + n }            #=> 45\n Multiply some numbers\n   (5..10).reduce(1, :*)                         #=> 151200\n Same using a block\n   (5..10).inject(1) {|product, n| product * n } #=> 151200\n find the longest word\n   longest = %w{ cat sheep bear }.inject do |memo,word|\n      memo.length > word.length ? memo : word\n   end\n   longest                                       #=> "sheep"\n
reject Enumerable.reject()\nReturns an array for all elements of <i>enum</i> for which\n<em>block</em> is false (see also `Enumerable#find_all`).\n\nIf no block is given, an enumerator is returned instead.\n\n   (1..10).reject {|i|  i % 3 == 0 }   #=> [1, 2, 4, 5, 7, 8, 10]\n
reverse_each Enumerable.reverse_each(*args)\nBuilds a temporary array and traverses that array in reverse order.\n\nIf no block is given, an enumerator is returned instead.\n\n    (1..3).reverse_each {|v| p v }\n\n  produces:\n\n    3\n    2\n    1\n
select Enumerable.select()\nReturns an array containing all elements of <i>enum</i> for which\n<em>block</em> is not `false` (see also\n`Enumerable#reject`).\n\nIf no block is given, an enumerator is returned instead.\n\n   (1..10).find_all {|i|  i % 3 == 0 }   #=> [3, 6, 9]\n
slice_before Enumerable.slice_before(p1 = v1)\n Creates an enumerator for each chunked elements.\n The beginnings of chunks are defined by _pattern_ and the block.\n If _pattern_ === _elt_ returns true or\n the block returns true for the element,\n the element is beginning of a chunk.\n\n The === and block is called from the first element to the last element\n of _enum_.\n The result for the first element is ignored.\n\n The result enumerator yields the chunked elements as an array for +each+\n method.\n +each+ method can be called as follows.\n\n   enum.slice_before(pattern).each {|ary| ... }\n   enum.slice_before {|elt| bool }.each {|ary| ... }\n   enum.slice_before(initial_state) {|elt, state| bool }.each {|ary| ... }\n\n Other methods of Enumerator class and Enumerable module,\n such as map, etc., are also usable.\n\n For example, iteration over ChangeLog entries can be implemented as\n follows.\n iterate over ChangeLog entries.\n   open("ChangeLog") {|f|\n     f.slice_before(/\A\S/).each {|e| pp e}\n   }\n same as above.  block is used instead of pattern argument.\n   open("ChangeLog") {|f|\n     f.slice_before {|line| /\A\S/ === line }.each {|e| pp e}\n   }\n\n"svn proplist -R" produces multiline output for each file.\nThey can be chunked as follows:\n\n   IO.popen([{"LC_ALL"=>"C"}, "svn", "proplist", "-R"]) {|f|\n     f.lines.slice_before(/\AProp/).each {|lines| p lines }\n   }\n=> ["Properties on '.':\\n", "  svn:ignore\\n", "  svk:merge\\n"]\n   ["Properties on 'goruby.c':\\n", "  svn:eol-style\\n"]\n   ["Properties on 'complex.c':\\n", "  svn:mime-type\\n", "\n   svn:eol-style\\n"]\n   ["Properties on 'regparse.c':\\n", "  svn:eol-style\\n"]\n   ...\n\n If the block needs to maintain state over multiple elements,\n local variables can be used.\n For example, three or more consecutive increasing numbers can be squashed\n as follows:\n\n   a = [0,2,3,4,6,7,9]\n   prev = a[0]\n   p a.slice_before {|e|\n     prev, prev2 = e, prev\n     prev2 + 1 != e\n   }.map {|es|\n     es.length <= 2 ? es.join(",") : "#{es.first}-#{es.last}"\n   }.join(",")\n=> "0,2-4,6,7,9"\n\n However local variables are not appropriate to maintain state\n if the result enumerator is used twice or more.\n In such case, the last state of the 1st +each+ is used in 2nd +each+.\n _initial_state_ argument can be used to avoid this problem.\n If non-nil value is given as _initial_state_,\n it is duplicated for each "each" method invocation of the enumerator.\n The duplicated object is passed to 2nd argument of the block for\n +slice_before+ method.\n word wrapping.\n this assumes all characters have same width.\n   def wordwrap(words, maxwidth)\n if cols is a local variable, 2nd "each" may start with non-zero cols.\n     words.slice_before(cols: 0) {|w, h|\n       h[:cols] += 1 if h[:cols] != 0\n       h[:cols] += w.length\n       if maxwidth < h[:cols]\n         h[:cols] = w.length\n         true\n       else\n         false\n       end\n     }\n   end\n   text = (1..20).to_a.join(" ")\n   enum = wordwrap(text.split(/\s+/), 10)\n   puts "-"*10\n   enum.each {|ws| puts ws.join(" ") }\n   puts "-"*10\n=> ----------\n   1 2 3 4 5\n   6 7 8 9 10\n   11 12 13\n   14 15 16\n   17 18 19\n   20\n   ----------\n\nmbox contains series of mails which start with Unix From line.\nSo each mail can be extracted by slice before Unix From line.\n parse mbox\n   open("mbox") {|f|\n     f.slice_before {|line|\n       line.start_with? "From "\n     }.each {|mail|\n       unix_from = mail.shift\n       i = mail.index("\\n")\n       header = mail[0...i]\n       body = mail[(i+1)..-1]\n       body.pop if body.last == "\\n"\n       fields = header.slice_before {|line| !" \t".include?(line[0]) }.to_a\n       p unix_from\n       pp fields\n       pp body\n     }\n   }\n split mails in mbox (slice before Unix From line after an empty line)\n   open("mbox") {|f|\n     f.slice_before(emp: true) {|line,h|\n       prevemp = h[:emp]\n       h[:emp] = line == "\\n"\n       prevemp && line.start_with?("From ")\n     }.each {|mail|\n       mail.pop if mail.last == "\\n"\n       pp mail\n     }\n   }\n
sort Enumerable.sort()\nReturns an array containing the items in <i>enum</i> sorted,\neither according to their own `<=>` method, or by using\nthe results of the supplied block. The block should return -1, 0, or\n+1 depending on the comparison between <i>a</i> and <i>b</i>. As of\nRuby 1.8, the method `Enumerable#sort_by` implements a\nbuilt-in Schwartzian Transform, useful when key computation or\ncomparison is expensive.\n\n   %w(rhea kea flea).sort         #=> ["flea", "kea", "rhea"]\n   (1..10).sort {|a,b| b <=> a}   #=> [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n
sort_by Enumerable.sort_by()\nSorts <i>enum</i> using a set of keys generated by mapping the\nvalues in <i>enum</i> through the given block.\n\nIf no block is given, an enumerator is returned instead.\n\n   %w{ apple pear fig }.sort_by {|word| word.length}\n=> ["fig", "pear", "apple"]\n\nThe current implementation of `sort_by` generates an\narray of tuples containing the original collection element and the\nmapped value. This makes `sort_by` fairly expensive when\nthe keysets are simple\n\n   require 'benchmark'\n\n   a = (1..100000).map {rand(100000)}\n\n   Benchmark.bm(10) do |b|\n     b.report("Sort")    { a.sort }\n     b.report("Sort by") { a.sort_by {|a| a} }\n   end\n\n<em>produces:</em>\n\n   user     system      total        real\n   Sort        0.180000   0.000000   0.180000 (  0.175469)\n   Sort by     1.980000   0.040000   2.020000 (  2.013586)\n\nHowever, consider the case where comparing the keys is a non-trivial\noperation. The following code sorts some files on modification time\nusing the basic `sort` method.\n\n   files = Dir["*"]\n   sorted = files.sort {|a,b| File.new(a).mtime <=> File.new(b).mtime}\n   sorted   #=> ["mon", "tues", "wed", "thurs"]\n\nThis sort is inefficient: it generates two new `File`\nobjects during every comparison. A slightly better technique is to\nuse the `Kernel#test` method to generate the modification\ntimes directly.\n\n   files = Dir["*"]\n   sorted = files.sort { |a,b|\n     test(?M, a) <=> test(?M, b)\n   }\n   sorted   #=> ["mon", "tues", "wed", "thurs"]\n\nThis still generates many unnecessary `Time` objects. A\nmore efficient technique is to cache the sort keys (modification\ntimes in this case) before the sort. Perl users often call this\napproach a Schwartzian Transform, after Randal Schwartz. We\nconstruct a temporary array, where each element is an array\ncontaining our sort key along with the filename. We sort this array,\nand then extract the filename from the result.\n\n   sorted = Dir["*"].collect { |f|\n      [test(?M, f), f]\n   }.sort.collect { |f| f[1] }\n   sorted   #=> ["mon", "tues", "wed", "thurs"]\n\nThis is exactly what `sort_by` does internally.\n\n   sorted = Dir["*"].sort_by {|f| test(?M, f)}\n   sorted   #=> ["mon", "tues", "wed", "thurs"]\n
take Enumerable.take(p1)\nReturns first n elements from <i>enum</i>.\n\n   a = [1, 2, 3, 4, 5, 0]\n   a.take(3)             #=> [1, 2, 3]\n
take_while Enumerable.take_while()\nPasses elements to the block until the block returns +nil+ or +false+,\nthen stops iterating and returns an array of all prior elements.\n\nIf no block is given, an enumerator is returned instead.\n\n   a = [1, 2, 3, 4, 5, 0]\n   a.take_while {|i| i < 3 }   #=> [1, 2]\n
to_a Enumerable.to_a(*args)\nReturns an array containing the items in <i>enum</i>.\n\n   (1..7).to_a                       #=> [1, 2, 3, 4, 5, 6, 7]\n   { 'a'=>1, 'b'=>2, 'c'=>3 }.to_a   #=> [["a", 1], ["b", 2], ["c", 3]]\n
to_set Enumerable.to_set(klass = Set, *args, &block)\nMakes a set from the enumerable object with given arguments.\nNeeds to +require "set"+ to use this method.\n
zip Enumerable.zip(*args)\nTakes one element from <i>enum</i> and merges corresponding\nelements from each <i>args</i>.  This generates a sequence of\n<em>n</em>-element arrays, where <em>n</em> is one more than the\ncount of arguments.  The length of the resulting sequence will be\n`enum#size`.  If the size of any argument is less than\n`enum#size`, `nil` values are supplied. If\na block is given, it is invoked for each output array, otherwise\nan array of arrays is returned.\n\n   a = [ 4, 5, 6 ]\n   b = [ 7, 8, 9 ]\n\n   [1,2,3].zip(a, b)      #=> [[1, 4, 7], [2, 5, 8], [3, 6, 9]]\n   [1,2].zip(a,b)         #=> [[1, 4, 7], [2, 5, 8]]\n   a.zip([1,2],[8])       #=> [[4, 1, 8], [5, 2, nil], [6, nil, nil]]\n
list Signal.list()\nReturns a list of signal names mapped to the corresponding\nunderlying signal numbers.\n\n  Signal.list   #=> {"EXIT"=>0, "HUP"=>1, "INT"=>2, "QUIT"=>3, "ILL"=>4,\n  "TRAP"=>5, "IOT"=>6, "ABRT"=>6, "FPE"=>8, "KILL"=>9, "BUS"=>7, "SEGV"=>11,\n  "SYS"=>31, "PIPE"=>13, "ALRM"=>14, "TERM"=>15, "URG"=>23, "STOP"=>19,\n  "TSTP"=>20, "CONT"=>18, "CHLD"=>17, "CLD"=>17, "TTIN"=>21, "TTOU"=>22,\n  "IO"=>29, "XCPU"=>24, "XFSZ"=>25, "VTALRM"=>26, "PROF"=>27, "WINCH"=>28,\n  "USR1"=>10, "USR2"=>12, "PWR"=>30, "POLL"=>29}\n
trap Signal.trap(*args)\nSpecifies the handling of signals. The first parameter is a signal\nname (a string such as ``SIGALRM'', ``SIGUSR1'', and so on) or a\nsignal number. The characters ``SIG'' may be omitted from the\nsignal name. The command or block specifies code to be run when the\nsignal is raised.\nIf the command is the string ``IGNORE'' or ``SIG_IGN'', the signal\nwill be ignored.\nIf the command is ``DEFAULT'' or ``SIG_DFL'', the Ruby's default handler\nwill be invoked.\nIf the command is ``EXIT'', the script will be terminated by the signal.\nIf the command is ``SYSTEM_DEFAULT'', the operating system's default\nhandler will be invoked.\nOtherwise, the given command or block will be run.\nThe special signal name ``EXIT'' or signal number zero will be\ninvoked just prior to program termination.\ntrap returns the previous handler for the given signal.\n\n    Signal.trap(0, proc { puts "Terminating: #{$$}" })\n    Signal.trap("CLD")  { puts "Child died" }\n    fork && Process.wait\n\nproduces:\n    Terminating: 27461\n    Child died\n    Terminating: 27460\n
between? Comparable.between?(p1, p2)\nReturns `false` if <i>obj</i> `<=>`\n<i>min</i> is less than zero or if <i>anObject</i> `<=>`\n<i>max</i> is greater than zero, `true` otherwise.\n\n   3.between?(1, 5)               #=> true\n   6.between?(1, 5)               #=> false\n   'cat'.between?('ant', 'dog')   #=> true\n   'gnu'.between?('ant', 'dog')   #=> false\n
count GC.count()\nThe number of times GC occurred.\n\nIt returns the number of times GC occurred since the process started.\n
disable GC.disable()\nDisables garbage collection, returning `true` if garbage\ncollection was already disabled.\n\n   GC.disable   #=> false\n   GC.disable   #=> true\n
enable GC.enable()\nEnables garbage collection, returning `true` if garbage\ncollection was previously disabled.\n\n   GC.disable   #=> false\n   GC.enable    #=> true\n   GC.enable    #=> false\n
malloc_allocated_size GC.malloc_allocated_size()\nThe allocated size by malloc().\n\nIt returns the allocated size by malloc().\n
malloc_allocations GC.malloc_allocations()\nThe number of allocated memory object by malloc().\n\nIt returns the number of allocated memory object by malloc().\n
start GC.start()\nInitiates garbage collection, unless manually disabled.\n
stat GC.stat(p1 = v1)\nReturns a Hash containing information about the GC.\n\nThe hash includes information about internal statistics about GC such as:\n\n  {\n    :count          => 18,\n    :heap_used      => 77,\n    :heap_length    => 77,\n    :heap_increment => 0,\n    :heap_live_num  => 23287,\n    :heap_free_num  => 8115,\n    :heap_final_num => 0,\n  }\n\nThe contents of the hash are implementation defined and may be changed in\nthe future.\n\nThis method is only expected to work on C Ruby.\n
stress GC.stress()\nreturns current status of GC stress mode.\n
stress= GC.stress=(p1)\nUpdates the GC stress mode.\n\nWhen stress mode is enabled the GC is invoked at every GC opportunity:\nall memory and object allocations.\n\nEnabling stress mode makes Ruby very slow, it is only for debugging.\n
garbage_collect GC.garbage_collect()\nInitiates garbage collection, unless manually disabled.\n
_id2ref ObjectSpace._id2ref(p1)\nConverts an object id to a reference to the object. May not be\ncalled on an object id passed as a parameter to a finalizer.\n\n   s = "I am a string"                    #=> "I am a string"\n   r = ObjectSpace._id2ref(s.object_id)   #=> "I am a string"\n   r == s                                 #=> true\n
count_objects ObjectSpace.count_objects(p1 = v1)\nCounts objects for each type.\n\nIt returns a hash as:\n{:TOTAL=>10000, :FREE=>3011, :T_OBJECT=>6, :T_CLASS=>404, ...}\n\nIf the optional argument, result_hash, is given,\nit is overwritten and returned.\nThis is intended to avoid probe effect.\n\nThe contents of the returned hash is implementation defined.\nIt may be changed in future.\n\nThis method is not expected to work except C Ruby.\n
define_finalizer ObjectSpace.define_finalizer(p1, p2 = v2)\nAdds <i>aProc</i> as a finalizer, to be called after <i>obj</i>\nwas destroyed.\n
each_object ObjectSpace.each_object(p1 = v1)\nCalls the block once for each living, nonimmediate object in this\nRuby process. If <i>module</i> is specified, calls the block\nfor only those classes or modules that match (or are a subclass of)\n<i>module</i>. Returns the number of objects found. Immediate\nobjects (`Fixnum`s, `Symbol`s\n`true`, `false`, and `nil`) are\nnever returned. In the example below, `each_object`\nreturns both the numbers we defined and several constants defined in\nthe `Math` module.\n\nIf no block is given, an enumerator is returned instead.\n\n   a = 102.7\n   b = 95       # Won't be returned\n   c = 12345678987654321\n   count = ObjectSpace.each_object(Numeric) {|x| p x }\n   puts "Total count: #{count}"\n\n<em>produces:</em>\n\n   12345678987654321\n   102.7\n   2.71828182845905\n   3.14159265358979\n   2.22044604925031e-16\n   1.7976931348623157e+308\n   2.2250738585072e-308\n   Total count: 7\n
garbage_collect ObjectSpace.garbage_collect()\nInitiates garbage collection, unless manually disabled.\n
undefine_finalizer ObjectSpace.undefine_finalizer(p1)\nRemoves all finalizers for <i>obj</i>.\n
clear GC::Profiler.clear()\nClears the GC profiler data.\n
disable GC::Profiler.disable()\nStops the GC profiler.\n
enable GC::Profiler.enable()\nStarts the GC profiler.\n
enabled? GC::Profiler.enabled?()\nThe current status of GC profile mode.\n
report GC::Profiler.report(p1 = v1)\nWrites the GC::Profiler#result to <tt>$stdout</tt> or the given IO object.\n
result GC::Profiler.result()\nReturns a profile data report such as:\n\n  GC 1 invokes.\n  Index    Invoke Time(sec)       Use Size(byte)     Total Size(byte)\n  Total Object                    GC time(ms)\n      1               0.012               159240               212940\n      10647         0.00000000000001530000\n
total_time GC::Profiler.total_time()\nThe total time used for garbage collection in milliseconds\n
blockdev? FileTest.blockdev?(p1)\nReturns `true` if the named file is a block device.\n
chardev? FileTest.chardev?(p1)\nReturns `true` if the named file is a character device.\n
directory? FileTest.directory?(p1)\nReturns `true` if the named file is a directory,\nor a symlink that points at a directory, and `false`\notherwise.\n\n   File.directory?(".")\n
executable? FileTest.executable?(p1)\nReturns `true` if the named file is executable by the effective\nuser id of this process.\n
executable_real? FileTest.executable_real?(p1)\nReturns `true` if the named file is executable by the real\nuser id of this process.\n
exist? FileTest.exist?(p1)\nReturns `true` if the named file is a directory,\n`false` otherwise.\n
exists? FileTest.exists?(p1)\nReturn `true` if the named file exists.\n
file? FileTest.file?(p1)\nReturns `true` if the named file exists and is a\nregular file.\n
grpowned? FileTest.grpowned?(p1)\nReturns `true` if the named file exists and the\neffective group id of the calling process is the owner of\nthe file. Returns `false` on Windows.\n
identical? FileTest.identical?(p1, p2)\nReturns `true` if the named files are identical.\n\n    open("a", "w") {}\n    p File.identical?("a", "a")      #=> true\n    p File.identical?("a", "./a")    #=> true\n    File.link("a", "b")\n    p File.identical?("a", "b")      #=> true\n    File.symlink("a", "c")\n    p File.identical?("a", "c")      #=> true\n    open("d", "w") {}\n    p File.identical?("a", "d")      #=> false\n
owned? FileTest.owned?(p1)\nReturns `true` if the named file exists and the\neffective used id of the calling process is the owner of\nthe file.\n
pipe? FileTest.pipe?(p1)\nReturns `true` if the named file is a pipe.\n
readable? FileTest.readable?(p1)\nReturns `true` if the named file is readable by the effective\nuser id of this process.\n
readable_real? FileTest.readable_real?(p1)\nReturns `true` if the named file is readable by the real\nuser id of this process.\n
setgid? FileTest.setgid?(p1)\nReturns `true` if the named file has the setgid bit set.\n
setuid? FileTest.setuid?(p1)\nReturns `true` if the named file has the setuid bit set.\n
size FileTest.size(p1)\nReturns the size of `file_name`.\n
size? FileTest.size?(p1)\nReturns +nil+ if +file_name+ doesn't exist or has zero size, the size of the\nfile otherwise.\n
socket? FileTest.socket?(p1)\nReturns `true` if the named file is a socket.\n
sticky? FileTest.sticky?(p1)\nReturns `true` if the named file has the sticky bit set.\n
symlink? FileTest.symlink?(p1)\nReturns `true` if the named file is a symbolic link.\n
world_readable? FileTest.world_readable?(p1)\nIf <i>file_name</i> is readable by others, returns an integer\nrepresenting the file permission bits of <i>file_name</i>. Returns\n`nil` otherwise. The meaning of the bits is platform\ndependent; on Unix systems, see `stat(2)`.\n\n   File.world_readable?("/etc/passwd")           #=> 420\n   m = File.world_readable?("/etc/passwd")\n   sprintf("%o", m)                              #=> "644"\n
world_writable? FileTest.world_writable?(p1)\nIf <i>file_name</i> is writable by others, returns an integer\nrepresenting the file permission bits of <i>file_name</i>. Returns\n`nil` otherwise. The meaning of the bits is platform\ndependent; on Unix systems, see `stat(2)`.\n\n   File.world_writable?("/tmp")                  #=> 511\n   m = File.world_writable?("/tmp")\n   sprintf("%o", m)                              #=> "777"\n
writable? FileTest.writable?(p1)\nReturns `true` if the named file is writable by the effective\nuser id of this process.\n
writable_real? FileTest.writable_real?(p1)\nReturns `true` if the named file is writable by the real\nuser id of this process.\n
zero? FileTest.zero?(p1)\nReturns `true` if the named file exists and has\na zero size.\n
abort Process.abort(p1)\nTerminate execution immediately, effectively by calling\n`Kernel.exit(false)`. If _msg_ is given, it is written\nto STDERR prior to terminating.\n
daemon Process.daemon(p1 = v1, p2 = v2)\nDetach the process from controlling terminal and run in\nthe background as system daemon.  Unless the argument\nnochdir is true (i.e. non false), it changes the current\nworking directory to the root ("/"). Unless the argument\nnoclose is true, daemon() will redirect standard input,\nstandard output and standard error to /dev/null.\nReturn zero on success, or raise one of Errno::*.\n
detach Process.detach(p1)\nSome operating systems retain the status of terminated child\nprocesses until the parent collects that status (normally using\nsome variant of `wait()`. If the parent never collects\nthis status, the child stays around as a <em>zombie</em> process.\n`Process::detach` prevents this by setting up a\nseparate Ruby thread whose sole job is to reap the status of the\nprocess _pid_ when it terminates. Use `detach`\nonly when you do not intent to explicitly wait for the child to\nterminate.\n\nThe waiting thread returns the exit status of the detached process\nwhen it terminates, so you can use `Thread#join` to\nknow the result.  If specified _pid_ is not a valid child process\nID, the thread returns +nil+ immediately.\n\nThe waiting thread has `pid` method which returns the pid.\n\nIn this first example, we don't reap the first child process, so\nit appears as a zombie in the process status display.\n\n   p1 = fork { sleep 0.1 }\n   p2 = fork { sleep 0.2 }\n   Process.waitpid(p2)\n   sleep 2\n   system("ps -ho pid,state -p #{p1}")\n\n<em>produces:</em>\n\n   27389 Z\n\nIn the next example, `Process::detach` is used to reap\nthe child automatically.\n\n   p1 = fork { sleep 0.1 }\n   p2 = fork { sleep 0.2 }\n   Process.detach(p1)\n   Process.waitpid(p2)\n   sleep 2\n   system("ps -ho pid,state -p #{p1}")\n\n<em>(produces no output)</em>\n
egid Process.egid()\nReturns the effective group ID for this process. Not available on\nall platforms.\n\n   Process.egid   #=> 500\n
egid= Process.egid=(p1)\nSets the effective group ID for this process. Not available on all\nplatforms.\n
euid Process.euid()\nReturns the effective user ID for this process.\n\n   Process.euid   #=> 501\n
euid= Process.euid=(p1)\nSets the effective user ID for this process. Not available on all\nplatforms.\n
exec Process.exec(*args)\nReplaces the current process by running the given external _command_.\n_command..._ is one of following forms.\n\n  commandline                 : command line string which is passed to the\n  standard shell\n  cmdname, arg1, ...          : command name and one or more arguments\n  (no shell)\n  [cmdname, argv0], arg1, ... : command name, argv[0] and zero or more\n  arguments (no shell)\n\nIf single string is given as the command,\nit is taken as a command line that is subject to shell expansion before\nbeing executed.\n\nThe standard shell means always `"/bin/sh"` on Unix-like systems,\n`ENV["RUBYSHELL"]` or `ENV["COMSPEC"]` on Windows NT series, and\nsimilar.\n\nIf two or more +string+ given,\nthe first is taken as a command name and\nthe rest are passed as parameters to command with no shell expansion.\n\nIf a two-element array at the beginning of the command,\nthe first element is the command to be executed,\nand the second argument is used as the `argv[0]` value,\nwhich may show up in process listings.\n\nIn order to execute the command, one of the `exec(2)`\nsystem calls is used, so the running command may inherit some of the\nenvironment\nof the original program (including open file descriptors).\nThis behavior is modified by env and options.\nSee `spawn` for details.\n\nRaises SystemCallError if the command couldn't execute (typically\n`Errno::ENOENT` when it was not found).\n\n   exec "echo *"       # echoes list of files in current directory\n never get here\n\n   exec "echo", "*"    # echoes an asterisk\n never get here\n
exit Process.exit(p1 = v1)\nInitiates the termination of the Ruby script by raising the\n`SystemExit` exception. This exception may be caught. The\noptional parameter is used to return a status code to the invoking\nenvironment.\n+true+ and +FALSE+ of _status_ means success and failure\nrespectively.  The interpretation of other integer values are\nsystem dependent.\n\n   begin\n     exit\n     puts "never get here"\n   rescue SystemExit\n     puts "rescued a SystemExit exception"\n   end\n   puts "after begin block"\n\n<em>produces:</em>\n\n   rescued a SystemExit exception\n   after begin block\n\nJust prior to termination, Ruby executes any `at_exit` functions\n(see Kernel::at_exit) and runs any object finalizers (see\nObjectSpace::define_finalizer).\n\n   at_exit { puts "at_exit function" }\n   ObjectSpace.define_finalizer("string",  proc { puts "in finalizer" })\n   exit\n\n<em>produces:</em>\n\n   at_exit function\n   in finalizer\n
exit! Process.exit!(p1 = v1)\nExits the process immediately. No exit handlers are\nrun. <em>status</em> is returned to the underlying system as the\nexit status.\n\n   Process.exit!(true)\n
fork Process.fork()\nCreates a subprocess. If a block is specified, that block is run\nin the subprocess, and the subprocess terminates with a status of\nzero. Otherwise, the +fork+ call returns twice, once in\nthe parent, returning the process ID of the child, and once in\nthe child, returning _nil_. The child process can exit using\n`Kernel.exit!` to avoid running any\n`at_exit` functions. The parent process should\nuse `Process.wait` to collect the termination statuses\nof its children or use `Process.detach` to register\ndisinterest in their status; otherwise, the operating system\nmay accumulate zombie processes.\n\nThe thread calling fork is the only thread in the created child process.\nfork doesn't copy other threads.\n\nIf fork is not usable, Process.respond_to?(:fork) returns false.\n
getpgid Process.getpgid(p1)\nReturns the process group ID for the given process id. Not\navailable on all platforms.\n\n   Process.getpgid(Process.ppid())   #=> 25527\n
getpgrp Process.getpgrp()\nReturns the process group ID for this process. Not available on\nall platforms.\n\n   Process.getpgid(0)   #=> 25527\n   Process.getpgrp      #=> 25527\n
getpriority Process.getpriority(p1, p2)\nGets the scheduling priority for specified process, process group,\nor user. <em>kind</em> indicates the kind of entity to find: one\nof `Process::PRIO_PGRP`,\n`Process::PRIO_USER`, or\n`Process::PRIO_PROCESS`. _integer_ is an id\nindicating the particular process, process group, or user (an id\nof 0 means _current_). Lower priorities are more favorable\nfor scheduling. Not available on all platforms.\n\n   Process.getpriority(Process::PRIO_USER, 0)      #=> 19\n   Process.getpriority(Process::PRIO_PROCESS, 0)   #=> 19\n
getrlimit Process.getrlimit(p1)\nGets the resource limit of the process.\n_cur_limit_ means current (soft) limit and\n_max_limit_ means maximum (hard) limit.\n\n_resource_ indicates the kind of resource to limit.\nIt is specified as a symbol such as `:CORE`,\na string such as `"CORE"` or\na constant such as `Process::RLIMIT_CORE`.\nSee Process.setrlimit for details.\n\n_cur_limit_ and _max_limit_ may be `Process::RLIM_INFINITY`,\n`Process::RLIM_SAVED_MAX` or\n`Process::RLIM_SAVED_CUR`.\nSee Process.setrlimit and the system getrlimit(2) manual for details.\n
gid Process.gid()\nReturns the (real) group ID for this process.\n\n   Process.gid   #=> 500\n
gid= Process.gid=(p1)\nSets the group ID for this process.\n
groups Process.groups()\nGet an `Array` of the gids of groups in the\nsupplemental group access list for this process.\n\n   Process.groups   #=> [27, 6, 10, 11]\n
groups= Process.groups=(p1)\nSet the supplemental group access list to the given\n`Array` of group IDs.\n\n   Process.groups   #=> [0, 1, 2, 3, 4, 6, 10, 11, 20, 26, 27]\n   Process.groups = [27, 6, 10, 11]   #=> [27, 6, 10, 11]\n   Process.groups   #=> [27, 6, 10, 11]\n
initgroups Process.initgroups(p1, p2)\nInitializes the supplemental group access list by reading the\nsystem group database and using all groups of which the given user\nis a member. The group with the specified <em>gid</em> is also\nadded to the list. Returns the resulting `Array` of the\ngids of all the groups in the supplementary group access list. Not\navailable on all platforms.\n\n   Process.groups   #=> [0, 1, 2, 3, 4, 6, 10, 11, 20, 26, 27]\n   Process.initgroups( "mgranger", 30 )   #=> [30, 6, 10, 11]\n   Process.groups   #=> [30, 6, 10, 11]\n
kill Process.kill(*args)\nSends the given signal to the specified process id(s), or to the\ncurrent process if _pid_ is zero. _signal_ may be an\ninteger signal number or a POSIX signal name (either with or without\na +SIG+ prefix). If _signal_ is negative (or starts\nwith a minus sign), kills process groups instead of\nprocesses. Not all signals are available on all platforms.\n\n   pid = fork do\n      Signal.trap("HUP") { puts "Ouch!"; exit }\n ... do some work ...\n   end\n ...\n   Process.kill("HUP", pid)\n   Process.wait\n\n<em>produces:</em>\n\n   Ouch!\n\nIf _signal_ is an integer but wrong for signal,\n`Errno::EINVAL` or +RangeError+ will be raised.\nOtherwise unless _signal_ is a +String+ or a +Symbol+, and a known\nsignal name, +ArgumentError+ will be raised.\n\nAlso, `Errno::ESRCH` or +RangeError+ for invalid _pid_,\n`Errno::EPERM` when failed because of no privilege,\nwill be raised.  In these cases, signals may have been sent to\npreceding processes.\n
maxgroups Process.maxgroups()\nReturns the maximum number of gids allowed in the supplemental\ngroup access list.\n\n   Process.maxgroups   #=> 32\n
maxgroups= Process.maxgroups=(p1)\nSets the maximum number of gids allowed in the supplemental group\naccess list.\n
pid Process.pid()\nReturns the process id of this process. Not available on all\nplatforms.\n\n   Process.pid   #=> 27415\n
ppid Process.ppid()\nReturns the process id of the parent of this process. Returns\nuntrustworthy value on Win32/64. Not available on all platforms.\n\n   puts "I am #{Process.pid}"\n   Process.fork { puts "Dad is #{Process.ppid}" }\n\n<em>produces:</em>\n\n   I am 27417\n   Dad is 27417\n
setpgid Process.setpgid(p1, p2)\nSets the process group ID of _pid_ (0 indicates this\nprocess) to <em>integer</em>. Not available on all platforms.\n
setpgrp Process.setpgrp()\nEquivalent to `setpgid(0,0)`. Not available on all\nplatforms.\n
setpriority Process.setpriority(p1, p2, p3)\nSee `Process#getpriority`.\n\n   Process.setpriority(Process::PRIO_USER, 0, 19)      #=> 0\n   Process.setpriority(Process::PRIO_PROCESS, 0, 19)   #=> 0\n   Process.getpriority(Process::PRIO_USER, 0)          #=> 19\n   Process.getpriority(Process::PRIO_PROCESS, 0)       #=> 19\n
setrlimit Process.setrlimit(p1, p2, p3 = v3)\nSets the resource limit of the process.\n_cur_limit_ means current (soft) limit and\n_max_limit_ means maximum (hard) limit.\n\nIf _max_limit_ is not given, _cur_limit_ is used.\n\n_resource_ indicates the kind of resource to limit.\nIt should be a symbol such as `:CORE`,\na string such as `"CORE"` or\na constant such as `Process::RLIMIT_CORE`.\nThe available resources are OS dependent.\nRuby may support following resources.\n\n[AS] total available memory (bytes) (SUSv3, NetBSD, FreeBSD, OpenBSD but\n4.4BSD-Lite)\n[CORE] core size (bytes) (SUSv3)\n[CPU] CPU time (seconds) (SUSv3)\n[DATA] data segment (bytes) (SUSv3)\n[FSIZE] file size (bytes) (SUSv3)\n[MEMLOCK] total size for mlock(2) (bytes) (4.4BSD, GNU/Linux)\n[MSGQUEUE] allocation for POSIX message queues (bytes) (GNU/Linux)\n[NICE] ceiling on process's nice(2) value (number) (GNU/Linux)\n[NOFILE] file descriptors (number) (SUSv3)\n[NPROC] number of processes for the user (number) (4.4BSD, GNU/Linux)\n[RSS] resident memory size (bytes) (4.2BSD, GNU/Linux)\n[RTPRIO] ceiling on the process's real-time priority (number) (GNU/Linux)\n[RTTIME] CPU time for real-time process (us) (GNU/Linux)\n[SBSIZE] all socket buffers (bytes) (NetBSD, FreeBSD)\n[SIGPENDING] number of queued signals allowed (signals) (GNU/Linux)\n[STACK] stack size (bytes) (SUSv3)\n\n_cur_limit_ and _max_limit_ may be\n`:INFINITY`, `"INFINITY"` or\n`Process::RLIM_INFINITY`,\nwhich means that the resource is not limited.\nThey may be `Process::RLIM_SAVED_MAX`,\n`Process::RLIM_SAVED_CUR` and\ncorresponding symbols and strings too.\nSee system setrlimit(2) manual for details.\n\nThe following example raises the soft limit of core size to\nthe hard limit to try to make core dump possible.\n\n  Process.setrlimit(:CORE, Process.getrlimit(:CORE)[1])\n
setsid Process.setsid()\nEstablishes this process as a new session and process group\nleader, with no controlling tty. Returns the session id. Not\navailable on all platforms.\n\n   Process.setsid   #=> 27422\n
spawn Process.spawn(*args)\nspawn executes specified command and return its pid.\n\nThis method doesn't wait for end of the command.\nThe parent process should\nuse `Process.wait` to collect\nthe termination status of its child or\nuse `Process.detach` to register\ndisinterest in their status;\notherwise, the operating system may accumulate zombie processes.\n\nspawn has bunch of options to specify process attributes:\n\n  env: hash\n    name => val : set the environment variable\n    name => nil : unset the environment variable\n  command...:\n    commandline                 : command line string which is passed to\n    the standard shell\n    cmdname, arg1, ...          : command name and one or more arguments\n    (no shell)\n    [cmdname, argv0], arg1, ... : command name, argv[0] and zero or more\n    arguments (no shell)\n  options: hash\n    clearing environment variables:\n      :unsetenv_others => true   : clear environment variables except\n      specified by env\n      :unsetenv_others => false  : don't clear (default)\n    process group:\n      :pgroup => true or 0 : make a new process group\n      :pgroup => pgid      : join to specified process group\n      :pgroup => nil       : don't change the process group (default)\n    create new process group: Windows only\n      :new_pgroup => true  : the new process is the root process of a new\n      process group\n      :new_pgroup => false : don't create a new process group (default)\n    resource limit: resourcename is core, cpu, data, etc.  See\n    Process.setrlimit.\n      :rlimit_resourcename => limit\n      :rlimit_resourcename => [cur_limit, max_limit]\n    current directory:\n      :chdir => str\n    umask:\n      :umask => int\n    redirection:\n      key:\n        FD              : single file descriptor in child process\n        [FD, FD, ...]   : multiple file descriptor in child process\n      value:\n        FD                        : redirect to the file descriptor in\n        parent process\n        string                    : redirect to file with open(string,\n        "r" or "w")\n        [string]                  : redirect to file with open(string,\n        File::RDONLY)\n        [string, open_mode]       : redirect to file with open(string,\n        open_mode, 0644)\n        [string, open_mode, perm] : redirect to file with open(string,\n        open_mode, perm)\n        [:child, FD]              : redirect to the redirected file descriptor\n        :close                    : close the file descriptor in child process\n      FD is one of follows\n        :in     : the file descriptor 0 which is the standard input\n        :out    : the file descriptor 1 which is the standard output\n        :err    : the file descriptor 2 which is the standard error\n        integer : the file descriptor of specified the integer\n        io      : the file descriptor specified as io.fileno\n    file descriptor inheritance: close non-redirected non-standard fds (3,\n    4, 5, ...) or not\n      :close_others => false : inherit fds (default for system and exec)\n      :close_others => true  : don't inherit (default for spawn and IO.popen)\n\nIf a hash is given as +env+, the environment is\nupdated by +env+ before `exec(2)` in the child process.\nIf a pair in +env+ has nil as the value, the variable is deleted.\n set FOO as BAR and unset BAZ.\n  pid = spawn({"FOO"=>"BAR", "BAZ"=>nil}, command)\n\nIf a hash is given as +options+,\nit specifies\nprocess group,\ncreate new process group,\nresource limit,\ncurrent directory,\numask and\nredirects for the child process.\nAlso, it can be specified to clear environment variables.\n\nThe `:unsetenv_others` key in +options+ specifies\nto clear environment variables, other than specified by +env+.\n\n  pid = spawn(command, :unsetenv_others=>true) # no environment variable\n  pid = spawn({"FOO"=>"BAR"}, command, :unsetenv_others=>true) # FOO only\n\nThe `:pgroup` key in +options+ specifies a process group.\nThe corresponding value should be true, zero or positive integer.\ntrue and zero means the process should be a process leader of a new\nprocess group.\nOther values specifies a process group to be belongs.\n\n  pid = spawn(command, :pgroup=>true) # process leader\n  pid = spawn(command, :pgroup=>10) # belongs to the process group 10\n\nThe `:new_pgroup` key in +options+ specifies to pass\n+CREATE_NEW_PROCESS_GROUP+ flag to `CreateProcessW()` that is\nWindows API. This option is only for Windows.\ntrue means the new process is the root process of the new process group.\nThe new process has CTRL+C disabled. This flag is necessary for\n`Process.kill(:SIGINT, pid)` on the subprocess.\n:new_pgroup is false by default.\n\n  pid = spawn(command, :new_pgroup=>true)  # new process group\n  pid = spawn(command, :new_pgroup=>false) # same process group\n\nThe `:rlimit_`<em>foo</em> key specifies a resource limit.\n<em>foo</em> should be one of resource types such as `core`.\nThe corresponding value should be an integer or an array which have one or\ntwo integers: same as cur_limit and max_limit arguments for\nProcess.setrlimit.\n\n  cur, max = Process.getrlimit(:CORE)\n  pid = spawn(command, :rlimit_core=>[0,max]) # disable core temporary.\n  pid = spawn(command, :rlimit_core=>max) # enable core dump\n  pid = spawn(command, :rlimit_core=>0) # never dump core.\n\nThe `:chdir` key in +options+ specifies the current directory.\n\n  pid = spawn(command, :chdir=>"/var/tmp")\n\nThe `:umask` key in +options+ specifies the umask.\n\n  pid = spawn(command, :umask=>077)\n\nThe :in, :out, :err, a fixnum, an IO and an array key specifies a redirection.\nThe redirection maps a file descriptor in the child process.\n\nFor example, stderr can be merged into stdout as follows:\n\n  pid = spawn(command, :err=>:out)\n  pid = spawn(command, 2=>1)\n  pid = spawn(command, STDERR=>:out)\n  pid = spawn(command, STDERR=>STDOUT)\n\nThe hash keys specifies a file descriptor\nin the child process started by `spawn`.\n:err, 2 and STDERR specifies the standard error stream (stderr).\n\nThe hash values specifies a file descriptor\nin the parent process which invokes `spawn`.\n:out, 1 and STDOUT specifies the standard output stream (stdout).\n\nIn the above example,\nthe standard output in the child process is not specified.\nSo it is inherited from the parent process.\n\nThe standard input stream (stdin) can be specified by :in, 0 and STDIN.\n\nA filename can be specified as a hash value.\n\n  pid = spawn(command, :in=>"/dev/null") # read mode\n  pid = spawn(command, :out=>"/dev/null") # write mode\n  pid = spawn(command, :err=>"log") # write mode\n  pid = spawn(command, 3=>"/dev/null") # read mode\n\nFor stdout and stderr,\nit is opened in write mode.\nOtherwise read mode is used.\n\nFor specifying flags and permission of file creation explicitly,\nan array is used instead.\n\n  pid = spawn(command, :in=>["file"]) # read mode is assumed\n  pid = spawn(command, :in=>["file", "r"])\n  pid = spawn(command, :out=>["log", "w"]) # 0644 assumed\n  pid = spawn(command, :out=>["log", "w", 0600])\n  pid = spawn(command, :out=>["log", File::WRONLY|File::EXCL|File::CREAT,\n  0600])\n\nThe array specifies a filename, flags and permission.\nThe flags can be a string or an integer.\nIf the flags is omitted or nil, File::RDONLY is assumed.\nThe permission should be an integer.\nIf the permission is omitted or nil, 0644 is assumed.\n\nIf an array of IOs and integers are specified as a hash key,\nall the elements are redirected.\n stdout and stderr is redirected to log file.\n The file "log" is opened just once.\n  pid = spawn(command, [:out, :err]=>["log", "w"])\n\nAnother way to merge multiple file descriptors is [:child, fd].\n\[:child, fd] means the file descriptor in the child process.\nThis is different from fd.\nFor example, :err=>:out means redirecting child stderr to parent stdout.\nBut :err=>[:child, :out] means redirecting child stderr to child stdout.\nThey differs if stdout is redirected in the child process as follows.\n stdout and stderr is redirected to log file.\n The file "log" is opened just once.\n  pid = spawn(command, :out=>["log", "w"], :err=>[:child, :out])\n\n\[:child, :out] can be used to merge stderr into stdout in IO.popen.\nIn this case, IO.popen redirects stdout to a pipe in the child process\nand [:child, :out] refers the redirected stdout.\n\n  io = IO.popen(["sh", "-c", "echo out; echo err >&2", :err=>[:child, :out]])\n  p io.read #=> "out\\nerr\\n"\n\nspawn closes all non-standard unspecified descriptors by default.\nThe "standard" descriptors are 0, 1 and 2.\nThis behavior is specified by :close_others option.\n:close_others doesn't affect the standard descriptors which are\nclosed only if :close is specified explicitly.\n\n  pid = spawn(command, :close_others=>true)  # close 3,4,5,... (default)\n  pid = spawn(command, :close_others=>false) # don't close 3,4,5,...\n\n:close_others is true by default for spawn and IO.popen.\n\nSo IO.pipe and spawn can be used as IO.popen.\n similar to r = IO.popen(command)\n  r, w = IO.pipe\n  pid = spawn(command, :out=>w)   # r, w is closed in the child process.\n  w.close\n\n:close is specified as a hash value to close a fd individually.\n\n  f = open(foo)\n  system(command, f=>:close)        # don't inherit f.\n\nIf a file descriptor need to be inherited,\nio=>io can be used.\n valgrind has --log-fd option for log destination.\n log_w=>log_w indicates log_w.fileno inherits to child process.\n  log_r, log_w = IO.pipe\n  pid = spawn("valgrind", "--log-fd=#{log_w.fileno}", "echo", "a",\n  log_w=>log_w)\n  log_w.close\n  p log_r.read\n\nIt is also possible to exchange file descriptors.\n\n  pid = spawn(command, :out=>:err, :err=>:out)\n\nThe hash keys specify file descriptors in the child process.\nThe hash values specifies file descriptors in the parent process.\nSo the above specifies exchanging stdout and stderr.\nInternally, +spawn+ uses an extra file descriptor to resolve such cyclic\nfile descriptor mapping.\n\nSee `Kernel.exec` for the standard shell.\n
times Process.times()\nReturns a `Tms` structure (see `Struct::Tms`)\nthat contains user and system CPU times for this process,\nand also for children processes.\n\n   t = Process.times\n   [ t.utime, t.stime, t.cutime, t.cstime ]   #=> [0.0, 0.02, 0.00, 0.00]\n
uid Process.uid()\nReturns the (real) user ID of this process.\n\n   Process.uid   #=> 501\n
uid= Process.uid=(p1)\nSets the (integer) user ID for this process. Not available on all\nplatforms.\n
wait Process.wait(p1 = v1, p2 = v2)\nWaits for a child process to exit, returns its process id, and\nsets `$?` to a `Process::Status` object\ncontaining information on that process. Which child it waits on\ndepends on the value of _pid_:\n\n> 0::   Waits for the child whose process ID equals _pid_.\n\n0::     Waits for any child whose process group ID equals that of the\n        calling process.\n\n-1::    Waits for any child process (the default if no _pid_ is\n        given).\n\n< -1::  Waits for any child whose process group ID equals the absolute\n        value of _pid_.\n\nThe _flags_ argument may be a logical or of the flag values\n`Process::WNOHANG` (do not block if no child available)\nor `Process::WUNTRACED` (return stopped children that\nhaven't been reported). Not all flags are available on all\nplatforms, but a flag value of zero will work on all platforms.\n\nCalling this method raises a `SystemError` if there are\nno child processes. Not available on all platforms.\n\n   include Process\n   fork { exit 99 }                 #=> 27429\n   wait                             #=> 27429\n   $?.exitstatus                    #=> 99\n\n   pid = fork { sleep 3 }           #=> 27440\n   Time.now                         #=> 2008-03-08 19:56:16 +0900\n   waitpid(pid, Process::WNOHANG)   #=> nil\n   Time.now                         #=> 2008-03-08 19:56:16 +0900\n   waitpid(pid, 0)                  #=> 27440\n   Time.now                         #=> 2008-03-08 19:56:19 +0900\n
wait2 Process.wait2(*args)\nWaits for a child process to exit (see Process::waitpid for exact\nsemantics) and returns an array containing the process id and the\nexit status (a `Process::Status` object) of that\nchild. Raises a `SystemError` if there are no child\nprocesses.\n\n   Process.fork { exit 99 }   #=> 27437\n   pid, status = Process.wait2\n   pid                        #=> 27437\n   status.exitstatus          #=> 99\n
waitall Process.waitall()\nWaits for all children, returning an array of\n_pid_/_status_ pairs (where _status_ is a\n`Process::Status` object).\n\n   fork { sleep 0.2; exit 2 }   #=> 27432\n   fork { sleep 0.1; exit 1 }   #=> 27433\n   fork {            exit 0 }   #=> 27434\n   p Process.waitall\n\n<em>produces</em>:\n\n   [[30982, #<Process::Status: pid 30982 exit 0>],\n    [30979, #<Process::Status: pid 30979 exit 1>],\n    [30976, #<Process::Status: pid 30976 exit 2>]]\n
waitpid Process.waitpid(p1 = v1, p2 = v2)\nWaits for a child process to exit, returns its process id, and\nsets `$?` to a `Process::Status` object\ncontaining information on that process. Which child it waits on\ndepends on the value of _pid_:\n\n> 0::   Waits for the child whose process ID equals _pid_.\n\n0::     Waits for any child whose process group ID equals that of the\n        calling process.\n\n-1::    Waits for any child process (the default if no _pid_ is\n        given).\n\n< -1::  Waits for any child whose process group ID equals the absolute\n        value of _pid_.\n\nThe _flags_ argument may be a logical or of the flag values\n`Process::WNOHANG` (do not block if no child available)\nor `Process::WUNTRACED` (return stopped children that\nhaven't been reported). Not all flags are available on all\nplatforms, but a flag value of zero will work on all platforms.\n\nCalling this method raises a `SystemError` if there are\nno child processes. Not available on all platforms.\n\n   include Process\n   fork { exit 99 }                 #=> 27429\n   wait                             #=> 27429\n   $?.exitstatus                    #=> 99\n\n   pid = fork { sleep 3 }           #=> 27440\n   Time.now                         #=> 2008-03-08 19:56:16 +0900\n   waitpid(pid, Process::WNOHANG)   #=> nil\n   Time.now                         #=> 2008-03-08 19:56:16 +0900\n   waitpid(pid, 0)                  #=> 27440\n   Time.now                         #=> 2008-03-08 19:56:19 +0900\n
waitpid2 Process.waitpid2(*args)\nWaits for a child process to exit (see Process::waitpid for exact\nsemantics) and returns an array containing the process id and the\nexit status (a `Process::Status` object) of that\nchild. Raises a `SystemError` if there are no child\nprocesses.\n\n   Process.fork { exit 99 }   #=> 27437\n   pid, status = Process.wait2\n   pid                        #=> 27437\n   status.exitstatus          #=> 99\n
change_privilege Process::UID.change_privilege(p1)\nChange the current process's real and effective user ID to that\nspecified by _integer_. Returns the new user ID. Not\navailable on all platforms.\n\n   [Process.uid, Process.euid]          #=> [0, 0]\n   Process::UID.change_privilege(31)    #=> 31\n   [Process.uid, Process.euid]          #=> [31, 31]\n
eid Process::UID.eid()\nReturns the effective user ID for this process.\n\n   Process.euid   #=> 501\n
grant_privilege Process::UID.grant_privilege(p1)\nSet the effective user ID, and if possible, the saved user ID of\nthe process to the given _integer_. Returns the new\neffective user ID. Not available on all platforms.\n\n   [Process.uid, Process.euid]          #=> [0, 0]\n   Process::UID.grant_privilege(31)     #=> 31\n   [Process.uid, Process.euid]          #=> [0, 31]\n
re_exchange Process::UID.re_exchange()\nExchange real and effective user IDs and return the new effective\nuser ID. Not available on all platforms.\n\n   [Process.uid, Process.euid]   #=> [0, 31]\n   Process::UID.re_exchange      #=> 0\n   [Process.uid, Process.euid]   #=> [31, 0]\n
re_exchangeable? Process::UID.re_exchangeable?()\nReturns +true+ if the real and effective user IDs of a\nprocess may be exchanged on the current platform.\n
rid Process::UID.rid()\nReturns the (real) user ID of this process.\n\n   Process.uid   #=> 501\n
sid_available? Process::UID.sid_available?()\nReturns +true+ if the current platform has saved user\nID functionality.\n
switch Process::UID.switch()\nSwitch the effective and real user IDs of the current process. If\na <em>block</em> is given, the user IDs will be switched back\nafter the block is executed. Returns the new effective user ID if\ncalled without a block, and the return value of the block if one\nis given.\n
change_privilege Process::GID.change_privilege(p1)\nChange the current process's real and effective group ID to that\nspecified by _integer_. Returns the new group ID. Not\navailable on all platforms.\n\n   [Process.gid, Process.egid]          #=> [0, 0]\n   Process::GID.change_privilege(33)    #=> 33\n   [Process.gid, Process.egid]          #=> [33, 33]\n
eid Process::GID.eid()\nReturns the effective group ID for this process. Not available on\nall platforms.\n\n   Process.egid   #=> 500\n
grant_privilege Process::GID.grant_privilege(p1)\nSet the effective group ID, and if possible, the saved group ID of\nthe process to the given _integer_. Returns the new\neffective group ID. Not available on all platforms.\n\n   [Process.gid, Process.egid]          #=> [0, 0]\n   Process::GID.grant_privilege(31)     #=> 33\n   [Process.gid, Process.egid]          #=> [0, 33]\n
re_exchange Process::GID.re_exchange()\nExchange real and effective group IDs and return the new effective\ngroup ID. Not available on all platforms.\n\n   [Process.gid, Process.egid]   #=> [0, 33]\n   Process::GID.re_exchange      #=> 0\n   [Process.gid, Process.egid]   #=> [33, 0]\n
re_exchangeable? Process::GID.re_exchangeable?()\nReturns +true+ if the real and effective group IDs of a\nprocess may be exchanged on the current platform.\n
rid Process::GID.rid()\nReturns the (real) group ID for this process.\n\n   Process.gid   #=> 500\n
sid_available? Process::GID.sid_available?()\nReturns +true+ if the current platform has saved group\nID functionality.\n
switch Process::GID.switch()\nSwitch the effective and real group IDs of the current process. If\na <em>block</em> is given, the group IDs will be switched back\nafter the block is executed. Returns the new effective group ID if\ncalled without a block, and the return value of the block if one\nis given.\n
getegid Process::Sys.getegid()\nReturns the effective group ID for this process. Not available on\nall platforms.\n\n   Process.egid   #=> 500\n
geteuid Process::Sys.geteuid()\nReturns the effective user ID for this process.\n\n   Process.euid   #=> 501\n
getgid Process::Sys.getgid()\nReturns the (real) group ID for this process.\n\n   Process.gid   #=> 500\n
getuid Process::Sys.getuid()\nReturns the (real) user ID of this process.\n\n   Process.uid   #=> 501\n
issetugid Process::Sys.issetugid()\nReturns +true+ if the process was created as a result\nof an execve(2) system call which had either of the setuid or\nsetgid bits set (and extra privileges were given as a result) or\nif it has changed any of its real, effective or saved user or\ngroup IDs since it began execution.\n
setegid Process::Sys.setegid(p1)\nSet the effective group ID of the calling process to\n_integer_.  Not available on all platforms.\n
seteuid Process::Sys.seteuid(p1)\nSet the effective user ID of the calling process to\n_integer_.  Not available on all platforms.\n
setgid Process::Sys.setgid(p1)\nSet the group ID of the current process to _integer_. Not\navailable on all platforms.\n
setregid Process::Sys.setregid(p1, p2)\nSets the (integer) real and/or effective group IDs of the current\nprocess to <em>rid</em> and <em>eid</em>, respectively. A value of\n`-1` for either means to leave that ID unchanged. Not\navailable on all platforms.\n
setresgid Process::Sys.setresgid(p1, p2, p3)\nSets the (integer) real, effective, and saved user IDs of the\ncurrent process to <em>rid</em>, <em>eid</em>, and <em>sid</em>\nrespectively. A value of `-1` for any value means to\nleave that ID unchanged. Not available on all platforms.\n
setresuid Process::Sys.setresuid(p1, p2, p3)\nSets the (integer) real, effective, and saved user IDs of the\ncurrent process to _rid_, _eid_, and _sid_ respectively. A\nvalue of `-1` for any value means to\nleave that ID unchanged. Not available on all platforms.\n
setreuid Process::Sys.setreuid(p1, p2)\nSets the (integer) real and/or effective user IDs of the current\nprocess to _rid_ and _eid_, respectively. A value of\n`-1` for either means to leave that ID unchanged. Not\navailable on all platforms.\n
setrgid Process::Sys.setrgid(p1)\nSet the real group ID of the calling process to _integer_.\nNot available on all platforms.\n
setruid Process::Sys.setruid(p1)\nSet the real user ID of the calling process to _integer_.\nNot available on all platforms.\n
setuid Process::Sys.setuid(p1)\nSet the user ID of the current process to _integer_. Not\navailable on all platforms.\n
acos Math.acos(p1)\nComputes the arc cosine of <i>x</i>. Returns 0..PI.\n
acosh Math.acosh(p1)\nComputes the inverse hyperbolic cosine of <i>x</i>.\n
asin Math.asin(p1)\nComputes the arc sine of <i>x</i>. Returns -{PI/2} .. {PI/2}.\n
asinh Math.asinh(p1)\nComputes the inverse hyperbolic sine of <i>x</i>.\n
atan Math.atan(p1)\nComputes the arc tangent of <i>x</i>. Returns -{PI/2} .. {PI/2}.\n
atan2 Math.atan2(p1, p2)\nComputes the arc tangent given <i>y</i> and <i>x</i>. Returns\n-PI..PI.\n\n  Math.atan2(-0.0, -1.0) #=> -3.141592653589793\n  Math.atan2(-1.0, -1.0) #=> -2.356194490192345\n  Math.atan2(-1.0, 0.0)  #=> -1.5707963267948966\n  Math.atan2(-1.0, 1.0)  #=> -0.7853981633974483\n  Math.atan2(-0.0, 1.0)  #=> -0.0\n  Math.atan2(0.0, 1.0)   #=> 0.0\n  Math.atan2(1.0, 1.0)   #=> 0.7853981633974483\n  Math.atan2(1.0, 0.0)   #=> 1.5707963267948966\n  Math.atan2(1.0, -1.0)  #=> 2.356194490192345\n  Math.atan2(0.0, -1.0)  #=> 3.141592653589793\n
atanh Math.atanh(p1)\nComputes the inverse hyperbolic tangent of <i>x</i>.\n
cbrt Math.cbrt(p1)\nReturns the cube root of <i>numeric</i>.\n\n  -9.upto(9) {|x|\n    p [x, Math.cbrt(x), Math.cbrt(x)**3]\n  }\n=>\n  [-9, -2.0800838230519, -9.0]\n  [-8, -2.0, -8.0]\n  [-7, -1.91293118277239, -7.0]\n  [-6, -1.81712059283214, -6.0]\n  [-5, -1.7099759466767, -5.0]\n  [-4, -1.5874010519682, -4.0]\n  [-3, -1.44224957030741, -3.0]\n  [-2, -1.25992104989487, -2.0]\n  [-1, -1.0, -1.0]\n  [0, 0.0, 0.0]\n  [1, 1.0, 1.0]\n  [2, 1.25992104989487, 2.0]\n  [3, 1.44224957030741, 3.0]\n  [4, 1.5874010519682, 4.0]\n  [5, 1.7099759466767, 5.0]\n  [6, 1.81712059283214, 6.0]\n  [7, 1.91293118277239, 7.0]\n  [8, 2.0, 8.0]\n  [9, 2.0800838230519, 9.0]\n
cos Math.cos(p1)\nComputes the cosine of <i>x</i> (expressed in radians). Returns\n-1..1.\n
cosh Math.cosh(p1)\nComputes the hyperbolic cosine of <i>x</i> (expressed in radians).\n
erf Math.erf(p1)\nCalculates the error function of x.\n
erfc Math.erfc(p1)\nCalculates the complementary error function of x.\n
exp Math.exp(p1)\nReturns e**x.\n\n  Math.exp(0)       #=> 1.0\n  Math.exp(1)       #=> 2.718281828459045\n  Math.exp(1.5)     #=> 4.4816890703380645\n
frexp Math.frexp(p1)\nReturns a two-element array containing the normalized fraction (a\n`Float`) and exponent (a `Fixnum`) of\n<i>numeric</i>.\n\n   fraction, exponent = Math.frexp(1234)   #=> [0.6025390625, 11]\n   fraction * 2**exponent                  #=> 1234.0\n
gamma Math.gamma(p1)\nCalculates the gamma function of x.\n\nNote that gamma(n) is same as fact(n-1) for integer n > 0.\nHowever gamma(n) returns float and can be an approximation.\n\n def fact(n) (1..n).inject(1) {|r,i| r*i } end\n 1.upto(26) {|i| p [i, Math.gamma(i), fact(i-1)] }\n=> [1, 1.0, 1]\n   [2, 1.0, 1]\n   [3, 2.0, 2]\n   [4, 6.0, 6]\n   [5, 24.0, 24]\n   [6, 120.0, 120]\n   [7, 720.0, 720]\n   [8, 5040.0, 5040]\n   [9, 40320.0, 40320]\n   [10, 362880.0, 362880]\n   [11, 3628800.0, 3628800]\n   [12, 39916800.0, 39916800]\n   [13, 479001600.0, 479001600]\n   [14, 6227020800.0, 6227020800]\n   [15, 87178291200.0, 87178291200]\n   [16, 1307674368000.0, 1307674368000]\n   [17, 20922789888000.0, 20922789888000]\n   [18, 355687428096000.0, 355687428096000]\n   [19, 6.402373705728e+15, 6402373705728000]\n   [20, 1.21645100408832e+17, 121645100408832000]\n   [21, 2.43290200817664e+18, 2432902008176640000]\n   [22, 5.109094217170944e+19, 51090942171709440000]\n   [23, 1.1240007277776077e+21, 1124000727777607680000]\n   [24, 2.5852016738885062e+22, 25852016738884976640000]\n   [25, 6.204484017332391e+23, 620448401733239439360000]\n   [26, 1.5511210043330954e+25, 15511210043330985984000000]\n
hypot Math.hypot(p1, p2)\nReturns sqrt(x**2 + y**2), the hypotenuse of a right-angled triangle\nwith sides <i>x</i> and <i>y</i>.\n\n   Math.hypot(3, 4)   #=> 5.0\n
ldexp Math.ldexp(p1, p2)\nReturns the value of <i>flt</i>*(2**<i>int</i>).\n\n   fraction, exponent = Math.frexp(1234)\n   Math.ldexp(fraction, exponent)   #=> 1234.0\n
lgamma Math.lgamma(p1)\nCalculates the logarithmic gamma of x and\nthe sign of gamma of x.\n\nMath.lgamma(x) is same as\n [Math.log(Math.gamma(x).abs), Math.gamma(x) < 0 ? -1 : 1]\nbut avoid overflow by Math.gamma(x) for large x.\n
log Math.log(p1, p2 = v2)\nReturns the natural logarithm of <i>numeric</i>.\nIf additional second argument is given, it will be the base\nof logarithm.\n\n  Math.log(1)          #=> 0.0\n  Math.log(Math::E)    #=> 1.0\n  Math.log(Math::E**3) #=> 3.0\n  Math.log(12,3)       #=> 2.2618595071429146\n
log10 Math.log10(p1)\nReturns the base 10 logarithm of <i>numeric</i>.\n\n  Math.log10(1)       #=> 0.0\n  Math.log10(10)      #=> 1.0\n  Math.log10(10**100) #=> 100.0\n
log2 Math.log2(p1)\nReturns the base 2 logarithm of <i>numeric</i>.\n\n  Math.log2(1)      #=> 0.0\n  Math.log2(2)      #=> 1.0\n  Math.log2(32768)  #=> 15.0\n  Math.log2(65536)  #=> 16.0\n
rsqrt Math.rsqrt(a)\nCompute square root of a non negative number. This method is\ninternally used by +Math.sqrt+.\n
sin Math.sin(p1)\nComputes the sine of <i>x</i> (expressed in radians). Returns\n-1..1.\n
sinh Math.sinh(p1)\nComputes the hyperbolic sine of <i>x</i> (expressed in\nradians).\n
sqrt Math.sqrt(p1)\nReturns the non-negative square root of <i>numeric</i>.\n\n  0.upto(10) {|x|\n    p [x, Math.sqrt(x), Math.sqrt(x)**2]\n  }\n=>\n  [0, 0.0, 0.0]\n  [1, 1.0, 1.0]\n  [2, 1.4142135623731, 2.0]\n  [3, 1.73205080756888, 3.0]\n  [4, 2.0, 4.0]\n  [5, 2.23606797749979, 5.0]\n  [6, 2.44948974278318, 6.0]\n  [7, 2.64575131106459, 7.0]\n  [8, 2.82842712474619, 8.0]\n  [9, 3.0, 9.0]\n  [10, 3.16227766016838, 10.0]\n
tan Math.tan(p1)\nReturns the tangent of <i>x</i> (expressed in radians).\n
tanh Math.tanh(p1)\nComputes the hyperbolic tangent of <i>x</i> (expressed in\nradians).\n
activate Gem.activate(dep, *requirements)\nActivates an installed gem matching +dep+.  The gem must satisfy\n+requirements+.\n\nReturns true if the gem is activated, false if it is already\nloaded, or an exception otherwise.\n\nGem#activate adds the library paths in +dep+ to $LOAD_PATH.  Before a Gem\nis activated its required Gems are activated.  If the version information\nis omitted, the highest version Gem of the supplied name is loaded.  If a\nGem is not found that meets the version requirements or a required Gem is\nnot found, a Gem::LoadError is raised.\n\nMore information on version requirements can be found in the\nGem::Requirement and Gem::Version documentation.\n
all_load_paths Gem.all_load_paths()\nAn Array of all possible load paths for all versions of all gems in the\nGem installation.\n
available? Gem.available?(dep, *requirements)\nSee if a given gem is available.\n
bin_path Gem.bin_path(name, exec_name = nil, *requirements)\nFind the full path to the executable for gem +name+.  If the +exec_name+\nis not given, the gem's default_executable is chosen, otherwise the\nspecified executable's path is returned.  +requirements+ allows\nyou to specify specific gem versions.\n
binary_mode Gem.binary_mode()\nThe mode needed to read a file as straight binary.\n
bindir Gem.bindir(install_dir=Gem.dir)\nThe path where gem executables are to be installed.\n
cache_dir Gem.cache_dir(custom_dir=false)\nGet the appropriate cache path.\n\nPass a string to use a different base path, or nil/false (default) for\nGem.dir.\n
cache_gem Gem.cache_gem(filename, user_dir=false)\nGiven a gem path, find the gem in cache.\n\nPass a string as the second argument to use a different base path, or\nnil/false (default) for Gem.dir.\n
clear_paths Gem.clear_paths()\nReset the +dir+ and +path+ values.  The next time +dir+ or +path+\nis requested, the values will be calculated from scratch.  This is\nmainly used by the unit tests to provide test isolation.\n
config_file Gem.config_file()\nThe path to standard location of the user's .gemrc file.\n
configuration Gem.configuration()\nThe standard configuration object for gems.\n
configuration= Gem.configuration=(config)\nUse the given configuration object (which implements the ConfigFile\nprotocol) as the standard configuration object.\n
datadir Gem.datadir(gem_name)\nThe path the the data directory specified by the gem name.  If the\npackage is not available as a gem, return nil.\n
default_bindir Gem.default_bindir()\nThe default directory for binaries\n
default_dir Gem.default_dir()\nDefault home directory path to be used if an alternate value is not\nspecified in the environment\n
default_exec_format Gem.default_exec_format()\nDeduce Ruby's --program-prefix and --program-suffix from its install name\n
default_path Gem.default_path()\nDefault gem load path\n
default_rubygems_dirs Gem.default_rubygems_dirs()\nPaths where RubyGems' .rb files and bin files are installed\n
default_sources Gem.default_sources()\nAn Array of the default sources that come with RubyGems\n
default_system_source_cache_dir Gem.default_system_source_cache_dir()\nThe default system-wide source info cache directory\n
default_user_source_cache_dir Gem.default_user_source_cache_dir()\nThe default user-specific source info cache directory\n
deflate Gem.deflate(data)\nA Zlib::Deflate.deflate wrapper\n
dir Gem.dir()\nThe path where gems are to be installed.\n
ensure_gem_subdirectories Gem.ensure_gem_subdirectories(dir = Gem.dir)\nQuietly ensure the named Gem directory contains all the proper\nsubdirectories.  If we can't create a directory due to a permission\nproblem, then we will silently continue.\n
ensure_ssl_available Gem.ensure_ssl_available()\nEnsure that SSL is available.  Throw an exception if it is not.\n
find_files Gem.find_files(glob, check_load_path=true)\nReturns a list of paths matching +glob+ that can be used by a gem to pick\nup features from other gems.  For example:\n\n  Gem.find_files('rdoc/discover').each do |path| load path end\n\nif +check_load_path+ is true (the default), then find_files also searches\n$LOAD_PATH for files as well as gems.\n\nNote that find_files will return all files even if they are from different\nversions of the same gem.\n
gunzip Gem.gunzip(data)\nZlib::GzipReader wrapper that unzips +data+.\n
gzip Gem.gzip(data)\nZlib::GzipWriter wrapper that zips +data+.\n
host Gem.host()\nGet the default RubyGems API host. This is normally\n<tt>https://rubygems.org</tt>.\n
host= Gem.host=(host)\nSet the default RubyGems API host.\n
inflate Gem.inflate(data)\nA Zlib::Inflate#inflate wrapper\n
latest_load_paths Gem.latest_load_paths()\nReturn a list of all possible load paths for the latest version for all\ngems in the Gem installation.\n
latest_rubygems_version Gem.latest_rubygems_version()\n\n
latest_spec_for Gem.latest_spec_for(name)\n\n
latest_version_for Gem.latest_version_for(name)\n\n
load_env_plugins Gem.load_env_plugins()\nFind all 'rubygems_plugin' files in $LOAD_PATH and load them\n
load_path_insert_index Gem.load_path_insert_index()\nThe index to insert activated gem paths into the $LOAD_PATH.\n\nDefaults to the site lib directory unless gem_prelude.rb has loaded paths,\nthen it inserts the activated gem's paths before the gem_prelude.rb paths\nso you can override the gem_prelude.rb default $LOAD_PATH paths.\n
load_plugin_files Gem.load_plugin_files(plugins)\nLoad +plugins+ as ruby files\n
load_plugins Gem.load_plugins()\nFind all 'rubygems_plugin' files in installed gems and load them\n
load_yaml Gem.load_yaml()\nLoads YAML, preferring Psych\n
loaded_path? Gem.loaded_path?(path)\n\n
location_of_caller Gem.location_of_caller()\nThe file name and line number of the caller of the caller of this method.\n
marshal_version Gem.marshal_version()\nThe version of the Marshal format for your Ruby.\n
path Gem.path()\n\n
paths Gem.paths()\n\n
paths= Gem.paths=(env)\n\n
platforms Gem.platforms()\nArray of platforms this RubyGems supports.\n
platforms= Gem.platforms=(platforms)\nSet array of platforms this RubyGems supports (primarily for testing).\n
post_build Gem.post_build(&hook)\nAdds a post-build hook that will be passed an Gem::Installer instance\nwhen Gem::Installer#install is called.  The hook is called after the gem\nhas been extracted and extensions have been built but before the\nexecutables or gemspec has been written.  If the hook returns +false+ then\nthe gem's files will be removed and the install will be aborted.\n
post_install Gem.post_install(&hook)\nAdds a post-install hook that will be passed an Gem::Installer instance\nwhen Gem::Installer#install is called\n
post_reset Gem.post_reset(&hook)\nAdds a hook that will get run after Gem::Specification.reset is\nrun.\n
post_uninstall Gem.post_uninstall(&hook)\nAdds a post-uninstall hook that will be passed a Gem::Uninstaller instance\nand the spec that was uninstalled when Gem::Uninstaller#uninstall is\ncalled\n
pre_install Gem.pre_install(&hook)\nAdds a pre-install hook that will be passed an Gem::Installer instance\nwhen Gem::Installer#install is called.  If the hook returns +false+ then\nthe install will be aborted.\n
pre_reset Gem.pre_reset(&hook)\nAdds a hook that will get run before Gem::Specification.reset is\nrun.\n
pre_uninstall Gem.pre_uninstall(&hook)\nAdds a pre-uninstall hook that will be passed an Gem::Uninstaller instance\nand the spec that will be uninstalled when Gem::Uninstaller#uninstall is\ncalled\n
prefix Gem.prefix()\nThe directory prefix this RubyGems was installed at. If your\nprefix is in a standard location (ie, rubygems is installed where\nyou'd expect it to be), then prefix returns nil.\n
promote_load_path Gem.promote_load_path(gem_name, over_name)\nPromotes the load paths of the +gem_name+ over the load paths of\n+over_name+.  Useful for allowing one gem to override features in another\nusing #find_files.\n
read_binary Gem.read_binary(path)\nSafely read a file in binary mode on all platforms.\n
refresh Gem.refresh()\nRefresh source_index from disk and clear searcher.\n
required_location Gem.required_location(gemname, libfile, *requirements)\nFull path to +libfile+ in +gemname+.  Searches for the latest gem unless\n+requirements+ is given.\n
ruby Gem.ruby()\nThe path to the running Ruby interpreter.\n
ruby= Gem.ruby=(ruby)\nAllows setting path to ruby.  This method is available when requiring\n'rubygems/test_case'\n
ruby_engine Gem.ruby_engine()\nA wrapper around RUBY_ENGINE const that may not be defined\n
ruby_version Gem.ruby_version()\nA Gem::Version for the currently running ruby.\n
searcher Gem.searcher()\nThe GemPathSearcher object used to search for matching installed gems.\n
searcher= Gem.searcher=(searcher)\nAllows setting the gem path searcher.  This method is available when\nrequiring 'rubygems/test_case'\n
source_index Gem.source_index()\nReturns the Gem::SourceIndex of specifications that are in the Gem.path\n
source_index= Gem.source_index=(si)\nAllows setting the default SourceIndex.  This method is available when\nrequiring 'rubygems/test_case'\n
sources Gem.sources()\nReturns an Array of sources to fetch remote gems from.  If the sources\nlist is empty, attempts to load the "sources" gem, then uses\ndefault_sources if it is not installed.\n
sources= Gem.sources=(new_sources)\nNeed to be able to set the sources without calling\nGem.sources.replace since that would cause an infinite loop.\n
ssl_available? Gem.ssl_available?()\nIs SSL (used by the signing commands) available on this\nplatform?\n
suffix_pattern Gem.suffix_pattern()\nGlob pattern for require-able path suffixes.\n
suffixes Gem.suffixes()\nSuffixes for require-able paths.\n
time Gem.time(msg, width = 0, display = Gem.configuration.verbose)\nPrints the amount of time the supplied block takes to run using the debug\nUI output.\n
try_activate Gem.try_activate(path)\nTry to activate a gem containing +path+. Returns true if\nactivation succeeded or wasn't needed because it was already\nactivated. Returns false if it can't find the path in a gem.\n
ui Gem.ui()\nLazily loads DefaultUserInteraction and returns the default UI.\n
unresolved_deps Gem.unresolved_deps()\n\n
use_paths Gem.use_paths(home, *paths)\nUse the +home+ and +paths+ values for Gem.dir and Gem.path.  Used mainly\nby the unit tests to provide environment isolation.\n
user_dir Gem.user_dir()\nPath for gems in the user's home directory\n
user_home Gem.user_home()\nThe home directory for the user.\n
win_platform= Gem.win_platform=(val)\nAllows toggling Windows behavior.  This method is available when requiring\n'rubygems/test_case'\n
win_platform? Gem.win_platform?()\nIs this a windows platform?\n
cd FileUtils.cd(dir, options = {})\nOptions: verbose\n\nChanges the current directory to the directory +dir+.\n\nIf this method is called with block, resumes to the old\nworking directory after the block execution finished.\n\n  FileUtils.cd('/', :verbose => true)   # chdir and report it\n\n  FileUtils.cd('/') do  # chdir\n    [...]               # do something\n  end                   # return to original directory\n
chdir FileUtils.chdir(dir, options = {})\n\n
chmod FileUtils.chmod(mode, list, options = {})\nOptions: noop verbose\n\nChanges permission bits on the named files (in +list+) to the bit pattern\nrepresented by +mode+.\n\n+mode+ is the symbolic and absolute mode can be used.\n\nAbsolute mode is\n  FileUtils.chmod 0755, 'somecommand'\n  FileUtils.chmod 0644, %w(my.rb your.rb his.rb her.rb)\n  FileUtils.chmod 0755, '/usr/bin/ruby', :verbose => true\n\nSymbolic mode is\n  FileUtils.chmod "u=wrx,go=rx", 'somecommand'\n  FileUtils.chmod "u=wr,go=rr", %w(my.rb your.rb his.rb her.rb)\n  FileUtils.chmod "u=wrx,go=rx", '/usr/bin/ruby', :verbose => true\n\n  "a" is user, group, other mask.\n  "u" is user's mask.\n  "g" is group's mask.\n  "o" is other's mask.\n  "w" is write permission.\n  "r" is read permission.\n  "x" is execute permission.\n  "s" is uid, gid.\n  "t" is sticky bit.\n  "+" is added to a class given the specified mode.\n  "-" Is removed from a given class given mode.\n  "=" Is the exact nature of the class will be given a specified mode.\n
chmod_R FileUtils.chmod_R(mode, list, options = {})\nOptions: noop verbose force\n\nChanges permission bits on the named files (in +list+)\nto the bit pattern represented by +mode+.\n\n  FileUtils.chmod_R 0700, "/tmp/app.#{$$}"\n  FileUtils.chmod_R "u=wrx", "/tmp/app.#{$$}"\n
chown FileUtils.chown(user, group, list, options = {})\nOptions: noop verbose\n\nChanges owner and group on the named files (in +list+)\nto the user +user+ and the group +group+.  +user+ and +group+\nmay be an ID (Integer/String) or a name (String).\nIf +user+ or +group+ is nil, this method does not change\nthe attribute.\n\n  FileUtils.chown 'root', 'staff', '/usr/local/bin/ruby'\n  FileUtils.chown nil, 'bin', Dir.glob('/usr/bin/*'), :verbose => true\n
chown_R FileUtils.chown_R(user, group, list, options = {})\nOptions: noop verbose force\n\nChanges owner and group on the named files (in +list+)\nto the user +user+ and the group +group+ recursively.\n+user+ and +group+ may be an ID (Integer/String) or\na name (String).  If +user+ or +group+ is nil, this\nmethod does not change the attribute.\n\n  FileUtils.chown_R 'www', 'www', '/var/www/htdocs'\n  FileUtils.chown_R 'cvs', 'cvs', '/var/cvs', :verbose => true\n
cmp FileUtils.cmp(a, b)\n\n
compare_file FileUtils.compare_file(a, b)\nReturns true if the contents of a file A and a file B are identical.\n\n  FileUtils.compare_file('somefile', 'somefile')  #=> true\n  FileUtils.compare_file('/bin/cp', '/bin/mv')    #=> maybe false\n
compare_stream FileUtils.compare_stream(a, b)\nReturns true if the contents of a stream +a+ and +b+ are identical.\n
copy FileUtils.copy(src, dest, options = {})\n\n
copy_entry FileUtils.copy_entry(src, dest, preserve = false, dereference_root = false,\nremove_destination = false)\nCopies a file system entry +src+ to +dest+.\nIf +src+ is a directory, this method copies its contents recursively.\nThis method preserves file types, c.f. symlink, directory...\n(FIFO, device files and etc. are not supported yet)\n\nBoth of +src+ and +dest+ must be a path name.\n+src+ must exist, +dest+ must not exist.\n\nIf +preserve+ is true, this method preserves owner, group, permissions\nand modified time.\n\nIf +dereference_root+ is true, this method dereference tree root.\n\nIf +remove_destination+ is true, this method removes each destination file\nbefore copy.\n
copy_file FileUtils.copy_file(src, dest, preserve = false, dereference = true)\nCopies file contents of +src+ to +dest+.\nBoth of +src+ and +dest+ must be a path name.\n
copy_stream FileUtils.copy_stream(src, dest)\nCopies stream +src+ to +dest+.\n+src+ must respond to #read(n) and\n+dest+ must respond to #write(str).\n
cp FileUtils.cp(src, dest, options = {})\nOptions: preserve noop verbose\n\nCopies a file content +src+ to +dest+.  If +dest+ is a directory,\ncopies +src+ to +dest/src+.\n\nIf +src+ is a list of files, then +dest+ must be a directory.\n\n  FileUtils.cp 'eval.c', 'eval.c.org'\n  FileUtils.cp %w(cgi.rb complex.rb date.rb), '/usr/lib/ruby/1.6'\n  FileUtils.cp %w(cgi.rb complex.rb date.rb), '/usr/lib/ruby/1.6', :verbose\n  => true\n  FileUtils.cp 'symlink', 'dest'   # copy content, "dest" is not a symlink\n
cp_r FileUtils.cp_r(src, dest, options = {})\nOptions: preserve noop verbose dereference_root remove_destination\n\nCopies +src+ to +dest+. If +src+ is a directory, this method copies\nall its contents recursively. If +dest+ is a directory, copies\n+src+ to +dest/src+.\n\n+src+ can be a list of files.\n Installing ruby library "mylib" under the site_ruby\n  FileUtils.rm_r site_ruby + '/mylib', :force\n  FileUtils.cp_r 'lib/', site_ruby + '/mylib'\n Examples of copying several files to target directory.\n  FileUtils.cp_r %w(mail.rb field.rb debug/), site_ruby + '/tmail'\n  FileUtils.cp_r Dir.glob('*.rb'), '/home/aamine/lib/ruby', :noop => true,\n  :verbose => true\n If you want to copy all contents of a directory instead of the\n directory itself, c.f. src/x -> dest/x, src/y -> dest/y,\n use following code.\n  FileUtils.cp_r 'src/.', 'dest'     # cp_r('src', 'dest') makes src/dest,\n but this doesn't.\n
getwd FileUtils.getwd()\n\n
identical? FileUtils.identical?(a, b)\n\n
install FileUtils.install(src, dest, options = {})\nOptions: mode preserve noop verbose\n\nIf +src+ is not same as +dest+, copies it and changes the permission\nmode to +mode+.  If +dest+ is a directory, destination is +dest+/+src+.\nThis method removes destination before copy.\n\n  FileUtils.install 'ruby', '/usr/local/bin/ruby', :mode => 0755, :verbose\n  => true\n  FileUtils.install 'lib.rb', '/usr/local/lib/ruby/site_ruby', :verbose => true\n
link FileUtils.link(src, dest, options = {})\n\n
ln FileUtils.ln(src, dest, options = {})\nOptions: force noop verbose\n\n<b><tt>ln(old, new, options = {})</tt></b>\n\nCreates a hard link +new+ which points to +old+.\nIf +new+ already exists and it is a directory, creates a link +new/old+.\nIf +new+ already exists and it is not a directory, raises Errno::EEXIST.\nBut if :force option is set, overwrite +new+.\n\n  FileUtils.ln 'gcc', 'cc', :verbose => true\n  FileUtils.ln '/usr/bin/emacs21', '/usr/bin/emacs'\n\n<b><tt>ln(list, destdir, options = {})</tt></b>\n\nCreates several hard links in a directory, with each one pointing to the\nitem in +list+.  If +destdir+ is not a directory, raises Errno::ENOTDIR.\n\n  include FileUtils\n  cd '/sbin'\n  FileUtils.ln %w(cp mv mkdir), '/bin'   # Now /sbin/cp and /bin/cp are linked.\n
ln_s FileUtils.ln_s(src, dest, options = {})\nOptions: force noop verbose\n\n<b><tt>ln_s(old, new, options = {})</tt></b>\n\nCreates a symbolic link +new+ which points to +old+.  If +new+ already\nexists and it is a directory, creates a symbolic link +new/old+.  If +new+\nalready exists and it is not a directory, raises Errno::EEXIST.  But if\n:force option is set, overwrite +new+.\n\n  FileUtils.ln_s '/usr/bin/ruby', '/usr/local/bin/ruby'\n  FileUtils.ln_s 'verylongsourcefilename.c', 'c', :force => true\n\n<b><tt>ln_s(list, destdir, options = {})</tt></b>\n\nCreates several symbolic links in a directory, with each one pointing to the\nitem in +list+.  If +destdir+ is not a directory, raises Errno::ENOTDIR.\n\nIf +destdir+ is not a directory, raises Errno::ENOTDIR.\n\n  FileUtils.ln_s Dir.glob('bin/*.rb'), '/home/aamine/bin'\n
ln_sf FileUtils.ln_sf(src, dest, options = {})\nOptions: noop verbose\n\nSame as\nln_s(src, dest, :force)\n
makedirs FileUtils.makedirs(list, options = {})\n\n
mkdir FileUtils.mkdir(list, options = {})\nOptions: mode noop verbose\n\nCreates one or more directories.\n\n  FileUtils.mkdir 'test'\n  FileUtils.mkdir %w( tmp data )\n  FileUtils.mkdir 'notexist', :noop => true  # Does not really create.\n  FileUtils.mkdir 'tmp', :mode => 0700\n
mkdir_p FileUtils.mkdir_p(list, options = {})\nOptions: mode noop verbose\n\nCreates a directory and all its parent directories.\nFor example,\n\n  FileUtils.mkdir_p '/usr/local/lib/ruby'\n\ncauses to make following directories, if it does not exist.\n    * /usr\n    * /usr/local\n    * /usr/local/lib\n    * /usr/local/lib/ruby\n\nYou can pass several directories at a time in a list.\n
mkpath FileUtils.mkpath(list, options = {})\n\n
move FileUtils.move(src, dest, options = {})\n\n
mv FileUtils.mv(src, dest, options = {})\nOptions: force noop verbose\n\nMoves file(s) +src+ to +dest+.  If +file+ and +dest+ exist on the different\ndisk partition, the file is copied then the original file is removed.\n\n  FileUtils.mv 'badname.rb', 'goodname.rb'\n  FileUtils.mv 'stuff.rb', '/notexist/lib/ruby', :force => true  # no error\n\n  FileUtils.mv %w(junk.txt dust.txt), '/home/aamine/.trash/'\n  FileUtils.mv Dir.glob('test*.rb'), 'test', :noop => true, :verbose => true\n
pwd FileUtils.pwd()\nOptions: (none)\n\nReturns the name of the current directory.\n
remove FileUtils.remove(list, options = {})\n\n
remove_dir FileUtils.remove_dir(path, force = false)\nRemoves a directory +dir+ and its contents recursively.\nThis method ignores StandardError if +force+ is true.\n
remove_entry FileUtils.remove_entry(path, force = false)\nThis method removes a file system entry +path+.\n+path+ might be a regular file, a directory, or something.\nIf +path+ is a directory, remove it recursively.\n\nSee also #remove_entry_secure.\n
remove_entry_secure FileUtils.remove_entry_secure(path, force = false)\nThis method removes a file system entry +path+.  +path+ shall be a\nregular file, a directory, or something.  If +path+ is a directory,\nremove it recursively.  This method is required to avoid TOCTTOU\n(time-of-check-to-time-of-use) local security vulnerability of #rm_r.\nrm_r causes security hole when:\n\n  * Parent directory is world writable (including /tmp).\n  * Removing directory tree includes world writable directory.\n  * The system has symbolic link.\n\nTo avoid this security hole, this method applies special preprocess.\nIf +path+ is a directory, this method chown(2) and chmod(2) all\nremoving directories.  This requires the current process is the\nowner of the removing whole directory tree, or is the super user (root).\n\nWARNING: You must ensure that *ALL* parent directories cannot be\nmoved by other untrusted users.  For example, parent directories\nshould not be owned by untrusted users, and should not be world\nwritable except when the sticky bit set.\n\nWARNING: Only the owner of the removing directory tree, or Unix super\nuser (root) should invoke this method.  Otherwise this method does not\nwork.\n\nFor details of this security vulnerability, see Perl's case:\n\n  http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CAN-2005-0448\n  http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CAN-2004-0452\n\nFor fileutils.rb, this vulnerability is reported in [ruby-dev:26100].\n
remove_file FileUtils.remove_file(path, force = false)\nRemoves a file +path+.\nThis method ignores StandardError if +force+ is true.\n
rm FileUtils.rm(list, options = {})\nOptions: force noop verbose\n\nRemove file(s) specified in +list+.  This method cannot remove directories.\nAll StandardErrors are ignored when the :force option is set.\n\n  FileUtils.rm %w( junk.txt dust.txt )\n  FileUtils.rm Dir.glob('*.so')\n  FileUtils.rm 'NotExistFile', :force => true   # never raises exception\n
rm_f FileUtils.rm_f(list, options = {})\nOptions: noop verbose\n\nEquivalent to\nrm(list, :force => true)\n
rm_r FileUtils.rm_r(list, options = {})\nOptions: force noop verbose secure\n\nremove files +list+[0] +list+[1]... If +list+[n] is a directory,\nremoves its all contents recursively. This method ignores\nStandardError when :force option is set.\n\n  FileUtils.rm_r Dir.glob('/tmp/*')\n  FileUtils.rm_r '/', :force => true          #  :-)\n\nWARNING: This method causes local vulnerability\nif one of parent directories or removing directory tree are world\nwritable (including /tmp, whose permission is 1777), and the current\nprocess has strong privilege such as Unix super user (root), and the\nsystem has symbolic link.  For secure removing, read the documentation\nof #remove_entry_secure carefully, and set :secure option to true.\nDefault is :secure=>false.\n\nNOTE: This method calls #remove_entry_secure if :secure option is set.\nSee also #remove_entry_secure.\n
rm_rf FileUtils.rm_rf(list, options = {})\nOptions: noop verbose secure\n\nEquivalent to\nrm_r(list, :force => true)\n\nWARNING: This method causes local vulnerability.\nRead the documentation of #rm_r first.\n
rmdir FileUtils.rmdir(list, options = {})\nOptions: noop, verbose\n\nRemoves one or more directories.\n\n  FileUtils.rmdir 'somedir'\n  FileUtils.rmdir %w(somedir anydir otherdir)\n Does not really remove directory; outputs message.\n  FileUtils.rmdir 'somedir', :verbose => true, :noop => true\n
rmtree FileUtils.rmtree(list, options = {})\n\n
safe_unlink FileUtils.safe_unlink(list, options = {})\n\n
symlink FileUtils.symlink(src, dest, options = {})\n\n
touch FileUtils.touch(list, options = {})\nOptions: noop verbose\n\nUpdates modification time (mtime) and access time (atime) of file(s) in\n+list+.  Files are created if they don't exist.\n\n  FileUtils.touch 'timestamp'\n  FileUtils.touch Dir.glob('*.c');  system 'make'\n
uptodate? FileUtils.uptodate?(new, old_list, options = nil)\nOptions: (none)\n\nReturns true if +newer+ is newer than all +old_list+.\nNon-existent files are older than any file.\n\n  FileUtils.uptodate?('hello.o', %w(hello.c hello.h)) or \\n      system 'make hello.o'\n
ruby FileUtils.ruby(*args,&block)\nRun a Ruby interpreter with the given arguments.\n\nExample:\n  ruby %{-pe '$_.upcase!' <README}\n
safe_ln FileUtils.safe_ln(*args)\nAttempt to do a normal file link, but fall back to a copy if the link\nfails.\n
sh FileUtils.sh(*cmd, &block)\nRun the system command +cmd+. If multiple arguments are given the command\nis not run with the shell (same semantics as Kernel::exec and\nKernel::system).\n\nExample:\n  sh %{ls -ltr}\n\n  sh 'ls', 'file with spaces'\n check exit status after command runs\n  sh %{grep pattern file} do |ok, res|\n    if ! ok\n      puts "pattern not found (status = #{res.exitstatus})"\n    end\n  end\n
split_all FileUtils.split_all(path)\nSplit a file path into individual directory names.\n\nExample:\n  split_all("a/b/c") =>  ['a', 'b', 'c']\n
each_strongly_connected_component TSort.each_strongly_connected_component()\nThe iterator version of the #strongly_connected_components method.\n<tt><em>obj</em>.each_strongly_connected_component</tt> is similar to\n<tt><em>obj</em>.strongly_connected_components.each</tt>, but\nmodification of _obj_ during the iteration may lead to unexpected results.\neach_strongly_connected_component returns +nil+.\n
each_strongly_connected_component_from TSort.each_strongly_connected_component_from(node, id_map={}, stack=[])\nIterates over strongly connected component in the subgraph reachable from\n_node_.\n\nReturn value is unspecified.\neach_strongly_connected_component_from doesn't call #tsort_each_node.\n
strongly_connected_components TSort.strongly_connected_components()\nReturns strongly connected components as an array of arrays of nodes.\nThe array is sorted from children to parents.\nEach elements of the array represents a strongly connected component.\n
tsort TSort.tsort()\nReturns a topologically sorted array of nodes.\nThe array is sorted from children to parents, i.e.\nthe first element has no child and the last node has no parent.\n\nIf there is a cycle, TSort::Cyclic is raised.\n
tsort_each TSort.tsort_each()\nThe iterator version of the #tsort method.\n<tt><em>obj</em>.tsort_each</tt> is similar to\n<tt><em>obj</em>.tsort.each</tt>, but\nmodification of _obj_ during the iteration may lead to unexpected results.\ntsort_each returns +nil+.\nIf there is a cycle, TSort::Cyclic is raised.\n
tsort_each_child TSort.tsort_each_child(node)\nShould be implemented by a extended class.\ntsort_each_child is used to iterate for child nodes of _node_.\n
tsort_each_node TSort.tsort_each_node()\nShould be implemented by a extended class.\ntsort_each_node is used to iterate for all nodes over a graph.\n
check_inspect_key PP::PPMethods.check_inspect_key(id)\n\n
comma_breakable PP::PPMethods.comma_breakable()\nA convenience method which is same as follows:\n\n  text ','\n  breakable\n
guard_inspect_key PP::PPMethods.guard_inspect_key()\n\n
object_address_group PP::PPMethods.object_address_group(obj, &block)\n\n
object_group PP::PPMethods.object_group(obj)\nA convenience method which is same as follows:\n\n  group(1, '#<' + obj.class.name, '>') { ... }\n
pop_inspect_key PP::PPMethods.pop_inspect_key(id)\n\n
pp PP::PPMethods.pp(obj)\nAdds +obj+ to the pretty printing buffer\nusing Object#pretty_print or Object#pretty_print_cycle.\n\nObject#pretty_print_cycle is used when +obj+ is already\nprinted, a.k.a the object reference chain has a cycle.\n
pp_hash PP::PPMethods.pp_hash(obj)\n\n
pp_object PP::PPMethods.pp_object(obj)\n\n
push_inspect_key PP::PPMethods.push_inspect_key(id)\n\n
seplist PP::PPMethods.seplist(list, sep=nil, iter_method=:each)\nAdds a separated list.\nThe list is separated by comma with breakable space, by default.\nseplist iterates the +list+ using +iter_method+.\nIt yields each object to the block given for #seplist.\nThe procedure +separator_proc+ is called between each yields.\n\nIf the iteration is zero times, +separator_proc+ is not called at all.\n\nIf +separator_proc+ is nil or not given,\n+lambda { comma_breakable }+ is used.\nIf +iter_method+ is not given, :each is used.\n\nFor example, following 3 code fragments has similar effect.\n\n  q.seplist([1,2,3]) {|v| xxx v }\n\n  q.seplist([1,2,3], lambda { q.comma_breakable }, :each) {|v| xxx v }\n\n  xxx 1\n  q.comma_breakable\n  xxx 2\n  q.comma_breakable\n  xxx 3\n
pretty_print PP::ObjectMixin.pretty_print(q)\nA default pretty printing method for general objects.\nIt calls #pretty_print_instance_variables to list instance variables.\n\nIf +self+ has a customized (redefined) #inspect method,\nthe result of self.inspect is used but it obviously has no\nline break hints.\n\nThis module provides predefined #pretty_print methods for some of\nthe most commonly used built-in classes for convenience.\n
pretty_print_cycle PP::ObjectMixin.pretty_print_cycle(q)\nA default pretty printing method for general objects that are\ndetected as part of a cycle.\n
pretty_print_inspect PP::ObjectMixin.pretty_print_inspect()\nIs #inspect implementation using #pretty_print.\nIf you implement #pretty_print, it can be used as follows.\n\n  alias inspect pretty_print_inspect\n\nHowever, doing this requires that every class that #inspect is called on\nimplement #pretty_print, or a RuntimeError will be raised.\n
pretty_print_instance_variables PP::ObjectMixin.pretty_print_instance_variables()\nReturns a sorted array of instance variable names.\n\nThis method should return an array of names of instance variables as symbols\nor strings as:\n+[:@a, :@b]+.\n
aref_to RDoc::Generator::Markup.aref_to(target_path)\nGenerates a relative URL from this object's path to +target_path+\n
as_href RDoc::Generator::Markup.as_href(from_path)\nGenerates a relative URL from +from_path+ to this object's path\n
cvs_url RDoc::Generator::Markup.cvs_url(url, full_path)\nBuild a webcvs URL starting for the given +url+ with +full_path+ appended\nas the destination path.  If +url+ contains '%s' +full_path+ will be\nsprintf'd into +url+ instead.\n
description RDoc::Generator::Markup.description()\nHandy wrapper for marking up this object's comment\n
formatter RDoc::Generator::Markup.formatter()\nCreates an RDoc::Markup::ToHtmlCrossref formatter\n
each RDoc::RI::Paths.each(system, site, home, gems, *extra_dirs)\nIterates over each selected path yielding the directory and type.\n\nYielded types:\n:system:: Where Ruby's ri data is stored.  Yielded when +system+ is\n          true\n:site:: Where ri for installed libraries are stored.  Yielded when\n        +site+ is true.  Normally no ri data is stored here.\n:home:: ~/.rdoc.  Yielded when +home+ is true.\n:gem:: ri data for an installed gem.  Yielded when +gems+ is true.\n:extra:: ri data directory from the command line.  Yielded for each\n         entry in +extra_dirs+\n
gemdirs RDoc::RI::Paths.gemdirs()\nThe latest installed gems' ri directories\n
path RDoc::RI::Paths.path(system, site, home, gems, *extra_dirs)\nReturns existing directories from the selected documentation directories\nas an Array.\n\nSee also ::each\n
raw_path RDoc::RI::Paths.raw_path(system, site, home, gems, *extra_dirs)\nReturns selected documentation directories including nonexistent\ndirectories.\n\nSee also ::each\n
read_file RDoc::Encoding.read_file(filename, encoding, force_transcode = false)\nReads the contents of +filename+ and handles any encoding directives in\nthe file.\n\nThe content will be converted to the +encoding+.  If the file cannot be\nconverted a warning will be printed and nil will be returned.\n\nIf +force_transcode+ is true the document will be transcoded and any\nunknown character in the target encoding will be replaced with '?'\n
set_encoding RDoc::Encoding.set_encoding(string)\nSets the encoding of +string+ based on the magic comment\n
add_token_listener RDoc::Parser::RubyTools.add_token_listener(obj)\nAdds a token listener +obj+, but you should probably use token_listener\n
get_tk RDoc::Parser::RubyTools.get_tk()\nFetches the next token from the scanner\n
get_tk_until RDoc::Parser::RubyTools.get_tk_until(*tokens)\nReads and returns all tokens up to one of +tokens+.  Leaves the matched\ntoken in the token list.\n
get_tkread RDoc::Parser::RubyTools.get_tkread()\nRetrieves a String representation of the read tokens\n
peek_read RDoc::Parser::RubyTools.peek_read()\nPeek equivalent for get_tkread\n
peek_tk RDoc::Parser::RubyTools.peek_tk()\nPeek at the next token, but don't remove it from the stream\n
remove_token_listener RDoc::Parser::RubyTools.remove_token_listener(obj)\nRemoves the token listener +obj+\n
reset RDoc::Parser::RubyTools.reset()\nResets the tools\n
skip_tkspace RDoc::Parser::RubyTools.skip_tkspace(skip_nl = true)\nSkips whitespace tokens including newlines if +skip_nl+ is true\n
token_listener RDoc::Parser::RubyTools.token_listener(obj)\nHas +obj+ listen to tokens\n
unget_tk RDoc::Parser::RubyTools.unget_tk(tk)\nReturns +tk+ to the scanner\n
add_token RDoc::TokenStream.add_token(*tokens)\n\n
add_tokens RDoc::TokenStream.add_tokens(*tokens)\nAdds +tokens+ to the collected tokens\n
collect_tokens RDoc::TokenStream.collect_tokens()\nStarts collecting tokens\n
pop_token RDoc::TokenStream.pop_token()\nRemove the last token from the collected tokens\n
start_collecting_tokens RDoc::TokenStream.start_collecting_tokens()\n\n
token_stream RDoc::TokenStream.token_stream()\nCurrent token stream\n
tokens_to_s RDoc::TokenStream.tokens_to_s()\nReturns a string representation of the token stream\n
encode_fallback RDoc::Text.encode_fallback(character, encoding, fallback)\nTranscodes +character+ to +encoding+ with a +fallback+ character.\n
expand_tabs RDoc::Text.expand_tabs(text)\nExpands tab characters in +text+ to eight spaces\n
flush_left RDoc::Text.flush_left(text)\nFlush +text+ left based on the shortest line\n
markup RDoc::Text.markup(text)\nConvert a string in markup format into HTML.\n\nRequires the including class to implement #formatter\n
normalize_comment RDoc::Text.normalize_comment(text)\nStrips hashes, expands tabs then flushes +text+ to the left\n
parse RDoc::Text.parse(text)\nNormalizes +text+ then builds a RDoc::Markup::Document from it\n
strip_hashes RDoc::Text.strip_hashes(text)\nStrips leading # characters from +text+\n
strip_newlines RDoc::Text.strip_newlines(text)\nStrips leading and trailing \\n characters from +text+\n
strip_stars RDoc::Text.strip_stars(text)\nStrips /* */ style comments\n
to_html RDoc::Text.to_html(text)\nConverts ampersand, dashes, ellipsis, quotes, copyright and registered\ntrademark symbols in +text+ to properly encoded characters.\n
wrap RDoc::Text.wrap(txt, line_len = 76)\nWraps +txt+ to +line_len+\n
CurrentContext IRB.CurrentContext()\n\n
Inspector IRB.Inspector(inspect, init = nil)\n\n
JobManager IRB.JobManager()\n\n
conf IRB.conf()\n\n
delete_caller IRB.delete_caller()\n\n
init_config IRB.init_config(ap_path)\n@CONF default setting\n
init_error IRB.init_error()\n\n
initialize_tracer IRB.initialize_tracer()\ninitialize tracing function\n
irb IRB.irb(file = nil, *main)\ninvoke multi-irb\n
irb_abort IRB.irb_abort(irb, exception = Abort)\n\n
irb_at_exit IRB.irb_at_exit()\n\n
irb_exit IRB.irb_exit(irb, ret)\n\n
load_modules IRB.load_modules()\nloading modules\n
parse_opts IRB.parse_opts()\noption analyzing\n
print_usage IRB.print_usage()\n\n
rc_file IRB.rc_file(ext = IRBRC_EXT)\n\n
rc_file_generators IRB.rc_file_generators()\nenumerate possible rc-file base name generators\n
run_config IRB.run_config()\nrunning config\n
setup IRB.setup(ap_path)\ninitialize config\n
start IRB.start(ap_path = nil)\ninitialize IRB and start TOP_LEVEL irb\n
version IRB.version()\nIRB version method\n
def_notifier IRB::Notifier.def_notifier(prefix = "", output_method = StdioOutputMethod.new)\n\n
def_token RubyToken.def_token(token_n, super_token = Token, reading = nil, *opts)\n\n
Token RubyToken.Token(token, value = nil)\n\n
select_message IRB::InputCompletor.select_message(receiver, message, candidates, sep = ".")\n\n
def_extend_command IRB::ExtendCommandBundle.def_extend_command(cmd_name, cmd_class, load_file =\nnil, *aliases)\naliases = [commands_alias, flag], ...\n
extend_object IRB::ExtendCommandBundle.extend_object(obj)\n\n
install_extend_commands IRB::ExtendCommandBundle.install_extend_commands()\n\n
irb_original_method_name IRB::ExtendCommandBundle.irb_original_method_name(method_name)\n\n
install_alias_method IRB::ExtendCommandBundle.install_alias_method(to, from, override = NO_OVERRIDE)\noverride = {NO_OVERRIDE, OVERRIDE_PRIVATE_ONLY, OVERRIDE_ALL}\n
irb_context IRB::ExtendCommandBundle.irb_context()\n\n
irb_exit IRB::ExtendCommandBundle.irb_exit(ret = 0)\n\n
irb_load IRB::ExtendCommandBundle.irb_load(*opts, &b)\n\n
irb_require IRB::ExtendCommandBundle.irb_require(*opts, &b)\n\n
def_extend_command IRB::ExtendCommandBundle::EXCB.def_extend_command(cmd_name, cmd_class,\nload_file = nil, *aliases)\naliases = [commands_alias, flag], ...\n
extend_object IRB::ExtendCommandBundle::EXCB.extend_object(obj)\n\n
install_extend_commands IRB::ExtendCommandBundle::EXCB.install_extend_commands()\n\n
irb_original_method_name IRB::ExtendCommandBundle::EXCB.irb_original_method_name(method_name)\n\n
install_alias_method IRB::ExtendCommandBundle::EXCB.install_alias_method(to, from, override =\nNO_OVERRIDE)\noverride = {NO_OVERRIDE, OVERRIDE_PRIVATE_ONLY, OVERRIDE_ALL}\n
irb_context IRB::ExtendCommandBundle::EXCB.irb_context()\n\n
irb_exit IRB::ExtendCommandBundle::EXCB.irb_exit(ret = 0)\n\n
irb_load IRB::ExtendCommandBundle::EXCB.irb_load(*opts, &b)\n\n
irb_require IRB::ExtendCommandBundle::EXCB.irb_require(*opts, &b)\n\n
def_extend_command IRB::ContextExtender.def_extend_command(cmd_name, load_file, *aliases)\n\n
install_extend_commands IRB::ContextExtender.install_extend_commands()\n\n
def_extend_command IRB::ContextExtender::CE.def_extend_command(cmd_name, load_file, *aliases)\n\n
install_extend_commands IRB::ContextExtender::CE.install_extend_commands()\n\n
def_post_proc IRB::MethodExtender.def_post_proc(base_method, extend_method)\n\n
def_pre_proc IRB::MethodExtender.def_pre_proc(base_method, extend_method)\n\n
new_alias_name IRB::MethodExtender.new_alias_name(name, prefix = "__alias_of__", postfix =\n"__")\nreturn #{prefix}#{name}#{postfix}<num>\n
def_inspector IRB::INSPECTORS.def_inspector(key, arg=nil, &block)\nex)\nINSPECTORS.def_inspector(key, init_p=nil){|v| v.inspect}\nINSPECTORS.def_inspector([key1,..], init_p=nil){|v| v.inspect}\nINSPECTORS.def_inspector(key, inspector)\nINSPECTORS.def_inspector([key1,...], inspector)\n
keys_with_inspector IRB::INSPECTORS.keys_with_inspector(inspector)\n\n
extended IRB::HistorySavingAbility.extended(obj)\ndef HistorySavingAbility.create_finalizer\n  proc do\n  if num = IRB.conf[:SAVE_HISTORY] and (num = num.to_i) > 0\n    if hf = IRB.conf[:HISTORY_FILE]\n      file = File.expand_path(hf)\n    end\n    file = IRB.rc_file("_history") unless file\n    open(file, 'w' ) do |f|\n      hist = HISTORY.to_a\n      f.puts(hist[-num..-1] || hist)\n    end\n  end\n  end\nend\n
load_history IRB::HistorySavingAbility.load_history()\n\n
save_history IRB::HistorySavingAbility.save_history()\n\n
irb_load IRB::IrbLoader.irb_load(fn, priv = nil)\n\n
load_file IRB::IrbLoader.load_file(path, priv = nil)\n\n
old IRB::IrbLoader.old()\n\n
search_file_from_ruby_path IRB::IrbLoader.search_file_from_ruby_path(fn)\n\n
source_file IRB::IrbLoader.source_file(path)\n\n
abbrev Abbrev.abbrev(words, pattern = nil)\nGiven a set of strings, calculate the set of unambiguous\nabbreviations for those strings, and return a hash where the keys\nare all the possible abbreviations and the values are the full\nstrings. Thus, given input of "car" and "cone", the keys pointing\nto "car" would be "ca" and "car", while those pointing to "cone"\nwould be "co", "con", and "cone".\n\nThe optional +pattern+ parameter is a pattern or a string. Only\nthose input strings matching the pattern, or begging the string,\nare considered for inclusion in the output hash\n
config DRb.config()\nGet the configuration of the current server.\n\nIf there is no current server, this returns the default configuration.\nSee #current_server and DRbServer::make_config.\n
current_server DRb.current_server()\nGet the 'current' server.\n\nIn the context of execution taking place within the main\nthread of a dRuby server (typically, as a result of a remote\ncall on the server or one of its objects), the current\nserver is that server.  Otherwise, the current server is\nthe primary server.\n\nIf the above rule fails to find a server, a DRbServerNotFound\nerror is raised.\n
fetch_server DRb.fetch_server(uri)\n\n
front DRb.front()\nGet the front object of the current server.\n\nThis raises a DRbServerNotFound error if there is no current server.\nSee #current_server.\n
here? DRb.here?(uri)\nIs +uri+ the URI for the current local server?\n
install_acl DRb.install_acl(acl)\nSet the default acl.\n\nSee DRb::DRbServer.default_acl.\n
install_id_conv DRb.install_id_conv(idconv)\nSet the default id conv object.\n\nSee DRbServer#default_id_conv.\n
mutex DRb.mutex()\n\n
regist_server DRb.regist_server(server)\n\n
remove_server DRb.remove_server(server)\n\n
start_service DRb.start_service(uri=nil, front=nil, config=nil)\nStart a dRuby server locally.\n\nThe new dRuby server will become the primary server, even\nif another server is currently the primary server.\n\n+uri+ is the URI for the server to bind to.  If nil,\nthe server will bind to random port on the default local host\nname and use the default dRuby protocol.\n\n+front+ is the server's front object.  This may be nil.\n\n+config+ is the configuration for the new server.  This may\nbe nil.\n\nSee DRbServer::new.\n
stop_service DRb.stop_service()\nStop the local dRuby server.\n\nThis operates on the primary server.  If there is no primary\nserver currently running, it is a noop.\n
thread DRb.thread()\nGet the thread of the primary server.\n\nThis returns nil if there is no primary server.  See #primary_server.\n
to_id DRb.to_id(obj)\nGet a reference id for an object using the current server.\n\nThis raises a DRbServerNotFound error if there is no current server.\nSee #current_server.\n
to_obj DRb.to_obj(ref)\nConvert a reference into an object using the current server.\n\nThis raises a DRbServerNotFound error if there is no current server.\nSee #current_server.\n
uri DRb.uri()\nGet the URI defining the local dRuby space.\n\nThis is the URI of the current server.  See #current_server.\n
add_protocol DRb::DRbProtocol.add_protocol(prot)\nAdd a new protocol to the DRbProtocol module.\n
open DRb::DRbProtocol.open(uri, config, first=true)\nOpen a client connection to +uri+ with the configuration +config+.\n\nThe DRbProtocol module asks each registered protocol in turn to\ntry to open the URI.  Each protocol signals that it does not handle that\nURI by raising a DRbBadScheme error.  If no protocol recognises the\nURI, then a DRbBadURI error is raised.  If a protocol accepts the\nURI, but an error occurs in opening it, a DRbConnError is raised.\n
open_server DRb::DRbProtocol.open_server(uri, config, first=true)\nOpen a server listening for connections at +uri+ with\nconfiguration +config+.\n\nThe DRbProtocol module asks each registered protocol in turn to\ntry to open a server at the URI.  Each protocol signals that it does\nnot handle that URI by raising a DRbBadScheme error.  If no protocol\nrecognises the URI, then a DRbBadURI error is raised.  If a protocol\naccepts the URI, but an error occurs in opening it, the underlying\nerror is passed on to the caller.\n
uri_option DRb::DRbProtocol.uri_option(uri, config, first=true)\nParse +uri+ into a [uri, option] pair.\n\nThe DRbProtocol module asks each registered protocol in turn to\ntry to parse the URI.  Each protocol signals that it does not handle that\nURI by raising a DRbBadScheme error.  If no protocol recognises the\nURI, then a DRbBadURI error is raised.\n
block_yield DRb::DRbServer::InvokeMethod18Mixin.block_yield(x)\n\n
perform_with_block DRb::DRbServer::InvokeMethod18Mixin.perform_with_block()\n\n
notify_observers DRb::DRbObservable.notify_observers(*arg)\n\n
iPIMethods XMLRPC.iPIMethods(prefix)\nshort-cut for creating a PublicInstanceMethodsInterface\n
interface XMLRPC.interface(prefix, &p)\nshort-form to create a Service::Interface\n
set_parser XMLRPC::ParserWriterChooseMixin.set_parser(parser)\n\n
set_writer XMLRPC::ParserWriterChooseMixin.set_writer(writer)\n\n
parse_content_type XMLRPC::ParseContentType.parse_content_type(str)\n\n
each_installed_writer XMLRPC::XMLWriter.each_installed_writer()\nyields an instance of each installed XML writer\n
base64 XMLRPC::Convert.base64(str)\n\n
boolean XMLRPC::Convert.boolean(str)\n\n
dateTime XMLRPC::Convert.dateTime(str)\n\n
double XMLRPC::Convert.double(str)\n\n
fault XMLRPC::Convert.fault(hash)\n\n
int XMLRPC::Convert.int(str)\n\n
struct XMLRPC::Convert.struct(hash)\n\n
each_installed_parser XMLRPC::XMLParser.each_installed_parser()\nyields an instance of each installed parser\n
new XMLRPC::XMLParser::StreamParserMixin.new(*a)\n\n
character XMLRPC::XMLParser::StreamParserMixin.character(data)\n\n
endElement XMLRPC::XMLParser::StreamParserMixin.endElement(name)\n\n
startElement XMLRPC::XMLParser::StreamParserMixin.startElement(name, attrs=[])\n\n
each Prime::OldCompatibility.each(&block)\nOverwrites Prime#each.\n\nIterates the given block over all prime numbers. Note that enumeration\nstarts from the current position of internal pointer, not rewound.\n
next Prime::OldCompatibility.next()\n\n
succ Prime::OldCompatibility.succ()\nReturns the next prime number and forwards internal pointer.\n
_load Singleton._load\nBy default calls instance(). Override to retain singleton state.\n
_dump Singleton._dump(depth = -1)\nBy default, do not retain any state when marshalling.\n
clone Singleton.clone()\nRaises a TypeError to prevent cloning.\n
dup Singleton.dup()\nRaises a TypeError to prevent duping.\n
Fail Exception2MessageMapper.Fail(klass = E2MM, err = nil, *rest)\n\n
Raise Exception2MessageMapper.Raise(klass = E2MM, err = nil, *rest)\nFail(klass, err, *rest)\n    klass:  class to define exception under.\n    err:    exception\n    rest:   message arguments\n
def_e2message Exception2MessageMapper.def_e2message(k, c, m)\nE2MM.def_e2message(k, e, m)\n        k:  class to define exception under.\n        e:  exception\n        m:  message_form\n    define exception c with message m.\n
def_exception Exception2MessageMapper.def_exception(k, n, m, s = StandardError)\nE2MM.def_exception(k, n, m, s)\n        k:  class to define exception under.\n        n:  exception_name\n        m:  message_form\n        s:  superclass(default: StandardError)\n    define exception named ``c'' with message m.\n
e2mm_message Exception2MessageMapper.e2mm_message(klass, exp)\n\n
extend_object Exception2MessageMapper.extend_object(cl)\n\n
message Exception2MessageMapper.message(klass, exp)\n\n
Fail Exception2MessageMapper.Fail(err = nil, *rest)\n\n
Raise Exception2MessageMapper.Raise(err = nil, *rest)\nFail(err, *rest)\n    err:    exception\n    rest:   message arguments\n
bind Exception2MessageMapper.bind(cl)\n\n
def_e2message Exception2MessageMapper.def_e2message(c, m)\ndef_e2message(c, m)\n        c:  exception\n        m:  message_form\n    define exception c with message m.\n
def_exception Exception2MessageMapper.def_exception(n, m, s = StandardError)\ndef_exception(n, m, s)\n        n:  exception_name\n        m:  message_form\n        s:  superclass(default: StandardError)\n    define exception named ``c'' with message m.\n
fail Exception2MessageMapper.fail(err = nil, *rest)\n\n
Fail Exception2MessageMapper::E2MM.Fail(klass = E2MM, err = nil, *rest)\n\n
Raise Exception2MessageMapper::E2MM.Raise(klass = E2MM, err = nil, *rest)\nFail(klass, err, *rest)\n    klass:  class to define exception under.\n    err:    exception\n    rest:   message arguments\n
def_e2message Exception2MessageMapper::E2MM.def_e2message(k, c, m)\nE2MM.def_e2message(k, e, m)\n        k:  class to define exception under.\n        e:  exception\n        m:  message_form\n    define exception c with message m.\n
def_exception Exception2MessageMapper::E2MM.def_exception(k, n, m, s = StandardError)\nE2MM.def_exception(k, n, m, s)\n        k:  class to define exception under.\n        n:  exception_name\n        m:  message_form\n        s:  superclass(default: StandardError)\n    define exception named ``c'' with message m.\n
e2mm_message Exception2MessageMapper::E2MM.e2mm_message(klass, exp)\n\n
extend_object Exception2MessageMapper::E2MM.extend_object(cl)\n\n
message Exception2MessageMapper::E2MM.message(klass, exp)\n\n
Fail Exception2MessageMapper::E2MM.Fail(err = nil, *rest)\n\n
Raise Exception2MessageMapper::E2MM.Raise(err = nil, *rest)\nFail(err, *rest)\n    err:    exception\n    rest:   message arguments\n
bind Exception2MessageMapper::E2MM.bind(cl)\n\n
def_e2message Exception2MessageMapper::E2MM.def_e2message(c, m)\ndef_e2message(c, m)\n        c:  exception\n        m:  message_form\n    define exception c with message m.\n
def_exception Exception2MessageMapper::E2MM.def_exception(n, m, s = StandardError)\ndef_exception(n, m, s)\n        n:  exception_name\n        m:  message_form\n        s:  superclass(default: StandardError)\n    define exception named ``c'' with message m.\n
fail Exception2MessageMapper::E2MM.fail(err = nil, *rest)\n\n
decode64 Base64.decode64(str)\nReturns the Base64-decoded version of +str+.\nThis method complies with RFC 2045.\nCharacters outside the base alphabet are ignored.\n\n  require 'base64'\n  str = 'VGhpcyBpcyBsaW5lIG9uZQpUaGlzIG' +\n        'lzIGxpbmUgdHdvClRoaXMgaXMgbGlu' +\n        'ZSB0aHJlZQpBbmQgc28gb24uLi4K'\n  puts Base64.decode64(str)\n\n<i>Generates:</i>\n\n   This is line one\n   This is line two\n   This is line three\n   And so on...\n
encode64 Base64.encode64(bin)\nReturns the Base64-encoded version of +bin+.\nThis method complies with RFC 2045.\nLine feeds are added to every 60 encoded charactors.\n\n   require 'base64'\n   Base64.encode64("Now is the time for all good coders\\nto learn Ruby")\n\n<i>Generates:</i>\n\n   Tm93IGlzIHRoZSB0aW1lIGZvciBhbGwgZ29vZCBjb2RlcnMKdG8gbGVhcm4g\n   UnVieQ==\n
strict_decode64 Base64.strict_decode64(str)\nReturns the Base64-decoded version of +str+.\nThis method complies with RFC 4648.\nArgumentError is raised if +str+ is incorrectly padded or contains\nnon-alphabet characters.  Note that CR or LF are also rejected.\n
strict_encode64 Base64.strict_encode64(bin)\nReturns the Base64-encoded version of +bin+.\nThis method complies with RFC 4648.\nNo line feeds are added.\n
urlsafe_decode64 Base64.urlsafe_decode64(str)\nReturns the Base64-decoded version of +str+.\nThis method complies with ``Base 64 Encoding with URL and Filename Safe\nAlphabet'' in RFC 4648.\nThe alphabet uses '-' instead of '+' and '_' instead of '/'.\n
urlsafe_encode64 Base64.urlsafe_encode64(bin)\nReturns the Base64-encoded version of +bin+.\nThis method complies with ``Base 64 Encoding with URL and Filename Safe\nAlphabet'' in RFC 4648.\nThe alphabet uses '-' instead of '+' and '_' instead of '/'.\n
capture2 Open3.capture2(*cmd, &block)\nOpen3.capture2 captures the standard output of a command.\n\n  stdout_str, status = Open3.capture2([env,] cmd... [, opts])\n\nThe arguments env, cmd and opts are passed to Open3.popen3 except\nopts[:stdin_data] and opts[:binmode].  See Process.spawn.\n\nIf opts[:stdin_data] is specified, it is sent to the command's standard input.\n\nIf opts[:binmode] is true, internal pipes are set to binary mode.\n\nExample:\n factor is a command for integer factorization.\n  o, s = Open3.capture2("factor", :stdin_data=>"42")\n  p o #=> "42: 2 3 7\\n"\n generate x**2 graph in png using gnuplot.\n  gnuplot_commands = <<"End"\n    set terminal png\n    plot x**2, "-" with lines\n    1 14\n    2 1\n    3 8\n    4 5\n    e\n  End\n  image, s = Open3.capture2("gnuplot", :stdin_data=>gnuplot_commands,\n  :binmode=>true)\n
capture2e Open3.capture2e(*cmd, &block)\nOpen3.capture2e captures the standard output and the standard error of\na command.\n\n  stdout_and_stderr_str, status = Open3.capture2e([env,] cmd... [, opts])\n\nThe arguments env, cmd and opts are passed to Open3.popen3 except\nopts[:stdin_data] and opts[:binmode].  See Process.spawn.\n\nIf opts[:stdin_data] is specified, it is sent to the command's standard input.\n\nIf opts[:binmode] is true, internal pipes are set to binary mode.\n\nExample:\n capture make log\n  make_log, s = Open3.capture2e("make")\n
capture3 Open3.capture3(*cmd, &block)\nOpen3.capture3 captures the standard output and the standard error of\na command.\n\n  stdout_str, stderr_str, status = Open3.capture3([env,] cmd... [, opts])\n\nThe arguments env, cmd and opts are passed to Open3.popen3 except\nopts[:stdin_data] and opts[:binmode].  See Process.spawn.\n\nIf opts[:stdin_data] is specified, it is sent to the command's standard input.\n\nIf opts[:binmode] is true, internal pipes are set to binary mode.\n\nExample:\n dot is a command of graphviz.\n  graph = <<'End'\n    digraph g {\n      a -> b\n    }\n  End\n  layouted_graph, dot_log = Open3.capture3("dot -v", :stdin_data=>graph)\n\n  o, e, s = Open3.capture3("echo a; sort >&2",\n  :stdin_data=>"foo\\nbar\\nbaz\\n")\n  p o #=> "a\\n"\n  p e #=> "bar\\nbaz\\nfoo\\n"\n  p s #=> #<Process::Status: pid 32682 exit 0>\n generate a thumnail image using the convert command of ImageMagick.\n However, if the image stored really in a file,\n system("convert", "-thumbnail", "80", "png:#{filename}", "png:-") is better\n because memory consumption.\n But if the image is stored in a DB or generated by gnuplot Open3.capture2\n example,\n Open3.capture3 is considerable.\n\n  image =\n  File.read("/usr/share/openclipart/png/animals/mammals/sheep-md-v0.1.png",\n  :binmode=>true)\n  thumnail, err, s = Open3.capture3("convert -thumbnail 80 png:- png:-",\n  :stdin_data=>image, :binmode=>true)\n  if s.success?\n    STDOUT.binmode; print thumnail\n  end\n
pipeline Open3.pipeline(*cmds)\nOpen3.pipeline starts a list of commands as a pipeline.\nIt waits the finish of the commands.\nNo pipe made for stdin of the first command and\nstdout of the last command.\n\n  status_list = Open3.pipeline(cmd1, cmd2, ... [, opts])\n\nEach cmd is a string or an array.\nIf it is an array, the elements are passed to Process.spawn.\n\n  cmd:\n    commandline                              command line string which is\n    passed to a shell\n    [env, commandline, opts]                 command line string which is\n    passed to a shell\n    [env, cmdname, arg1, ..., opts]          command name and one or more\n    arguments (no shell)\n    [env, [cmdname, argv0], arg1, ..., opts] command name and arguments\n    including argv[0] (no shell)\n\n  Note that env and opts are optional, as Process.spawn.\n\nExample:\n\n  fname = "/usr/share/man/man1/ruby.1.gz"\n  p Open3.pipeline(["zcat", fname], "nroff -man", "less")\n=> [#<Process::Status: pid 11817 exit 0>,\n    #<Process::Status: pid 11820 exit 0>,\n    #<Process::Status: pid 11828 exit 0>]\n\n  fname = "/usr/share/man/man1/ls.1.gz"\n  Open3.pipeline(["zcat", fname], "nroff -man", "colcrt")\n convert PDF to PS and send to a printer by lpr\n  pdf_file = "paper.pdf"\n  printer = "printer-name"\n  Open3.pipeline(["pdftops", pdf_file, "-"],\n                 ["lpr", "-P#{printer}"])\n count lines\n  Open3.pipeline("sort", "uniq -c", :in=>"names.txt", :out=>"count")\n cyclic pipeline\n  r,w = IO.pipe\n  w.print "ibase=14\\n10\\n"\n  Open3.pipeline("bc", "tee /dev/tty", :in=>r, :out=>w)\n=> 14\n   18\n   22\n   30\n   42\n   58\n   78\n   106\n   202\n
pipeline_r Open3.pipeline_r(*cmds, &block)\nOpen3.pipeline_r starts a list of commands as a pipeline with a pipe\nwhich connects stdout of the last command.\n\n  Open3.pipeline_r(cmd1, cmd2, ... [, opts]) {|last_stdout, wait_threads|\n    ...\n  }\n\n  last_stdout, wait_threads = Open3.pipeline_r(cmd1, cmd2, ... [, opts])\n  ...\n  last_stdout.close\n\nEach cmd is a string or an array.\nIf it is an array, the elements are passed to Process.spawn.\n\n  cmd:\n    commandline                              command line string which is\n    passed to a shell\n    [env, commandline, opts]                 command line string which is\n    passed to a shell\n    [env, cmdname, arg1, ..., opts]          command name and one or more\n    arguments (no shell)\n    [env, [cmdname, argv0], arg1, ..., opts] command name and arguments\n    including argv[0] (no shell)\n\n  Note that env and opts are optional, as Process.spawn.\n\nExample:\n\n  Open3.pipeline_r("zcat /var/log/apache2/access.log.*.gz",\n                   [{"LANG"=>"C"}, "grep", "GET /favicon.ico"],\n                   "logresolve") {|o, ts|\n    o.each_line {|line|\n      ...\n    }\n  }\n\n  Open3.pipeline_r("yes", "head -10") {|o, ts|\n    p o.read      #=> "y\\ny\\ny\\ny\\ny\\ny\\ny\\ny\\ny\\ny\\n"\n    p ts[0].value #=> #<Process::Status: pid 24910 SIGPIPE (signal 13)>\n    p ts[1].value #=> #<Process::Status: pid 24913 exit 0>\n  }\n
pipeline_rw Open3.pipeline_rw(*cmds, &block)\nOpen3.pipeline_rw starts a list of commands as a pipeline with pipes\nwhich connects stdin of the first command and stdout of the last command.\n\n  Open3.pipeline_rw(cmd1, cmd2, ... [, opts]) {|first_stdin, last_stdout,\n  wait_threads|\n    ...\n  }\n\n  first_stdin, last_stdout, wait_threads = Open3.pipeline_rw(cmd1, cmd2,\n  ... [, opts])\n  ...\n  first_stdin.close\n  last_stdout.close\n\nEach cmd is a string or an array.\nIf it is an array, the elements are passed to Process.spawn.\n\n  cmd:\n    commandline                              command line string which is\n    passed to a shell\n    [env, commandline, opts]                 command line string which is\n    passed to a shell\n    [env, cmdname, arg1, ..., opts]          command name and one or more\n    arguments (no shell)\n    [env, [cmdname, argv0], arg1, ..., opts] command name and arguments\n    including argv[0] (no shell)\n\n  Note that env and opts are optional, as Process.spawn.\n\nThe option to pass Process.spawn is constructed by merging\n+opts+, the last hash element of the array and\nspecification for the pipe between each commands.\n\nExample:\n\n  Open3.pipeline_rw("tr -dc A-Za-z", "wc -c") {|i,o,ts|\n    i.puts "All persons more than a mile high to leave the court."\n    i.close\n    p o.gets #=> "42\\n"\n  }\n\n  Open3.pipeline_rw("sort", "cat -n") {|stdin, stdout, wait_thrs|\n    stdin.puts "foo"\n    stdin.puts "bar"\n    stdin.puts "baz"\n    stdin.close     # send EOF to sort.\n    p stdout.read   #=> "     1\tbar\\n     2\tbaz\\n     3\tfoo\\n"\n  }\n
pipeline_start Open3.pipeline_start(*cmds, &block)\nOpen3.pipeline_start starts a list of commands as a pipeline.\nNo pipe made for stdin of the first command and\nstdout of the last command.\n\n  Open3.pipeline_start(cmd1, cmd2, ... [, opts]) {|wait_threads|\n    ...\n  }\n\n  wait_threads = Open3.pipeline_start(cmd1, cmd2, ... [, opts])\n  ...\n\nEach cmd is a string or an array.\nIf it is an array, the elements are passed to Process.spawn.\n\n  cmd:\n    commandline                              command line string which is\n    passed to a shell\n    [env, commandline, opts]                 command line string which is\n    passed to a shell\n    [env, cmdname, arg1, ..., opts]          command name and one or more\n    arguments (no shell)\n    [env, [cmdname, argv0], arg1, ..., opts] command name and arguments\n    including argv[0] (no shell)\n\n  Note that env and opts are optional, as Process.spawn.\n\nExample:\n run xeyes in 10 seconds.\n  Open3.pipeline_start("xeyes") {|ts|\n    sleep 10\n    t = ts[0]\n    Process.kill("TERM", t.pid)\n    p t.value #=> #<Process::Status: pid 911 SIGTERM (signal 15)>\n  }\n convert pdf to ps and send it to a printer.\n collect error message of pdftops and lpr.\n  pdf_file = "paper.pdf"\n  printer = "printer-name"\n  err_r, err_w = IO.pipe\n  Open3.pipeline_start(["pdftops", pdf_file, "-"],\n                       ["lpr", "-P#{printer}"],\n                       :err=>err_w) {|ts|\n    err_w.close\n    p err_r.read # error messages of pdftops and lpr.\n  }\n
pipeline_w Open3.pipeline_w(*cmds, &block)\nOpen3.pipeline_w starts a list of commands as a pipeline with a pipe\nwhich connects stdin of the first command.\n\n  Open3.pipeline_w(cmd1, cmd2, ... [, opts]) {|first_stdin, wait_threads|\n    ...\n  }\n\n  first_stdin, wait_threads = Open3.pipeline_w(cmd1, cmd2, ... [, opts])\n  ...\n  first_stdin.close\n\nEach cmd is a string or an array.\nIf it is an array, the elements are passed to Process.spawn.\n\n  cmd:\n    commandline                              command line string which is\n    passed to a shell\n    [env, commandline, opts]                 command line string which is\n    passed to a shell\n    [env, cmdname, arg1, ..., opts]          command name and one or more\n    arguments (no shell)\n    [env, [cmdname, argv0], arg1, ..., opts] command name and arguments\n    including argv[0] (no shell)\n\n  Note that env and opts are optional, as Process.spawn.\n\nExample:\n\n  Open3.pipeline_w("bzip2 -c", :out=>"/tmp/hello.bz2") {|i, ts|\n    i.puts "hello"\n  }\n
popen2 Open3.popen2(*cmd, &block)\nOpen3.popen2 is similer to Open3.popen3 except it doesn't make a pipe for\nthe standard error stream.\n\nBlock form:\n\n  Open3.popen2([env,] cmd... [, opts]) {|stdin, stdout, wait_thr|\n    pid = wait_thr.pid # pid of the started process.\n    ...\n    exit_status = wait_thr.value # Process::Status object returned.\n  }\n\nNon-block form:\n\n  stdin, stdout, wait_thr = Open3.popen2([env,] cmd... [, opts])\n  ...\n  stdin.close  # stdin and stdout should be closed explicitly in this form.\n  stdout.close\n\nSee Process.spawn for the optional hash arguments _env_ and _opts_.\n\nExample:\n\n  Open3.popen2("wc -c") {|i,o,t|\n    i.print "answer to life the universe and everything"\n    i.close\n    p o.gets #=> "42\\n"\n  }\n\n  Open3.popen2("bc -q") {|i,o,t|\n    i.puts "obase=13"\n    i.puts "6 * 9"\n    p o.gets #=> "42\\n"\n  }\n\n  Open3.popen2("dc") {|i,o,t|\n    i.print "42P"\n    i.close\n    p o.read #=> "*"\n  }\n
popen2e Open3.popen2e(*cmd, &block)\nOpen3.popen2e is similer to Open3.popen3 except it merges\nthe standard output stream and the standard error stream.\n\nBlock form:\n\n  Open3.popen2e([env,] cmd... [, opts]) {|stdin, stdout_and_stderr, wait_thr|\n    pid = wait_thr.pid # pid of the started process.\n    ...\n    exit_status = wait_thr.value # Process::Status object returned.\n  }\n\nNon-block form:\n\n  stdin, stdout_and_stderr, wait_thr = Open3.popen2e([env,] cmd... [, opts])\n  ...\n  stdin.close  # stdin and stdout_and_stderr should be closed explicitly in\n  this form.\n  stdout_and_stderr.close\n\nSee Process.spawn for the optional hash arguments _env_ and _opts_.\n\nExample:\n check gcc warnings\n  source = "foo.c"\n  Open3.popen2e("gcc", "-Wall", source) {|i,oe,t|\n    oe.each {|line|\n      if /warning/ =~ line\n        ...\n      end\n    }\n  }\n
popen3 Open3.popen3(*cmd, &block)\nOpen stdin, stdout, and stderr streams and start external executable.\nIn addition, a thread for waiting the started process is noticed.\nThe thread has a pid method and thread variable :pid which is the pid of\nthe started process.\n\nBlock form:\n\n  Open3.popen3([env,] cmd... [, opts]) {|stdin, stdout, stderr, wait_thr|\n    pid = wait_thr.pid # pid of the started process.\n    ...\n    exit_status = wait_thr.value # Process::Status object returned.\n  }\n\nNon-block form:\n\n  stdin, stdout, stderr, wait_thr = Open3.popen3([env,] cmd... [, opts])\n  pid = wait_thr[:pid]  # pid of the started process.\n  ...\n  stdin.close  # stdin, stdout and stderr should be closed explicitly in\n  this form.\n  stdout.close\n  stderr.close\n  exit_status = wait_thr.value  # Process::Status object returned.\n\nThe parameters +cmd...+ is passed to Process.spawn.\nSo a commandline string and list of argument strings can be accepted as\nfollows.\n\n  Open3.popen3("echo a") {|i, o, e, t| ... }\n  Open3.popen3("echo", "a") {|i, o, e, t| ... }\n  Open3.popen3(["echo", "argv0"], "a") {|i, o, e, t| ... }\n\nIf the last parameter, opts, is a Hash, it is recognized as an option for\nProcess.spawn.\n\n  Open3.popen3("pwd", :chdir=>"/") {|i,o,e,t|\n    p o.read.chomp #=> "/"\n  }\n\nwait_thr.value waits the termination of the process.\nThe block form also waits the process when it returns.\n\nClosing stdin, stdout and stderr does not wait the process.\n
append_features RSS::SlashModel.append_features(klass)\n\n
append_features RSS::SyndicationModel.append_features(klass)\n\n
new RSS::XMLStyleSheetMixin.new(*args)\n\n
element_initialize_arguments? RSS::Utils.element_initialize_arguments?(args)\n\n
get_file_and_line_from_caller RSS::Utils.get_file_and_line_from_caller(i=0)\n\n
h RSS::Utils.h(s)\n\n
html_escape RSS::Utils.html_escape(s)\nescape '&', '"', '<' and '>' for use in HTML.\n
new_with_value_if_need RSS::Utils.new_with_value_if_need(klass, value)\nIf +value+ is an instance of class +klass+, return it, else\ncreate a new instance of +klass+ with value +value+.\n
to_class_name RSS::Utils.to_class_name(name)\nConvert a name_with_underscores to CamelCase.\n
parse RSS::Utils::YesCleanOther.parse(value)\n\n
parse RSS::Utils::YesOther.parse(value)\n\n
parse RSS::Utils::CSV.parse(value, &block)\n\n
inherited_array_reader RSS::Utils::InheritedReader.inherited_array_reader(constant_name)\n\n
inherited_hash_reader RSS::Utils::InheritedReader.inherited_hash_reader(constant_name)\n\n
inherited_reader RSS::Utils::InheritedReader.inherited_reader(constant_name)\n\n
append_features RSS::ContentModel.append_features(klass)\n\n
append_features RSS::RSS10.append_features(klass)\n\n
new RSS::ListenerMixin.new()\n\n
instruction RSS::ListenerMixin.instruction(name, content)\n\n
tag_end RSS::ListenerMixin.tag_end(name)\n\n
tag_start RSS::ListenerMixin.tag_start(name, attributes)\n\n
text RSS::ListenerMixin.text(data)\n\n
xmldecl RSS::ListenerMixin.xmldecl(version, encoding, standalone)\nset instance vars for version, encoding, standalone\n
add_maker RSS::Maker.add_maker(version, normalized_version, maker)\n\n
make RSS::Maker.make(version, &block)\n\n
makers RSS::Maker.makers()\n\n
supported? RSS::Maker.supported?(version)\n\n
versions RSS::Maker.versions()\n\n
append_features RSS::Maker::SlashModel.append_features(klass)\n\n
append_features RSS::Maker::SyndicationModel.append_features(klass)\n\n
append_features RSS::Maker::ContentModel.append_features(klass)\n\n
append_features RSS::Maker::AtomPersonConstructBase.append_features(klass)\n\n
append_features RSS::Maker::AtomTextConstructBase.append_features(klass)\n\n
included RSS::Maker::AtomTextConstructBase::EnsureXMLContent.included(base)\n\n
ensure_xml_content RSS::Maker::AtomTextConstructBase::EnsureXMLContent.ensure_xml_content(content)\n\n
xhtml= RSS::Maker::AtomTextConstructBase::EnsureXMLContent.xhtml=(content)\n\n
xml_content= RSS::Maker::AtomTextConstructBase::EnsureXMLContent.xml_content=(content)\n\n
append_features RSS::Maker::TrackBackModel.append_features(klass)\n\n
def_atom_persons RSS::Maker::AtomPersons.def_atom_persons(klass, name, maker_name, plural=nil)\n\n
def_atom_text_construct RSS::Maker::AtomTextConstruct.def_atom_text_construct(klass, name, maker_name,\nklass_name=nil, atom_klass_name=nil)\n\n
to_feed RSS::Maker::AtomCategory.to_feed(feed, current)\n\n
to_feed RSS::Maker::AtomLink.to_feed(feed, current)\n\n
to_feed RSS::Maker::AtomGenerator.to_feed(feed, current)\n\n
to_feed RSS::Maker::AtomLogo.to_feed(feed, current)\n\n
def_class_accessor RSS::Maker::ITunesBaseModel.def_class_accessor(klass, name, type, *args)\n\n
def_csv_accessor RSS::Maker::ITunesBaseModel.def_csv_accessor(klass, full_name)\n\n
def_elements_class_accessor RSS::Maker::ITunesBaseModel.def_elements_class_accessor(klass,\nname, full_name, full_plural_name, klass_name, plural_klass_name,\nrecommended_attribute_name=nil)\n\n
def_yes_clean_other_accessor RSS::Maker::ITunesBaseModel.def_yes_clean_other_accessor(klass, full_name)\n\n
def_yes_other_accessor RSS::Maker::ITunesBaseModel.def_yes_other_accessor(klass, full_name)\n\n
append_features RSS::Maker::ITunesChannelModel.append_features(klass)\n\n
append_features RSS::Maker::ITunesItemModel.append_features(klass)\n\n
append_features RSS::Maker::ImageItemModel.append_features(klass)\n\n
install_image_item RSS::Maker::ImageItemModel.install_image_item(klass)\n\n
append_features RSS::Maker::ImageFaviconModel.append_features(klass)\n\n
install_image_favicon RSS::Maker::ImageFaviconModel.install_image_favicon(klass)\n\n
append_features RSS::Maker::DublinCoreModel.append_features(klass)\n\n
install_dublin_core RSS::Maker::DublinCoreModel.install_dublin_core(klass)\n\n
append_features RSS::Maker::TaxonomyTopicsModel.append_features(klass)\n\n
install_taxo_topics RSS::Maker::TaxonomyTopicsModel.install_taxo_topics(klass)\n\n
append_features RSS::Maker::TaxonomyTopicModel.append_features(klass)\n\n
install_taxo_topic RSS::Maker::TaxonomyTopicModel.install_taxo_topic(klass)\n\n
install_date_element RSS::BaseModel.install_date_element(tag_name, uri, occurs, name=nil, type=nil,\ndisp_name=nil)\n\n
install_have_attribute_element RSS::BaseModel.install_have_attribute_element(tag_name, uri, occurs,\nname=nil, type=nil)\n\n
install_have_child_element RSS::BaseModel.install_have_child_element(tag_name, uri, occurs, name=nil,\ntype=nil)\n\n
install_have_children_element RSS::BaseModel.install_have_children_element(tag_name, uri, occurs, name=nil,\nplural_name=nil)\n\n
install_text_element RSS::BaseModel.install_text_element(tag_name, uri, occurs, name=nil, type=nil,\ndisp_name=nil)\n\n
setup_maker RSS::SetupMaker.setup_maker(maker)\n\n
new RSS::RootElementMixin.new(feed_version, version=nil, encoding=nil,\nstandalone=nil)\n\n
feed_info RSS::RootElementMixin.feed_info()\n\n
output_encoding= RSS::RootElementMixin.output_encoding=(enc)\n\n
setup_maker RSS::RootElementMixin.setup_maker(maker)\n\n
to_atom RSS::RootElementMixin.to_atom(type, &block)\n\n
to_feed RSS::RootElementMixin.to_feed(type, &block)\n\n
to_rss RSS::RootElementMixin.to_rss(type, &block)\n\n
to_xml RSS::RootElementMixin.to_xml(type=nil, &block)\n\n
append_features RSS::RSS09.append_features(klass)\n\n
append_features RSS::BaseTrackBackModel.append_features(klass)\n\n
append_features RSS::Atom::CommonModel.append_features(klass)\n\n
need_parent? RSS::Atom::CommonModel.need_parent?()\n\n
required_uri RSS::Atom::CommonModel.required_uri()\n\n
append_features RSS::Atom::ContentModel.append_features(klass)\n\n
maker_target RSS::Atom::ContentModel.maker_target(target)\n\n
content_type RSS::Atom::ContentModel::ClassMethods.content_type()\n\n
append_features RSS::Atom::URIContentModel.append_features(klass)\n\n
append_features RSS::Atom::TextConstruct.append_features(klass)\n\n
xml_getter RSS::Atom::TextConstruct.xml_getter()\n\n
xml_setter RSS::Atom::TextConstruct.xml_setter()\n\n
atom_validate RSS::Atom::TextConstruct.atom_validate(ignore_unknown_element, tags, uri)\n\n
have_xml_content? RSS::Atom::TextConstruct.have_xml_content?()\n\n
xhtml RSS::Atom::TextConstruct.xhtml()\n\n
append_features RSS::Atom::PersonConstruct.append_features(klass)\n\n
maker_target RSS::Atom::PersonConstruct.maker_target(target)\n\n
append_features RSS::Atom::DateConstruct.append_features(klass)\n\n
atom_validate RSS::Atom::DateConstruct.atom_validate(ignore_unknown_element, tags, uri)\n\n
validate_duplicate_links RSS::Atom::DuplicateLinkChecker.validate_duplicate_links(links)\n\n
def_class_accessor RSS::ITunesModelUtils.def_class_accessor(klass, name, type, *args)\n\n
def_element_class_accessor RSS::ITunesModelUtils.def_element_class_accessor(klass, name, full_name,\nklass_name, recommended_attribute_name=nil)\n\n
def_elements_class_accessor RSS::ITunesModelUtils.def_elements_class_accessor(klass, name, full_name,\nklass_name, plural_name, recommended_attribute_name=nil)\n\n
append_features RSS::ITunesChannelModel.append_features(klass)\n\n
append_features RSS::ITunesItemModel.append_features(klass)\n\n
validate_one_tag_name RSS::ImageModelUtils.validate_one_tag_name(ignore_unknown_element, name, tags)\n\n
append_features RSS::ImageItemModel.append_features(klass)\n\n
append_features RSS::ImageFaviconModel.append_features(klass)\n\n
append_features RSS::BaseDublinCoreModel.append_features(klass)\n\n
append_features RSS::TaxonomyTopicsModel.append_features(klass)\n\n
append_features RSS::TaxonomyTopicModel.append_features(klass)\n\n
add_private_type Psych.add_private_type(type_tag, &block)\n\n
add_ruby_type Psych.add_ruby_type(type_tag, &block)\n\n
detect_implicit Psych.detect_implicit(thing)\n\n
dump Psych.dump(o, io = nil, options = {})\nDump Ruby object +o+ to a YAML string.  Optional +options+ may be passed in\nto control the output format.  If an IO object is passed in, the YAML will\nbe dumped to that IO object.\n\nExample:\n Dump an array, get back a YAML string\n  Psych.dump(['a', 'b'])  # => "---\\n- a\\n- b\\n"\n Dump an array to an IO object\n  Psych.dump(['a', 'b'], StringIO.new)  # => #<StringIO:0x000001009d0890>\n Dump an array with indentation set\n  Psych.dump(['a', ['b']], :indentation => 3) # => "---\\n- a\\n-  - b\\n"\n Dump an array to an IO with indentation set\n  Psych.dump(['a', ['b']], StringIO.new, :indentation => 3)\n
dump_stream Psych.dump_stream(*objects)\nDump a list of objects as separate documents to a document stream.\n\nExample:\n\n  Psych.dump_stream("foo\\n  ", {}) # => "--- ! \"foo\\\n  \"\\n--- {}\\n"\n
libyaml_version Psych.libyaml_version()\nReturns the version of libyaml being used\n
load Psych.load(yaml, filename = nil)\nLoad +yaml+ in to a Ruby data structure.  If multiple documents are\nprovided, the object contained in the first document will be returned.\n+filename+ will be used in the exception message if any exception is raised\nwhile parsing.\n\nRaises a Psych::SyntaxError when a YAML syntax error is detected.\n\nExample:\n\n  Psych.load("--- a")             # => 'a'\n  Psych.load("---\\n - a\\n - b")   # => ['a', 'b']\n\n  begin\n    Psych.load("--- `", "file.txt")\n  rescue Psych::SyntaxError => ex\n    ex.file    # => 'file.txt'\n    ex.message # => "(foo.txt): found character that cannot start any token"\n  end\n
load_documents Psych.load_documents(yaml, &block)\n\n
load_file Psych.load_file(filename)\nLoad the document contained in +filename+.  Returns the yaml contained in\n+filename+ as a ruby object\n
load_stream Psych.load_stream(yaml, filename = nil)\nLoad multiple documents given in +yaml+.  Returns the parsed documents\nas a list.  If a block is given, each document will be converted to ruby\nand passed to the block during parsing\n\nExample:\n\n  Psych.load_stream("--- foo\\n...\\n--- bar\\n...") # => ['foo', 'bar']\n\n  list = []\n  Psych.load_stream("--- foo\\n...\\n--- bar\\n...") do |ruby|\n    list << ruby\n  end\n  list # => ['foo', 'bar']\n
object_maker Psych.object_maker(klass, hash)\n\n
parse Psych.parse(yaml, filename = nil)\nParse a YAML string in +yaml+.  Returns the first object of a YAML AST.\n+filename+ is used in the exception message if a Psych::SyntaxError is\nraised.\n\nRaises a Psych::SyntaxError when a YAML syntax error is detected.\n\nExample:\n\n  Psych.parse("---\\n - a\\n - b") # => #<Psych::Nodes::Sequence:0x00>\n\n  begin\n    Psych.parse("--- `", "file.txt")\n  rescue Psych::SyntaxError => ex\n    ex.file    # => 'file.txt'\n    ex.message # => "(foo.txt): found character that cannot start any token"\n  end\n\nSee Psych::Nodes for more information about YAML AST.\n
parse_file Psych.parse_file(filename)\nParse a file at +filename+. Returns the YAML AST.\n\nRaises a Psych::SyntaxError when a YAML syntax error is detected.\n
parse_stream Psych.parse_stream(yaml, filename = nil, &block)\nParse a YAML string in +yaml+.  Returns the full AST for the YAML document.\nThis method can handle multiple YAML documents contained in +yaml+.\n+filename+ is used in the exception message if a Psych::SyntaxError is\nraised.\n\nIf a block is given, a Psych::Nodes::Document node will be yielded to the\nblock as it's being parsed.\n\nRaises a Psych::SyntaxError when a YAML syntax error is detected.\n\nExample:\n\n  Psych.parse_stream("---\\n - a\\n - b") # => #<Psych::Nodes::Stream:0x00>\n\n  Psych.parse_stream("--- a\\n--- b") do |node|\n    node # => #<Psych::Nodes::Document:0x00>\n  end\n\n  begin\n    Psych.parse_stream("--- `", "file.txt")\n  rescue Psych::SyntaxError => ex\n    ex.file    # => 'file.txt'\n    ex.message # => "(foo.txt): found character that cannot start any token"\n  end\n\nSee Psych::Nodes for more information about YAML AST.\n
parser Psych.parser()\nReturns a default parser\n
quick_emit Psych.quick_emit(thing, opts = {})\n\n
read_type_class Psych.read_type_class(type, reference)\n\n
tagurize Psych.tagurize(thing)\n\n
to_json Psych.to_json(o)\nDump Ruby object +o+ to a JSON string.\n
append_features Sync_m.append_features(cl)\n\n
define_aliases Sync_m.define_aliases(cl)\n\n
extend_object Sync_m.extend_object(obj)\n\n
new Sync_m.new(*args)\n\n
sync_exclusive? Sync_m.sync_exclusive?()\n\n
sync_extend Sync_m.sync_extend()\n\n
sync_inspect Sync_m.sync_inspect()\n\n
sync_lock Sync_m.sync_lock(m = EX)\n\n
sync_locked? Sync_m.sync_locked?()\naccessing\n
sync_shared? Sync_m.sync_shared?()\n\n
sync_synchronize Sync_m.sync_synchronize(mode = EX)\n\n
sync_try_lock Sync_m.sync_try_lock(mode = EX)\nlocking methods.\n
sync_unlock Sync_m.sync_unlock(m = EX)\n\n
append_features Sync_m.append_features(cl)\n\n
define_aliases Sync_m.define_aliases(cl)\n\n
extend_object Sync_m.extend_object(obj)\n\n
new Sync_m.new(*args)\n\n
sync_exclusive? Sync_m.sync_exclusive?()\n\n
sync_extend Sync_m.sync_extend()\n\n
sync_inspect Sync_m.sync_inspect()\n\n
sync_lock Sync_m.sync_lock(m = EX)\n\n
sync_locked? Sync_m.sync_locked?()\naccessing\n
sync_shared? Sync_m.sync_shared?()\n\n
sync_synchronize Sync_m.sync_synchronize(mode = EX)\n\n
sync_try_lock Sync_m.sync_try_lock(mode = EX)\nlocking methods.\n
sync_unlock Sync_m.sync_unlock(m = EX)\n\n
charset OpenURI::Meta.charset()\nreturns a charset parameter in Content-Type field.\nIt is downcased for canonicalization.\n\nIf charset parameter is not given but a block is given,\nthe block is called and its result is returned.\nIt can be used to guess charset.\n\nIf charset parameter and block is not given,\nnil is returned except text type in HTTP.\nIn that case, "iso-8859-1" is returned as defined by RFC2616 3.7.1.\n
content_encoding OpenURI::Meta.content_encoding()\nReturns a list of encodings in Content-Encoding field as an array of\nstrings.\n\nThe encodings are downcased for canonicalization.\n
content_type OpenURI::Meta.content_type()\nreturns "type/subtype" which is MIME Content-Type.\nIt is downcased for canonicalization.\nContent-Type parameters are stripped.\n
last_modified OpenURI::Meta.last_modified()\nreturns a Time that represents the Last-Modified field.\n
open OpenURI::OpenRead.open(*rest, &block)\nOpenURI::OpenRead#open provides `open' for URI::HTTP and URI::FTP.\n\nOpenURI::OpenRead#open takes optional 3 arguments as:\n\n  OpenURI::OpenRead#open([mode [, perm]] [, options]) [{|io| ... }]\n\nOpenURI::OpenRead#open returns an IO-like object if block is not given.\nOtherwise it yields the IO object and return the value of the block.\nThe IO object is extended with OpenURI::Meta.\n\n+mode+ and +perm+ are the same as Kernel#open.\n\nHowever, +mode+ must be read mode because OpenURI::OpenRead#open doesn't\nsupport write mode (yet).\nAlso +perm+ is ignored because it is meaningful only for file creation.\n\n+options+ must be a hash.\n\nEach option with a string key specifies an extra header field for HTTP.\nI.e., it is ignored for FTP without HTTP proxy.\n\nThe hash may include other options, where keys are symbols:\n\n[:proxy]\n Synopsis:\n   :proxy => "http://proxy.foo.com:8000/"\n   :proxy => URI.parse("http://proxy.foo.com:8000/")\n   :proxy => true\n   :proxy => false\n   :proxy => nil\n\n If :proxy option is specified, the value should be String, URI,\n boolean or nil.\n\n When String or URI is given, it is treated as proxy URI.\n\n When true is given or the option itself is not specified,\n environment variable `scheme_proxy' is examined.\n `scheme' is replaced by `http', `https' or `ftp'.\n\n When false or nil is given, the environment variables are ignored and\n connection will be made to a server directly.\n\n[:proxy_http_basic_authentication]\n Synopsis:\n   :proxy_http_basic_authentication =>\n     ["http://proxy.foo.com:8000/", "proxy-user", "proxy-password"]\n   :proxy_http_basic_authentication =>\n     [URI.parse("http://proxy.foo.com:8000/"),\n      "proxy-user", "proxy-password"]\n\n If :proxy option is specified, the value should be an Array with 3\n elements.  It should contain a proxy URI, a proxy user name and a proxy\n password.  The proxy URI should be a String, an URI or nil.  The proxy\n user name and password should be a String.\n\n If nil is given for the proxy URI, this option is just ignored.\n\n If :proxy and :proxy_http_basic_authentication is specified,\n ArgumentError is raised.\n\n[:http_basic_authentication]\n Synopsis:\n   :http_basic_authentication=>[user, password]\n\n If :http_basic_authentication is specified,\n the value should be an array which contains 2 strings:\n username and password.\n It is used for HTTP Basic authentication defined by RFC 2617.\n\n[:content_length_proc]\n Synopsis:\n   :content_length_proc => lambda {|content_length| ... }\n\n If :content_length_proc option is specified, the option value procedure\n is called before actual transfer is started.\n It takes one argument, which is expected content length in bytes.\n\n If two or more transfer is done by HTTP redirection, the procedure\n is called only one for a last transfer.\n\n When expected content length is unknown, the procedure is called with\n nil.  This happens when the HTTP response has no Content-Length header.\n\n[:progress_proc]\n Synopsis:\n   :progress_proc => lambda {|size| ...}\n\n If :progress_proc option is specified, the proc is called with one\n argument each time when `open' gets content fragment from network.\n The argument +size+ is the accumulated transferred size in bytes.\n\n If two or more transfer is done by HTTP redirection, the procedure\n is called only one for a last transfer.\n\n :progress_proc and :content_length_proc are intended to be used for\n progress bar.\n For example, it can be implemented as follows using Ruby/ProgressBar.\n\n   pbar = nil\n   open("http://...",\n     :content_length_proc => lambda {|t|\n       if t && 0 < t\n         pbar = ProgressBar.new("...", t)\n         pbar.file_transfer_mode\n       end\n     },\n     :progress_proc => lambda {|s|\n       pbar.set s if pbar\n     }) {|f| ... }\n\n[:read_timeout]\n Synopsis:\n   :read_timeout=>nil     (no timeout)\n   :read_timeout=>10      (10 second)\n\n :read_timeout option specifies a timeout of read for http connections.\n\n[:ssl_ca_cert]\n Synopsis:\n   :ssl_ca_cert=>filename\n\n :ssl_ca_cert is used to specify CA certificate for SSL.\n If it is given, default certificates are not used.\n\n[:ssl_verify_mode]\n Synopsis:\n   :ssl_verify_mode=>mode\n\n :ssl_verify_mode is used to specify openssl verify mode.\n\n[:ftp_active_mode]\n Synopsis:\n   :ftp_active_mode=>bool\n\n <tt>:ftp_active_mode => true</tt> is used to make ftp active mode.\n Ruby 1.9 uses passive mode by default.\n Note that the active mode is default in Ruby 1.8 or prior.\n\n[:redirect]\n Synopsis:\n   :redirect=>bool\n\n +:redirect+ is true by default.  <tt>:redirect => false</tt> is used to\n disable all HTTP redirects.\n\n OpenURI::HTTPRedirect exception raised on redirection.\n Using +true+ also means that redirections between http and ftp are\n permitted.\n
read OpenURI::OpenRead.read(options={})\nOpenURI::OpenRead#read([options]) reads a content referenced by self and\nreturns the content as string.\nThe string is extended with OpenURI::Meta.\nThe argument +options+ is same as OpenURI::OpenRead#open.\n
decode_www_form URI.decode_www_form(str, enc=Encoding::UTF_8)\nDecode URL-encoded form data from given +str+.\n\nThis decodes application/x-www-form-urlencoded data\nand returns array of key-value array.\nThis internally uses URI.decode_www_form_component.\n\n_charset_ hack is not supported now because the mapping from given charset\nto Ruby's encoding is not clear yet.\nsee also http://www.w3.org/TR/html5/syntax.html#character-encodings-0\n\nThis refers http://www.w3.org/TR/html5/forms.html#url-encoded-form-data\n\nary = URI.decode_www_form("a=1&a=2&b=3")\np ary                  #=> [['a', '1'], ['a', '2'], ['b', '3']]\np ary.assoc('a').last  #=> '1'\np ary.assoc('b').last  #=> '3'\np ary.rassoc('a').last #=> '2'\np Hash[ary]            # => {"a"=>"2", "b"=>"3"}\n\nSee URI.decode_www_form_component, URI.encode_www_form\n
decode_www_form_component URI.decode_www_form_component(str, enc=Encoding::UTF_8)\nDecode given +str+ of URL-encoded form data.\n\nThis decods + to SP.\n\nSee URI.encode_www_form_component, URI.decode_www_form\n
encode_www_form URI.encode_www_form(enum)\nGenerate URL-encoded form data from given +enum+.\n\nThis generates application/x-www-form-urlencoded data defined in HTML5\nfrom given an Enumerable object.\n\nThis internally uses URI.encode_www_form_component(str).\n\nThis method doesn't convert the encoding of given items, so convert them\nbefore call this method if you want to send data as other than original\nencoding or mixed encoding data. (Strings which are encoded in an HTML5\nASCII incompatible encoding are converted to UTF-8.)\n\nThis method doesn't handle files.  When you send a file, use\nmultipart/form-data.\n\nThis is an implementation of\nhttp://www.w3.org/TR/html5/forms.html#url-encoded-form-data\n\n   URI.encode_www_form([["q", "ruby"], ["lang", "en"]])\n=> "q=ruby&lang=en"\n   URI.encode_www_form("q" => "ruby", "lang" => "en")\n=> "q=ruby&lang=en"\n   URI.encode_www_form("q" => ["ruby", "perl"], "lang" => "en")\n=> "q=ruby&q=perl&lang=en"\n   URI.encode_www_form([["q", "ruby"], ["q", "perl"], ["lang", "en"]])\n=> "q=ruby&q=perl&lang=en"\n\nSee URI.encode_www_form_component, URI.decode_www_form\n
encode_www_form_component URI.encode_www_form_component(str)\nEncode given +str+ to URL-encoded form data.\n\nThis method doesn't convert *, -, ., 0-9, A-Z, _, a-z, but does convert SP\n(ASCII space) to + and converts others to %XX.\n\nThis is an implementation of\nhttp://www.w3.org/TR/html5/forms.html#url-encoded-form-data\n\nSee URI.decode_www_form_component, URI.encode_www_form\n
extract URI.extract(str, schemes = nil, &block)\n== Synopsis\n\n  URI::extract(str[, schemes][,&blk])\n\n== Args\n\n+str+::\n  String to extract URIs from.\n+schemes+::\n  Limit URI matching to a specific schemes.\n\n== Description\n\nExtracts URIs from a string. If block given, iterates through all matched URIs.\nReturns nil if block given or array with matches.\n\n== Usage\n\n  require "uri"\n\n  URI.extract("text here http://foo.example.org/bla and here\n  mailto:test@example.com and here also.")\n => ["http://foo.example.com/bla", "mailto:test@example.com"]\n
join URI.join(*str)\n== Synopsis\n\n  URI::join(str[, str, ...])\n\n== Args\n\n+str+::\n  String(s) to work with\n\n== Description\n\nJoins URIs.\n\n== Usage\n\n  require 'uri'\n\n  p URI.join("http://example.com/","main.rbx")\n => #<URI::HTTP:0x2022ac02 URL:http://localhost/main.rbx>\n\n  p URI.join('http://example.com', 'foo')\n => #<URI::HTTP:0x01ab80a0 URL:http://example.com/foo>\n\n  p URI.join('http://example.com', '/foo', '/bar')\n => #<URI::HTTP:0x01aaf0b0 URL:http://example.com/bar>\n\n  p URI.join('http://example.com', '/foo', 'bar')\n => #<URI::HTTP:0x801a92af0 URL:http://example.com/bar>\n\n  p URI.join('http://example.com', '/foo/', 'bar')\n => #<URI::HTTP:0x80135a3a0 URL:http://example.com/foo/bar>\n
parse URI.parse(uri)\n== Synopsis\n\n  URI::parse(uri_str)\n\n== Args\n\n+uri_str+::\n  String with URI.\n\n== Description\n\nCreates one of the URI's subclasses instance from the string.\n\n== Raises\n\nURI::InvalidURIError\n  Raised if URI given is not a correct one.\n\n== Usage\n\n  require 'uri'\n\n  uri = URI.parse("http://www.ruby-lang.org/")\n  p uri\n => #<URI::HTTP:0x202281be URL:http://www.ruby-lang.org/>\n  p uri.scheme\n => "http"\n  p uri.host\n => "www.ruby-lang.org"\n
regexp URI.regexp(schemes = nil)\n== Synopsis\n\n  URI::regexp([match_schemes])\n\n== Args\n\n+match_schemes+::\n  Array of schemes. If given, resulting regexp matches to URIs\n  whose scheme is one of the match_schemes.\n\n== Description\nReturns a Regexp object which matches to URI-like strings.\nThe Regexp object returned by this method includes arbitrary\nnumber of capture group (parentheses).  Never rely on it's number.\n\n== Usage\n\n  require 'uri'\n extract first URI from html_string\n  html_string.slice(URI.regexp)\n remove ftp URIs\n  html_string.sub(URI.regexp(['ftp'])\n You should not rely on the number of parentheses\n  html_string.scan(URI.regexp) do |*matches|\n    p $&\n  end\n
scheme_list URI.scheme_list()\nReturns a Hash of the defined schemes\n
split URI.split(uri)\n== Synopsis\n\n  URI::split(uri)\n\n== Args\n\n+uri+::\n  String with URI.\n\n== Description\n\nSplits the string on following parts and returns array with result:\n\n  * Scheme\n  * Userinfo\n  * Host\n  * Port\n  * Registry\n  * Path\n  * Opaque\n  * Query\n  * Fragment\n\n== Usage\n\n  require 'uri'\n\n  p URI.split("http://www.ruby-lang.org/")\n => ["http", nil, "www.ruby-lang.org", nil, nil, "/", nil, nil, nil]\n
def_delegator Forwardable.def_delegator(accessor, method, ali = method)\n\n
def_delegators Forwardable.def_delegators(accessor, *methods)\n\n
def_instance_delegator Forwardable.def_instance_delegator(accessor, method, ali = method)\nDefine +method+ as delegator instance method with an optional\nalias name +ali+. Method calls to +ali+ will be delegated to\n+accessor.method+.\n\n  class MyQueue\n    extend Forwardable\n    attr_reader :queue\n    def initialize\n      @queue = []\n    end\n\n    def_delegator :@queue, :push, :mypush\n  end\n\n  q = MyQueue.new\n  q.mypush 42\n  q.queue    #=> [42]\n  q.push 23  #=> NoMethodError\n
def_instance_delegators Forwardable.def_instance_delegators(accessor, *methods)\nShortcut for defining multiple delegator methods, but with no\nprovision for using a different name.  The following two code\nsamples have the same effect:\n\n  def_delegators :@records, :size, :<<, :map\n\n  def_delegator :@records, :size\n  def_delegator :@records, :<<\n  def_delegator :@records, :map\n
delegate Forwardable.delegate(hash)\n\n
instance_delegate Forwardable.instance_delegate(hash)\nTakes a hash as its argument.  The key is a symbol or an array of\nsymbols.  These symbols correspond to method names.  The value is\nthe accessor to which the methods will be delegated.\n
def_delegator SingleForwardable.def_delegator(accessor, method, ali = method)\n\n
def_delegators SingleForwardable.def_delegators(accessor, *methods)\n\n
def_single_delegator SingleForwardable.def_single_delegator(accessor, method, ali = method)\nDefines a method _method_ which delegates to _obj_ (i.e. it calls\nthe method of the same name in _obj_).  If _new_name_ is\nprovided, it is used as the name for the delegate method.\n
def_single_delegators SingleForwardable.def_single_delegators(accessor, *methods)\nShortcut for defining multiple delegator methods, but with no\nprovision for using a different name.  The following two code\nsamples have the same effect:\n\n  def_delegators :@records, :size, :<<, :map\n\n  def_delegator :@records, :size\n  def_delegator :@records, :<<\n  def_delegator :@records, :map\n
delegate SingleForwardable.delegate(hash)\n\n
single_delegate SingleForwardable.single_delegate(hash)\nTakes a hash as its argument.  The key is a symbol or an array of\nsymbols.  These symbols correspond to method names.  The value is\nthe accessor to which the methods will be delegated.\n
candidate OptionParser::Completion.candidate(key, icase = false, pat = nil, &block)\n\n
regexp OptionParser::Completion.regexp(key, icase)\n\n
candidate OptionParser::Completion.candidate(key, icase = false, pat = nil)\n\n
complete OptionParser::Completion.complete(key, icase = false, pat = nil)\n\n
convert OptionParser::Completion.convert(opt = nil, val = nil, *)\n\n
extend_object OptionParser::Arguable.extend_object(obj)\nInitializes instance variable.\n
new OptionParser::Arguable.new(*args)\n\n
getopts OptionParser::Arguable.getopts(*args)\nSubstitution of getopts is possible as follows. Also see\nOptionParser#getopts.\n\n  def getopts(*args)\n    ($OPT = ARGV.getopts(*args)).each do |opt, val|\n      eval "$OPT_#{opt.gsub(/[^A-Za-z0-9_]/, '_')} = val"\n    end\n  rescue OptionParser::ParseError\n  end\n
options OptionParser::Arguable.options()\nActual OptionParser object, automatically created if nonexistent.\n\nIf called with a block, yields the OptionParser object and returns the\nresult of the block. If an OptionParser::ParseError exception occurs\nin the block, it is rescued, a error message printed to STDERR and\n+nil+ returned.\n
options= OptionParser::Arguable.options=(opt)\nSets OptionParser object, when +opt+ is +false+ or +nil+, methods\nOptionParser::Arguable#options and OptionParser::Arguable#options= are\nundefined. Thus, there is no ways to access the OptionParser object\nvia the receiver object.\n
order! OptionParser::Arguable.order!(&blk)\nParses +self+ destructively in order and returns +self+ containing the\nrest arguments left unparsed.\n
parse! OptionParser::Arguable.parse!()\nParses +self+ destructively and returns +self+ containing the\nrest arguments left unparsed.\n
permute! OptionParser::Arguable.permute!()\nParses +self+ destructively in permutation mode and returns +self+\ncontaining the rest arguments left unparsed.\n
find Find.find(*paths)\nCalls the associated block with the name of every file and directory listed\nas arguments, then recursively on their subdirectories, and so on.\n\nSee the +Find+ module documentation for an example.\n
prune Find.prune()\nSkips the current file or directory, restarting the loop with the next\nentry. If the current file is a directory, that directory will not be\nrecursively entered. Meaningful only within the block associated with\nFind::find.\n\nSee the +Find+ module documentation for an example.\n
add_key_option Gem::GemcutterUtilities.add_key_option()\nAdd the --key option\n
api_key Gem::GemcutterUtilities.api_key()\n\n
rubygems_api_request Gem::GemcutterUtilities.rubygems_api_request(method, path, host = Gem.host,\n&block)\n\n
sign_in Gem::GemcutterUtilities.sign_in()\n\n
verify_api_key Gem::GemcutterUtilities.verify_api_key(key)\n\n
with_response Gem::GemcutterUtilities.with_response(resp)\n\n
ui Gem::DefaultUserInteraction.ui()\nReturn the default UI.\n
ui= Gem::DefaultUserInteraction.ui=(new_ui)\nSet the default UI.  If the default UI is never explicitly set, a simple\nconsole based UserInteraction will be used automatically.\n
use_ui Gem::DefaultUserInteraction.use_ui(new_ui)\nUse +new_ui+ for the duration of +block+.\n
ui Gem::DefaultUserInteraction.ui()\nSee DefaultUserInteraction::ui\n
ui= Gem::DefaultUserInteraction.ui=(new_ui)\nSee DefaultUserInteraction::ui=\n
use_ui Gem::DefaultUserInteraction.use_ui(new_ui, &block)\nSee DefaultUserInteraction::use_ui\n
alert Gem::UserInteraction.alert(*args)\n\n
alert_error Gem::UserInteraction.alert_error(*args)\n\n
alert_warning Gem::UserInteraction.alert_warning(*args)\n\n
ask Gem::UserInteraction.ask(*args)\n\n
ask_for_password Gem::UserInteraction.ask_for_password(*args)\n\n
ask_yes_no Gem::UserInteraction.ask_yes_no(*args)\n\n
choose_from_list Gem::UserInteraction.choose_from_list(*args)\n\n
say Gem::UserInteraction.say(*args)\n\n
terminate_interaction Gem::UserInteraction.terminate_interaction(*args)\n\n
open Gem::Package.open(io, mode = "r", signer = nil, &block)\nFIX: zenspider said: does it really take an IO?\npassed to a method called open?!? that seems stupid.\n
pack Gem::Package.pack(src, destname, signer = nil)\n\n
add_platform_option Gem::VersionOption.add_platform_option(task = command, *wrap)\nAdd the --platform option to the option parser.\n
add_prerelease_option Gem::VersionOption.add_prerelease_option(*wrap)\nAdd the --prerelease option to the option parser.\n
add_version_option Gem::VersionOption.add_version_option(task = command, *wrap)\nAdd the --version option to the option parser.\n
write_require_paths_file_if_needed Gem::RequirePathsBuilder.write_require_paths_file_if_needed(spec = @spec,\ngem_home = @gem_home)\n\n
deprecate Gem::Deprecate.deprecate(name, repl, year, month)\nSimple deprecation method that deprecates +name+ by wrapping it up\nin a dummy method. It warns on each call to the dummy method\ntelling the user of +repl+ (unless +repl+ is :none) and the\nyear/month that it is planned to go away.\n
skip_during Gem::Deprecate.skip_during()\nTemporarily turn off warnings. Intended for tests only.\n
noecho Gem::MockGemUi::TTY.noecho()\n\n
tty? Gem::MockGemUi::TTY.tty?()\n\n
debug OpenSSL.debug()\n\n
debug= OpenSSL.debug=(p1)\nTurns on or off CRYPTO_MEM_CHECK.\nAlso shows some debugging message on stderr.\n
errors OpenSSL.errors()\nSee any remaining errors held in queue.\n\nAny errors you see here are probably due to a bug in ruby's OpenSSL\nimplementation.\n
accept_uri_http Gem::LocalRemoteOptions.accept_uri_http()\nAllows OptionParser to handle HTTP URIs.\n
add_bulk_threshold_option Gem::LocalRemoteOptions.add_bulk_threshold_option()\nAdd the --bulk-threshold option\n
add_clear_sources_option Gem::LocalRemoteOptions.add_clear_sources_option()\nAdd the --clear-sources option\n
add_local_remote_options Gem::LocalRemoteOptions.add_local_remote_options()\nAdd local/remote options to the command line parser.\n
add_proxy_option Gem::LocalRemoteOptions.add_proxy_option()\nAdd the --http-proxy option\n
add_source_option Gem::LocalRemoteOptions.add_source_option()\nAdd the --source option\n
add_update_sources_option Gem::LocalRemoteOptions.add_update_sources_option()\nAdd the --update-sources option\n
both? Gem::LocalRemoteOptions.both?()\nIs fetching of local and remote information enabled?\n
local? Gem::LocalRemoteOptions.local?()\nIs local fetching enabled?\n
remote? Gem::LocalRemoteOptions.remote?()\nIs remote fetching enabled?\n
add_trusted_cert Gem::Security.add_trusted_cert(cert, opt = {})\nAdd certificate to trusted cert list.\n\nNote: At the moment these are stored in OPT[:trust_dir], although that\ndirectory may change in the future.\n
build_cert Gem::Security.build_cert(name, key, opt = {})\nBuild a certificate from the given DN and private key.\n
build_self_signed_cert Gem::Security.build_self_signed_cert(email_addr, opt = {})\nBuild a self-signed certificate for the given email address.\n
email_to_name Gem::Security.email_to_name(email_address, munge_re)\nTurns +email_address+ into an OpenSSL::X509::Name\n
sign_cert Gem::Security.sign_cert(cert, signing_key, signing_cert, opt = {})\nSign the cert cert with @signing_key and @signing_cert, using the digest\nalgorithm opt[:dgst_algo]. Returns the newly signed certificate.\n
verify_trust_dir Gem::Security.verify_trust_dir(path, perms)\nMake sure the trust directory exists.  If it does exist, make sure it's\nactually a directory.  If not, then create it with the appropriate\npermissions.\n
add_install_update_options Gem::InstallUpdateOptions.add_install_update_options()\nAdd the install/update options to the option parser.\n
install_update_defaults_str Gem::InstallUpdateOptions.install_update_defaults_str()\nDefault options for the gem install command.\n
format_text Gem::Text.format_text(text, wrap, indent=0)\nWraps +text+ to +wrap+ characters and optionally indents by +indent+\ncharacters\n
levenshtein_distance Gem::Text.levenshtein_distance(str1, str2)\nThis code is based directly on the Text gem implementation\nReturns a value representing the "cost" of transforming str1 into str2\n
print_profile Profiler__.print_profile(f)\n\n
start_profile Profiler__.start_profile()\n\n
stop_profile Profiler__.stop_profile()\n\n
extend_object MonitorMixin.extend_object(obj)\n\n
new MonitorMixin.new(*args)\nUse <tt>extend MonitorMixin</tt> or <tt>include MonitorMixin</tt> instead\nof this constructor.  Have look at the examples above to understand how to\nuse this module.\n
mon_enter MonitorMixin.mon_enter()\nEnters exclusive section.\n
mon_exit MonitorMixin.mon_exit()\nLeaves exclusive section.\n
mon_synchronize MonitorMixin.mon_synchronize()\nEnters exclusive section and executes the block.  Leaves the exclusive\nsection automatically when the block exits.  See example under\n+MonitorMixin+.\n
mon_try_enter MonitorMixin.mon_try_enter()\nAttempts to enter exclusive section.  Returns +false+ if lock fails.\n
new_cond MonitorMixin.new_cond()\nCreates a new MonitorMixin::ConditionVariable associated with the\nreceiver.\n
synchronize MonitorMixin.synchronize()\n\n
try_mon_enter MonitorMixin.try_mon_enter()\nFor backward compatibility\n
have_run? Test::Unit::RunCount.have_run?()\n\n
run_once Test::Unit::RunCount.run_once()\n\n
run Test::Unit::RunCount.run(*)\n\n
new Test::Unit::Options.new(*, &block)\n\n
option_parser Test::Unit::Options.option_parser()\n\n
process_args Test::Unit::Options.process_args(args = [])\n\n
non_options Test::Unit::GlobOption.non_options(files, options)\n\n
setup_options Test::Unit::GlobOption.setup_options(parser, options)\n\n
setup_options Test::Unit::LoadPathOption.setup_options(parser, options)\n\n
non_options Test::Unit::GCStressOption.non_options(files, options)\n\n
setup_options Test::Unit::GCStressOption.setup_options(parser, options)\n\n
non_options Test::Unit::RequireFiles.non_options(files, options)\n\n
assert Test::Unit::Assertions.assert(test, msg = UNASSIGNED)\nTests if +test+ is true.\n\n+msg+ may be a String or a Proc. If +msg+ is a String, it will be used\nas the failure message. Otherwise, the result of calling +msg+ will be\nused as the message if the assertion fails.\n\nIf no +msg+ is given, a default message will be used.\n\n    assert(false, "This was expected to be true")\n
assert_block Test::Unit::Assertions.assert_block(*msgs)\nTests the result of the given block. If the block does not return true,\nthe assertion will fail. The optional +failure_message+ argument is the same\nas in\nAssertions#assert.\n\n    assert_block do\n      [1, 2, 3].any? { |num| num < 1 }\n    end\n
assert_equal Test::Unit::Assertions.assert_equal(exp, act, msg = nil)\nTests if +expected+ is equal to +actual+.\n\nAn optional failure message may be provided as the final argument.\n
assert_no_match Test::Unit::Assertions.assert_no_match(regexp, string, msg=nil)\nTests if the given Regexp does not match a given String.\n\nAn optional failure message may be provided as the final argument.\n
assert_not_equal Test::Unit::Assertions.assert_not_equal(exp, act, msg=nil)\nTests if +expected+ is not equal to +actual+.\n\nAn optional failure message may be provided as the final argument.\n
assert_not_nil Test::Unit::Assertions.assert_not_nil(exp, msg=nil)\nTests if +expression+ is not nil.\n\nAn optional failure message may be provided as the final argument.\n
assert_not_same Test::Unit::Assertions.assert_not_same(expected, actual, message="")\nTests if +expected+ is not the same object as +actual+.\nThis test uses Object#equal? to test equality.\n\nAn optional failure message may be provided as the final argument.\n\n    assert_not_same("x", "x") #Succeeds\n
assert_not_send Test::Unit::Assertions.assert_not_send(send_ary, m = nil)\nPasses if the method send doesn't return a true value.\n\n+send_array+ is composed of:\n* A receiver\n* A method\n* Arguments to the method\n\nExample:\n  assert_not_send([[1, 2], :member?, 1]) # -> fail\n  assert_not_send([[1, 2], :member?, 4]) # -> pass\n
assert_nothing_raised Test::Unit::Assertions.assert_nothing_raised(*args)\nIf any exceptions are given as arguments, the assertion will\nfail if one of those exceptions are raised. Otherwise, the test fails\nif any exceptions are raised.\n\nThe final argument may be a failure message.\n\n    assert_nothing_raised RuntimeError do\n      raise Exception #Assertion passes, Exception is not a RuntimeError\n    end\n\n    assert_nothing_raised do\n      raise Exception #Assertion fails\n    end\n
assert_nothing_thrown Test::Unit::Assertions.assert_nothing_thrown(msg=nil)\nFails if the given block uses a call to Kernel#throw.\n\nAn optional failure message may be provided as the final argument.\n\n    assert_nothing_thrown "Something was thrown!" do\n      throw :problem?\n    end\n
assert_raise Test::Unit::Assertions.assert_raise(*args, &b)\nTests if the given block raises an exception. Acceptable exception\ntypes maye be given as optional arguments. If the last argument is a\nString, it will be used as the error message.\n\n    assert_raise do #Fails, no Exceptions are raised\n    end\n\n    assert_raise NameError do\n      puts x  #Raises NameError, so assertion succeeds\n    end\n
assert_respond_to Test::Unit::Assertions.assert_respond_to(obj, meth, msg = nil)\nTests if the given Object responds to +method+.\n\nAn optional failure message may be provided as the final argument.\n\n    assert_respond_to("hello", :reverse)  #Succeeds\n    assert_respond_to("hello", :does_not_exist)  #Fails\n
assert_send Test::Unit::Assertions.assert_send(send_ary, m = nil)\nPasses if the method send returns a true value.\n\n+send_array+ is composed of:\n* A receiver\n* A method\n* Arguments to the method\n\nExample:\n  assert_send([[1, 2], :member?, 1]) # -> pass\n  assert_send([[1, 2], :member?, 4]) # -> fail\n
application Rake.application()\nCurrent Rake Application\n
application= Rake.application=(app)\nSet the current Rake application object.\n
load_rakefile Rake.load_rakefile(path)\nLoad a rakefile.\n
original_dir Rake.original_dir()\nReturn the original directory where the Rake application was started.\n
run_tests Rake.run_tests(pattern='test/test*.rb', log_enabled=false)\n\n
clone Rake::Cloneable.clone()\n\n
dup Rake::Cloneable.dup()\nClone an object by making a new object and setting all the instance\nvariables to the same values.\n
copy Sys.copy(file_name, dest_file)\nCopy a single file from +file_name+ to +dest_file+.\n
copy_files Sys.copy_files(wildcard, dest_dir)\nCopy all files matching +wildcard+ into the directory +dest_dir+.\n
delete Sys.delete(*wildcards)\nRemove all files matching +wildcard+.  If a matching file is a\ndirectory, it must be empty to be removed.  used +delete_all+ to\nrecursively delete directories.\n
delete_all Sys.delete_all(*wildcards)\nRecursively delete all files and directories matching +wildcard+.\n
for_files Sys.for_files(*wildcards)\nPerform a block with each file matching a set of wildcards.\n
indir Sys.indir(dir)\nMake +dir+ the current working directory for the duration of\nexecuting the given block.\n
install Sys.install(wildcard, dest_dir, mode)\nInstall all the files matching +wildcard+ into the +dest_dir+\ndirectory.  The permission mode is set to +mode+.\n
link Sys.link(file_name, dest_file)\nLink +file_name+ to +dest_file+.\n
link_files Sys.link_files(wildcard, dest_dir)\nLink all files matching +wildcard+ into the directory +dest_dir+.\n
log Sys.log(msg)\nWrite a message to standard error if $verbose is enabled.\n
makedirs Sys.makedirs(*dirs)\nMake the directories given in +dirs+.\n
quiet Sys.quiet(&block)\nPerform a block with $verbose disabled.\n
ruby Sys.ruby(*args)\nRun a Ruby interpreter with the given arguments.\n
run Sys.run(cmd)\nRun the system command +cmd+.\n
split_all Sys.split_all(path)\nSplit a file path into individual directory names.\n\nFor example:\n  split_all("a/b/c") =>  ['a', 'b', 'c']\n
symlink Sys.symlink(file_name, dest_file)\nSymlink +file_name+ to +dest_file+.\n
symlink_files Sys.symlink_files(wildcard, dest_dir)\nSymlink all files matching +wildcard+ into the directory +dest_dir+.\n
verbose Sys.verbose(&block)\nPerform a block with $verbose enabled.\n
normalize Rake::Win32.normalize(path)\nNormalize a win32 path so that the slashes are all forward slashes.\n
rake_system Rake::Win32.rake_system(*cmd)\nRun a command line on windows.\n
windows? Rake::Win32.windows?()\nTrue if running on a windows system.\n
chain Rake::InvocationExceptionMixin.chain()\nReturn the invocation chain (list of Rake tasks) that were in\neffect when this exception was detected by rake.  May be null if\nno tasks were active.\n
chain= Rake::InvocationExceptionMixin.chain=(value)\nSet the invocation chain in effect when this exception was\ndetected.\n
nowrite Rake::FileUtilsExt.nowrite(value=nil)\nGet/set the nowrite flag controlling output from the FileUtils\nutilities.  If verbose is true, then the utility method is\nechoed to standard output.\n\nExamples:\n   nowrite              # return the current value of the\n nowrite flag\n   nowrite(v)           # set the nowrite flag to _v_.\n   nowrite(v) { code }  # Execute code with the nowrite flag set\n temporarily to _v_. Return to the\n original value when code is done.\n
rake_check_options Rake::FileUtilsExt.rake_check_options(options, *optdecl)\nCheck that the options do not contain options not listed in\n+optdecl+.  An ArgumentError exception is thrown if non-declared\noptions are found.\n
rake_merge_option Rake::FileUtilsExt.rake_merge_option(args, defaults)\nMerge the given options with the default values.\n
rake_output_message Rake::FileUtilsExt.rake_output_message(message)\nSend the message to the default rake output (which is $stderr).\n
verbose Rake::FileUtilsExt.verbose(value=nil)\nGet/set the verbose flag controlling output from the FileUtils\nutilities.  If verbose is true, then the utility method is\nechoed to standard output.\n\nExamples:\n   verbose              # return the current value of the\n verbose flag\n   verbose(v)           # set the verbose flag to _v_.\n   verbose(v) { code }  # Execute code with the verbose flag set\n temporarily to _v_.  Return to the\n original value when code is done.\n
when_writing Rake::FileUtilsExt.when_writing(msg=nil)\nUse this function to prevent potentially destructive ruby code\nfrom running when the :nowrite flag is set.\n\nExample:\n\n  when_writing("Building Project") do\n    project.build\n  end\n\nThe following code will build the project under normal\nconditions. If the nowrite(true) flag is set, then the example\nwill print:\n\n     DRYRUN: Building Project\n\ninstead of actually building the project.\n
define_module_function Rake::AltSystem.define_module_function(name, &block)\n\n
backticks Rake::AltSystem.backticks(cmd)\n\n
find_runnable Rake::AltSystem.find_runnable(file)\n\n
repair_command Rake::AltSystem.repair_command(cmd)\n\n
system Rake::AltSystem.system(cmd, *args)\n\n
new Rake::TaskManager.new()\n\n
clear Rake::TaskManager.clear()\nClear all tasks in this application.\n
create_rule Rake::TaskManager.create_rule(*args, &block)\n\n
current_scope Rake::TaskManager.current_scope()\nReturn the list of scope names currently active in the task\nmanager.\n
define_task Rake::TaskManager.define_task(task_class, *args, &block)\n\n
enhance_with_matching_rule Rake::TaskManager.enhance_with_matching_rule(task_name, level=0)\nIf a rule can be found that matches the task name, enhance the\ntask with the prerequisites and actions from the rule.  Set the\nsource attribute of the task appropriately for the rule.  Return\nthe enhanced task or nil of no rule was found.\n
in_namespace Rake::TaskManager.in_namespace(name)\nEvaluate the block in a nested namespace named +name+.  Create\nan anonymous namespace if +name+ is nil.\n
intern Rake::TaskManager.intern(task_class, task_name)\nLookup a task.  Return an existing task if found, otherwise\ncreate a task of the current type.\n
lookup Rake::TaskManager.lookup(task_name, initial_scope=nil)\nLookup a task, using scope and the scope hints in the task name.\nThis method performs straight lookups without trying to\nsynthesize file tasks or rules.  Special scope names (e.g. '^')\nare recognized.  If no scope argument is supplied, use the\ncurrent scope.  Return nil if the task cannot be found.\n
resolve_args Rake::TaskManager.resolve_args(args)\nResolve the arguments for a task/rule.  Returns a triplet of\n[task_name, arg_name_list, prerequisites].\n
synthesize_file_task Rake::TaskManager.synthesize_file_task(task_name)\n\n
tasks Rake::TaskManager.tasks()\nList of all defined tasks in this application.\n
tasks_in_scope Rake::TaskManager.tasks_in_scope(scope)\nList of all the tasks defined in the given scope (and its\nsub-scopes).\n
base64 SecureRandom.base64(n=nil)\nSecureRandom.base64 generates a random base64 string.\n\nThe argument _n_ specifies the length of the random length.\nThe length of the result string is about 4/3 of _n_.\n\nIf _n_ is not specified, 16 is assumed.\nIt may be larger in future.\n\nThe result may contain A-Z, a-z, 0-9, "+", "/" and "=".\n\n  p SecureRandom.base64 #=> "/2BuBuLf3+WfSKyQbRcc/A=="\n  p SecureRandom.base64 #=> "6BbW0pxO0YENxn38HMUbcQ=="\n\nIf secure random number generator is not available,\nNotImplementedError is raised.\n\nSee RFC 3548 for the definition of base64.\n
hex SecureRandom.hex(n=nil)\nSecureRandom.hex generates a random hex string.\n\nThe argument _n_ specifies the length of the random length.\nThe length of the result string is twice of _n_.\n\nIf _n_ is not specified, 16 is assumed.\nIt may be larger in future.\n\nThe result may contain 0-9 and a-f.\n\n  p SecureRandom.hex #=> "eb693ec8252cd630102fd0d0fb7c3485"\n  p SecureRandom.hex #=> "91dc3bfb4de5b11d029d376634589b61"\n\nIf secure random number generator is not available,\nNotImplementedError is raised.\n
random_bytes SecureRandom.random_bytes(n=nil)\nSecureRandom.random_bytes generates a random binary string.\n\nThe argument _n_ specifies the length of the result string.\n\nIf _n_ is not specified, 16 is assumed.\nIt may be larger in future.\n\nThe result may contain any byte: "\x00" - "\xff".\n\n  p SecureRandom.random_bytes #=>\n  "\xD8\\\xE0\xF4\r\xB2\xFC*WM\xFF\x83\x18\xF45\xB6"\n  p SecureRandom.random_bytes #=> "m\xDC\xFC/\a\x00Uf\xB2\xB2P\xBD\xFF6S\x97"\n\nIf secure random number generator is not available,\nNotImplementedError is raised.\n
random_number SecureRandom.random_number(n=0)\nSecureRandom.random_number generates a random number.\n\nIf a positive integer is given as _n_,\nSecureRandom.random_number returns an integer:\n0 <= SecureRandom.random_number(n) < n.\n\n  p SecureRandom.random_number(100) #=> 15\n  p SecureRandom.random_number(100) #=> 88\n\nIf 0 is given or an argument is not given,\nSecureRandom.random_number returns a float:\n0.0 <= SecureRandom.random_number() < 1.0.\n\n  p SecureRandom.random_number #=> 0.596506046187744\n  p SecureRandom.random_number #=> 0.350621695741409\n
urlsafe_base64 SecureRandom.urlsafe_base64(n=nil, padding=false)\nSecureRandom.urlsafe_base64 generates a random URL-safe base64 string.\n\nThe argument _n_ specifies the length of the random length.\nThe length of the result string is about 4/3 of _n_.\n\nIf _n_ is not specified, 16 is assumed.\nIt may be larger in future.\n\nThe boolean argument _padding_ specifies the padding.\nIf it is false or nil, padding is not generated.\nOtherwise padding is generated.\nBy default, padding is not generated because "=" may be used as a URL\ndelimiter.\n\nThe result may contain A-Z, a-z, 0-9, "-" and "_".\n"=" is also used if _padding_ is true.\n\n  p SecureRandom.urlsafe_base64 #=> "b4GOKm4pOYU_-BOXcrUGDg"\n  p SecureRandom.urlsafe_base64 #=> "UZLdOkzop70Ddx-IJR0ABg"\n\n  p SecureRandom.urlsafe_base64(nil, true) #=> "i0XQ-7gglIsHGV2_BNPrdQ=="\n  p SecureRandom.urlsafe_base64(nil, true) #=> "-M8rLhr7JEpJlqFGUMmOxg=="\n\nIf secure random number generator is not available,\nNotImplementedError is raised.\n\nSee RFC 3548 for the definition of URL-safe base64.\n
uuid SecureRandom.uuid()\nSecureRandom.uuid generates a v4 random UUID (Universally Unique IDentifier).\n\n  p SecureRandom.uuid #=> "2d931510-d99f-494a-8c67-87feb05e1594"\n  p SecureRandom.uuid #=> "bad85eb9-0713-4da7-8d36-07a8e4b00eab"\n  p SecureRandom.uuid #=> "62936e70-1815-439b-bf89-8492855a7e6b"\n\nThe version 4 UUID is purely random (except the version).\nIt doesn't contain meaningful information such as MAC address, time, etc.\n\nSee RFC 4122 for details of UUID.\n
a CGI::HtmlExtension.a(href = "")\nGenerate an Anchor element as a string.\n\n+href+ can either be a string, giving the URL\nfor the HREF attribute, or it can be a hash of\nthe element's attributes.\n\nThe body of the element is the string returned by the no-argument\nblock passed in.\n\n  a("http://www.example.com") { "Example" }\n => "<A HREF=\"http://www.example.com\">Example</A>"\n\n  a("HREF" => "http://www.example.com", "TARGET" => "_top") { "Example" }\n => "<A HREF=\"http://www.example.com\" TARGET=\"_top\">Example</A>"\n
base CGI::HtmlExtension.base(href = "")\nGenerate a Document Base URI element as a String.\n\n+href+ can either by a string, giving the base URL for the HREF\nattribute, or it can be a has of the element's attributes.\n\nThe passed-in no-argument block is ignored.\n\n  base("http://www.example.com/cgi")\n => "<BASE HREF=\"http://www.example.com/cgi\">"\n
blockquote CGI::HtmlExtension.blockquote(cite = {})\nGenerate a BlockQuote element as a string.\n\n+cite+ can either be a string, give the URI for the source of\nthe quoted text, or a hash, giving all attributes of the element,\nor it can be omitted, in which case the element has no attributes.\n\nThe body is provided by the passed-in no-argument block\n\n  blockquote("http://www.example.com/quotes/foo.html") { "Foo!" }\n=> "<BLOCKQUOTE\nCITE=\"http://www.example.com/quotes/foo.html\">Foo!</BLOCKQUOTE>\n
caption CGI::HtmlExtension.caption(align = {})\nGenerate a Table Caption element as a string.\n\n+align+ can be a string, giving the alignment of the caption\n(one of top, bottom, left, or right).  It can be a hash of\nall the attributes of the element.  Or it can be omitted.\n\nThe body of the element is provided by the passed-in no-argument block.\n\n  caption("left") { "Capital Cities" }\n => <CAPTION ALIGN=\"left\">Capital Cities</CAPTION>\n
checkbox CGI::HtmlExtension.checkbox(name = "", value = nil, checked = nil)\nGenerate a Checkbox Input element as a string.\n\nThe attributes of the element can be specified as three arguments,\n+name+, +value+, and +checked+.  +checked+ is a boolean value;\nif true, the CHECKED attribute will be included in the element.\n\nAlternatively, the attributes can be specified as a hash.\n\n  checkbox("name")\n = checkbox("NAME" => "name")\n\n  checkbox("name", "value")\n = checkbox("NAME" => "name", "VALUE" => "value")\n\n  checkbox("name", "value", true)\n = checkbox("NAME" => "name", "VALUE" => "value", "CHECKED" => true)\n
checkbox_group CGI::HtmlExtension.checkbox_group(name = "", *values)\nGenerate a sequence of checkbox elements, as a String.\n\nThe checkboxes will all have the same +name+ attribute.\nEach checkbox is followed by a label.\nThere will be one checkbox for each value.  Each value\ncan be specified as a String, which will be used both\nas the value of the VALUE attribute and as the label\nfor that checkbox.  A single-element array has the\nsame effect.\n\nEach value can also be specified as a three-element array.\nThe first element is the VALUE attribute; the second is the\nlabel; and the third is a boolean specifying whether this\ncheckbox is CHECKED.\n\nEach value can also be specified as a two-element\narray, by omitting either the value element (defaults\nto the same as the label), or the boolean checked element\n(defaults to false).\n\n  checkbox_group("name", "foo", "bar", "baz")\n <INPUT TYPE="checkbox" NAME="name" VALUE="foo">foo\n <INPUT TYPE="checkbox" NAME="name" VALUE="bar">bar\n <INPUT TYPE="checkbox" NAME="name" VALUE="baz">baz\n\n  checkbox_group("name", ["foo"], ["bar", true], "baz")\n <INPUT TYPE="checkbox" NAME="name" VALUE="foo">foo\n <INPUT TYPE="checkbox" CHECKED NAME="name" VALUE="bar">bar\n <INPUT TYPE="checkbox" NAME="name" VALUE="baz">baz\n\n  checkbox_group("name", ["1", "Foo"], ["2", "Bar", true], "Baz")\n <INPUT TYPE="checkbox" NAME="name" VALUE="1">Foo\n <INPUT TYPE="checkbox" CHECKED NAME="name" VALUE="2">Bar\n <INPUT TYPE="checkbox" NAME="name" VALUE="Baz">Baz\n\n  checkbox_group("NAME" => "name",\n                   "VALUES" => ["foo", "bar", "baz"])\n\n  checkbox_group("NAME" => "name",\n                   "VALUES" => [["foo"], ["bar", true], "baz"])\n\n  checkbox_group("NAME" => "name",\n                   "VALUES" => [["1", "Foo"], ["2", "Bar", true], "Baz"])\n
file_field CGI::HtmlExtension.file_field(name = "", size = 20, maxlength = nil)\nGenerate an File Upload Input element as a string.\n\nThe attributes of the element can be specified as three arguments,\n+name+, +size+, and +maxlength+.  +maxlength+ is the maximum length\nof the file's _name_, not of the file's _contents_.\n\nAlternatively, the attributes can be specified as a hash.\n\nSee #multipart_form() for forms that include file uploads.\n\n  file_field("name")\n <INPUT TYPE="file" NAME="name" SIZE="20">\n\n  file_field("name", 40)\n <INPUT TYPE="file" NAME="name" SIZE="40">\n\n  file_field("name", 40, 100)\n <INPUT TYPE="file" NAME="name" SIZE="40" MAXLENGTH="100">\n\n  file_field("NAME" => "name", "SIZE" => 40)\n <INPUT TYPE="file" NAME="name" SIZE="40">\n
form CGI::HtmlExtension.form(method = "post", action = script_name, enctype =\n"application/x-www-form-urlencoded")\nGenerate a Form element as a string.\n\n+method+ should be either "get" or "post", and defaults to the latter.\n+action+ defaults to the current CGI script name.  +enctype+\ndefaults to "application/x-www-form-urlencoded".\n\nAlternatively, the attributes can be specified as a hash.\n\nSee also #multipart_form() for forms that include file uploads.\n\n  form{ "string" }\n <FORM METHOD="post" ENCTYPE="application/x-www-form-urlencoded">string</FORM>\n\n  form("get") { "string" }\n <FORM METHOD="get" ENCTYPE="application/x-www-form-urlencoded">string</FORM>\n\n  form("get", "url") { "string" }\n <FORM METHOD="get" ACTION="url"\n ENCTYPE="application/x-www-form-urlencoded">string</FORM>\n\n  form("METHOD" => "post", "ENCTYPE" => "enctype") { "string" }\n <FORM METHOD="post" ENCTYPE="enctype">string</FORM>\n
hidden CGI::HtmlExtension.hidden(name = "", value = nil)\nGenerate a Hidden Input element as a string.\n\nThe attributes of the element can be specified as two arguments,\n+name+ and +value+.\n\nAlternatively, the attributes can be specified as a hash.\n\n  hidden("name")\n <INPUT TYPE="hidden" NAME="name">\n\n  hidden("name", "value")\n <INPUT TYPE="hidden" NAME="name" VALUE="value">\n\n  hidden("NAME" => "name", "VALUE" => "reset", "ID" => "foo")\n <INPUT TYPE="hidden" NAME="name" VALUE="value" ID="foo">\n
html CGI::HtmlExtension.html(attributes = {})\nGenerate a top-level HTML element as a string.\n\nThe attributes of the element are specified as a hash.  The\npseudo-attribute "PRETTY" can be used to specify that the generated\nHTML string should be indented.  "PRETTY" can also be specified as\na string as the sole argument to this method.  The pseudo-attribute\n"DOCTYPE", if given, is used as the leading DOCTYPE SGML tag; it\nshould include the entire text of this tag, including angle brackets.\n\nThe body of the html element is supplied as a block.\n\n  html{ "string" }\n <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"><HTML>string</HTML>\n\n  html("LANG" => "ja") { "string" }\n <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"><HTML\n LANG="ja">string</HTML>\n\n  html("DOCTYPE" => false) { "string" }\n <HTML>string</HTML>\n\n  html("DOCTYPE" => '<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">') {\n  "string" }\n <!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN"><HTML>string</HTML>\n\n  html("PRETTY" => "  ") { "<BODY></BODY>" }\n <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n <HTML>\n   <BODY>\n   </BODY>\n </HTML>\n\n  html("PRETTY" => "\t") { "<BODY></BODY>" }\n <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n <HTML>\n         <BODY>\n         </BODY>\n </HTML>\n\n  html("PRETTY") { "<BODY></BODY>" }\n = html("PRETTY" => "  ") { "<BODY></BODY>" }\n\n  html(if $VERBOSE then "PRETTY" end) { "HTML string" }\n
image_button CGI::HtmlExtension.image_button(src = "", name = nil, alt = nil)\nGenerate an Image Button Input element as a string.\n\n+src+ is the URL of the image to use for the button.  +name+\nis the input name.  +alt+ is the alternative text for the image.\n\nAlternatively, the attributes can be specified as a hash.\n\n  image_button("url")\n <INPUT TYPE="image" SRC="url">\n\n  image_button("url", "name", "string")\n <INPUT TYPE="image" SRC="url" NAME="name" ALT="string">\n\n  image_button("SRC" => "url", "ALT" => "string")\n <INPUT TYPE="image" SRC="url" ALT="string">\n
img CGI::HtmlExtension.img(src = "", alt = "", width = nil, height = nil)\nGenerate an Image element as a string.\n\n+src+ is the URL of the image.  +alt+ is the alternative text for\nthe image.  +width+ is the width of the image, and +height+ is\nits height.\n\nAlternatively, the attributes can be specified as a hash.\n\n  img("src", "alt", 100, 50)\n <IMG SRC="src" ALT="alt" WIDTH="100" HEIGHT="50">\n\n  img("SRC" => "src", "ALT" => "alt", "WIDTH" => 100, "HEIGHT" => 50)\n <IMG SRC="src" ALT="alt" WIDTH="100" HEIGHT="50">\n
multipart_form CGI::HtmlExtension.multipart_form(action = nil, enctype =\n"multipart/form-data")\nGenerate a Form element with multipart encoding as a String.\n\nMultipart encoding is used for forms that include file uploads.\n\n+action+ is the action to perform.  +enctype+ is the encoding\ntype, which defaults to "multipart/form-data".\n\nAlternatively, the attributes can be specified as a hash.\n\n  multipart_form{ "string" }\n <FORM METHOD="post" ENCTYPE="multipart/form-data">string</FORM>\n\n  multipart_form("url") { "string" }\n <FORM METHOD="post" ACTION="url" ENCTYPE="multipart/form-data">string</FORM>\n
password_field CGI::HtmlExtension.password_field(name = "", value = nil, size = 40, maxlength\n= nil)\nGenerate a Password Input element as a string.\n\n+name+ is the name of the input field.  +value+ is its default\nvalue.  +size+ is the size of the input field display.  +maxlength+\nis the maximum length of the inputted password.\n\nAlternatively, attributes can be specified as a hash.\n\n  password_field("name")\n <INPUT TYPE="password" NAME="name" SIZE="40">\n\n  password_field("name", "value")\n <INPUT TYPE="password" NAME="name" VALUE="value" SIZE="40">\n\n  password_field("password", "value", 80, 200)\n <INPUT TYPE="password" NAME="name" VALUE="value" SIZE="80" MAXLENGTH="200">\n\n  password_field("NAME" => "name", "VALUE" => "value")\n <INPUT TYPE="password" NAME="name" VALUE="value">\n
popup_menu CGI::HtmlExtension.popup_menu(name = "", *values)\nGenerate a Select element as a string.\n\n+name+ is the name of the element.  The +values+ are the options that\ncan be selected from the Select menu.  Each value can be a String or\na one, two, or three-element Array.  If a String or a one-element\nArray, this is both the value of that option and the text displayed for\nit.  If a three-element Array, the elements are the option value, displayed\ntext, and a boolean value specifying whether this option starts as selected.\nThe two-element version omits either the option value (defaults to the same\nas the display text) or the boolean selected specifier (defaults to false).\n\nThe attributes and options can also be specified as a hash.  In this\ncase, options are specified as an array of values as described above,\nwith the hash key of "VALUES".\n\n  popup_menu("name", "foo", "bar", "baz")\n <SELECT NAME="name">\n   <OPTION VALUE="foo">foo</OPTION>\n   <OPTION VALUE="bar">bar</OPTION>\n   <OPTION VALUE="baz">baz</OPTION>\n </SELECT>\n\n  popup_menu("name", ["foo"], ["bar", true], "baz")\n <SELECT NAME="name">\n   <OPTION VALUE="foo">foo</OPTION>\n   <OPTION VALUE="bar" SELECTED>bar</OPTION>\n   <OPTION VALUE="baz">baz</OPTION>\n </SELECT>\n\n  popup_menu("name", ["1", "Foo"], ["2", "Bar", true], "Baz")\n <SELECT NAME="name">\n   <OPTION VALUE="1">Foo</OPTION>\n   <OPTION SELECTED VALUE="2">Bar</OPTION>\n   <OPTION VALUE="Baz">Baz</OPTION>\n </SELECT>\n\n  popup_menu("NAME" => "name", "SIZE" => 2, "MULTIPLE" => true,\n              "VALUES" => [["1", "Foo"], ["2", "Bar", true], "Baz"])\n <SELECT NAME="name" MULTIPLE SIZE="2">\n   <OPTION VALUE="1">Foo</OPTION>\n   <OPTION SELECTED VALUE="2">Bar</OPTION>\n   <OPTION VALUE="Baz">Baz</OPTION>\n </SELECT>\n
radio_button CGI::HtmlExtension.radio_button(name = "", value = nil, checked = nil)\nGenerates a radio-button Input element.\n\n+name+ is the name of the input field.  +value+ is the value of\nthe field if checked.  +checked+ specifies whether the field\nstarts off checked.\n\nAlternatively, the attributes can be specified as a hash.\n\n  radio_button("name", "value")\n <INPUT TYPE="radio" NAME="name" VALUE="value">\n\n  radio_button("name", "value", true)\n <INPUT TYPE="radio" NAME="name" VALUE="value" CHECKED>\n\n  radio_button("NAME" => "name", "VALUE" => "value", "ID" => "foo")\n <INPUT TYPE="radio" NAME="name" VALUE="value" ID="foo">\n
radio_group CGI::HtmlExtension.radio_group(name = "", *values)\nGenerate a sequence of radio button Input elements, as a String.\n\nThis works the same as #checkbox_group().  However, it is not valid\nto have more than one radiobutton in a group checked.\n\n  radio_group("name", "foo", "bar", "baz")\n <INPUT TYPE="radio" NAME="name" VALUE="foo">foo\n <INPUT TYPE="radio" NAME="name" VALUE="bar">bar\n <INPUT TYPE="radio" NAME="name" VALUE="baz">baz\n\n  radio_group("name", ["foo"], ["bar", true], "baz")\n <INPUT TYPE="radio" NAME="name" VALUE="foo">foo\n <INPUT TYPE="radio" CHECKED NAME="name" VALUE="bar">bar\n <INPUT TYPE="radio" NAME="name" VALUE="baz">baz\n\n  radio_group("name", ["1", "Foo"], ["2", "Bar", true], "Baz")\n <INPUT TYPE="radio" NAME="name" VALUE="1">Foo\n <INPUT TYPE="radio" CHECKED NAME="name" VALUE="2">Bar\n <INPUT TYPE="radio" NAME="name" VALUE="Baz">Baz\n\n  radio_group("NAME" => "name",\n                "VALUES" => ["foo", "bar", "baz"])\n\n  radio_group("NAME" => "name",\n                "VALUES" => [["foo"], ["bar", true], "baz"])\n\n  radio_group("NAME" => "name",\n                "VALUES" => [["1", "Foo"], ["2", "Bar", true], "Baz"])\n
reset CGI::HtmlExtension.reset(value = nil, name = nil)\nGenerate a reset button Input element, as a String.\n\nThis resets the values on a form to their initial values.  +value+\nis the text displayed on the button. +name+ is the name of this button.\n\nAlternatively, the attributes can be specified as a hash.\n\n  reset\n <INPUT TYPE="reset">\n\n  reset("reset")\n <INPUT TYPE="reset" VALUE="reset">\n\n  reset("VALUE" => "reset", "ID" => "foo")\n <INPUT TYPE="reset" VALUE="reset" ID="foo">\n
scrolling_list CGI::HtmlExtension.scrolling_list(name = "", *values)\n\n
submit CGI::HtmlExtension.submit(value = nil, name = nil)\nGenerate a submit button Input element, as a String.\n\n+value+ is the text to display on the button.  +name+ is the name\nof the input.\n\nAlternatively, the attributes can be specified as a hash.\n\n  submit\n <INPUT TYPE="submit">\n\n  submit("ok")\n <INPUT TYPE="submit" VALUE="ok">\n\n  submit("ok", "button1")\n <INPUT TYPE="submit" VALUE="ok" NAME="button1">\n\n  submit("VALUE" => "ok", "NAME" => "button1", "ID" => "foo")\n <INPUT TYPE="submit" VALUE="ok" NAME="button1" ID="foo">\n
text_field CGI::HtmlExtension.text_field(name = "", value = nil, size = 40, maxlength\n= nil)\nGenerate a text field Input element, as a String.\n\n+name+ is the name of the input field.  +value+ is its initial\nvalue.  +size+ is the size of the input area.  +maxlength+\nis the maximum length of input accepted.\n\nAlternatively, the attributes can be specified as a hash.\n\n  text_field("name")\n <INPUT TYPE="text" NAME="name" SIZE="40">\n\n  text_field("name", "value")\n <INPUT TYPE="text" NAME="name" VALUE="value" SIZE="40">\n\n  text_field("name", "value", 80)\n <INPUT TYPE="text" NAME="name" VALUE="value" SIZE="80">\n\n  text_field("name", "value", 80, 200)\n <INPUT TYPE="text" NAME="name" VALUE="value" SIZE="80" MAXLENGTH="200">\n\n  text_field("NAME" => "name", "VALUE" => "value")\n <INPUT TYPE="text" NAME="name" VALUE="value">\n
textarea CGI::HtmlExtension.textarea(name = "", cols = 70, rows = 10)\nGenerate a TextArea element, as a String.\n\n+name+ is the name of the textarea.  +cols+ is the number of\ncolumns and +rows+ is the number of rows in the display.\n\nAlternatively, the attributes can be specified as a hash.\n\nThe body is provided by the passed-in no-argument block\n\n  textarea("name")\n = textarea("NAME" => "name", "COLS" => 70, "ROWS" => 10)\n\n  textarea("name", 40, 5)\n = textarea("NAME" => "name", "COLS" => 40, "ROWS" => 5)\n
has_key? CGI::QueryExtension.has_key?(*args)\nReturns true if a given query string parameter exists.\n
include? CGI::QueryExtension.include?(*args)\n\n
key? CGI::QueryExtension.key?(*args)\n\n
keys CGI::QueryExtension.keys(*args)\nReturn all query parameter names as an array of String.\n
multipart? CGI::QueryExtension.multipart?()\nReturns whether the form contained multipart/form-data\n
params= CGI::QueryExtension.params=(hash)\nSet all the parameters.\n
raw_cookie CGI::QueryExtension.raw_cookie()\nGet the raw cookies as a string.\n
raw_cookie2 CGI::QueryExtension.raw_cookie2()\nGet the raw RFC2965 cookies as a string.\n
add_field Net::HTTPHeader.add_field(key, val)\n[Ruby 1.8.3]\nAdds a value to a named header field, instead of replacing its value.\nSecond argument +val+ must be a String.\nSee also #[]=, #[] and #get_fields.\n\n  request.add_field 'X-My-Header', 'a'\n  p request['X-My-Header']              #=> "a"\n  p request.get_fields('X-My-Header')   #=> ["a"]\n  request.add_field 'X-My-Header', 'b'\n  p request['X-My-Header']              #=> "a, b"\n  p request.get_fields('X-My-Header')   #=> ["a", "b"]\n  request.add_field 'X-My-Header', 'c'\n  p request['X-My-Header']              #=> "a, b, c"\n  p request.get_fields('X-My-Header')   #=> ["a", "b", "c"]\n
basic_auth Net::HTTPHeader.basic_auth(account, password)\nSet the Authorization: header for "Basic" authorization.\n
canonical_each Net::HTTPHeader.canonical_each()\n\n
chunked? Net::HTTPHeader.chunked?()\nReturns "true" if the "transfer-encoding" header is present and\nset to "chunked".  This is an HTTP/1.1 feature, allowing the\nthe content to be sent in "chunks" without at the outset\nstating the entire content length.\n
connection_close? Net::HTTPHeader.connection_close?()\n\n
connection_keep_alive? Net::HTTPHeader.connection_keep_alive?()\n\n
content_length Net::HTTPHeader.content_length()\nReturns an Integer object which represents the HTTP Content-Length:\nheader field, or +nil+ if that field was not provided.\n
content_length= Net::HTTPHeader.content_length=(len)\n\n
content_range Net::HTTPHeader.content_range()\nReturns a Range object which represents the value of the Content-Range:\nheader field.\nFor a partial entity body, this indicates where this fragment\nfits inside the full entity body, as range of byte offsets.\n
content_type Net::HTTPHeader.content_type()\nReturns a content type string such as "text/html".\nThis method returns nil if Content-Type: header field does not exist.\n
content_type= Net::HTTPHeader.content_type=(type, params = {})\n\n
delete Net::HTTPHeader.delete(key)\nRemoves a header field, specified by case-insensitive key.\n
each Net::HTTPHeader.each()\n\n
each_capitalized Net::HTTPHeader.each_capitalized()\nAs for #each_header, except the keys are provided in capitalized form.\n\nNote that header names are capitalized systematically;\ncapitalization may not match that used by the remote HTTP\nserver in its response.\n
each_capitalized_name Net::HTTPHeader.each_capitalized_name()\nIterates through the header names in the header, passing\ncapitalized header names to the code block.\n\nNote that header names are capitalized systematically;\ncapitalization may not match that used by the remote HTTP\nserver in its response.\n
each_header Net::HTTPHeader.each_header()\nIterates through the header names and values, passing in the name\nand value to the code block supplied.\n\nExample:\n\n    response.header.each_header {|key,value| puts "#{key} = #{value}" }\n
each_key Net::HTTPHeader.each_key()\n\n
each_name Net::HTTPHeader.each_name()\nIterates through the header names in the header, passing\neach header name to the code block.\n
each_value Net::HTTPHeader.each_value()\nIterates through header values, passing each value to the\ncode block.\n
fetch Net::HTTPHeader.fetch(key, *args)\nReturns the header field corresponding to the case-insensitive key.\nReturns the default value +args+, or the result of the block, or\nraises an IndexError if there's no header field named +key+\nSee Hash#fetch\n
form_data= Net::HTTPHeader.form_data=(params, sep = '&')\n\n
get_fields Net::HTTPHeader.get_fields(key)\n[Ruby 1.8.3]\nReturns an array of header field strings corresponding to the\ncase-insensitive +key+.  This method allows you to get duplicated\nheader fields without any processing.  See also #[].\n\n  p response.get_fields('Set-Cookie')\n=> ["session=al98axx; expires=Fri, 31-Dec-1999 23:58:23",\n         "query=rubyscript; expires=Fri, 31-Dec-1999 23:58:23"]\n  p response['Set-Cookie']\n=> "session=al98axx; expires=Fri, 31-Dec-1999 23:58:23, query=rubyscript;\nexpires=Fri, 31-Dec-1999 23:58:23"\n
initialize_http_header Net::HTTPHeader.initialize_http_header(initheader)\n\n
key? Net::HTTPHeader.key?(key)\ntrue if +key+ header exists.\n
main_type Net::HTTPHeader.main_type()\nReturns a content type string such as "text".\nThis method returns nil if Content-Type: header field does not exist.\n
proxy_basic_auth Net::HTTPHeader.proxy_basic_auth(account, password)\nSet Proxy-Authorization: header for "Basic" authorization.\n
range Net::HTTPHeader.range()\nReturns an Array of Range objects which represent the Range:\nHTTP header field, or +nil+ if there is no such header.\n
range= Net::HTTPHeader.range=(r, e = nil)\n\n
range_length Net::HTTPHeader.range_length()\nThe length of the range represented in Content-Range: header.\n
set_content_type Net::HTTPHeader.set_content_type(type, params = {})\nSets the content type in an HTTP header.\nThe +type+ should be a full HTTP content type, e.g. "text/html".\nThe +params+ are an optional Hash of parameters to add after the\ncontent type, e.g. {'charset' => 'iso-8859-1'}\n
set_form Net::HTTPHeader.set_form(params, enctype='application/x-www-form-urlencoded',\nformopt={})\nSet a HTML form data set.\n+params+ is the form data set; it is an Array of Arrays or a Hash\n+enctype is the type to encode the form data set.\nIt is application/x-www-form-urlencoded or multipart/form-data.\n+formpot+ is an optional hash to specify the detail.\n\nboundary:: the boundary of the multipart message\ncharset::  the charset of the message. All names and the values of\n           non-file fields are encoded as the charset.\n\nEach item of params is an array and contains following items:\n+name+::  the name of the field\n+value+:: the value of the field, it should be a String or a File\n+opt+::   an optional hash to specify additional information\n\nEach item is a file field or a normal field.\nIf +value+ is a File object or the +opt+ have a filename key,\nthe item is treated as a file field.\n\nIf Transfer-Encoding is set as chunked, this send the request in\nchunked encoding. Because chunked encoding is HTTP/1.1 feature,\nyou must confirm the server to support HTTP/1.1 before sending it.\n\nExample:\n   http.set_form([["q", "ruby"], ["lang", "en"]])\n\nSee also RFC 2388, RFC 2616, HTML 4.01, and HTML5\n
set_form_data Net::HTTPHeader.set_form_data(params, sep = '&')\nSet header fields and a body from HTML form data.\n+params+ should be an Array of Arrays or\na Hash containing HTML form data.\nOptional argument +sep+ means data record separator.\n\nValues are URL encoded as necessary and the content-type is set to\napplication/x-www-form-urlencoded\n\nExample:\n   http.form_data = {"q" => "ruby", "lang" => "en"}\n   http.form_data = {"q" => ["ruby", "perl"], "lang" => "en"}\n   http.set_form_data({"q" => "ruby", "lang" => "en"}, ';')\n
set_range Net::HTTPHeader.set_range(r, e = nil)\nSets the HTTP Range: header.\nAccepts either a Range object as a single argument,\nor a beginning index and a length from that index.\nExample:\n\n  req.range = (0..1023)\n  req.set_range 0, 1023\n
sub_type Net::HTTPHeader.sub_type()\nReturns a content type string such as "html".\nThis method returns nil if Content-Type: header field does not exist\nor sub-type is not given (e.g. "Content-Type: text").\n
to_hash Net::HTTPHeader.to_hash()\nReturns a Hash consisting of header names and values.\ne.g.\n{"cache-control" => "private",\n "content-type" => "text/html",\n "date" => "Wed, 22 Jun 2005 22:11:50 GMT"}\n
type_params Net::HTTPHeader.type_params()\nAny parameters specified for the content type, returned as a Hash.\nFor example, a header of Content-Type: text/html; charset=EUC-JP\nwould result in type_params returning {'charset' => 'EUC-JP'}\n
nowrite Rake::FileUtilsExt.nowrite(value=nil)\nGet/set the nowrite flag controlling output from the FileUtils\nutilities.  If verbose is true, then the utility method is\nechoed to standard output.\n\nExamples:\n   nowrite              # return the current value of the\n nowrite flag\n   nowrite(v)           # set the nowrite flag to _v_.\n   nowrite(v) { code }  # Execute code with the nowrite flag set\n temporarily to _v_. Return to the\n original value when code is done.\n
rake_check_options Rake::FileUtilsExt.rake_check_options(options, *optdecl)\nCheck that the options do not contain options not listed in\n+optdecl+.  An ArgumentError exception is thrown if non-declared\noptions are found.\n
rake_merge_option Rake::FileUtilsExt.rake_merge_option(args, defaults)\nMerge the given options with the default values.\n
rake_output_message Rake::FileUtilsExt.rake_output_message(message)\nSend the message to the default rake output (which is $stderr).\n
verbose Rake::FileUtilsExt.verbose(value=nil)\nGet/set the verbose flag controlling output from the FileUtils\nutilities.  If verbose is true, then the utility method is\nechoed to standard output.\n\nExamples:\n   verbose              # return the current value of the\n verbose flag\n   verbose(v)           # set the verbose flag to _v_.\n   verbose(v) { code }  # Execute code with the verbose flag set\n temporarily to _v_.  Return to the\n original value when code is done.\n
when_writing Rake::FileUtilsExt.when_writing(msg=nil)\nUse this function to prevent potentially destructive ruby code\nfrom running when the :nowrite flag is set.\n\nExample:\n\n  when_writing("Building Project") do\n    project.build\n  end\n\nThe following code will build the project under normal\nconditions. If the nowrite(true) flag is set, then the example\nwill print:\n\n     DRYRUN: Building Project\n\ninstead of actually building the project.\n
append_features Mutex_m.append_features(cl)\n\n
define_aliases Mutex_m.define_aliases(cl)\n\n
extend_object Mutex_m.extend_object(obj)\n\n
new Mutex_m.new(*args)\n\n
mu_extended Mutex_m.mu_extended()\n\n
mu_lock Mutex_m.mu_lock()\n\n
mu_locked? Mutex_m.mu_locked?()\n\n
mu_synchronize Mutex_m.mu_synchronize(&block)\nlocking\n
mu_try_lock Mutex_m.mu_try_lock()\n\n
mu_unlock Mutex_m.mu_unlock()\n\n
sleep Mutex_m.sleep(timeout = nil)\n\n
must_be MiniTest::Expectations.must_be\nSee MiniTest::Assertions#assert_operator\n\n   n.must_be :<=, 42\n
must_be_empty MiniTest::Expectations.must_be_empty\nSee MiniTest::Assertions#assert_empty.\n\n   collection.must_be_empty\n
must_be_instance_of MiniTest::Expectations.must_be_instance_of\nSee MiniTest::Assertions#assert_instance_of\n\n   obj.must_be_instance_of klass\n
must_be_kind_of MiniTest::Expectations.must_be_kind_of\nSee MiniTest::Assertions#assert_kind_of\n\n   obj.must_be_kind_of mod\n
must_be_nil MiniTest::Expectations.must_be_nil\nSee MiniTest::Assertions#assert_nil\n\n   obj.must_be_nil\n
must_be_same_as MiniTest::Expectations.must_be_same_as\nSee MiniTest::Assertions#assert_same\n\n   a.must_be_same_as b\n
must_be_silent MiniTest::Expectations.must_be_silent\nSee MiniTest::Assertions#assert_silent\n\n   proc { ... }.must_be_silent\n
must_be_within_delta MiniTest::Expectations.must_be_within_delta\nSee MiniTest::Assertions#assert_in_delta\n\n   n.must_be_close_to m [, delta]\n
must_be_within_epsilon MiniTest::Expectations.must_be_within_epsilon\nSee MiniTest::Assertions#assert_in_epsilon\n\n   n.must_be_within_epsilon m [, epsilon]\n
must_equal MiniTest::Expectations.must_equal\nSee MiniTest::Assertions#assert_equal\n\n   a.must_equal b\n
must_include MiniTest::Expectations.must_include\nSee MiniTest::Assertions#assert_includes\n\n   collection.must_include obj\n
must_match MiniTest::Expectations.must_match\nSee MiniTest::Assertions#assert_match\n\n   a.must_match b\n
must_output MiniTest::Expectations.must_output\nSee MiniTest::Assertions#assert_output\n\n   proc { ... }.must_output out_or_nil [, err]\n
must_raise MiniTest::Expectations.must_raise\nSee MiniTest::Assertions#assert_raises\n\n   proc { ... }.must_raise exception\n
must_respond_to MiniTest::Expectations.must_respond_to\nSee MiniTest::Assertions#assert_respond_to\n\n   obj.must_respond_to msg\n
must_send MiniTest::Expectations.must_send\nSee MiniTest::Assertions#assert_send\nTODO: remove me\n\n   a.must_send\n
must_throw MiniTest::Expectations.must_throw\nSee MiniTest::Assertions#assert_throws\n\n   proc { ... }.must_throw sym\n
wont_be MiniTest::Expectations.wont_be\nSee MiniTest::Assertions#refute_operator\n\n   n.wont_be :<=, 42\n
wont_be_close_to MiniTest::Expectations.wont_be_close_to\n\n
wont_be_empty MiniTest::Expectations.wont_be_empty\nSee MiniTest::Assertions#refute_empty\n\n   collection.wont_be_empty\n
wont_be_instance_of MiniTest::Expectations.wont_be_instance_of\nSee MiniTest::Assertions#refute_instance_of\n\n   obj.wont_be_instance_of klass\n
wont_be_kind_of MiniTest::Expectations.wont_be_kind_of\nSee MiniTest::Assertions#refute_kind_of\n\n   obj.wont_be_kind_of mod\n
wont_be_nil MiniTest::Expectations.wont_be_nil\nSee MiniTest::Assertions#refute_nil\n\n   obj.wont_be_nil\n
wont_be_same_as MiniTest::Expectations.wont_be_same_as\nSee MiniTest::Assertions#refute_same\n\n   a.wont_be_same_as b\n
wont_be_within_delta MiniTest::Expectations.wont_be_within_delta\nSee MiniTest::Assertions#refute_in_delta\n\n   n.wont_be_close_to m [, delta]\n
wont_be_within_epsilon MiniTest::Expectations.wont_be_within_epsilon\nSee MiniTest::Assertions#refute_in_epsilon\n\n   n.wont_be_within_epsilon m [, epsilon]\n
wont_equal MiniTest::Expectations.wont_equal\nSee MiniTest::Assertions#refute_equal\n\n   a.wont_equal b\n
wont_include MiniTest::Expectations.wont_include\nSee MiniTest::Assertions#refute_includes\n\n   collection.wont_include obj\n
wont_match MiniTest::Expectations.wont_match\nSee MiniTest::Assertions#refute_match\n\n   a.wont_match b\n
wont_respond_to MiniTest::Expectations.wont_respond_to\nSee MiniTest::Assertions#refute_respond_to\n\n   obj.wont_respond_to msg\n
diff MiniTest::Assertions.diff()\nReturns the diff command to use in #diff. Tries to intelligently\nfigure out what diff to use.\n
diff= MiniTest::Assertions.diff=(o)\nSet the diff command to use in #diff.\n
assert MiniTest::Assertions.assert(test, msg = nil)\nFails unless +test+ is a true value.\n
assert_block MiniTest::Assertions.assert_block(msg = nil)\nFails unless the block returns a true value.\n
assert_empty MiniTest::Assertions.assert_empty(obj, msg = nil)\nFails unless +obj+ is empty.\n
assert_equal MiniTest::Assertions.assert_equal(exp, act, msg = nil)\nFails unless <tt>exp == act</tt> printing the difference between\nthe two, if possible.\n\nIf there is no visible difference but the assertion fails, you\nshould suspect that your #== is buggy, or your inspect output is\nmissing crucial details.\n\nFor floats use assert_in_delta.\n\nSee also: MiniTest::Assertions.diff\n
assert_in_delta MiniTest::Assertions.assert_in_delta(exp, act, delta = 0.001, msg = nil)\nFor comparing Floats.  Fails unless +exp+ and +act+ are within +delta+\nof each other.\n\n  assert_in_delta Math::PI, (22.0 / 7.0), 0.01\n
assert_in_epsilon MiniTest::Assertions.assert_in_epsilon(a, b, epsilon = 0.001, msg = nil)\nFor comparing Floats.  Fails unless +exp+ and +act+ have a relative\nerror less than +epsilon+.\n
assert_includes MiniTest::Assertions.assert_includes(collection, obj, msg = nil)\nFails unless +collection+ includes +obj+.\n
assert_instance_of MiniTest::Assertions.assert_instance_of(cls, obj, msg = nil)\nFails unless +obj+ is an instace of +cls+.\n
assert_kind_of MiniTest::Assertions.assert_kind_of(cls, obj, msg = nil)\nFails unless +obj+ is a kind of +cls+.\n
assert_match MiniTest::Assertions.assert_match(exp, act, msg = nil)\nFails unless +exp+ is <tt>=~</tt> +act+.\n
assert_nil MiniTest::Assertions.assert_nil(obj, msg = nil)\nFails unless +obj+ is nil\n
assert_operator MiniTest::Assertions.assert_operator(o1, op, o2, msg = nil)\nFor testing equality operators and so-forth.\n\n  assert_operator 5, :<=, 4\n
assert_output MiniTest::Assertions.assert_output(stdout = nil, stderr = nil)\nFails if stdout or stderr do not output the expected results.\nPass in nil if you don't care about that streams output. Pass in\n"" if you require it to be silent.\n\nSee also: #assert_silent\n
assert_raises MiniTest::Assertions.assert_raises(*exp)\nFails unless the block raises one of +exp+\n
assert_respond_to MiniTest::Assertions.assert_respond_to(obj, meth, msg = nil)\nFails unless +obj+ responds to +meth+.\n
assert_same MiniTest::Assertions.assert_same(exp, act, msg = nil)\nFails unless +exp+ and +act+ are #equal?\n
assert_send MiniTest::Assertions.assert_send(send_ary, m = nil)\n+send_ary+ is a receiver, message and arguments.\n\nFails unless the call returns a true value\nTODO: I should prolly remove this from specs\n
assert_silent MiniTest::Assertions.assert_silent()\nFails if the block outputs anything to stderr or stdout.\n\nSee also: #assert_output\n
assert_throws MiniTest::Assertions.assert_throws(sym, msg = nil)\nFails unless the block throws +sym+\n
capture_io MiniTest::Assertions.capture_io()\nCaptures $stdout and $stderr into strings:\n\n  out, err = capture_io do\n    warn "You did a bad thing"\n  end\n\n  assert_match %r%bad%, err\n
diff MiniTest::Assertions.diff(exp, act)\nReturns a diff between +exp+ and +act+. If there is no known\ndiff command or if it doesn't make sense to diff the output\n(single line, short output), then it simply returns a basic\ncomparison between the two.\n
exception_details MiniTest::Assertions.exception_details(e, msg)\nReturns details for exception +e+\n
flunk MiniTest::Assertions.flunk(msg = nil)\nFails with +msg+\n
message MiniTest::Assertions.message(msg = nil, ending = ".", &default)\nReturns a proc that will output +msg+ along with the default message.\n
mu_pp MiniTest::Assertions.mu_pp(obj)\nThis returns a human-readable version of +obj+. By default\ninspect is called. You can override this to use #pretty_print\nif you want.\n
mu_pp_for_diff MiniTest::Assertions.mu_pp_for_diff(obj)\nThis returns a diff-able human-readable version of +obj+. This\ndiffers from the regular mu_pp because it expands escaped\nnewlines and makes hex-values generic (like object_ids). This\nuses mu_pp to do the first pass and then cleans it up.\n
pass MiniTest::Assertions.pass(msg = nil)\nused for counting assertions\n
refute MiniTest::Assertions.refute(test, msg = nil)\nFails if +test+ is a true value\n
refute_empty MiniTest::Assertions.refute_empty(obj, msg = nil)\nFails if +obj+ is empty.\n
refute_equal MiniTest::Assertions.refute_equal(exp, act, msg = nil)\nFails if <tt>exp == act</tt>.\n\nFor floats use refute_in_delta.\n
refute_in_delta MiniTest::Assertions.refute_in_delta(exp, act, delta = 0.001, msg = nil)\nFor comparing Floats.  Fails if +exp+ is within +delta+ of +act+\n\n  refute_in_delta Math::PI, (22.0 / 7.0)\n
refute_in_epsilon MiniTest::Assertions.refute_in_epsilon(a, b, epsilon = 0.001, msg = nil)\nFor comparing Floats.  Fails if +exp+ and +act+ have a relative error\nless than +epsilon+.\n
refute_includes MiniTest::Assertions.refute_includes(collection, obj, msg = nil)\nFails if +collection+ includes +obj+\n
refute_instance_of MiniTest::Assertions.refute_instance_of(cls, obj, msg = nil)\nFails if +obj+ is an instance of +cls+\n
refute_kind_of MiniTest::Assertions.refute_kind_of(cls, obj, msg = nil)\nFails if +obj+ is a kind of +cls+\n
refute_match MiniTest::Assertions.refute_match(exp, act, msg = nil)\nFails if +exp+ <tt>=~</tt> +act+\n
refute_nil MiniTest::Assertions.refute_nil(obj, msg = nil)\nFails if +obj+ is nil.\n
refute_operator MiniTest::Assertions.refute_operator(o1, op, o2, msg = nil)\nFails if +o1+ is not +op+ +o2+. Eg:\n\n  refute_operator 1, :>, 2 #=> pass\n  refute_operator 1, :<, 2 #=> fail\n
refute_respond_to MiniTest::Assertions.refute_respond_to(obj, meth, msg = nil)\nFails if +obj+ responds to the message +meth+.\n
refute_same MiniTest::Assertions.refute_same(exp, act, msg = nil)\nFails if +exp+ is the same (by object identity) as +act+.\n
skip MiniTest::Assertions.skip(msg = nil, bt = caller)\nSkips the current test. Gets listed at the end of the run but\ndoesn't cause a failure exit code.\n
add_observer Observable.add_observer(observer, func=:update)\nAdd +observer+ as an observer on this object. so that it will receive\nnotifications.\n\n+observer+:: the object that will be notified of changes.\n+func+:: Symbol naming the method that will be called when this Observable\n         has changes.\n\n         This method must return true for +observer.respond_to?+ and will\n         receive <tt>*arg</tt> when #notify_observers is called, where\n         <tt>*arg</tt> is the value passed to #notify_observers by this\n         Observable\n
changed Observable.changed(state=true)\nSet the changed state of this object.  Notifications will be sent only if\nthe changed +state+ is +true+.\n\n+state+:: Boolean indicating the changed state of this Observable.\n
changed? Observable.changed?()\nReturns true if this object's state has been changed since the last\nnotify_observers call.\n
count_observers Observable.count_observers()\nReturn the number of observers associated with this object.\n
delete_observer Observable.delete_observer(observer)\nRemove +observer+ as an observer on this object so that it will no longer\nreceive notifications.\n\n+observer+:: An observer of this Observable\n
delete_observers Observable.delete_observers()\nRemove all observers associated with this object.\n
notify_observers Observable.notify_observers(*arg)\nNotify observers of a change in state *if* this object's changed state is\n+true+.\n\nThis will invoke the method named in #add_observer, pasing <tt>*arg</tt>.\nThe changed state is then set to +false+.\n\n<tt>*arg</tt>:: Any arguments to pass to the observers.\n
decode URI::Escape.decode(*arg)\n\n
encode URI::Escape.encode(*arg)\n\n
escape URI::Escape.escape(*arg)\n== Synopsis\n\n  URI.escape(str [, unsafe])\n\n== Args\n\n+str+::\n  String to replaces in.\n+unsafe+::\n  Regexp that matches all symbols that must be replaced with codes.\n  By default uses <tt>REGEXP::UNSAFE</tt>.\n  When this argument is a String, it represents a character set.\n\n== Description\n\nEscapes the string, replacing all unsafe characters with codes.\n\n== Usage\n\n  require 'uri'\n\n  enc_uri = URI.escape("http://example.com/?a=\11\15")\n  p enc_uri\n => "http://example.com/?a=%09%0D"\n\n  p URI.unescape(enc_uri)\n => "http://example.com/?a=\t\r"\n\n  p URI.escape("@?@!", "!?")\n => "@%3F@%21"\n
unescape URI::Escape.unescape(*arg)\n== Synopsis\n\n  URI.unescape(str)\n\n== Args\n\n+str+::\n  Unescapes the string.\n\n== Usage\n\n  require 'uri'\n\n  enc_uri = URI.escape("http://example.com/?a=\11\15")\n  p enc_uri\n => "http://example.com/?a=%09%0D"\n\n  p URI.unescape(enc_uri)\n => "http://example.com/?a=\t\r"\n
acos CMath.acos(z)\nreturns the arc cosine of +z+\n
acos! CMath.acos!(z)\n\n
acosh CMath.acosh(z)\nreturns the inverse hyperbolic cosine of +z+\n
acosh! CMath.acosh!(z)\n\n
asin CMath.asin(z)\nreturns the arc sine of +z+\n
asin! CMath.asin!(z)\n\n
asinh CMath.asinh(z)\nreturns the inverse hyperbolic sine of +z+\n
asinh! CMath.asinh!(z)\n\n
atan CMath.atan(z)\nreturns the arc tangent of +z+\n
atan! CMath.atan!(z)\n\n
atan2 CMath.atan2(y,x)\nreturns the arc tangent of +y+ divided by +x+ using the signs of +y+ and\n+x+ to determine the quadrant\n
atan2! CMath.atan2!(y,x)\n\n
atanh CMath.atanh(z)\nreturns the inverse hyperbolic tangent of +z+\n
atanh! CMath.atanh!(z)\n\n
cbrt CMath.cbrt(z)\nreturns the principal value of the cube root of +z+\n
cbrt! CMath.cbrt!(z)\n\n
cos CMath.cos(z)\nreturns the cosine of +z+, where +z+ is given in radians\n
cos! CMath.cos!(z)\n\n
cosh CMath.cosh(z)\nreturns the hyperbolic cosine of +z+, where +z+ is given in radians\n
cosh! CMath.cosh!(z)\n\n
exp CMath.exp(z)\nMath::E raised to the +z+ power\n\n  exp(Complex(0,0))      #=> 1.0+0.0i\n  exp(Complex(0,PI))     #=> -1.0+1.2246467991473532e-16i\n  exp(Complex(0,PI/2.0)) #=> 6.123233995736766e-17+1.0i\n
exp! CMath.exp!(z)\n\n
log CMath.log(*args)\nReturns the natural logarithm of Complex.  If a second argument is given,\nit will be the base of logarithm.\n\n  log(Complex(0,0)) #=> -Infinity+0.0i\n
log! CMath.log!(*args)\n\n
log10 CMath.log10(z)\nreturns the base 10 logarithm of +z+\n
log10! CMath.log10!(z)\n\n
log2 CMath.log2(z)\nreturns the base 2 logarithm of +z+\n
log2! CMath.log2!(z)\n\n
sin CMath.sin(z)\nreturns the sine of +z+, where +z+ is given in radians\n
sin! CMath.sin!(z)\n\n
sinh CMath.sinh(z)\nreturns the hyperbolic sine of +z+, where +z+ is given in radians\n
sinh! CMath.sinh!(z)\n\n
sqrt CMath.sqrt(z)\nReturns the non-negative square root of Complex.\n  sqrt(-1)            #=> 0+1.0i\n  sqrt(Complex(-1,0)) #=> 0.0+1.0i\n  sqrt(Complex(0,8))  #=> 2.0+2.0i\n
sqrt! CMath.sqrt!(z)\n\n
tan CMath.tan(z)\nreturns the tangent of +z+, where +z+ is given in radians\n
tan! CMath.tan!(z)\n\n
tanh CMath.tanh(z)\nreturns the hyperbolic tangent of +z+, where +z+ is given in radians\n
tanh! CMath.tanh!(z)\n\n
timeout Timeout.timeout(sec, klass = nil)\nPerform an operation in a block, raising an error if it takes longer than\n+sec+ seconds to complete.\n\n+sec+:: Number of seconds to wait for the block to terminate. Any number\n        may be used, including Floats to specify fractional seconds. A\n        value of 0 or +nil+ will execute the block without any timeout.\n+klass+:: Exception Class to raise if the block fails to terminate\n          in +sec+ seconds.  Omitting will use the default, Timeout::Error\n\nThe block will be executed on another thread and will be given one\nargument: +sec+.\n\nReturns the result of the block *if* the block completed before\n+sec+ seconds, otherwise throws an exception, based on the value of +klass+.\n\nNote that this is both a method of module Timeout, so you can <tt>include\nTimeout</tt> into your classes so they have a #timeout method, as well as\na module method, so you can call it directly as Timeout.timeout().\n
escape Shellwords.escape(str)\n\n
join Shellwords.join(array)\n\n
shellescape Shellwords.shellescape(str)\nEscapes a string so that it can be safely used in a Bourne shell\ncommand line.\n\nNote that a resulted string should be used unquoted and is not\nintended for use in double quotes nor in single quotes.\n\n  open("| grep #{Shellwords.escape(pattern)} file") { |pipe|\n ...\n  }\n\nString#shellescape is a shorthand for this function.\n\n  open("| grep #{pattern.shellescape} file") { |pipe|\n ...\n  }\n\nIt is caller's responsibility to encode the string in the right\nencoding for the shell environment where this string is used.\nMultibyte characters are treated as multibyte characters, not\nbytes.\n
shelljoin Shellwords.shelljoin(array)\nBuilds a command line string from an argument list +array+ joining\nall elements escaped for Bourne shell and separated by a space.\n\n  open('|' + Shellwords.join(['grep', pattern, *files])) { |pipe|\n ...\n  }\n\nArray#shelljoin is a shorthand for this function.\n\n  open('|' + ['grep', pattern, *files].shelljoin) { |pipe|\n ...\n  }\n
shellsplit Shellwords.shellsplit(line)\nSplits a string into an array of tokens in the same way the UNIX\nBourne shell does.\n\n  argv = Shellwords.split('here are "two words"')\n  argv #=> ["here", "are", "two words"]\n\nString#shellsplit is a shorthand for this function.\n\n  argv = 'here are "two words"'.shellsplit\n  argv #=> ["here", "are", "two words"]\n
shellwords Shellwords.shellwords(line)\n\n
split Shellwords.split(line)\n\n
escape WEBrick::AccessLog.escape(data)\n\n
format WEBrick::AccessLog.format(format_string, params)\n\n
setup_params WEBrick::AccessLog.setup_params(config, req, res)\nThis format specification is a subset of mod_log_config of Apache:\n\n%a:: Remote IP address\n%b:: Total response size\n%e{variable}:: Given variable in ENV\n%f:: Response filename\n%h:: Remote host name\n%{header}i:: Given request header\n%l:: Remote logname, always "-"\n%m:: Request method\n%{attr}n:: Given request attribute from <tt>req.attributes</tt>\n%{header}o:: Given response header\n%p:: Server's request port\n%{format}p:: The canonical port of the server serving the request or the\n             actual port or the client's actual port.  Valid formats are\n             canonical, local or remote.\n%q:: Request query string\n%r:: First line of the request\n%s:: Request status\n%t:: Time the request was recieved\n%T:: Time taken to process the request\n%u:: Remote user from auth\n%U:: Unparsed URI\n%%:: Literal %\n
create_listeners WEBrick::Utils.create_listeners(address, port, logger=nil)\nCreates TCP server sockets bound to +address+:+port+ and returns them.\n\nIt will create IPV4 and IPV6 sockets on all interfaces.\n
create_self_signed_cert WEBrick::Utils.create_self_signed_cert(bits, cn, comment)\n\n
getservername WEBrick::Utils.getservername()\nThe server hostname\n
random_string WEBrick::Utils.random_string(len)\nGenerates a random string of length +len+\n
set_close_on_exec WEBrick::Utils.set_close_on_exec(io)\nSets the close on exec flag for +io+\n
set_non_blocking WEBrick::Utils.set_non_blocking(io)\nSets IO operations on +io+ to be non-blocking\n
su WEBrick::Utils.su(user)\nChanges the process's uid and gid to the ones of +user+\n
timeout WEBrick::Utils.timeout(seconds, exception=Timeout::Error)\nExecutes the passed block and raises +exception+ if execution takes more\nthan +seconds+.\n\nIf +seconds+ is zero or nil, simply executes the block\n
basic_auth WEBrick::HTTPAuth.basic_auth(req, res, realm)\nSimple wrapper for providing basic authentication for a request.  When\ncalled with a request +req+, response +res+, authentication +realm+ and\n+block+ the block will be called with a +username+ and +password+.  If\nthe block returns true the request is allowed to continue, otherwise an\nHTTPStatus::Unauthorized error is raised.\n
proxy_basic_auth WEBrick::HTTPAuth.proxy_basic_auth(req, res, realm)\nSimple wrapper for providing basic authentication for a proxied request.\nWhen called with a request +req+, response +res+, authentication +realm+\nand +block+ the block will be called with a +username+ and +password+.\nIf the block returns true the request is allowed to continue, otherwise\nan HTTPStatus::ProxyAuthenticationRequired error is raised.\n
client_error? WEBrick::HTTPStatus.client_error?(code)\nIs +code+ a client error status?\n
error? WEBrick::HTTPStatus.error?(code)\nIs +code+ an error status?\n
info? WEBrick::HTTPStatus.info?(code)\nIs +code+ an informational status?\n
reason_phrase WEBrick::HTTPStatus.reason_phrase(code)\nReturns the description corresponding to the HTTP status +code+\n\n  WEBrick::HTTPStatus.reason_phrase 404\n  => "Not Found"\n
redirect? WEBrick::HTTPStatus.redirect?(code)\nIs +code+ a redirection status?\n
server_error? WEBrick::HTTPStatus.server_error?(code)\nIs +code+ a server error status?\n
success? WEBrick::HTTPStatus.success?(code)\nIs +code+ a successful status?\n
dequote WEBrick::HTTPUtils.dequote(str)\n\n
load_mime_types WEBrick::HTTPUtils.load_mime_types(file)\nLoad Apache compatible mime.types file.\n
mime_type WEBrick::HTTPUtils.mime_type(filename, mime_tab)\n\n
normalize_path WEBrick::HTTPUtils.normalize_path(path)\n\n
parse_form_data WEBrick::HTTPUtils.parse_form_data(io, boundary)\n\n
parse_header WEBrick::HTTPUtils.parse_header(raw)\n\n
parse_query WEBrick::HTTPUtils.parse_query(str)\n\n
parse_qvalues WEBrick::HTTPUtils.parse_qvalues(value)\n\n
parse_range_header WEBrick::HTTPUtils.parse_range_header(ranges_specifier)\n\n
quote WEBrick::HTTPUtils.quote(str)\n\n
split_header_value WEBrick::HTTPUtils.split_header_value(str)\n\n
_escape WEBrick::HTTPUtils._escape(str, regex)\n\n
_make_regex WEBrick::HTTPUtils._make_regex(str)\n\n
_make_regex! WEBrick::HTTPUtils._make_regex!(str)\n\n
_unescape WEBrick::HTTPUtils._unescape(str, regex)\n\n
escape WEBrick::HTTPUtils.escape(str)\n\n
escape8bit WEBrick::HTTPUtils.escape8bit(str)\n\n
escape_form WEBrick::HTTPUtils.escape_form(str)\n\n
escape_path WEBrick::HTTPUtils.escape_path(str)\n\n
unescape WEBrick::HTTPUtils.unescape(str)\n\n
unescape_form WEBrick::HTTPUtils.unescape_form(str)\n\n
escape WEBrick::HTMLUtils.escape(string)\nEscapes &, ", > and < in +string+\n
get_passwd WEBrick::HTTPAuth::UserDB.get_passwd(realm, user, reload_db=false)\nRetrieves a password in +realm+ for +user+ for the auth_type of this\ndatabase.  +reload_db+ is a dummy value.\n
make_passwd WEBrick::HTTPAuth::UserDB.make_passwd(realm, user, pass)\nCreates an obscured password in +realm+ with +user+ and +password+\nusing the auth_type of this database.\n
set_passwd WEBrick::HTTPAuth::UserDB.set_passwd(realm, user, pass)\nSets a password in +realm+ with +user+ and +password+ for the\nauth_type of this database.\n
gets WEBrick::NullReader.gets(*args)\n\n
read WEBrick::NullReader.read(*args)\n\n
method_missing WEBrick::FakeProxyURI.method_missing(meth, *args)\n\n
h ERB::Util.h(s)\n\n
html_escape ERB::Util.html_escape(s)\nA utility method for escaping HTML tag characters in _s_.\n\n  require "erb"\n  include ERB::Util\n\n  puts html_escape("is a > 0 & a < 10?")\n\n_Generates_\n\n  is a &gt; 0 &amp; a &lt; 10?\n
u ERB::Util.u(s)\n\n
url_encode ERB::Util.url_encode(s)\nA utility method for encoding the String _s_ as a URL.\n\n  require "erb"\n  include ERB::Util\n\n  puts url_encode("Programming Ruby:  The Pragmatic Programmer's Guide")\n\n_Generates_\n\n  Programming%20Ruby%3A%20%20The%20Pragmatic%20Programmer%27s%20Guide\n
def_erb_method ERB::DefMethod.def_erb_method(methodname, erb_or_fname)\ndefine _methodname_ as instance method of current module, using ERB\nobject or eRuby file\n
benchmark Benchmark.benchmark(caption = "", label_width = nil, format = nil, *labels)\nInvokes the block with a <tt>Benchmark::Report</tt> object, which\nmay be used to collect and report on the results of individual\nbenchmark tests. Reserves <i>label_width</i> leading spaces for\nlabels on each line. Prints _caption_ at the top of the\nreport, and uses _format_ to format each line.\nReturns an array of Benchmark::Tms objects.\n\nIf the block returns an array of\n<tt>Benchmark::Tms</tt> objects, these will be used to format\nadditional lines of output. If _label_ parameters are\ngiven, these are used to label these extra lines.\n\n_Note_: Other methods provide a simpler interface to this one, and are\nsuitable for nearly all benchmarking requirements.  See the examples in\nBenchmark, and the #bm and #bmbm methods.\n\nExample:\n\n    require 'benchmark'\n    include Benchmark          # we need the CAPTION and FORMAT constants\n\n    n = 50000\n    Benchmark.benchmark(CAPTION, 7, FORMAT, ">total:", ">avg:") do |x|\n      tf = x.report("for:")   { for i in 1..n; a = "1"; end }\n      tt = x.report("times:") { n.times do   ; a = "1"; end }\n      tu = x.report("upto:")  { 1.upto(n) do ; a = "1"; end }\n      [tf+tt+tu, (tf+tt+tu)/3]\n    end\n\n<i>Generates:</i>\n\n                    user     system      total        real\n       for:     1.016667   0.016667   1.033333 (  0.485749)\n       times:   1.450000   0.016667   1.466667 (  0.681367)\n       upto:    1.533333   0.000000   1.533333 (  0.722166)\n       >total:  4.000000   0.033333   4.033333 (  1.889282)\n       >avg:    1.333333   0.011111   1.344444 (  0.629761)\n
bm Benchmark.bm(label_width = 0, *labels)\nA simple interface to the #benchmark method, #bm is generates sequential\nreports\nwith labels.  The parameters have the same meaning as for #benchmark.\n\n    require 'benchmark'\n\n    n = 50000\n    Benchmark.bm(7) do |x|\n      x.report("for:")   { for i in 1..n; a = "1"; end }\n      x.report("times:") { n.times do   ; a = "1"; end }\n      x.report("upto:")  { 1.upto(n) do ; a = "1"; end }\n    end\n\n<i>Generates:</i>\n\n                    user     system      total        real\n       for:     1.050000   0.000000   1.050000 (  0.503462)\n       times:   1.533333   0.016667   1.550000 (  0.735473)\n       upto:    1.500000   0.016667   1.516667 (  0.711239)\n
bmbm Benchmark.bmbm(width = 0)\nSometimes benchmark results are skewed because code executed\nearlier encounters different garbage collection overheads than\nthat run later. #bmbm attempts to minimize this effect by running\nthe tests twice, the first time as a rehearsal in order to get the\nruntime environment stable, the second time for\nreal. <tt>GC.start</tt> is executed before the start of each of\nthe real timings; the cost of this is not included in the\ntimings. In reality, though, there's only so much that #bmbm can\ndo, and the results are not guaranteed to be isolated from garbage\ncollection and other effects.\n\nBecause #bmbm takes two passes through the tests, it can\ncalculate the required label width.\n\n      require 'benchmark'\n\n      array = (1..1000000).map { rand }\n\n      Benchmark.bmbm do |x|\n        x.report("sort!") { array.dup.sort! }\n        x.report("sort")  { array.dup.sort  }\n      end\n\n<i>Generates:</i>\n\n       Rehearsal -----------------------------------------\n       sort!  11.928000   0.010000  11.938000 ( 12.756000)\n       sort   13.048000   0.020000  13.068000 ( 13.857000)\n       ------------------------------- total: 25.006000sec\n\n                   user     system      total        real\n       sort!  12.959000   0.010000  12.969000 ( 13.793000)\n       sort   12.007000   0.000000  12.007000 ( 12.791000)\nbmbm yields a Benchmark::Job object and returns an array of\nBenchmark::Tms objects.\n
measure Benchmark.measure(label = "")\nReturns the time used to execute the given block as a\nBenchmark::Tms object.\n
realtime Benchmark.realtime()\nReturns the elapsed real time used to execute the given block.\n
entity_expansion_text_limit REXML.entity_expansion_text_limit()\nGet the entity expansion limit. By default the limit is set to 10240.\n
entity_expansion_text_limit= REXML.entity_expansion_text_limit=( val )\nSet the entity expansion limit. By default the limit is set to 10240.\n
each_recursive REXML::Node.each_recursive()\nVisit all subnodes of +self+ recursively\n
find_first_recursive REXML::Node.find_first_recursive()\nFind (and return) first subnode (recursively) for which the block\nevaluates to true. Returns +nil+ if none was found.\n
indent REXML::Node.indent(to, ind)\n\n
index_in_parent REXML::Node.index_in_parent()\nReturns the position that +self+ holds in its parent's array, indexed\nfrom 1.\n
next_sibling_node REXML::Node.next_sibling_node()\n@return the next sibling (nil if unset)\n
parent? REXML::Node.parent?()\n\n
previous_sibling_node REXML::Node.previous_sibling_node()\n@return the previous sibling (nil if unset)\n
to_s REXML::Node.to_s(indent=nil)\nindent::\n  *DEPRECATED* This parameter is now ignored.  See the formatters in the\n  REXML::Formatters package for changing the output style.\n
attlistdecl REXML::SAX2Listener.attlistdecl(element, pairs, contents)\nIf a doctype includes an ATTLIST declaration, it will cause this\nmethod to be called.  The content is the declaration itself, unparsed.\nEG, <!ATTLIST el attr CDATA #REQUIRED> will come to this method as "el\nattr CDATA #REQUIRED".  This is the same for all of the .*decl\nmethods.\n
cdata REXML::SAX2Listener.cdata(content)\nCalled when <![CDATA[ ... ]]> is encountered in a document.\n@p content "..."\n
characters REXML::SAX2Listener.characters(text)\n\n
comment REXML::SAX2Listener.comment(comment)\nCalled when a comment is encountered.\n@p comment The content of the comment\n
doctype REXML::SAX2Listener.doctype(name, pub_sys, long_name, uri)\nHandles a doctype declaration. Any attributes of the doctype which are\nnot supplied will be nil.  # EG, <!DOCTYPE me PUBLIC "foo" "bar">\n@p name the name of the doctype; EG, "me"\n@p pub_sys "PUBLIC", "SYSTEM", or nil.  EG, "PUBLIC"\n@p long_name the supplied long name, or nil.  EG, "foo"\n@p uri the uri of the doctype, or nil.  EG, "bar"\n
elementdecl REXML::SAX2Listener.elementdecl(content)\n<!ELEMENT ...>\n
end_document REXML::SAX2Listener.end_document()\n\n
end_element REXML::SAX2Listener.end_element(uri, localname, qname)\n\n
end_prefix_mapping REXML::SAX2Listener.end_prefix_mapping(prefix)\n\n
entitydecl REXML::SAX2Listener.entitydecl(name, decl)\n<!ENTITY ...>\nThe argument passed to this method is an array of the entity\ndeclaration.  It can be in a number of formats, but in general it\nreturns (example, result):\n <!ENTITY % YN '"Yes"'>\n ["%", "YN", "'\"Yes\"'", "\""]\n <!ENTITY % YN 'Yes'>\n ["%", "YN", "'Yes'", "s"]\n <!ENTITY WhatHeSaid "He said %YN;">\n ["WhatHeSaid", "\"He said %YN;\"", "YN"]\n <!ENTITY open-hatch SYSTEM\n "http://www.textuality.com/boilerplate/OpenHatch.xml">\n ["open-hatch", "SYSTEM",\n "\"http://www.textuality.com/boilerplate/OpenHatch.xml\""]\n <!ENTITY open-hatch PUBLIC "-//Textuality//TEXT Standard open-hatch\n boilerplate//EN" "http://www.textuality.com/boilerplate/OpenHatch.xml">\n ["open-hatch", "PUBLIC", "\"-//Textuality//TEXT Standard open-hatch\n boilerplate//EN\"", "\"http://www.textuality.com/boilerplate/OpenHatch.xml\""]\n <!ENTITY hatch-pic SYSTEM "../grafix/OpenHatch.gif" NDATA gif>\n ["hatch-pic", "SYSTEM", "\"../grafix/OpenHatch.gif\"", "\\n\t\t\t\t\t\t\tNDATA\n gif", "gif"]\n
notationdecl REXML::SAX2Listener.notationdecl(content)\n<!NOTATION ...>\n
processing_instruction REXML::SAX2Listener.processing_instruction(target, data)\n\n
progress REXML::SAX2Listener.progress(position)\n\n
start_document REXML::SAX2Listener.start_document()\n\n
start_element REXML::SAX2Listener.start_element(uri, localname, qname, attributes)\n\n
start_prefix_mapping REXML::SAX2Listener.start_prefix_mapping(prefix, uri)\n\n
xmldecl REXML::SAX2Listener.xmldecl(version, encoding, standalone)\nCalled when an XML PI is encountered in the document.\nEG: <?xml version="1.0" encoding="utf"?>\n@p version the version attribute value.  EG, "1.0"\n@p encoding the encoding attribute value, or nil.  EG, "utf"\n@p standalone the standalone attribute value, or nil.  EG, nil\n@p spaced the declaration is followed by a line break\n
check_encoding REXML::Encoding.check_encoding(xml)\n\n
decode REXML::Encoding.decode(string)\n\n
encode REXML::Encoding.encode(string)\n\n
encoding= REXML::Encoding.encoding=(encoding)\n\n
dump REXML::Validation::Validator.dump()\n\n
reset REXML::Validation::Validator.reset()\n\n
validate REXML::Validation::Validator.validate( event )\n\n
boolean REXML::Functions.boolean( object=nil )\nUNTESTED\n
ceiling REXML::Functions.ceiling( number )\n\n
compare_language REXML::Functions.compare_language(lang1, lang2)\n\n
concat REXML::Functions.concat( *objects )\nUNTESTED\n
contains REXML::Functions.contains( string, test )\nFixed by Mike Stok\n
context= REXML::Functions.context=(value)\n\n
count REXML::Functions.count( node_set )\nReturns the size of the given list of nodes.\n
false REXML::Functions.false( )\nUNTESTED\n
floor REXML::Functions.floor( number )\n\n
get_namespace REXML::Functions.get_namespace( node_set = nil )\nHelper method.\n
id REXML::Functions.id( object )\nSince REXML is non-validating, this method is not implemented as it\nrequires a DTD\n
lang REXML::Functions.lang( language )\nUNTESTED\n
last REXML::Functions.last( )\nReturns the last node of the given list of nodes.\n
local_name REXML::Functions.local_name( node_set=nil )\nUNTESTED\n
method_missing REXML::Functions.method_missing( id )\n\n
name REXML::Functions.name( node_set=nil )\n\n
namespace_context REXML::Functions.namespace_context()\n\n
namespace_context= REXML::Functions.namespace_context=(x)\n\n
namespace_uri REXML::Functions.namespace_uri( node_set=nil )\n\n
normalize_space REXML::Functions.normalize_space( string=nil )\nUNTESTED\n
not REXML::Functions.not( object )\nUNTESTED\n
number REXML::Functions.number( object=nil )\na string that consists of optional whitespace followed by an optional\nminus sign followed by a Number followed by whitespace is converted to\nthe IEEE 754 number that is nearest (according to the IEEE 754\nround-to-nearest rule) to the mathematical value represented by the\nstring; any other string is converted to NaN\n\nboolean true is converted to 1; boolean false is converted to 0\n\na node-set is first converted to a string as if by a call to the string\nfunction and then converted in the same way as a string argument\n\nan object of a type other than the four basic types is converted to a\nnumber in a way that is dependent on that type\n
position REXML::Functions.position( )\n\n
processing_instruction REXML::Functions.processing_instruction( node )\n\n
round REXML::Functions.round( number )\n\n
starts_with REXML::Functions.starts_with( string, test )\nFixed by Mike Stok\n
string REXML::Functions.string( object=nil )\nA node-set is converted to a string by returning the string-value of the\nnode in the node-set that is first in document order. If the node-set is\nempty, an empty string is returned.\n\nA number is converted to a string as follows\n\nNaN is converted to the string NaN\n\npositive zero is converted to the string 0\n\nnegative zero is converted to the string 0\n\npositive infinity is converted to the string Infinity\n\nnegative infinity is converted to the string -Infinity\n\nif the number is an integer, the number is represented in decimal form\nas a Number with no decimal point and no leading zeros, preceded by a\nminus sign (-) if the number is negative\n\notherwise, the number is represented in decimal form as a Number\nincluding a decimal point with at least one digit before the decimal\npoint and at least one digit after the decimal point, preceded by a\nminus sign (-) if the number is negative; there must be no leading zeros\nbefore the decimal point apart possibly from the one required digit\nimmediately before the decimal point; beyond the one required digit\nafter the decimal point there must be as many, but only as many, more\ndigits as are needed to uniquely distinguish the number from all other\nIEEE 754 numeric values.\n\nThe boolean false value is converted to the string false. The boolean\ntrue value is converted to the string true.\n\nAn object of a type other than the four basic types is converted to a\nstring in a way that is dependent on that type.\n
string_length REXML::Functions.string_length( string )\nUNTESTED\n
string_value REXML::Functions.string_value( o )\nA node-set is converted to a string by\nreturning the concatenation of the string-value\nof each of the children of the node in the\nnode-set that is first in document order.\nIf the node-set is empty, an empty string is returned.\n
substring REXML::Functions.substring( string, start, length=nil )\nTake equal portions of Mike Stok and Sean Russell; mix\nvigorously, and pour into a tall, chilled glass.  Serves 10,000.\n
substring_after REXML::Functions.substring_after( string, test )\nKouhei fixed this too\n
substring_before REXML::Functions.substring_before( string, test )\nKouhei fixed this\n
sum REXML::Functions.sum( nodes )\n\n
text REXML::Functions.text( )\n\n
translate REXML::Functions.translate( string, tr1, tr2 )\nThis is entirely Mike Stok's beast\n
true REXML::Functions.true( )\nUNTESTED\n
variables REXML::Functions.variables()\n\n
variables= REXML::Functions.variables=(x)\n\n
fully_expanded_name REXML::Namespace.fully_expanded_name()\nFully expand the name, even if the prefix wasn't specified in the\nsource file.\n
has_name? REXML::Namespace.has_name?( other, ns=nil )\nCompares names optionally WITH namespaces\n
name= REXML::Namespace.name=( name )\nSets the name and the expanded name\n
attlistdecl REXML::StreamListener.attlistdecl(element_name, attributes, raw_content)\nIf a doctype includes an ATTLIST declaration, it will cause this\nmethod to be called.  The content is the declaration itself, unparsed.\nEG, <!ATTLIST el attr CDATA #REQUIRED> will come to this method as "el\nattr CDATA #REQUIRED".  This is the same for all of the .*decl\nmethods.\n
cdata REXML::StreamListener.cdata(content)\nCalled when <![CDATA[ ... ]]> is encountered in a document.\n@p content "..."\n
comment REXML::StreamListener.comment(comment)\nCalled when a comment is encountered.\n@p comment The content of the comment\n
doctype REXML::StreamListener.doctype(name, pub_sys, long_name, uri)\nHandles a doctype declaration. Any attributes of the doctype which are\nnot supplied will be nil.  # EG, <!DOCTYPE me PUBLIC "foo" "bar">\n@p name the name of the doctype; EG, "me"\n@p pub_sys "PUBLIC", "SYSTEM", or nil.  EG, "PUBLIC"\n@p long_name the supplied long name, or nil.  EG, "foo"\n@p uri the uri of the doctype, or nil.  EG, "bar"\n
doctype_end REXML::StreamListener.doctype_end()\nCalled when the doctype is done\n
elementdecl REXML::StreamListener.elementdecl(content)\n<!ELEMENT ...>\n
entity REXML::StreamListener.entity(content)\nCalled when %foo; is encountered in a doctype declaration.\n@p content "foo"\n
entitydecl REXML::StreamListener.entitydecl(content)\n<!ENTITY ...>\nThe argument passed to this method is an array of the entity\ndeclaration.  It can be in a number of formats, but in general it\nreturns (example, result):\n <!ENTITY % YN '"Yes"'>\n ["%", "YN", "'\"Yes\"'", "\""]\n <!ENTITY % YN 'Yes'>\n ["%", "YN", "'Yes'", "s"]\n <!ENTITY WhatHeSaid "He said %YN;">\n ["WhatHeSaid", "\"He said %YN;\"", "YN"]\n <!ENTITY open-hatch SYSTEM\n "http://www.textuality.com/boilerplate/OpenHatch.xml">\n ["open-hatch", "SYSTEM",\n "\"http://www.textuality.com/boilerplate/OpenHatch.xml\""]\n <!ENTITY open-hatch PUBLIC "-//Textuality//TEXT Standard open-hatch\n boilerplate//EN" "http://www.textuality.com/boilerplate/OpenHatch.xml">\n ["open-hatch", "PUBLIC", "\"-//Textuality//TEXT Standard open-hatch\n boilerplate//EN\"", "\"http://www.textuality.com/boilerplate/OpenHatch.xml\""]\n <!ENTITY hatch-pic SYSTEM "../grafix/OpenHatch.gif" NDATA gif>\n ["hatch-pic", "SYSTEM", "\"../grafix/OpenHatch.gif\"", "\\n\t\t\t\t\t\t\tNDATA\n gif", "gif"]\n
instruction REXML::StreamListener.instruction(name, instruction)\nCalled when an instruction is encountered.  EG: <?xsl sheet='foo'?>\n@p name the instruction name; in the example, "xsl"\n@p instruction the rest of the instruction.  In the example,\n"sheet='foo'"\n
notationdecl REXML::StreamListener.notationdecl(content)\n<!NOTATION ...>\n
tag_end REXML::StreamListener.tag_end(name)\nCalled when the end tag is reached.  In the case of <tag/>, tag_end\nwill be called immidiately after tag_start\n@p the name of the tag\n
tag_start REXML::StreamListener.tag_start(name, attrs)\nCalled when a tag is encountered.\n@p name the tag name\n@p attrs an array of arrays of attribute/value pairs, suitable for\nuse with assoc or rassoc.  IE, <tag attr1="value1" attr2="value2">\nwill result in\ntag_start( "tag", # [["attr1","value1"],["attr2","value2"]])\n
text REXML::StreamListener.text(text)\nCalled when text is encountered in the document\n@p text the text content.\n
xmldecl REXML::StreamListener.xmldecl(version, encoding, standalone)\nCalled when an XML PI is encountered in the document.\nEG: <?xml version="1.0" encoding="utf"?>\n@p version the version attribute value.  EG, "1.0"\n@p encoding the encoding attribute value, or nil.  EG, "utf"\n@p standalone the standalone attribute value, or nil.  EG, nil\n
exp BigMath.exp(p1, p2)\nComputes the value of e (the base of natural logarithms) raised to the\npower of x, to the specified number of digits of precision.\n\nIf x is infinite, returns Infinity.\n\nIf x is NaN, returns NaN.\n
log BigMath.log(p1, p2)\nComputes the natural logarithm of x to the specified number of digits of\nprecision.\n\nIf x is zero or negative, raises Math::DomainError.\n\nIf x is positive infinite, returns Infinity.\n\nIf x is NaN, returns NaN.\n
E BigMath.E(prec)\nComputes e (the base of natural logarithms) to the specified number of\ndigits of precision.\n
PI BigMath.PI(prec)\nComputes the value of pi to the specified number of digits of precision.\n
atan BigMath.atan(x, prec)\nComputes the arctangent of x to the specified number of digits of precision.\n\nIf x is NaN, returns NaN.\n
cos BigMath.cos(x, prec)\nComputes the cosine of x to the specified number of digits of precision.\n\nIf x is infinite or NaN, returns NaN.\n
sin BigMath.sin(x, prec)\nComputes the sine of x to the specified number of digits of precision.\n\nIf x is infinite or NaN, returns NaN.\n
sqrt BigMath.sqrt(x,prec)\nComputes the square root of x to the specified number of digits of\nprecision.\n\nBigDecimal.new('2').sqrt(16).to_s\n -> "0.14142135623730950488016887242096975E1"\n
dfdxi Jacobian.dfdxi(f,fx,x,i)\nComputes the derivative of f[i] at x[i].\nfx is the value of f at x.\n
isEqual Jacobian.isEqual(a,b,zero=0.0,e=1.0e-8)\nDetermines the equality of two numbers by comparing to zero, or using the\nepsilon value\n
jacobian Jacobian.jacobian(f,fx,x)\nComputes the Jacobian of f at x. fx is the value of f at x.\n
ludecomp LUSolve.ludecomp(a,n,zero=0,one=1)\nPerforms LU decomposition of the n by n matrix a.\n
lusolve LUSolve.lusolve(a,b,ps,zero=0.0)\nSolves a*x = b for x, using LU decomposition.\n\na is a matrix, b is a constant vector, x is the solution vector.\n\nps is the pivot, a vector which indicates the permutation of rows performed\nduring LU decomposition.\n
nlsolve Newton.nlsolve(f,x)\n\n
norm Newton.norm(fv,zero=0.0)\n\n
result Coverage.result()\nReturns a hash that contains filename as key and coverage array as value\nand disables coverage measurement.\n
start Coverage.start()\nEnables coverage measurement.\n
ESCDELAY Curses.ESCDELAY()\nReturns the total time, in milliseconds, for which\ncurses will await a character sequence, e.g., a function key\n
ESCDELAY= Curses.ESCDELAY=(p1)\nSets the ESCDELAY to Integer +value+\n
TABSIZE Curses.TABSIZE()\nReturns the number of positions in a tab.\n
TABSIZE= Curses.TABSIZE=(p1)\nSets the TABSIZE to Integer +value+\n
addch Curses.addch(p1)\nAdd a character +ch+, with attributes, then advance the cursor.\n\nsee also the system manual for curs_addch(3)\n
addstr Curses.addstr(p1)\nadd a string of characters +str+, to the window and advance cursor\n
attroff Curses.attroff(p1)\nTurns on the named attributes +attrs+ without affecting any others.\n\nSee also Curses::Window.attrset for additional information.\n
attron Curses.attron(p1)\nTurns off the named attributes +attrs+\nwithout turning any other attributes on or off.\n\nSee also Curses::Window.attrset for additional information.\n
attrset Curses.attrset(p1)\nSets the current attributes of the given window to +attrs+.\n\nsee also Curses::Window.attrset\n
beep Curses.beep()\nSounds an audible alarm on the terminal, if possible;\notherwise it flashes the screen (visual bell).\n\nsee also Curses.flash\n
bkgd Curses.bkgd(p1)\nWindow background manipulation routines.\n\nSet the background property of the current\nand then apply the character Integer +ch+ setting\nto every character position in that window.\n\nsee also the system manual for curs_bkgd(3)\n
bkgdset Curses.bkgdset(p1)\nManipulate the background of the named window\nwith character Integer +ch+\n\nThe background becomes a property of the character\nand moves with the character through any scrolling\nand insert/delete line/character operations.\n\nsee also the system manual for curs_bkgd(3)\n
can_change_color? Curses.can_change_color?()\nReturns +true+ or +false+ depending on whether the terminal can change\ncolor attributes\n
cbreak Curses.cbreak()\nPut the terminal into cbreak mode.\n\nNormally, the tty driver buffers typed characters until\na newline or carriage return is typed. The Curses.cbreak\nroutine disables line buffering and erase/kill\ncharacter-processing (interrupt and flow control characters\nare unaffected), making characters typed by the user\nimmediately available to the program.\n\nThe Curses.nocbreak routine returns the terminal to normal (cooked) mode.\n\nInitially the terminal may or may not be in cbreak mode,\nas the mode is inherited; therefore, a program should\ncall Curses.cbreak or Curses.nocbreak explicitly.\nMost interactive programs using curses set the cbreak mode.\nNote that Curses.cbreak overrides Curses.raw.\n\nsee also Curses.raw\n
clear Curses.clear()\nClears every position on the screen completely,\nso that a subsequent call by Curses.refresh for the screen/window\nwill be repainted from scratch.\n
close_screen Curses.close_screen()\nA program should always call Curses.close_screen before exiting or\nescaping from curses mode temporarily. This routine\nrestores tty modes, moves the cursor to the lower\nleft-hand corner of the screen and resets the terminal\ninto the proper non-visual mode.\n\nCalling Curses.refresh or Curses.doupdate after a temporary\nescape causes the program to resume visual mode.\n
closed? Curses.closed?()\nReturns +true+ if the window/screen has been closed,\nwithout any subsequent Curses.refresh calls,\nreturns +false+ otherwise.\n
clrtoeol Curses.clrtoeol()\nClears to the end of line, that the cursor is currently on.\n
color_content Curses.color_content(p1)\nReturns an 3 item Array of the RGB values in +color+\n
color_pair Curses.color_pair(p1)\nSets the color pair attributes to +attrs+.\n\nThis should be equivalent to Curses.attrset(COLOR_PAIR(+attrs+))\n\nTODO: validate that equivalency\n
color_pairs Curses.color_pairs()\nReturns the COLOR_PAIRS available, if the curses library supports it.\n
colors Curses.colors()\nreturns COLORS\n
cols Curses.cols()\nReturns the number of columns on the screen\n
crmode Curses.crmode()\nPut the terminal into normal mode (out of cbreak mode).\n\nSee Curses.cbreak for more detail.\n
curs_set Curses.curs_set(p1)\nSets Cursor Visibility.\n0: invisible\n1: visible\n2: very visible\n
def_prog_mode Curses.def_prog_mode()\nSave the current terminal modes as the "program"\nstate for use by the Curses.reset_prog_mode\n\nThis is done automatically by Curses.init_screen\n
delch Curses.delch()\nDelete the character under the cursor\n
deleteln Curses.deleteln()\nDelete the line under the cursor.\n
doupdate Curses.doupdate()\nRefreshes the windows and lines.\n\nCurses.doupdate allows multiple updates with\nmore efficiency than Curses.refresh alone.\n
echo Curses.echo()\nEnables characters typed by the user\nto be echoed by Curses.getch as they are typed.\n
flash Curses.flash()\nFlashs the screen, for visual alarm on the terminal, if possible;\notherwise it sounds the alert.\n\nsee also Curses.beep\n
getch Curses.getch()\nRead and returns a character from the window.\n\nSee Curses::Key to all the function KEY_* available\n
getmouse Curses.getmouse()\nReturns coordinates of the mouse.\n\nThis will read and pop the mouse event data off the queue\n\nSee the BUTTON*, ALL_MOUSE_EVENTS and REPORT_MOUSE_POSITION constants,\nto examine the mask of the event\n
getstr Curses.getstr()\nThis is equivalent to a series f Curses::Window.getch calls\n
has_colors? Curses.has_colors?()\nReturns +true+ or +false+ depending on whether the terminal has color\ncapbilities.\n
inch Curses.inch()\nReturns the character at the current position.\n
init_color Curses.init_color(p1, p2, p3, p4)\nChanges the definition of a color. It takes four arguments:\n* the number of the color to be changed, +color+\n* the amount of red, +r+\n* the amount of green, +g+\n* the amount of blue, +b+\n\nThe value of the first argument must be between 0 and  COLORS.\n(See the section Colors for the default color index.)  Each\nof the last three arguments must be a value between 0 and 1000.\nWhen Curses.init_color is used, all occurrences of that color\non the screen immediately change to the new definition.\n
init_pair Curses.init_pair(p1, p2, p3)\nChanges the definition of a color-pair.\n\nIt takes three arguments: the number of the color-pair to be changed +pair+,\nthe foreground color number +f+, and the background color number +b+.\n\nIf the color-pair was previously initialized, the screen is\nrefreshed and all occurrences of that color-pair are changed\nto the new definition.\n
init_screen Curses.init_screen()\nInitialize a standard screen\n\nsee also Curses.stdscr\n
insch Curses.insch(p1)\nInsert a character +ch+, before the cursor.\n
insertln Curses.insertln()\nInserts a line above the cursor, and the bottom line is lost\n
keyname Curses.keyname(p1)\nReturns the character string corresponding to key +c+\n
lines Curses.lines()\nReturns the number of lines on the screen\n
mouseinterval Curses.mouseinterval(p1)\nThe Curses.mouseinterval function sets the maximum time\n(in thousands of a second) that can elapse between press\nand release events for them to be recognized as a click.\n\nUse Curses.mouseinterval(0) to disable click resolution.\nThis function returns the previous interval value.\n\nUse Curses.mouseinterval(-1) to obtain the interval without\naltering it.\n\nThe default is one sixth of a second.\n
mousemask Curses.mousemask(p1)\nReturns the +mask+ of the reportable events\n
nl Curses.nl()\nEnable the underlying display device to translate\nthe return key into newline on input, and whether it\ntranslates newline into return and line-feed on output\n(in either case, the call Curses.addch('\\n') does the\nequivalent of return and line feed on the virtual screen).\n\nInitially, these translations do occur. If you disable\nthem using Curses.nonl, curses will be able to make better use\nof the line-feed capability, resulting in faster cursor\nmotion. Also, curses will then be able to detect the return key.\n
nocbreak Curses.nocbreak()\nPut the terminal into normal mode (out of cbreak mode).\n\nSee Curses.cbreak for more detail.\n
nocrmode Curses.nocrmode()\nPut the terminal into normal mode (out of cbreak mode).\n\nSee Curses.cbreak for more detail.\n
noecho Curses.noecho()\nDisables characters typed by the user\nto be echoed by Curses.getch as they are typed.\n
nonl Curses.nonl()\nDisable the underlying display device to translate\nthe return key into newline on input\n\nSee Curses.nl for more detail\n
noraw Curses.noraw()\nPut the terminal out of raw mode.\n\nsee Curses.raw for more detail\n
pair_content Curses.pair_content(p1)\nReturns a 2 item Array, with the foreground and\nbackground color, in +pair+\n
pair_number Curses.pair_number(p1)\nReturns the Fixnum color pair number of attributes +attrs+.\n
raw Curses.raw()\nPut the terminal into raw mode.\n\nRaw mode is similar to Curses.cbreak mode, in that characters typed\nare immediately passed through to the user program.\n\nThe differences are that in raw mode, the interrupt, quit,\nsuspend, and flow control characters are all passed through\nuninterpreted, instead of generating a signal. The behavior\nof the BREAK key depends on other bits in the tty driver\nthat are not set by curses.\n
refresh Curses.refresh()\nRefreshes the windows and lines.\n
reset_prog_mode Curses.reset_prog_mode()\nReset the current terminal modes to the saved state\nby the Curses.def_prog_mode\n\nThis is done automatically by Curses.close_screen\n
resize Curses.resize(p1, p2)\nResize the current term to Fixnum +lines+ and Fixnum +cols+\n
resizeterm Curses.resizeterm(p1, p2)\nResize the current term to Fixnum +lines+ and Fixnum +cols+\n
scrl Curses.scrl(p1)\nScrolls the current window Fixnum +num+ lines.\nThe current cursor position is not changed.\n\nFor positive +num+, it scrolls up.\n\nFor negative +num+, it scrolls down.\n
setpos Curses.setpos(p1, p2)\nA setter for the position of the cursor,\nusing coordinates +x+ and +y+\n
setscrreg Curses.setscrreg(p1, p2)\nSet a software scrolling region in a window.\n+top+ and +bottom+ are lines numbers of the margin.\n\nIf this option and Curses.scrollok are enabled, an attempt to move off\nthe bottom margin line causes all lines in the scrolling region\nto scroll one line in the direction of the first line.\nOnly the text of the window is scrolled.\n
standend Curses.standend()\nEnables the Normal display (no highlight)\n\nThis is equivalent to Curses.attron(A_NORMAL)\n\nsee also Curses::Window.attrset for additional information.\n
standout Curses.standout()\nEnables the best highlighting mode of the terminal.\n\nThis is equivalent to Curses:Window.attron(A_STANDOUT)\n\nsee also Curses::Window.attrset additional information\n
start_color Curses.start_color()\nInitializes the color attributes, for terminals that support it.\n\nThis must be called, in order to use color attributes.\nIt is good practice to call it just after Curses.init_screen\n
stdscr Curses.stdscr()\n   The Standard Screen.\n\n   Upon initializing curses, a default window called stdscr,\n   which is the size of the terminal screen, is created.\n\n   Many curses functions use this window.\nInitialize a standard screen\n\nsee also Curses.stdscr\n
timeout= Curses.timeout=(p1)\nSets block and non-blocking reads for the window.\n- If delay is negative, blocking read is used (i.e., waits indefinitely\nfor input).\n- If delay is zero, then non-blocking read is used (i.e., read returns ERR\nif no input is waiting).\n- If delay is positive, then read blocks for delay milliseconds, and returns\nERR if there is still no input.\n
ungetch Curses.ungetch(p1)\nPlaces +ch+ back onto the input queue to be returned by\nthe next call to Curses.getch.\n\nThere is just one input queue for all windows.\n
ungetmouse Curses.ungetmouse(p1)\nIt pushes a KEY_MOUSE event onto the input queue, and associates with that\nevent the given state data and screen-relative character-cell coordinates.\n\nThe Curses.ungetmouse function behaves analogously to Curses.ungetch.\n
use_default_colors Curses.use_default_colors()\ntells the curses library to use terminal's default colors.\n\nsee also the system manual for default_colors(3)\n
hexencode Digest.hexencode(p1)\nGenerates a hex-encoded version of a given _string_.\n
base64digest Digest::Instance.base64digest(str = nil)\nIf none is given, returns the resulting hash value of the digest\nin a base64 encoded form, keeping the digest's state.\n\nIf a +string+ is given, returns the hash value for the given\n+string+ in a base64 encoded form, resetting the digest to the\ninitial state before and after the process.\n\nIn either case, the return value is properly padded with '=' and\ncontains no line feeds.\n
base64digest! Digest::Instance.base64digest!()\nReturns the resulting hash value and resets the digest to the\ninitial state.\n
block_length Digest::Instance.block_length()\nReturns the block length of the digest.\n\nThis method is overridden by each implementation subclass.\n
digest Digest::Instance.digest(p1 = v1)\nIf none is given, returns the resulting hash value of the digest,\nkeeping the digest's state.\n\nIf a _string_ is given, returns the hash value for the given\n_string_, resetting the digest to the initial state before and\nafter the process.\n
digest! Digest::Instance.digest!()\nReturns the resulting hash value and resets the digest to the\ninitial state.\n
digest_length Digest::Instance.digest_length()\nReturns the length of the hash value of the digest.\n\nThis method should be overridden by each implementation subclass.\nIf not, digest_obj.digest().length() is returned.\n
file Digest::Instance.file(name)\nupdates the digest with the contents of a given file _name_ and\nreturns self.\n
hexdigest Digest::Instance.hexdigest(p1 = v1)\nIf none is given, returns the resulting hash value of the digest in\na hex-encoded form, keeping the digest's state.\n\nIf a _string_ is given, returns the hash value for the given\n_string_ in a hex-encoded form, resetting the digest to the initial\nstate before and after the process.\n
hexdigest! Digest::Instance.hexdigest!()\nReturns the resulting hash value in a hex-encoded form and resets\nthe digest to the initial state.\n
inspect Digest::Instance.inspect()\nCreates a printable version of the digest object.\n
length Digest::Instance.length()\nReturns digest_obj.digest_length().\n
new Digest::Instance.new()\nReturns a new, initialized copy of the digest object.  Equivalent\nto digest_obj.clone().reset().\n
reset Digest::Instance.reset()\nResets the digest to the initial state and returns self.\n\nThis method is overridden by each implementation subclass.\n
size Digest::Instance.size()\nReturns digest_obj.digest_length().\n
to_s Digest::Instance.to_s()\nReturns digest_obj.hexdigest().\n
update Digest::Instance.update(p1)\nUpdates the digest using a given _string_ and returns self.\n\nThe update() method and the left-shift operator are overridden by\neach implementation subclass. (One should be an alias for the\nother)\n
dlopen DL.dlopen(*args)\n\n
dlunwrap DL.dlunwrap(p1)\n\n
dlwrap DL.dlwrap(p1)\n\n
fiddle? DL.fiddle?()\n\n
free DL.free(p1)\nFree the memory at address +addr+\n
malloc DL.malloc(p1)\nAllocate +size+ bytes of memory and return the integer memory address\nfor the allocated memory.\n
realloc DL.realloc(p1, p2)\nChange the size of the memory allocated at the memory location +addr+ to\n+size+ bytes.  Returns the memory address of the reallocated memory, which\nmay be different than the address passed in.\n
remove_callback DL.remove_callback(addr, ctype = nil)\n\n
remove_callback_internal DL.remove_callback_internal(proc_entry, addr_entry, addr, ctype = nil)\n\n
remove_cdecl_callback DL.remove_cdecl_callback(addr, ctype = nil)\n\n
remove_stdcall_callback DL.remove_stdcall_callback(addr, ctype = nil)\n\n
set_callback DL.set_callback(ty, argc, &cbp)\n\n
set_callback_internal DL.set_callback_internal(proc_entry, addr_entry, argc, ty, abi = nil, &cbp)\n\n
set_cdecl_callback DL.set_cdecl_callback(ty, argc, &cbp)\n\n
set_stdcall_callback DL.set_stdcall_callback(ty, argc, &cbp)\n\n
bind DL::Importer.bind(signature, *opts, &blk)\n\n
bind_function DL::Importer.bind_function(name, ctype, argtype, call_type = nil, &block)\n\n
create_carried_function DL::Importer.create_carried_function(name, ctype, argtype, call_type = nil,\nn = 0)\n\n
create_temp_function DL::Importer.create_temp_function(name, ctype, argtype, call_type = nil)\n\n
create_value DL::Importer.create_value(ty, val=nil)\n\n
dlload DL::Importer.dlload(*libs)\n\n
extern DL::Importer.extern(signature, *opts)\n\n
handler DL::Importer.handler()\n\n
import_function DL::Importer.import_function(name, ctype, argtype, call_type = nil)\n\n
import_symbol DL::Importer.import_symbol(name)\n\n
import_value DL::Importer.import_value(ty, addr)\n\n
sizeof DL::Importer.sizeof(ty)\n\n
struct DL::Importer.struct(signature)\n\n
typealias DL::Importer.typealias(alias_type, orig_type)\n\n
union DL::Importer.union(signature)\n\n
value DL::Importer.value(ty, val=nil)\n\n
signed_value DL::ValueUtil.signed_value(val, ty)\n\n
unsigned_value DL::ValueUtil.unsigned_value(val, ty)\n\n
wrap_arg DL::ValueUtil.wrap_arg(arg, ty, funcs = [], &block)\n\n
wrap_args DL::ValueUtil.wrap_args(args, tys, funcs, &block)\n\n
create DL::CStructBuilder.create(klass, types, members)\n\n
align DL::PackInfo.align(addr, align)\n\n
parse_ctype DL::CParser.parse_ctype(ty, tymap=nil)\n\n
parse_signature DL::CParser.parse_signature(signature, tymap=nil)\n\n
parse_struct_signature DL::CParser.parse_struct_signature(signature, tymap=nil)\n\n
CloseKey Win32::Registry::API.CloseKey(hkey)\n\n
CreateKey Win32::Registry::API.CreateKey(hkey, name, opt, desired)\n\n
DeleteKey Win32::Registry::API.DeleteKey(hkey, name)\n\n
DeleteValue Win32::Registry::API.DeleteValue(hkey, name)\n\n
EnumKey Win32::Registry::API.EnumKey(hkey, index)\n\n
EnumValue Win32::Registry::API.EnumValue(hkey, index)\n\n
FlushKey Win32::Registry::API.FlushKey(hkey)\n\n
OpenKey Win32::Registry::API.OpenKey(hkey, name, opt, desired)\n\n
QueryInfoKey Win32::Registry::API.QueryInfoKey(hkey)\n\n
QueryValue Win32::Registry::API.QueryValue(hkey, name)\n\n
SetValue Win32::Registry::API.SetValue(hkey, name, type, data, size)\n\n
check Win32::Registry::API.check(result)\n\n
packdw Win32::Registry::API.packdw(dw)\n\n
packqw Win32::Registry::API.packqw(qw)\n\n
unpackdw Win32::Registry::API.unpackdw(dw)\n\n
unpackqw Win32::Registry::API.unpackqw(qw)\n\n
get_hosts_path Win32::Resolv.get_hosts_path()\n\n
get_resolv_info Win32::Resolv.get_resolv_info()\n\n
endgrent Etc.endgrent()\nEnds the process of scanning through the /etc/group file begun by\ngetgrent, and closes the file.\n
endpwent Etc.endpwent()\nEnds the process of scanning through the /etc/passwd file begun with\ngetpwent, and closes the file.\n
getgrent Etc.getgrent()\nReturns an entry from the /etc/group file. The first time it is called it\nopens the file and returns the first entry; each successive call returns\nthe next entry, or nil if the end of the file has been reached.\n\nTo close the file when processing is complete, call endgrent.\n\nEach entry is returned as a Struct::Group:\n\n- Group#name contains the name of the group as a String.\n\n- Group#passwd contains the encrypted password as a String. An 'x' is\n  returned if password access to the group is not available; an empty\n  string is returned if no password is needed to obtain membership of\n  the group.\n\n- Group#gid contains the group's numeric ID as an integer.\n\n- Group#mem is an Array of Strings containing the short login names of the\n  members of the group.\n
getgrgid Etc.getgrgid(p1 = v1)\nReturns information about the group with specified integer group id (gid),\nas found in /etc/group.\n\nThe information is returned as a Struct::Group; see getgrent above for\ndetails.\n\ne.g.  Etc.getgrgid(100) -> #<struct Struct::Group name="users", passwd="x",\ngid=100, mem=["meta", "root"]>\n
getgrnam Etc.getgrnam(p1)\nReturns information about the group with specified String name, as found\nin /etc/group.\n\nThe information is returned as a Struct::Group; see getgrent above for\ndetails.\n\ne.g.  Etc.getgrnam('users') -> #<struct Struct::Group name="users",\npasswd="x", gid=100, mem=["meta", "root"]>\n
getlogin Etc.getlogin()\nReturns the short user name of the currently logged in user.\nUnfortunately, it is often rather easy to fool getlogin().\nAvoid getlogin() for security-related purposes.\n\ne.g.\n  Etc.getlogin -> 'guest'\n
getpwent Etc.getpwent()\nReturns an entry from the /etc/passwd file. The first time it is called it\nopens the file and returns the first entry; each successive call returns\nthe next entry, or nil if the end of the file has been reached.\n\nTo close the file when processing is complete, call endpwent.\n\nEach entry is returned as a Struct::Passwd:\n\n- Passwd#name contains the short login name of the user as a String.\n\n- Passwd#passwd contains the encrypted password of the user as a String.\n  an 'x' is returned if shadow passwords are in use. An '*' is returned\n  if the user cannot log in using a password.\n\n- Passwd#uid contains the integer user ID (uid) of the user.\n\n- Passwd#gid contains the integer group ID (gid) of the user's primary group.\n\n- Passwd#gecos contains a longer String description of the user, such as\n  a full name. Some Unix systems provide structured information in the\n  gecos field, but this is system-dependent.\n\n- Passwd#dir contains the path to the home directory of the user as a String.\n\n- Passwd#shell contains the path to the login shell of the user as a String.\n
getpwnam Etc.getpwnam(p1)\nReturns the /etc/passwd information for the user with specified login name.\n\nThe information is returned as a Struct::Passwd; see getpwent above for\ndetails.\n\ne.g.  * Etc.getpwnam('root') -> #<struct Struct::Passwd name="root",\npasswd="x", uid=0, gid=0, gecos="root",dir="/root", shell="/bin/bash">\n
getpwuid Etc.getpwuid(p1 = v1)\nReturns the /etc/passwd information for the user with specified integer\nuser id (uid).\n\nThe information is returned as a Struct::Passwd; see getpwent above for\ndetails.\n\ne.g.  * Etc.getpwuid(0) -> #<struct Struct::Passwd name="root",\npasswd="x", uid=0, gid=0, gecos="root",dir="/root", shell="/bin/bash">\n
group Etc.group()\nProvides a convenient Ruby iterator which executes a block for each entry\nin the /etc/group file.\n\nThe code block is passed an Struct::Group struct; see getgrent above for\ndetails.\n\nExample:\n\n    require 'etc'\n\n    Etc.group {|g|\n      puts g.name + ": " + g.mem.join(', ')\n    }\n
passwd Etc.passwd()\nProvides a convenient Ruby iterator which executes a block for each entry\nin the /etc/passwd file.\n\nThe code block is passed an Struct::Passwd struct; see getpwent above for\ndetails.\n\nExample:\n\n    require 'etc'\n\n    Etc.passwd {|u|\n      puts u.name + " = " + u.gecos\n    }\n
setgrent Etc.setgrent()\nResets the process of reading the /etc/group file, so that the next call\nto getgrent will return the first entry again.\n
setpwent Etc.setpwent()\nResets the process of reading the /etc/passwd file, so that the next call\nto getpwent will return the first entry again.\n
sysconfdir Etc.sysconfdir()\nReturns system configuration directory.\n
systmpdir Etc.systmpdir()\nReturns system temporary directory.\n
last_error Fiddle.last_error()\nReturns the last +Error+ of the current executing +Thread+ or nil if none\n
last_error= Fiddle.last_error=(error)\nSets the last +Error+ of the current executing +Thread+ to +error+\n
win32_last_error Fiddle.win32_last_error()\nReturns the last win32 +Error+ of the current executing +Thread+ or nil\nif none\n
win32_last_error= Fiddle.win32_last_error=(error)\nSets the last win32 +Error+ of the current executing +Thread+ to +error+\n
new Iconv::Failure.new(p1, p2, p3)\nCreates new code converter from a coding-system designated with +from+\nto another one designated with +to+.\n\n=== Parameters\n\n+to+::   encoding name for destination\n+from+:: encoding name for source\n+options+:: options for converter\n\n=== Exceptions\n\nTypeError::       if +to+ or +from+ aren't String\nInvalidEncoding:: if designated converter couldn't find out\nSystemCallError:: if <tt>iconv_open(3)</tt> fails\n
failed Iconv::Failure.failed()\nReturns substring of the original string passed to Iconv that starts at the\ncharacter caused the exception.\n
inspect Iconv::Failure.inspect()\nReturns inspected string like as: #<_class_: _success_, _failed_>\n
success Iconv::Failure.success()\nReturns string(s) translated successfully until the exception occurred.\n* In the case of failure occurred within Iconv.iconv, returned\n  value is an array of strings translated successfully preceding\n  failure and the last element is string on the way.\n
getch IO::readable.getch(*args)\n\n
read_nonblock IO::readable.read_nonblock(*args)\nSimilar to #read, but raises +EOFError+ at end of string instead of\nreturning +nil+, as well as IO#sysread does.\n
readbyte IO::readable.readbyte()\nSee IO#readbyte.\n
readchar IO::readable.readchar()\nSee IO#readchar.\n
readline IO::readable.readline(*args)\nSee IO#readline.\n
readpartial IO::readable.readpartial(*args)\nSimilar to #read, but raises +EOFError+ at end of string instead of\nreturning +nil+, as well as IO#sysread does.\n
sysread IO::readable.sysread(*args)\nSimilar to #read, but raises +EOFError+ at end of string instead of\nreturning +nil+, as well as IO#sysread does.\n
const_defined_in? JSON.const_defined_in?(modul, constant)\n\n
iconv JSON.iconv(to, from, string)\nEncodes string using Ruby's _String.encode_\n
restore JSON.restore(source, proc = nil, options = {})\n\n
dump JSON.dump(obj, anIO = nil, limit = nil)\nDumps _obj_ as a JSON string, i.e. calls generate on the object and returns\nthe result.\n\nIf anIO (an IO-like object or an object that responds to the write method)\nwas given, the resulting JSON is written to it.\n\nIf the number of nested arrays or objects exceeds _limit_, an ArgumentError\nexception is raised. This argument is similar (but not exactly the\nsame!) to the _limit_ argument in Marshal.dump.\n\nThis method is part of the implementation of the load/dump interface of\nMarshal and YAML.\n
fast_generate JSON.fast_generate(obj, opts = nil)\nGenerate a JSON document from the Ruby data structure _obj_ and return it.\nThis method disables the checks for circles in Ruby objects.\n\n*WARNING*: Be careful not to pass any Ruby data structures with circles as\n_obj_ argument because this will cause JSON to go into an infinite loop.\n
generate JSON.generate(obj, opts = nil)\nGenerate a JSON document from the Ruby data structure _obj_ and return\nit. _state_ is * a JSON::State object,\n* or a Hash like object (responding to to_hash),\n* an object convertible into a hash by a to_h method,\nthat is used as or to configure a State object.\n\nIt defaults to a state object, that creates the shortest possible JSON text\nin one line, checks for circular data structures and doesn't allow NaN,\nInfinity, and -Infinity.\n\nA _state_ hash can have the following keys:\n* *indent*: a string used to indent levels (default: ''),\n* *space*: a string that is put after, a : or , delimiter (default: ''),\n* *space_before*: a string that is put before a : pair delimiter (default: ''),\n* *object_nl*: a string that is put at the end of a JSON object (default: ''),\n* *array_nl*: a string that is put at the end of a JSON array (default: ''),\n* *allow_nan*: true if NaN, Infinity, and -Infinity should be\n  generated, otherwise an exception is thrown if these values are\n  encountered. This options defaults to false.\n* *max_nesting*: The maximum depth of nesting allowed in the data\n  structures from which JSON is to be generated. Disable depth checking\n  with :max_nesting => false, it defaults to 19.\n\nSee also the fast_generate for the fastest creation method with the least\namount of sanity checks, and the pretty_generate method for some\ndefaults for pretty output.\n
load JSON.load(source, proc = nil, options = {})\nLoad a ruby data structure from a JSON _source_ and return it. A source can\neither be a string-like object, an IO-like object, or an object responding\nto the read method. If _proc_ was given, it will be called with any nested\nRuby object as an argument recursively in depth first order. To modify the\ndefault options pass in the optional _options_ argument as well.\n\nThis method is part of the implementation of the load/dump interface of\nMarshal and YAML.\n
parse JSON.parse(source, opts = {})\nParse the JSON document _source_ into a Ruby data structure and return it.\n\n_opts_ can have the following\nkeys:\n* *max_nesting*: The maximum depth of nesting allowed in the parsed data\n  structures. Disable depth checking with :max_nesting => false. It defaults\n  to 19.\n* *allow_nan*: If set to true, allow NaN, Infinity and -Infinity in\n  defiance of RFC 4627 to be parsed by the Parser. This option defaults\n  to false.\n* *symbolize_names*: If set to true, returns symbols for the names\n  (keys) in a JSON object. Otherwise strings are returned. Strings are\n  the default.\n* *create_additions*: If set to false, the Parser doesn't create\n  additions even if a matching class and create_id was found. This option\n  defaults to false.\n* *object_class*: Defaults to Hash\n* *array_class*: Defaults to Array\n
parse! JSON.parse!(source, opts = {})\nParse the JSON document _source_ into a Ruby data structure and return it.\nThe bang version of the parse method defaults to the more dangerous values\nfor the _opts_ hash, so be sure only to parse trusted _source_ documents.\n\n_opts_ can have the following keys:\n* *max_nesting*: The maximum depth of nesting allowed in the parsed data\n  structures. Enable depth checking with :max_nesting => anInteger. The parse!\n  methods defaults to not doing max depth checking: This can be dangerous\n  if someone wants to fill up your stack.\n* *allow_nan*: If set to true, allow NaN, Infinity, and -Infinity in\n  defiance of RFC 4627 to be parsed by the Parser. This option defaults\n  to true.\n* *create_additions*: If set to false, the Parser doesn't create\n  additions even if a matching class and create_id was found. This option\n  defaults to false.\n
pretty_generate JSON.pretty_generate(obj, opts = nil)\nGenerate a JSON document from the Ruby data structure _obj_ and return it.\nThe returned document is a prettier form of the document returned by\nunparse.\n\nThe _opts_ argument can be used to configure the generator. See the\ngenerate method for a more detailed explanation.\n
recurse_proc JSON.recurse_proc(result, &proc)\nRecursively calls passed _Proc_ if the parsed data structure is an _Array_\nor _Hash_\n
guess Kconv.guess(str)\nGuess input encoding by NKF.guess\n
iseuc Kconv.iseuc(str)\nReturns whether input encoding is EUC-JP or not.\n\n*Note* don't expect this return value is MatchData.\n
isjis Kconv.isjis(str)\nReturns whether input encoding is ISO-2022-JP or not.\n
issjis Kconv.issjis(str)\nReturns whether input encoding is Shift_JIS or not.\n
isutf8 Kconv.isutf8(str)\nReturns whether input encoding is UTF-8 or not.\n
kconv Kconv.kconv(str, to_enc, from_enc=nil)\nConvert `str` to `to_enc`.\n`to_enc` and `from_enc` are given as constants of Kconv or Encoding objects.\n
toeuc Kconv.toeuc(str)\nConvert `str` to EUC-JP\n
tojis Kconv.tojis(str)\nConvert `str` to ISO-2022-JP\n
tolocale Kconv.tolocale(str)\nConvert `self` to locale encoding\n
tosjis Kconv.tosjis(str)\nConvert `str` to Shift_JIS\n
toutf16 Kconv.toutf16(str)\nConvert `str` to UTF-16\n
toutf32 Kconv.toutf32(str)\nConvert `str` to UTF-32\n
toutf8 Kconv.toutf8(str)\nConvert `str` to UTF-8\n
guess NKF.guess(p1)\nReturns guessed encoding of _str_ by nkf routine.\n
nkf NKF.nkf(p1, p2)\nConvert _str_ and return converted result.\nConversion details are specified by _opt_ as String.\n\n   require 'nkf'\n   output = NKF.nkf("-s", input)\n
expand_hexstring OpenSSL::X509::Name::RFC2253DN.expand_hexstring(str)\n\n
expand_pair OpenSSL::X509::Name::RFC2253DN.expand_pair(str)\n\n
expand_value OpenSSL::X509::Name::RFC2253DN.expand_value(str1, str2, str3)\n\n
scan OpenSSL::X509::Name::RFC2253DN.scan(dn)\n\n
new OpenSSL::Buffering.new(*args)\n\n
close OpenSSL::Buffering.close()\nCloses the SSLSocket and flushes any unwritten data.\n
each OpenSSL::Buffering.each(eol=$/)\nExecutes the block for every line in the stream where lines are separated\nby +eol+.\n\nSee also #gets\n
each_byte OpenSSL::Buffering.each_byte()\nCalls the given block once for each byte in the stream.\n
each_line OpenSSL::Buffering.each_line(eol=$/)\n\n
eof OpenSSL::Buffering.eof()\n\n
eof? OpenSSL::Buffering.eof?()\nReturns true if the stream is at file which means there is no more data to\nbe read.\n
flush OpenSSL::Buffering.flush()\nFlushes buffered data to the SSLSocket.\n
getc OpenSSL::Buffering.getc()\nReads one character from the stream.  Returns nil if called at end of\nfile.\n
gets OpenSSL::Buffering.gets(eol=$/, limit=nil)\nReads the next "line+ from the stream.  Lines are separated by +eol+.  If\n+limit+ is provided the result will not be longer than the given number of\nbytes.\n\n+eol+ may be a String or Regexp.\n\nUnlike IO#gets the line read will not be assigned to +$_+.\n\nUnlike IO#gets the separator must be provided if a limit is provided.\n
print OpenSSL::Buffering.print(*args)\nWrites +args+ to the stream.\n\nSee IO#print for full details.\n
printf OpenSSL::Buffering.printf(s, *args)\nFormats and writes to the stream converting parameters under control of\nthe format string.\n\nSee Kernel#sprintf for format string details.\n
puts OpenSSL::Buffering.puts(*args)\nWrites +args+ to the stream along with a record separator.\n\nSee IO#puts for full details.\n
read OpenSSL::Buffering.read(size=nil, buf=nil)\nReads +size+ bytes from the stream.  If +buf+ is provided it must\nreference a string which will receive the data.\n\nSee IO#read for full details.\n
read_nonblock OpenSSL::Buffering.read_nonblock(maxlen, buf=nil)\nReads at most +maxlen+ bytes in the non-blocking manner.\n\nWhen no data can be read without blocking it raises\nOpenSSL::SSL::SSLError extended by IO::WaitReadable or IO::WaitWritable.\n\nIO::WaitReadable means SSL needs to read internally so read_nonblock\nshould be called again when the underlying IO is readable.\n\nIO::WaitWritable means SSL needs to write internally so read_nonblock\nshould be called again after the underlying IO is writable.\n\nOpenSSL::Buffering#read_nonblock needs two rescue clause as follows:\n emulates blocking read (readpartial).\n  begin\n    result = ssl.read_nonblock(maxlen)\n  rescue IO::WaitReadable\n    IO.select([io])\n    retry\n  rescue IO::WaitWritable\n    IO.select(nil, [io])\n    retry\n  end\n\nNote that one reason that read_nonblock writes to the underlying IO is\nwhen the peer requests a new TLS/SSL handshake.  See openssl the FAQ for\nmore details.  http://www.openssl.org/support/faq.html\n
readchar OpenSSL::Buffering.readchar()\nReads a one-character string from the stream.  Raises an EOFError at end\nof file.\n
readline OpenSSL::Buffering.readline(eol=$/)\nReads a line from the stream which is separated by +eol+.\n\nRaises EOFError if at end of file.\n
readlines OpenSSL::Buffering.readlines(eol=$/)\nReads lines from the stream which are separated by +eol+.\n\nSee also #gets\n
readpartial OpenSSL::Buffering.readpartial(maxlen, buf=nil)\nReads at most +maxlen+ bytes from the stream.  If +buf+ is provided it\nmust reference a string which will receive the data.\n\nSee IO#readpartial for full details.\n
ungetc OpenSSL::Buffering.ungetc(c)\nPushes character +c+ back onto the stream such that a subsequent buffered\ncharacter read will return it.\n\nUnlike IO#getc multiple bytes may be pushed back onto the stream.\n\nHas no effect on unbuffered reads (such as #sysread).\n
write OpenSSL::Buffering.write(s)\nWrites +s+ to the stream.  If the argument is not a string it will be\nconverted using String#to_s.  Returns the number of bytes written.\n
write_nonblock OpenSSL::Buffering.write_nonblock(s)\nWrites +str+ in the non-blocking manner.\n\nIf there is buffered data, it is flushed first.  This may block.\n\nwrite_nonblock returns number of bytes written to the SSL connection.\n\nWhen no data can be written without blocking it raises\nOpenSSL::SSL::SSLError extended by IO::WaitReadable or IO::WaitWritable.\n\nIO::WaitReadable means SSL needs to read internally so write_nonblock\nshould be called again after the underlying IO is readable.\n\nIO::WaitWritable means SSL needs to write internally so write_nonblock\nshould be called again after underlying IO is writable.\n\nSo OpenSSL::Buffering#write_nonblock needs two rescue clause as follows.\n emulates blocking write.\n  begin\n    result = ssl.write_nonblock(str)\n  rescue IO::WaitReadable\n    IO.select([io])\n    retry\n  rescue IO::WaitWritable\n    IO.select(nil, [io])\n    retry\n  end\n\nNote that one reason that write_nonblock reads from the underlying IO\nis when the peer requests a new TLS/SSL handshake.  See the openssl FAQ\nfor more details.  http://www.openssl.org/support/faq.html\n
verify_certificate_identity OpenSSL::SSL.verify_certificate_identity(cert, hostname)\n\n
addr OpenSSL::SSL::SocketForwarder.addr()\n\n
closed? OpenSSL::SSL::SocketForwarder.closed?()\n\n
do_not_reverse_lookup= OpenSSL::SSL::SocketForwarder.do_not_reverse_lookup=(flag)\n\n
fcntl OpenSSL::SSL::SocketForwarder.fcntl(*args)\n\n
getsockopt OpenSSL::SSL::SocketForwarder.getsockopt(level, optname)\n\n
peeraddr OpenSSL::SSL::SocketForwarder.peeraddr()\n\n
setsockopt OpenSSL::SSL::SocketForwarder.setsockopt(level, optname, optval)\n\n
new OpenSSL::SSL::Nonblock.new(*args)\n\n
decode OpenSSL::ASN1.decode(p1)\nDecodes a BER- or DER-encoded value and creates an ASN1Data instance. +der+\nmay be a +String+ or any object that features a +#to_der+ method transforming\nit into a BER-/DER-encoded +String+.\n\n== Example\n  der = File.binread('asn1data')\n  asn1 = OpenSSL::ASN1.decode(der)\n
decode_all OpenSSL::ASN1.decode_all(p1)\nSimilar to +decode+ with the difference that +decode+ expects one\ndistinct value represented in +der+. +decode_all+ on the contrary\ndecodes a sequence of sequential BER/DER values lined up in +der+\nand returns them as an array.\n\n== Example\n  ders = File.binread('asn1data_seq')\n  asn1_ary = OpenSSL::ASN1.decode_all(ders)\n
traverse OpenSSL::ASN1.traverse(p1)\nIf a block is given, it prints out each of the elements encountered.\nBlock parameters are (in that order):\n* depth: The recursion depth, plus one with each constructed value being\nencountered (Number)\n* offset: Current byte offset (Number)\n* header length: Combined length in bytes of the Tag and Length\nheaders. (Number)\n* length: The overall remaining length of the entire data (Number)\n* constructed: Whether this value is constructed or not (Boolean)\n* tag_class: Current tag class (Symbol)\n* tag: The current tag (Number)\n\n== Example\n  der = File.binread('asn1data.der')\n  OpenSSL::ASN1.traverse(der) do | depth, offset, header_len, length,\n  constructed, tag_class, tag|\n    puts "Depth: #{depth} Offset: #{offset} Length: #{length}"\n    puts "Header length: #{header_len} Tag: #{tag} Tag class: #{tag_class}\n    Constructed: #{constructed}"\n  end\n
pbkdf2_hmac OpenSSL::PKCS5.pbkdf2_hmac(p1, p2, p3, p4, p5)\n=== Parameters\n* +pass+ - string\n* +salt+ - string\n* +iter+ - integer - should be greater than 1000.  2000 is better.\n* +keylen+ - integer\n* +digest+ - a string or OpenSSL::Digest object.\n\nAvailable in OpenSSL 0.9.9?.\n\nDigests other than SHA1 may not be supported by other cryptography libraries.\n
pbkdf2_hmac_sha1 OpenSSL::PKCS5.pbkdf2_hmac_sha1(p1, p2, p3, p4)\n=== Parameters\n* +pass+ - string\n* +salt+ - string\n* +iter+ - integer - should be greater than 1000.  2000 is better.\n* +keylen+ - integer\n\nThis method is available almost any version OpenSSL.\n\nConforms to rfc2898.\n
read OpenSSL::PKey.read(p1, p2 = v2)\n=== Parameters\n* +string+ is a DER- or PEM-encoded string containing an arbitrary private\nor public key.\n* +file+ is an instance of +File+ containing a DER- or PEM-encoded\narbitrary private or public key.\n* +pwd+ is an optional password in case +string+ or +file+ is an encrypted\nPEM resource.\n
new Psych::Streaming.new(io)\nCreate a new streaming emitter.  Emitter will print to +io+.  See\nPsych::Stream for an example.\n
start Psych::Streaming.start(encoding = Nodes::Stream::UTF8)\nStart streaming using +encoding+\n
check PTY.check(p1, p2 = v2)\nChecks the status of the child process specified by +pid+.\nReturns +nil+ if the process is still alive.  If the process\nis not alive, will return a <tt>Process::Status</tt> or raise\na <tt>PTY::ChildExited</tt> (if +raise+ was true).\n\n+pid+:: The process id of the process to check\n+raise+:: If true and the process identified by +pid+ is no longer\n          alive a <tt>PTY::ChildExited</tt> is raised.\n\nReturns nil or a <tt>Process::Status</tt> when +raise+ is false.\n
getpty PTY.getpty(*args)\nSpawns the specified command on a newly allocated pty.\n\nThe command's controlling tty is set to the slave device of the pty\nand its standard input/output/error is redirected to the slave device.\n\n<tt>command_line</tt>:: The full command line to run\n<tt>command</tt>:: The command to run, as a String.\n<tt>args</tt>:: Zero or more arguments, as Strings, representing\n                the arguments to +command+\n\nIn the non-block form this returns an array of size three,\n<tt>[r, w, pid]</tt>.  In the block form the block will be called with\nthese as arguments, <tt>|r,w,pid|</tt>:\n\n+r+:: An IO that can be read from that contains the command's\n      standard output and standard error\n+w+:: An IO that can be written to that is the command's\n      standard input\n+pid+:: The process identifier for the command.\n
open PTY.open()\nAllocates a pty (pseudo-terminal).\n\nIn the non-block form, returns a two element array, <tt>[master_io,\nslave_file]</tt>.\n\nIn the block form, yields two arguments <tt>master_io, slave_file</tt>\nand the value of the block is returned from +open+.\n\nThe IO and File are both closed after the block completes if they haven't\nbeen already closed.\n\nThe arguments in both forms are:\n\n<tt>master_io</tt>:: the master of the pty, as an IO.\n<tt>slave_file</tt>:: the slave of the pty, as a File.  The path to the\n                      terminal device is available via\n                      <tt>slave_file.path</tt>\n\n=== Example\n\n  PTY.open {|m, s|\n    p m      #=> #<IO:masterpty:/dev/pts/1>\n    p s      #=> #<File:/dev/pts/1>\n    p s.path #=> "/dev/pts/1"\n  }\n Change the buffering type in factor command,\n assuming that factor uses stdio for stdout buffering.\n If IO.pipe is used instead of PTY.open,\n this code deadlocks because factor's stdout is fully buffered.\n  require 'io/console' # for IO#raw!\n  m, s = PTY.open\n  s.raw! # disable newline conversion.\n  r, w = IO.pipe\n  pid = spawn("factor", :in=>r, :out=>s)\n  r.close\n  s.close\n  w.puts "42"\n  p m.gets #=> "42: 2 3 7\\n"\n  w.puts "144"\n  p m.gets #=> "144: 2 2 2 2 3 3\\n"\n  w.close\n The result of read operation when pty slave is closed is platform\n dependent.\n  ret = begin\n          m.gets          # FreeBSD returns nil.\n        rescue Errno::EIO # GNU/Linux raises EIO.\n          nil\n        end\n  p ret #=> nil\n
spawn PTY.spawn(*args)\nSpawns the specified command on a newly allocated pty.\n\nThe command's controlling tty is set to the slave device of the pty\nand its standard input/output/error is redirected to the slave device.\n\n<tt>command_line</tt>:: The full command line to run\n<tt>command</tt>:: The command to run, as a String.\n<tt>args</tt>:: Zero or more arguments, as Strings, representing\n                the arguments to +command+\n\nIn the non-block form this returns an array of size three,\n<tt>[r, w, pid]</tt>.  In the block form the block will be called with\nthese as arguments, <tt>|r,w,pid|</tt>:\n\n+r+:: An IO that can be read from that contains the command's\n      standard output and standard error\n+w+:: An IO that can be written to that is the command's\n      standard input\n+pid+:: The process identifier for the command.\n
basic_quote_characters Readline.basic_quote_characters()\nGets a list of quote characters which can cause a word break.\n\nRaises NotImplementedError if the using readline library does not support.\n\nRaises SecurityError exception if $SAFE is 4.\n
basic_quote_characters= Readline.basic_quote_characters=(p1)\nSets a list of quote characters which can cause a word break.\n\nRaises NotImplementedError if the using readline library does not support.\n\nRaises SecurityError exception if $SAFE is 4.\n
basic_word_break_characters Readline.basic_word_break_characters()\nGets the basic list of characters that signal a break between words\nfor the completer routine.\n\nRaises NotImplementedError if the using readline library does not support.\n\nRaises SecurityError exception if $SAFE is 4.\n
basic_word_break_characters= Readline.basic_word_break_characters=(p1)\nSets the basic list of characters that signal a break between words\nfor the completer routine. The default is the characters which\nbreak words for completion in Bash: "\t\\n\"\\'`@$><=;|&{(".\n\nRaises NotImplementedError if the using readline library does not support.\n\nRaises SecurityError exception if $SAFE is 4.\n
completer_quote_characters Readline.completer_quote_characters()\nGets a list of characters which can be used to quote a substring of\nthe line.\n\nRaises NotImplementedError if the using readline library does not support.\n\nRaises SecurityError exception if $SAFE is 4.\n
completer_quote_characters= Readline.completer_quote_characters=(p1)\nSets a list of characters which can be used to quote a substring of\nthe line. Completion occurs on the entire substring, and within\nthe substring Readline.completer_word_break_characters are treated\nas any other character, unless they also appear within this list.\n\nRaises NotImplementedError if the using readline library does not support.\n\nRaises SecurityError exception if $SAFE is 4.\n
completer_word_break_characters Readline.completer_word_break_characters()\nGets the basic list of characters that signal a break between words\nfor rl_complete_internal().\n\nRaises NotImplementedError if the using readline library does not support.\n\nRaises SecurityError exception if $SAFE is 4.\n
completer_word_break_characters= Readline.completer_word_break_characters=(p1)\nSets the basic list of characters that signal a break between words\nfor rl_complete_internal(). The default is the value of\nReadline.basic_word_break_characters.\n\nRaises NotImplementedError if the using readline library does not support.\n\nRaises SecurityError exception if $SAFE is 4.\n
completion_append_character Readline.completion_append_character()\nReturns a string containing a character to be appended on\ncompletion. The default is a space (" ").\n\nRaises NotImplementedError if the using readline library does not support.\n\nRaises SecurityError exception if $SAFE is 4.\n
completion_append_character= Readline.completion_append_character=(p1)\nSpecifies a character to be appended on completion.\nNothing will be appended if an empty string ("") or nil is\nspecified.\n\nFor example:\n  require "readline"\n\n  Readline.readline("> ", true)\n  Readline.completion_append_character = " "\n\nResult:\n  >\n  Input "/var/li".\n\n  > /var/li\n  Press TAB key.\n\n  > /var/lib\n  Completes "b" and appends " ". So, you can continuously input "/usr".\n\n  > /var/lib /usr\n\nNOTE: Only one character can be specified. When "string" is\nspecified, sets only "s" that is the first.\n\n  require "readline"\n\n  Readline.completion_append_character = "string"\n  p Readline.completion_append_character # => "s"\n\nRaises NotImplementedError if the using readline library does not support.\n\nRaises SecurityError exception if $SAFE is 4.\n
completion_case_fold Readline.completion_case_fold()\nReturns true if completion ignores case. If no, returns false.\n\nNOTE: Returns the same object that is specified by\nReadline.completion_case_fold= method.\n\n  require "readline"\n\n  Readline.completion_case_fold = "This is a String."\n  p Readline.completion_case_fold # => "This is a String."\n\nRaises SecurityError exception if $SAFE is 4.\n
completion_case_fold= Readline.completion_case_fold=(p1)\nSets whether or not to ignore case on completion.\n\nRaises SecurityError exception if $SAFE is 4.\n
completion_proc Readline.completion_proc()\nReturns the completion Proc object.\n\nRaises SecurityError exception if $SAFE is 4.\n
completion_proc= Readline.completion_proc=(p1)\nSpecifies a Proc object +proc+ to determine completion behavior.  It\nshould take input string and return an array of completion candidates.\n\nThe default completion is used if +proc+ is nil.\n\nThe String that is passed to the Proc depends on the\nReadline.completer_word_break_characters property.  By default the word\nunder the cursor is passed to the Proc.  For example, if the input is "foo\nbar" then only "bar" would be passed to the completion Proc.\n\nUpon successful completion the Readline.completion_append_character will be\nappended to the input so the user can start working on their next argument.\n\n= Examples\n\n== Completion for a Static List\n\n  require 'readline'\n\n  LIST = [\n    'search', 'download', 'open',\n    'help', 'history', 'quit',\n    'url', 'next', 'clear',\n    'prev', 'past'\n  ].sort\n\n  comp = proc { |s| LIST.grep(/^#{Regexp.escape(s)}/) }\n\n  Readline.completion_append_character = " "\n  Readline.completion_proc = comp\n\n  while line = Readline.readline('> ', true)\n    p line\n  end\n\n== Completion For Directory Contents\n\n  require 'readline'\n\n  Readline.completion_append_character = " "\n  Readline.completion_proc = Proc.new do |str|\n    Dir[str+'*'].grep(/^#{Regexp.escape(str)}/)\n  end\n\n  while line = Readline.readline('> ', true)\n    p line\n  end\n\n= Autocomplete strategies\n\nWhen working with auto-complete there are some strategies that work well.\nTo get some ideas you can take a look at the\ncompletion.rb[http://svn.ruby-lang.org/repos/ruby/trunk/lib/irb/completion.rb]\nfile for irb.\n\nThe common strategy is to take a list of possible completions and filter it\ndown to those completions that start with the user input.  In the above\nexamples Enumerator.grep is used.  The input is escaped to prevent Regexp\nspecial characters from interfering with the matching.\n\nIt may also be helpful to use the Abbrev library to generate completions.\n\nRaises ArgumentError if +proc+ does not respond to the call method.\n\nRaises SecurityError if $SAFE is 4.\n
emacs_editing_mode Readline.emacs_editing_mode()\nSpecifies Emacs editing mode. The default is this mode. See the\nmanual of GNU Readline for details of Emacs editing mode.\n\nRaises NotImplementedError if the using readline library does not support.\n\nRaises SecurityError exception if $SAFE is 4.\n
emacs_editing_mode? Readline.emacs_editing_mode?()\nReturns true if emacs mode is active. Returns false if not.\n\nRaises NotImplementedError if the using readline library does not support.\n\nRaises SecurityError exception if $SAFE is 4.\n
filename_quote_characters Readline.filename_quote_characters()\nGets a list of characters that cause a filename to be quoted by the completer\nwhen they appear in a completed filename.\n\nRaises NotImplementedError if the using readline library does not support.\n\nRaises SecurityError exception if $SAFE is 4.\n
filename_quote_characters= Readline.filename_quote_characters=(p1)\nSets a list of characters that cause a filename to be quoted by the completer\nwhen they appear in a completed filename. The default is nil.\n\nRaises NotImplementedError if the using readline library does not support.\n\nRaises SecurityError exception if $SAFE is 4.\n
get_screen_size Readline.get_screen_size()\nReturns the terminal's rows and columns.\n\nSee GNU Readline's rl_get_screen_size function.\n\nRaises NotImplementedError if the using readline library does not support.\n\nRaises SecurityError exception if $SAFE is 4.\n
input= Readline.input=(p1)\nSpecifies a File object +input+ that is input stream for\nReadline.readline method.\n\nRaises SecurityError exception if $SAFE is 4.\n
line_buffer Readline.line_buffer()\nReturns the full line that is being edited. This is useful from\nwithin the complete_proc for determining the context of the\ncompletion request.\n\nThe length of +Readline.line_buffer+ and GNU Readline's rl_end are\nsame.\n
output= Readline.output=(p1)\nSpecifies a File object +output+ that is output stream for\nReadline.readline method.\n\nRaises SecurityError exception if $SAFE is 4.\n
point Readline.point()\nReturns the index of the current cursor position in\n+Readline.line_buffer+.\n\nThe index in +Readline.line_buffer+ which matches the start of\ninput-string passed to completion_proc is computed by subtracting\nthe length of input-string from +Readline.point+.\n\n  start = (the length of input-string) - Readline.point\n
readline Readline.readline(p1 = v1, p2 = v2)\nShows the +prompt+ and reads the inputted line with line editing.\nThe inputted line is added to the history if +add_hist+ is true.\n\nReturns nil when the inputted line is empty and user inputs EOF\n(Presses ^D on UNIX).\n\nRaises IOError exception if below conditions are satisfied.\n1. stdin is not tty.\n2. stdin was closed. (errno is EBADF after called isatty(2).)\n\nThis method supports thread. Switchs the thread context when waits\ninputting line.\n\nSupports line edit when inputs line. Provides VI and Emacs editing mode.\nDefault is Emacs editing mode.\n\nNOTE: Terminates ruby interpreter and does not return the terminal\nstatus after user pressed '^C' when wait inputting line.\nGive 3 examples that avoid it.\n\n* Catches the Interrupt exception by pressed ^C after returns\n  terminal status:\n\n    require "readline"\n\n    stty_save = `stty -g`.chomp\n    begin\n      while buf = Readline.readline\n          p buf\n          end\n        rescue Interrupt\n          system("stty", stty_save)\n          exit\n        end\n      end\n    end\n\n* Catches the INT signal by pressed ^C after returns terminal\n  status:\n\n    require "readline"\n\n    stty_save = `stty -g`.chomp\n    trap("INT") { system "stty", stty_save; exit }\n\n    while buf = Readline.readline\n      p buf\n    end\n\n* Ignores pressing ^C:\n\n    require "readline"\n\n    trap("INT", "SIG_IGN")\n\n    while buf = Readline.readline\n      p buf\n    end\n\nCan make as follows with Readline::HISTORY constant.\nIt does not record to the history if the inputted line is empty or\nthe same it as last one.\n\n  require "readline"\n\n  while buf = Readline.readline("> ", true)\n p Readline::HISTORY.to_a\n    Readline::HISTORY.pop if /^\s*$/ =~ buf\n\n    begin\n      if Readline::HISTORY[Readline::HISTORY.length-2] == buf\n        Readline::HISTORY.pop\n      end\n    rescue IndexError\n    end\n p Readline::HISTORY.to_a\n    print "-> ", buf, "\\n"\n  end\n\nRaises SecurityError exception if $SAFE is 4.\n
refresh_line Readline.refresh_line()\nClear the current input line.\n\nRaises SecurityError exception if $SAFE is 4.\n
set_screen_size Readline.set_screen_size(p1, p2)\nSet terminal size to +rows+ and +columns+.\n\nSee GNU Readline's rl_set_screen_size function.\n\nRaises NotImplementedError if the using readline library does not support.\n\nRaises SecurityError exception if $SAFE is 4.\n
vi_editing_mode Readline.vi_editing_mode()\nSpecifies VI editing mode. See the manual of GNU Readline for\ndetails of VI editing mode.\n\nRaises NotImplementedError if the using readline library does not support.\n\nRaises SecurityError exception if $SAFE is 4.\n
vi_editing_mode? Readline.vi_editing_mode?()\nReturns true if vi mode is active. Returns false if not.\n\nRaises NotImplementedError if the using readline library does not support.\n\nRaises SecurityError exception if $SAFE is 4.\n
print IO::writable.print(*args)\nSee IO#print.\n
printf IO::writable.printf(*args)\nSee IO#printf.\n
puts IO::writable.puts(*args)\nSee IO#puts.\n
LOG_MASK Syslog.LOG_MASK(p1)\nGenerates a mask bit for a priority level. See #mask=\n
LOG_UPTO Syslog.LOG_UPTO(p1)\nGenerates a mask value for priority levels at or below the level specified.\nSee #mask=\n
close Syslog.close()\nCloses the syslog facility.\nRaises a runtime exception if it is not open.\n
facility Syslog.facility()\nReturns the facility number used in the last call to open()\n
ident Syslog.ident()\nReturns the identity string used in the last call to open()\n
inspect Syslog.inspect()\nReturns an inspect() string summarizing the object state.\n
instance Syslog.instance()\nReturns self, for backward compatibility.\n
log Syslog.log(*args)\nLog a message with the specified priority. Example:\n\n  Syslog.log(Syslog::LOG_CRIT, "Out of disk space")\n  Syslog.log(Syslog::LOG_CRIT, "User %s logged in", ENV['USER'])\n\nThe priority levels, in descending order, are:\n\nLOG_EMERG::   System is unusable\nLOG_ALERT::   Action needs to be taken immediately\nLOG_CRIT::    A critical condition has occurred\nLOG_ERR::     An error occurred\nLOG_WARNING:: Warning of a possible problem\nLOG_NOTICE::  A normal but significant condition occurred\nLOG_INFO::    Informational message\nLOG_DEBUG::   Debugging information\n\nEach priority level also has a shortcut method that logs with it's named\npriority.\nAs an example, the two following statements would produce the same result:\n\n  Syslog.log(Syslog::LOG_ALERT, "Out of memory")\n  Syslog.alert("Out of memory")\n\nFormat strings are as for printf/sprintf, except that in addition %m is\nreplaced with the error message string that would be returned by\nstrerror(errno).\n
mask Syslog.mask()\nReturns the log priority mask in effect. The mask is not reset by opening\nor closing syslog.\n
mask= Syslog.mask=(p1)\nSets the log priority mask. A method LOG_UPTO is defined to make it easier\nto set mask values. Example:\n\n  Syslog.mask = Syslog::LOG_UPTO(Syslog::LOG_ERR)\n\nAlternatively, specific priorities can be selected and added together using\nbinary OR. Example:\n\n  Syslog.mask = Syslog::LOG_MASK(Syslog::LOG_ERR) |\n  Syslog::LOG_MASK(Syslog::LOG_CRIT)\n\nThe priority mask persists through calls to open() and close().\n
open Syslog.open(p1 = v1, p2 = v2, p3 = v3)\nOpen the syslog facility.\nRaises a runtime exception if it is already open.\n\nCan be called with or without a code block. If called with a block, the\nSyslog object created is passed to the block.\n\nIf the syslog is already open, raises a RuntimeError.\n\n+ident+ is a String which identifies the calling program.\n\n+options+ is the logical OR of any of the following:\n\nLOG_CONS:: If there is an error while sending to the system logger,\n           write directly to the console instead.\n\nLOG_NDELAY:: Open the connection now, rather than waiting for the first\n             message to be written.\n\nLOG_NOWAIT:: Don't wait for any child processes created while logging\n             messages. (Has no effect on Linux.)\n\nLOG_ODELAY:: Opposite of LOG_NDELAY; wait until a message is sent before\n             opening the connection. (This is the default.)\n\nLOG_PERROR:: Print the message to stderr as well as sending it to syslog.\n             (Not in POSIX.1-2001.)\n\nLOG_PID:: Include the current process ID with each message.\n\n+facility+ describes the type of program opening the syslog, and is\nthe logical OR of any of the following which are defined for the host OS:\n\nLOG_AUTH:: Security or authorization. Deprecated, use LOG_AUTHPRIV\n           instead.\n\nLOG_AUTHPRIV:: Security or authorization messages which should be kept\n               private.\n\nLOG_CONSOLE:: System console message.\n\nLOG_CRON:: System task scheduler (cron or at).\n\nLOG_DAEMON:: A system daemon which has no facility value of its own.\n\nLOG_FTP:: An FTP server.\n\nLOG_KERN:: A kernel message (not sendable by user processes, so not of\n           much use to Ruby, but listed here for completeness).\n\nLOG_LRP:: Line printer subsystem.\n\nLOG_MAIL:: Mail delivery or transport subsystem.\n\nLOG_NEWS:: Usenet news system.\n\nLOG_NTP:: Network Time Protocol server.\n\nLOG_SECURITY:: General security message.\n\nLOG_SYSLOG:: Messages generated internally by syslog.\n\nLOG_USER:: Generic user-level message.\n\nLOG_UUCP:: UUCP subsystem.\n\nLOG_LOCAL0 to LOG_LOCAL7:: Locally-defined facilities.\n\nExample:\n\n Syslog.open("webrick", Syslog::LOG_PID,\n             Syslog::LOG_DAEMON | Syslog::LOG_LOCAL3)\n
open! Syslog.open!(*args)\nCloses and then reopens the syslog.\n\nArguments are the same as for open().\n
opened? Syslog.opened?()\nReturns true if the syslog is open.\n
options Syslog.options()\nReturns the options bitmask used in the last call to open()\n
reopen Syslog.reopen(*args)\nCloses and then reopens the syslog.\n\nArguments are the same as for open().\n
LOG_MASK Syslog::Constants.LOG_MASK(p1)\nGenerates a mask bit for a priority level. See #mask=\n
LOG_UPTO Syslog::Constants.LOG_UPTO(p1)\nGenerates a mask value for priority levels at or below the level specified.\nSee #mask=\n
adler32 Zlib.adler32(*args)\nCalculates Adler-32 checksum for +string+, and returns updated value of\n+adler+. If +string+ is omitted, it returns the Adler-32 initial value. If\n+adler+ is omitted, it assumes that the initial value is given to +adler+.\n\nFIXME: expression.\n
adler32_combine Zlib.adler32_combine(p1, p2, p3)\nCombine two Adler-32 check values in to one.  +alder1+ is the first Adler-32\nvalue, +adler2+ is the second Adler-32 value.  +len2+ is the length of the\nstring used to generate +adler2+.\n
crc32 Zlib.crc32(*args)\nCalculates CRC checksum for +string+, and returns updated value of +crc+. If\n+string+ is omitted, it returns the CRC initial value. If +crc+ is omitted, it\nassumes that the initial value is given to +crc+.\n\nFIXME: expression.\n
crc32_combine Zlib.crc32_combine(p1, p2, p3)\nCombine two CRC-32 check values in to one.  +crc1+ is the first CRC-32\nvalue, +crc2+ is the second CRC-32 value.  +len2+ is the length of the\nstring used to generate +crc2+.\n
crc_table Zlib.crc_table()\nReturns the table for calculating CRC checksum as an array.\n
deflate Zlib.deflate(p1, p2 = v2)\nCompresses the given +string+. Valid values of level are\n<tt>NO_COMPRESSION</tt>, <tt>BEST_SPEED</tt>,\n<tt>BEST_COMPRESSION</tt>, <tt>DEFAULT_COMPRESSION</tt>, and an\ninteger from 0 to 9 (the default is 6).\n\nThis method is almost equivalent to the following code:\n\n  def deflate(string, level)\n    z = Zlib::Deflate.new(level)\n    dst = z.deflate(string, Zlib::NO_FLUSH)\n    z.close\n    dst\n  end\n\nSee also Zlib.inflate\n
inflate Zlib.inflate(p1)\nDecompresses +string+. Raises a Zlib::NeedDict exception if a preset\ndictionary is needed for decompression.\n\nThis method is almost equivalent to the following code:\n\n  def inflate(string)\n    zstream = Zlib::Inflate.new\n    buf = zstream.inflate(string)\n    zstream.finish\n    zstream.close\n    buf\n  end\n\nSee also Zlib.deflate\n
zlib_version Zlib.zlib_version()\nReturns the string which represents the version of zlib library.\n
append_features Object::Synchronizer_m.append_features(cl)\n\n
define_aliases Object::Synchronizer_m.define_aliases(cl)\n\n
extend_object Object::Synchronizer_m.extend_object(obj)\n\n
new Object::Synchronizer_m.new(*args)\n\n
sync_exclusive? Object::Synchronizer_m.sync_exclusive?()\n\n
sync_extend Object::Synchronizer_m.sync_extend()\n\n
sync_inspect Object::Synchronizer_m.sync_inspect()\n\n
sync_lock Object::Synchronizer_m.sync_lock(m = EX)\n\n
sync_locked? Object::Synchronizer_m.sync_locked?()\naccessing\n
sync_shared? Object::Synchronizer_m.sync_shared?()\n\n
sync_synchronize Object::Synchronizer_m.sync_synchronize(mode = EX)\n\n
sync_try_lock Object::Synchronizer_m.sync_try_lock(mode = EX)\nlocking methods.\n
sync_unlock Object::Synchronizer_m.sync_unlock(m = EX)\n\n
